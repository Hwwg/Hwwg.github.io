<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>java反射机制 - Tlife</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Tlife"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Tlife"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="如何理解反射反射可以理解为一种手段，对象通过反射可以获取他的类，类可以通过反射获取他的所有方法，通过反射，我们可以将java这种静态语言附加上动态特性。 这种动态获取的信息以及动态调用对象的功能成为java语言的反射机制 如何理解动态特性⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化 获取类对象的方法1.forname()方法通过动态修改forname的参数，可以获取不同的java类"><meta property="og:type" content="article"><meta property="og:title" content="java反射机制"><meta property="og:url" content="http://example.com/2022/02/21/java%E5%AE%A1%E8%AE%A13/"><meta property="og:site_name" content="Tlife"><meta property="og:description" content="如何理解反射反射可以理解为一种手段，对象通过反射可以获取他的类，类可以通过反射获取他的所有方法，通过反射，我们可以将java这种静态语言附加上动态特性。 这种动态获取的信息以及动态调用对象的功能成为java语言的反射机制 如何理解动态特性⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化 获取类对象的方法1.forname()方法通过动态修改forname的参数，可以获取不同的java类"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2022-02-21T08:26:37.000Z"><meta property="article:modified_time" content="2022-02-24T09:59:27.582Z"><meta property="article:author" content="vague huang"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/02/21/java%E5%AE%A1%E8%AE%A13/"},"headline":"java反射机制","image":["http://example.com/img/og_image.png"],"datePublished":"2022-02-21T08:26:37.000Z","dateModified":"2022-02-24T09:59:27.582Z","author":{"@type":"Person","name":"vague huang"},"publisher":{"@type":"Organization","name":"Tlife","logo":{"@type":"ImageObject"}},"description":"如何理解反射反射可以理解为一种手段，对象通过反射可以获取他的类，类可以通过反射获取他的所有方法，通过反射，我们可以将java这种静态语言附加上动态特性。 这种动态获取的信息以及动态调用对象的功能成为java语言的反射机制 如何理解动态特性⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化 获取类对象的方法1.forname()方法通过动态修改forname的参数，可以获取不同的java类"}</script><link rel="canonical" href="http://example.com/2022/02/21/java%E5%AE%A1%E8%AE%A13/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Tlife</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-21T08:26:37.000Z" title="2022/2/21 下午4:26:37">2022-02-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-02-24T09:59:27.582Z" title="2022/2/24 下午5:59:27">2022-02-24</time></span></div></div><h1 class="title is-3 is-size-4-mobile">java反射机制</h1><div class="content"><h2 id="如何理解反射"><a href="#如何理解反射" class="headerlink" title="如何理解反射"></a>如何理解反射</h2><p>反射可以理解为一种手段，对象通过反射可以获取他的类，类可以通过反射获取他的所有方法，通过反射，我们可以将java这种静态语言附加上动态特性。</p>
<p><strong>这种动态获取的信息以及动态调用对象的功能成为java语言的反射机制</strong></p>
<h3 id="如何理解动态特性"><a href="#如何理解动态特性" class="headerlink" title="如何理解动态特性"></a>如何理解动态特性</h3><p>⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化</p>
<h2 id="获取类对象的方法"><a href="#获取类对象的方法" class="headerlink" title="获取类对象的方法"></a>获取类对象的方法</h2><h3 id="1-forname-方法"><a href="#1-forname-方法" class="headerlink" title="1.forname()方法"></a>1.forname()方法</h3><p>通过动态修改forname的参数，可以获取不同的java类</p>
<p>并且其静态方法JVM会装在类，并且执行static()中的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class reflect_test &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">        Class name&#x3D; Class.forName(&quot;xxxx&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-直接获取"><a href="#2-直接获取" class="headerlink" title="2.直接获取"></a>2.直接获取</h3><p>任何数据类型都具备静态的属性，因此可以使用.class直接获取其对应的class对象,需要明确用到类中的静态成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">    Class&lt;?&gt; name&#x3D;Runtime.class;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用getclass-方法"><a href="#3-使用getclass-方法" class="headerlink" title="3.使用getclass()方法"></a>3.使用getclass()方法</h3><p>我们可以通过object类中的getclass()方法来获取字节码对象<br><strong>需要明确具体的类，然后创建对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">    Runtime rt&#x3D; Runtime.getRuntime();</span><br><span class="line">    Class&lt;?&gt; name&#x3D;rt.getClass();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用getSystemClassLoader-loadClass"><a href="#4-使用getSystemClassLoader-loadClass" class="headerlink" title="4.使用getSystemClassLoader().loadClass()"></a>4.使用getSystemClassLoader().loadClass()</h3><p>1.类似于forName()</p>
<p>但是不会执行static中的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">    Class&lt;?&gt; name&#x3D;ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h2><h3 id="1-getDeclaredMethods方法"><a href="#1-getDeclaredMethods方法" class="headerlink" title="1.getDeclaredMethods方法"></a>1.getDeclaredMethods方法</h3><p>getDeclaredMethods方法 返回类或接口声明的所有办法，包括public、protected、private、和默认方法，但不包括继承的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">public class getfunction &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">        Class name&#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">        Method[] declaredMethods&#x3D;name.getDeclaredMethods();</span><br><span class="line">        System.out.println(&quot;通过getDeclaredMethods获取的方法有:&quot;);</span><br><span class="line">        for(Method m:declaredMethods)</span><br><span class="line">            System.out.println(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-getMethods方法"><a href="#2-getMethods方法" class="headerlink" title="2.getMethods方法"></a>2.getMethods方法</h3><p>getMethods方法返回某个类的所有public方法，包括其继承类的public方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">    Class name&#x3D; Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">    Method[] declaredMethods&#x3D;name.getMethods();</span><br><span class="line">    System.out.println(&quot;通过getMethods获取的方法有:&quot;);</span><br><span class="line">    for(Method m:declaredMethods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-getMethod方法"><a href="#3-getMethod方法" class="headerlink" title="3.getMethod方法"></a>3.getMethod方法</h3><p>只能返回一个特定的方法，如Runtime类中的exec方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应class的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException,NoSuchMethodException&#123;</span><br><span class="line">    Runtime rt&#x3D;Runtime.getRuntime();</span><br><span class="line">    Class&lt;?&gt; name&#x3D; rt.getClass();</span><br><span class="line">    Method method&#x3D;name.getMethod(&quot;exec&quot;,String.class);</span><br><span class="line">    System.out.println(&quot;通过getMethods获取的方法有:&quot;);</span><br><span class="line">    System.out.println(method);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-getDeclaredMethod方法"><a href="#4-getDeclaredMethod方法" class="headerlink" title="4.getDeclaredMethod方法"></a>4.getDeclaredMethod方法</h3><p>getDeclaredMethod方法和getMethod类似</p>
<h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><h3 id="1-getDeclaredFields方法"><a href="#1-getDeclaredFields方法" class="headerlink" title="1.getDeclaredFields方法"></a>1.getDeclaredFields方法</h3><p>getDeclaredFields能获得类的成员变量数组，包括public、private、protected，但是不包括父类的声明字段</p>
<h3 id="2-getFields方法"><a href="#2-getFields方法" class="headerlink" title="2.getFields方法"></a>2.getFields方法</h3><p>getFields能够获得某个类的所有public字段，包括父类中的字段，</p>
<h3 id="3-getDeclaredField方法"><a href="#3-getDeclaredField方法" class="headerlink" title="3.getDeclaredField方法"></a>3.getDeclaredField方法</h3><p>只能获得类的单个成员变量</p>
<h3 id="4-getField方法"><a href="#4-getField方法" class="headerlink" title="4.getField方法"></a>4.getField方法</h3><p>类似getFields方法，能够获得某个类特定的public字段，包括父类中的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; name&#x3D;student.getClass()</span><br><span class="line">Field getField&#x3D;name.getField(&quot;content&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>forNam</code>e不是获取“类”的唯⼀途径，通常来说我们有如下三种⽅式获取⼀个“类”，也就是java.lang.Class对象：</p>
<p><code>obj.getClass()</code> 如果上下⽂中存在某个类的实例obj，那么我们可以直接通过obj.getClass()来获取它的类<br><code>Test.class </code>如果你已经加载了某个类，只是想获取到它的java.lang.Class对象，那么就直接拿它的class属性即可。这个⽅法其实不属于反射。<code>Class.forName </code>如果你知道某个类的名字，想获取到这个类，就可以使⽤forName来获取</p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/02/22/2022vnctf/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2022vnctf-rce小结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/21/java%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"><span class="level-item">java初探（二）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Tlife</a><p class="is-size-7"><span>&copy; 2023 vague huang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>